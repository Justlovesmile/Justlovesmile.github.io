[{"title":"旋转目标检测 | SCRDet，适用于旋转、密集、小目标的检测器","slug":"人工智能-SCRDet论文笔记","url":"/posts/8f7eb979.html","content":"\n# 1. 论文信息\n\n论文标题：`《SCRDet: Towards More Robust Detection for Small, Cluttered and Rotated Objects》`\n\n>论文发表：ICCV2019\n>论文链接：[https://openaccess.thecvf.com](https://openaccess.thecvf.com/content_ICCV_2019/papers/Yang_SCRDet_Towards_More_Robust_Detection_for_Small_Cluttered_and_Rotated_ICCV_2019_paper.pdf)\n>论文代码：[https://github.com/DetectionTeamUCAS](https://github.com/DetectionTeamUCAS)\n\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306124344.png)\n\n```bib\n@inproceedings{yang2019scrdet,\n  title={Scrdet: Towards more robust detection for small, cluttered and rotated objects},\n  author={Yang, Xue and Yang, Jirui and Yan, Junchi and Zhang, Yue and Zhang, Tengfei and Guo, Zhi and Sun, Xian and Fu, Kun},\n  booktitle={Proceedings of the IEEE/CVF International Conference on Computer Vision},\n  pages={8232--8241},\n  year={2019}\n}\n```\n\n\n# 2. 归纳总结\n\n| 标签                            | 目的                       | 方法                          | 总结                 |\n| ------------------------------- | -------------------------- | ----------------------------- | -------------------- |\n| #遥感 #注意力机制 #旋转目标检测 | 解决了遥感目标角度边界问题 | IoU SmoothL1 Loss，多维注意力 | 从遥感目标的难点出发 |\n\n# 3. 问题背景\n\n遥感目标检测的难点：\n- 小目标（small size）\n- 密集（dense distribution）\n- 方向任意（arbitrary direction）\n\n# 4. 主要工作\n\n针对上述问题进行改进：\n-   对于小目标：通过特征融合和anchor采样角度出发设计了一个特征融合结构。\n-   对于密集排列问题：设计了一个有监督的多维注意力网络（supervised pixel attention network and the channel attention network）以减少背景噪声的不利影响。\n-   对于任意方向问题：通过添加IoU常数因子设计了一种改进的平滑L1损失，该因子专门用于解决旋转边界框回归的边界问题。\n\n# 5. 相关工作\n\n目标检测经典模型：\n- 两阶段：Fast R-CNN，Faster R-CNN，R-FCN\n- 单阶段：YOLO，SSD\n\n针对小目标：RP-Faster R-CNN\n\n# 6. 模型方法\n\n整个框架基于Faster R-CNN based R2CNN实现，模型结构如下图：\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306125233.png)\n\n主要包含三个部分：\n- SF-Net\n- MDA-Net\n- Rotation-Branch\n\n## 6.1 SF-Net\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306130142.png)\n针对小目标检测，作者认为**特征融合**和**有效采样**是关键。对于anchor-based来说，anchor的铺设方式直接影响正样本采样率。经典的anchor铺设方式和特征图的分辩率有关，也就是anchor铺设的步长（C2-C5上的anchor步长分别是4,8,16,32）。随着网络加加深，特征图分辨率下降，anchor的步长扩大，常常会导致小目标的采样丢失，如下图所示：\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306125943.png)\n文章通过resize的方式选取了一个合适的特征图分别率，尽可能保证小目标都被采样到，再加上简单的特征融合保证丰富的语义信息和位置信息。在这里之所以不使用C2，是因为遥感目标检测会设置较多的尺度和比例，那么在C2这个特征图上面的anchor就变得太多了，而且在遥感数据集中最小的目标一般也都在10像素以上（特指[DOTA1.0](https://arxiv.org/abs/1807.02700)，[DOTA1.5](https://captain-whu.github.io/DOAI2019/dataset.html)则给出了像素10以下的标注）。\n\n## 6.2 MAD-Net\n由于遥感图像背景的复杂性，RPN产生的建议区域可能引入大量噪声信息，如下图所示:\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306130354.png)\n过多的噪音可能会混淆物体信息，物体之间的界限将变得模糊，导致漏检并增加虚警。因此，有必要增强物体特征并削弱非物体特征。为了更有效地捕捉复杂背景下小物体的特征，文章设计了一种有监督的多维注意力网络（MDA-Net），如下图所示。具体来说，在基于像素的注意网络中，特征图F3通过具有不同大小卷积核进行卷积运算，学习得到双通道的显著图（参见上图d）。这个显著图显示了前景和背景的分数。选择显著图中的一个通道与F3相乘，得到新的信息特征图A3（参见上图c）。需要注意的是，Softmax函数之后的显着图的值在[0,1]之间。换句话说，它可以降低噪声并相对的增强对象信息。由于显著图是连续的，因此不会完全消除背景信息，这有利于保留某些上下文信息并提高鲁棒性。\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306130420.png)\n其实这个模块现在也是被用的比较烂了，就是空间注意力加通道注意力的组合。但在实际的应用过程中，空间注意力在遥感检测真的是非常有用的；\n\n## 6.3 IoU-Smooth L1 Loss\n首先我们要先了解一下两种旋转边界框的两种常见的方式，下图来自这篇文章的作者yangxue：\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306130754.png)\nSCRDet是采用的opencv 表示法。在当前常用的旋转检测框的角度定义下，由于存在旋转角度的边界问题，会产生不必要的损失，如下图所示：\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306130911.png)\n\n最理想的角度回归路线是由蓝色框逆时针旋转到红色框，但由于角度的周期性，导致按照这个回归方式的损失非常大（参见上图右边的Example）。此时模型必须以更复杂的形式回归（例如蓝色框顺时针旋转，同时缩放w和h），增加了回归的难度。为了更好地解决这个问题，我们在传统的smooth L1 损失函数中引入了IoU常数因子。在边界情况下，新的损失函数近似等于0，消除了损失的突增。新的回归损失可分为两部分，smooth L1回归损失函数取单位向量确定梯度传播的方向，而IoU表示梯度的大小，这样loss函数就变得连续。此外，使用IoU优化回归任务与评估方法的度量标准保持一致，这比坐标回归更直接和有效。IoU-Smooth L1 loss公式如下： \n\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306131108.png)\n\n可以看一下两种loss在边界情况下的效果对比：\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306131310.png)\n\n导致这种原因的根本原因是角度的预测超出了所定义范围。其实解决这种问题的方法并不唯一，[RRPN](https://arxiv.org/abs/1703.01086)和[R-DFPN](https://www.mdpi.com/2072-4292/10/1/132)在论文的loss公式中就判断了是不是在定义范围内，通过加减$k\\pi$来缓解这个问题，但这种做法明显不优美而且仍然存在问题，主要是较难判断超出预测范围几个角度周期。当然可以通过对角度部分的loss加一个周期性函数，比如tan、cos等三角函数来做，但是我在实际使用过程中常常出现不收敛的情况。对于边界问题，我其实还做了其他方法的研究，会在以后的文章中详细讨论。\n\n# 7. 实验结果\n\n消融实验：\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306131425.png)\n\n对比实验：\n![](https://unpkg.com/justlovesmile-post@1.0.7/20220306131447.png)\n\n# 8. 参考文献\n\n[旋转目标检测方法解读 （SCRDet, ICCV2019） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/107400817)","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"Python小工具 | 如何自动下载、压缩并批量替换文章中的外链图片","slug":"代码编程-python批量替换博客图片","url":"/posts/7a5857a0.html","content":"\n由于前段时间JsdelivrCDN加速的崩盘，博主存在Github上的图片全部访问失败，文章阅读体验极差，于是2022年以后的文章全部采用npm做图床，在此之前的文章由于数量过多并没有替换。再加上之前一直忙着研一阶段的期末考，懒得动博客。幸好这段时间有空，于是写了个python小工具来替换博客中外链图片，具体流程如下：\n- 首先，遍历`hexo\\source\\_posts\\`文件夹中的全部文章，把里面含有`https://cdn.jsdelivr.net/gh`的图片全部下载下来，并替换链接为npm的CDN链接。\n- 其次，对下载下来的图片做简单的压缩。\n- 最后，把压缩后的图片上传npm。\n\n总体流程非常简单，下面是具体实现。\n\n# 1. 下载并替换图片外链\n\n```python\nimport os\nimport os.path as osp\nimport shutil as sh\nimport  re\nfrom tqdm.auto import tqdm\nimport requests\n\ndef makedir(root):\n    if not osp.exists(root):\n        os.mkdir(root)  \n\ndef save_img(root,img_url):\n    path=root+img_url.split('/')[-1]\n    try:\n        if not osp.exists(path):\n            s = requests.session()\n            s.keep_alive = False # 关闭多余连接\n            r = s.get(img_url) # 你需要的网址\n            #r=requests.get(img_url)\n            with open(path,'wb') as f:\n                f.write(r.content)\n                f.close()\n        else:\n            print(path+\"文件已存在！\")\n            return 0\n    except Exception as e:\n        print(img_url+\", 爬取失败！\")\n        return 1\n    print(img_url+\"已下载\")\n    return 0\n\ndef findimg(line,ori_pre):\n    try:\n        img = re.findall(f\"({ori_pre}.*?(\\.jfif|\\.svg|\\.webp|\\.gif|\\.jpeg|\\.jpg|\\.png|\\.PNG|\\.JPEG|\\.JPG))\",line)[0][0]\n        name = img.split('/')[-1]\n    except Exception as e:\n        print(\"已自动忽略：\",line)\n        img,name = None,None\n    return img,name\n\ndef changeurl(ori_root,save_root,down_root,ori_pre,new_pre):\n    assert ori_pre[-1]=='/' and new_pre[-1]==\"/\"\n    if osp.isdir(ori_root):\n        files = os.listdir(ori_root)\n    else:\n        file = osp.basename(ori_root)\n        ori_root = ori_root.split(file)[0]\n        files = [file]\n    makedir(save_root)\n    makedir(down_root)\n    for file in tqdm(files):\n        print(\"Starting... \",file)\n        with open(ori_root+file,'r',encoding = 'utf-8') as f:\n            content = f.readlines()\n        with open(save_root+file,'w',encoding='utf-8') as f:\n            for line in content:\n                if ori_pre in line:\n                    img,name = findimg(line,ori_pre)\n                    if img!=None:\n                        change = new_pre + name\n                        print(line,\"==>\",line.replace(img,change))\n                        code = save_img(down_root,img)\n                        if code == 0:\n                            line = line.replace(img,change)\n                f.write(line)\n\n\ndef main():\n    ori_root = './hexo/source/_posts/'\n    save_root = './markdown/'\n    down_root = './download/'\n    ori_pre = 'https://cdn.jsdelivr.net/gh/'\n    new_pre = 'https://unpkg.com/justlovesmile-post@1.0.3/'\n    changeurl(ori_root,save_root,down_root,ori_pre,new_pre)\n    \nif __name__ == \"__main__\":\n    main()\n```\n\n# 2. 压缩图片\n\n由第一步已经下载好图片了，这一步需要对图片进行简单的压缩，这里我采用最简单的图片缩放，通过`缩小图片来压缩(有损)`，需要无损压缩的可以用软件或者其他方法（百度、CSDN）。\n\n```python\nfrom PIL import Image\nfrom glob import glob\nimport os\nfrom tqdm import tqdm\nimport shutil\nimport sys\nfrom itertools import chain\n \nfrom multiprocessing import Pool\n \n# image_dir = \"image_dir\"\ntemplate_dir = 'template'\noutput_dir = 'output'\nerror_dir = 'error'\n \n \ndef clean_dir(dir_name):\n    if os.path.exists(dir_name):\n        shutil.rmtree(dir_name)\n        os.makedirs(dir_name)\n    else:\n        os.makedirs(dir_name)\n \n \n# image_file_list = glob(f\"{image_dir}/*\")\n# image_file_list\n \n \ndef imagesize(filepath):\n    \"\"\"\n    获得文件的磁盘大小\n    :param filepath:\n    :return:\n    \"\"\"\n    return os.path.getsize(filepath) / 1024\n \n \ndef compress_image(image_path, target_size=500):\n    raw_image = Image.open(image_path)\n    temp_image_name = image_path.split(os.sep)[-1]\n    template_image = os.path.join(template_dir, temp_image_name)\n    output_image = os.path.join(output_dir, temp_image_name)\n    error_image = os.path.join(error_dir, temp_image_name)\n \n    target_size = target_size  # kb\n \n    try:\n \n        if imagesize(image_path) < target_size:\n            shutil.copyfile(image_path, output_image)\n        else:\n            width, height = raw_image.size\n            raw_image.resize((int(width * 0.9), int(height * 0.9)), Image.ANTIALIAS).save(template_image)\n            while imagesize(template_image) > target_size:\n                template_iamge2 = Image.open(template_image)\n                width_2, height_2 = template_iamge2.size\n                template_iamge2.resize((int(width_2 * 0.9), int(height_2 * 0.9)), Image.ANTIALIAS).save(template_image)\n \n            shutil.copyfile(template_image, output_image)\n    except Exception as e:\n        shutil.copyfile(image_path, error_image)\n        print(f'文件保存失败: {image_path}')\n        # print(e)\n \n \nif __name__ == '__main__':\n    # 批量创建文件夹\n    [clean_dir(i) for i in [template_dir, output_dir, error_dir]]\n \n    image_dir = input('dir path:')\n    target_size = int(input('target size (kb):'))\n \n    image_file_list = list(chain(*[glob(os.path.join(image_dir, i)) for i in ['*.png', '*.jpg', '*.jpeg']]))\n \n    #for temp_image_path in tqdm(image_file_list):\n    #     compress_image(temp_image_path)\n \n    print(f'\\n\\n文件保存父目录: {os.getcwd()}\\n'\n          f'输出文件位置:{os.path.join(os.getcwd(), output_dir)}\\n\\n')\n \n    # parallel\n    P = Pool(processes=10)\n    pbar = tqdm(total=len(image_file_list))\n \n    res_temp = [P.apply_async(func=compress_image, args=(i,target_size), callback=lambda _: pbar.update(1)) for i in\n                image_file_list]\n \n    _ = [res.get() for res in res_temp]\n```\n\n# 3. 上传npm\n\n到这一步就很简单了，把之前压缩好的图片放在一个文件夹里，如：\n\n```txt\n- mj-img\\\n    - 1.jpg\n    - 2.png\n      ...\n    - xxx.jpeg\n```\n\n之前用过npm的，可以直接在文件夹里打开`bash`，输入`npm init`与`npm publish`.\n\n没有使用过npm的，可以参考[Akilar的npm图床使用技巧](https://akilar.top/posts/3e956346/).","tags":["Python","爬虫"],"categories":["代码编程"]},{"title":"旋转目标检测 | IENet，单阶段Anchor-Free旋转目标检测模型","slug":"人工智能-IENet，单阶段Anchor-Free旋转目标检测模型","url":"/posts/afb37b1d.html","content":"\n# 1. 论文信息\n\n论文标题：《IENet: Interactive Embranchment Network Based One-Stage Anchor Free Detector for Orientational Aerial Object Detection》\n\n>论文发表：arxiv 2019\n>论文链接：[https://arxiv.org/pdf/1912.00969](https://arxiv.org/pdf/1912.00969)\n\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220420214710.png)\n\n```bib\n@article{lin2019ienet,\n  title={IENet: Interacting embranchment one stage anchor free detector for orientation aerial object detection},\n  author={Lin, Youtian and Feng, Pengming and Guan, Jian and Wang, Wenwu and Chambers, Jonathon},\n  journal={arXiv preprint arXiv:1912.00969},\n  year={2019}\n}\n```\n\n\n# 2. 归纳总结\n\n| Name   | Value                                  |\n| ------ | -------------------------------------- |\n| 标签   | #遥感 #目标检测                        |\n| 数据集 | DOTA,HRSC2016                          |\n| 目的   | 两阶段方法计算量大，单阶段方法性能不足 | \n| 方法   | 基于自注意力的互动分支                 |\n\n# 3. 问题背景\n\n作者提到，遥感图像的目标检测任务的难点在于：\n- 和自然图像相比，物体形状相似且可见特征稀少\n- 目标具有不同的旋转角度\n- 具有更多的小目标和密集目标\n\n而目前最好的性能都是两阶段算法实现的，但是两阶段算法通常在第一阶段定位，在第二阶段分类，因此计算量是非常大的，尤其是对旋转目标检测而言，因为Anchor匹配（涉及IoU计算）和RoI特征提取的计算量大。\n\n# 4. 主要工作\n\n针对上诉问题，作者提出了**IENet**（interactive embranchment network），其是一个**单阶段**的**Anchor-Free旋转目标**检测器，其包含如下贡献点：\n- 一个新的geometric transformation（几何变换），用于更好地表示旋转目标框\n- 一个基于自注意力机制的分支交互模块（a branch interactive module with a self-attention mechanism）\n- 一个针对旋转框检测改进的IoU Loss\n\n## 4.1 模型结构\n\n### （1） Baseline模型结构(FCOS-O)\n\n在FCOS的基础上增加了一个独立的角度回归分支（Orientation Regression）\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220420221515.png)\n\n### （2） IENet\n\n由于独立的角度分支不能很好的利用位置等信息，因此检测性能下降，基于此IENet提出了基于自注意力机制的分支交互模块即IE（Interactive Embranchment） Module，用于利用分类和位置回归信息。\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220420221600.png)\n\n## 4.2 旋转框几何变换\n\nIENet使用HBB+几何变换来表征OBB，如下图所示：\n\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220422192914.png)\n\nIENet使用HBB加h,w来表示一个OBB，其中GT OBB是一个8维的向量$[x_1,y_1,x_2,y_2,x_3,y_3,x_4,y_4]$，HBB可由$[x_{min},y_{min},x_{max},y_{max}]$表示，h和w计算如下：\n$$w=x_{max}-x_2$$\n$$h=y_{max}-y_1$$\n基于上述几何变化，可将OBB回归问题转换成HBB回归和方向回归的问题，其中HBB回归和FCOS的一致，为Box的偏移量$R_b=[l,t,r,b]$，方向回归为$R_o=[w,h]$.\n\n## 4.3 IE Module\n\nIE模块结构图：\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220420221612.png)\n\n在获得了分类和位置回归的特征图$F^m$后，使用1x1的卷积层和softmax层来构建自注意力模块：\n- 首先利用三个1x1的卷积层$f(F^m),g(F^m),h(F^m)$将特征映射到三个特征空间\n- 将$f(\\cdot)$和$g(\\cdot)$和并通过softmax层组成注意力图$\\gamma= softmax(f(F^m)^Tg(F^m))$，因此特征图之间的关系为$\\gamma_{q,p}= \\frac{exp(\\delta_{pq})}{\\sum_{p=1}^{N}exp(\\delta_{pq})}$，其中$q,p\\in\\{1,...,N\\}$为注意力图的行号和列号，$\\delta$代表$f(F^m)^Tg(F^m)$输出的NxN的矩阵\n- 然后，注意图可以用来表示输入特征之间的关系，并对$h(\\cdot)$的起作用，得到$\\theta=(\\theta_1,\\theta_2,...,\\theta_1,...,\\theta_N)$，且$\\theta_q=\\sum_{p=1}^N\\gamma_{q,p}h(f_p^m)$\n- 为了保留原始特征信息，最后输出的特征为$\\mathbb{Y}=\\gamma\\theta+F^m$\n\n## 4.4 损失函数\n\n总损失为：\n$$L = \\frac{1}{N_{pos}}L_{cls}+\\frac{\\lambda}{N_pos}L_{reg}+\\frac{\\omega}{N_{pos}}L_{ori}$$\n其中分类损失为Focal Loss损失\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220422200843.png)\n位置回归损失为centerness损失加smoothL1\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220422200856.png)\n角度回归损失为smoothL1损失\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220422200905.png)\n\n# 5. 实验结果\n\nDOTA_v1\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220420222408.png)\n\nHRSC2016\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220420222445.png)\n\n同时IENet在推理和训练时的速度上也有优势：\n\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220630104801.png)\n\n消融实验：\n\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220630104802.png)\n\n特征可视化：\n\n![](https://unpkg.com/justlovesmile-post@1.0.2/20220630104803.png)","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"目标检测 | ATSS，正负样本的选择决定检测性能","slug":"人工智能-ATSS论文笔记","url":"/posts/c9c6591.html","content":"\n# 1. 论文信息\n\n论文标题：`《Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection》`\n\n>论文发表：`CVPR2020`\n>论文链接：[https://openaccess.thecvf.com](https://openaccess.thecvf.com/content_CVPR_2020/papers/Zhang_Bridging_the_Gap_Between_Anchor-Based_and_Anchor-Free_Detection_via_Adaptive_CVPR_2020_paper.pdf)\n>论文代码：[https://github.com/sfzhang15/ATSS](https://github.com/sfzhang15/ATSS)\n\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220308201514.png)\n\n```bib\n@inproceedings{zhang2020bridging,\n  title={Bridging the gap between anchor-based and anchor-free detection via adaptive training sample selection},\n  author={Zhang, Shifeng and Chi, Cheng and Yao, Yongqiang and Lei, Zhen and Li, Stan Z},\n  booktitle={Proceedings of the IEEE/CVF conference on computer vision and pattern recognition},\n  pages={9759--9768},\n  year={2020}\n}\n```\n\n# 2. 归纳总结\n\n| Name   | Value  |\n| :----: | :----: |\n| 标签   | #正负样本 #目标检测 |\n| 数据集 | `MSCOCO`           |\n| 目的   | 通过实验发现`Anchor-Base`和`Anchor-Free`的区别在于正负样本定义，并提出了`ATSS` |\n| 方法   | 使用IoU的均值和标准差作为判断正负样本的自适应`IoU`阈值  |\n\n# 3. 问题背景\n\n论文指出单阶段`Anchor-Based`和`Center-Based Anchor-Free`检测算法的性能差异主要来自于`正负样本的选择策略不同`，基于此问题，作者提出了ATSS(Adaptive Training Sample Selection)方法，该方法能够自动根据真实框（GT）的相关统计特征自适应地选择合适的样本，进而提升模型性能...\n\n# 4. 主要工作\n\n- 指出`Anchor-Free`和`Anchor-Based`方法的根本差异主要来源于正负样本的选择;\n- 提出`ATSS`( `Adaptive Training Sample Selection`)方法来根据对象的统计特征自动选择正负样本;\n- 证明每个位置设定多个`anchor`是无用的操作;\n- 不引入其它额外的开销，在`MS COCO`上达到`SOTA`;\n\n\n## 4.1 `Anchor-Based`和`Anchor-Free`的区别分析\n\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220311102454.png)\n\n由于`FCOS`是基于`point`进行预测，故可以认为就是一个像素位置有一个`anchor`，为了公平对比，将`RetinaNet`的`anchor`也设置为1个(`#A=1`),将`FCOS`的训练策略移动到`RetinaNet`上面，可以发现性能依然是`RetinaNet`低于fcos 0.8mAP。 排除这个因素后，现在两个算法的区别是：\n- 1.**正负样本定义；**![](https://unpkg.com/justlovesmile-post@1.0.1/20220311102531.png)\n- 2.**回归分支中从`point`回归还是从`anchor`回归；**从`point`回归就是指的每个点预测距离4条边的距离模式，而从`anchor`回归是指的`RetinaNet`那种基于`anchor`偏移量回归的模式。![](https://unpkg.com/justlovesmile-post@1.0.1/20220311102948.png)\n\n但作者通过实验分析可以知道回归分支中从point回归还是从anchor回归对最终影响很小，反而是正负样本定义对结果影响最大。\n\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220311103001.png)\n\n## 4.2 ATSS\n\n算法流程如下：\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220311103116.png)\n\n论文提出ATSS方法，该方法根据目标的相关统计特征自动进行正负样本的选择，具体逻辑如算法1所示。对于每个GT box  `g`，首先在每个特征层找到中心点最近的`k`个候选anchor boxes(非预测结果)，计算候选box与GT间的IoU $U_g$，计算IoU的均值$m_g$和标准差$v_g$，得到IoU阈值$t_g=m_g+v_g$，最后选择阈值大于$t_g$的box作为最后的输出。如果anchor box对应多个GT，则选择IoU最大的GT。\n\n均值$m_g$表示预设的anchor与GT的匹配程度，均值高则应当提高阈值来调整正样本，均值低则应当降低阈值来调整正样本。标准差$v_g$表示适合GT的FPN层数，标准差高则表示高质量的anchor box集中在一个层中，应将阈值加上标准差来过滤其他层的anchor box，低则表示多个层都适合该GT，将阈值加上标准差来选择合适的层的anchor box，均值和标准差结合作为IoU阈值能够很好地自动选择对应的特征层上合适的anchor box;\n\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220311110826.png)\n\n根据统计原理，大约16%的anchor box会落在$[m_g+v_g,1]$，尽管候选框的IoU不是标准正态分布，但统计下来每个GT大约有0.2×kL个正样本，与其大小和长宽比无关，而RetinaNet和FCOS则是偏向大目标有更多的正样本，导致训练不公平；其中ATSS仅有一个超参数k，并且实验表明ATSS的性能对k不敏感，参数`k`在区间$[7,17]$几乎是一样的，过大的设置会到导致过多的低质量候选anchor，而过小的设置则会导致过少的正样本，而且统计结果也不稳定。总体而言，参数`k`是相对鲁棒的，所以ATSS几乎是hyperparameter-free的。\n\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220311111137.png)\n\n\n将ATSS应用到RetinaNet和FCOS上测试效果：\n- 将RetinaNet中的正负样本替换为ATSS，AP提升了2.9%，这样的性能提升几乎是没有任何额外消耗的\n- 在FCOS上的应用主要用两种：lite版本采用ATSS的思想，从选取GT内的anchor point改为选取每层离GT最近的top-$k$个候选anchor point，提升了0.8%AP；full版本将FCOS的`anchor point`改为长宽为$8S$的`anchor box`来根据ATSS选择正负样本，但仍然使用原始的回归方法，提升了1.4%AP。两种方法找到的`anchor point`在空间位置上大致相同，但是在`FPN`层上的选择不太一样。从结果来看，自适应的选择方法比固定的方法更有效。\n\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220629153201.png)\n\n论文还补充测试了不同anchor数下的性能，并且其实验结果证明，在每个位置设定多个anchor box是无用的操作，关键在于选择合适的正样本；\n\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220629153202.png)\n\n# 5. 实验结果\n\n![](https://unpkg.com/justlovesmile-post@1.0.1/20220311111508.png)\n\n\n# 6. 参考文献\n\n[ATSS : 目标检测的自适应正负anchor选择，很扎实的trick | CVPR 2020 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/115407465)","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"Hexo博客 | 如何为博客添加顶部轮播图和文章推荐卡片","slug":"博客相关-如何为博客添加顶部轮播图和文章推荐卡片","url":"/posts/6a0d6454.html","content":"\n最近看了[zhheo](https://blog.zhheo.com/)大佬的博客首页，发现大佬的布局还是那么的好看，于是果断`COPY`，再加上我一直想要在我的博客首页加一个大画幅的轮播图插件，于是又参考了[Hassan](https://hassanwong.top/)的文章轮播图...经过一番折腾，效果如下：\n\n![](https://unpkg.com/justlovesmile-post@1.0.0/2022062808552601.jpg)\n\n# 1. 创建首页顶部模块\n\n## 1.1 创建`hometop.pug`\n\n在`themes/butterfly/layout/includes`路径下创建`hometop.pug`文件：\n\n```pug\nif is_home()\n  #home_top\n    include bbTimeList.pug\n    .home_top_group\n      #homeTopGroup.homeTopGroup\n        #banner_group\n          #banners\n            include sticky.pug //轮播图\n          .category_group\n            .category_item\n              a.category_button(href=<左下角标签1路径>,style=\"background:linear-gradient(to right,#364f6b,#3fc1c9)\")\n                span.category_button_text <标签1名称>\n                i.fas.fa-laptop-code\n            .category_item\n              a.category_button(href=<左下角标签2路径>,style=\"background:linear-gradient(to right,#6639a6,#3490de)\")\n                span.category_button_text <标签2名称>\n                i.fas.fa-lightbulb\n            .category_item\n              a.category_button(href=<左下角标签3路径>,style=\"background:linear-gradient(to right,#f65,#ffbf37)\")\n                span.category_button_text <标签3名称>\n                i.fas.fa-book\n        .top_post_group // 右侧文章推荐卡片\n          if site.data.slider\n            each i in site.data.slider\n              .top_post_item\n                .post_cover\n                  a(href=url_for(i.link) title=i.title)\n                    img.post_bg.entered.loaded(src=url_for(i.cover))\n                    .post_cover_info\n                      p.post_cover_text= i.description\n\n                .post_info(onclick=`\"window.open(`+url_for(i.link)+`,\"_self\")\"`)\n                  a.article-title(href=url_for(i.link) title=i.title)= i.title\n```\n\n其中第一行的`is_home()`是`Hexo`自带的辅助函数，用于判断是否为首页，但是其在`justlovesmile.top/`以及`justlovesmile.top/page/2/`等页面都返回`True`，因此如果你只想在首页的第一页显示该模块，可以使用`is_current('/')`。\n\n## 1.2 添加`css`样式\n\n在自己的`css`文件中添加：\n\n```css\n:root{\n    --mj-white: #fff;\n    --mj-card-bg: #fff;\n    --mj-theme: #425AEF;\n    --mj-main: #425AEF;\n    --mj-secondbg: #ededed;\n    --mj-card-border: #e3e8f7;\n    --style-border: 1px solid var(--mj-card-border);\n    --style-hover-border: 1px solid var(--mj-theme);\n}\n/* home top */\n#home_top {\n    max-width: 1500px;\n    width: 100%;\n    margin-top: .5rem;\n    padding: 0 15px;\n    margin: 0 auto;\n}\n.home_top_group {\n    border-radius: 12px;\n    overflow: auto;\n    width: 100%;\n    margin-bottom: 0;\n}\n.homeTopGroup {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    width: 100%;\n    margin-top: 1rem;\n    overflow: auto;\n    overflow-x: score;\n    border-radius: 12px;\n}\n.homeTopGroup::-webkit-scrollbar {\n    display: none;\n}\n.homeTopGroup #banner_group {display: flex;}\ndiv#banners {display: none;}\n@media screen and (min-width: 1300px){\n  .homeTopGroup #banner_group {\n    width: calc(100% - 600px - 1.5rem);\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n  }\n  div#banners {\n    display: flex;\n    width: 100%;\n    height: 100%;\n    background: var(--mj-main);\n    margin-bottom: .5rem;\n    margin-right: .5rem;\n    border: var(--style-border);\n    border-radius: 12px;\n    overflow: hidden;\n    position: relative;\n  }\n  div#banners:hover{\n    border: var(--style-hover-border);\n  }\n  .homeTopGroup .category_group {\n    flex-direction: row !important;\n  }\n  .homeTopGroup .category_item {\n    width: calc(100% / 3 - .33rem);\n    height: 100% !important;\n    margin-right: .5rem;\n  }\n  .homeTopGroup .category_item:nth-child(3) {\n    margin-right: 0;\n    display: flex !important;\n  }\n  #banner-page {\n    width: 100%;\n    height: 100%;\n  }\n  .top_post_group {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: flex-end;\n    height: calc(328px + .5rem);\n    align-content: space-between;\n    width: calc(600px + 1.5rem);\n  }\n}\n\n.homeTopGroup .category_group{\n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n    min-width: 200px;\n}\n.homeTopGroup .category_item {\n    overflow: hidden;\n    transform: scale(1);\n    transition: .3s;\n    height: 48%;\n    border-radius: 12px;\n}\n.homeTopGroup .category_item:nth-child(3) {\n    display: none;\n}\n.homeTopGroup .category_item a.category_button {\n    height: 100%;\n    width: 100%;\n    background: var(--mj-card-bg);\n    border-radius: 12px;\n    display: inline-block;\n    text-align: left;\n    line-height: 4em;\n    font-weight: 700;\n    font-size: .9rem;\n    color: var(--mj-white);\n    transition: all .4s cubic-bezier(.39,.575,.565,1);\n    transform: scale(1);\n    overflow: hidden;\n    font-family: PingFang SC,Hiragino Sans GB,Microsoft YaHei;\n}\n.category_button_text {\n    padding-left: 25px;\n}\na.category_button i {\n    font-size: 3rem;\n    opacity: .3;\n    position: absolute;\n    right: 15px;\n    top: 10%;\n    transition: .3s;\n    transform: rotate(-10deg);\n    /*width: 100px;\n    text-align: center;*/\n}\na.category_button:hover i {\n    opacity: .8;\n    transition: .8s;\n    transition-delay: .15s;\n    transform: scale(1.1)\n}\na.category_button:hover:after{\n    width: 3rem;\n    transition: .8s;\n}\na.category_button:after {\n    top: 40px;\n    width: 1rem;\n    left: 25px;\n    height: 2px;\n    background: var(--mj-white);\n    content: \"\";\n    border-radius: 1px;\n    position: absolute;\n    transition: .8s;\n}\n@media screen and (max-width: 768px){\n  #home_top{\n    padding: 0 5px;\n  }\n  .homeTopGroup .category_group {\n    min-width: 130px!important;\n  }\n  .top_post_group .top_post_item{\n    border-radius: 0;\n  }\n}\n.top_post_group{\n    display: flex;\n    position: relative;\n}\n.top_post_group .top_post_item {\n    display: flex;\n    width: 200px;\n    min-width: 200px;\n    height: 164px;\n    max-height: 164px;\n    flex-direction: column;\n    align-items: flex-start;\n    margin-left: .5rem;\n    background: var(--mj-card-bg);\n    border-radius: 12px;\n    overflow: hidden;\n    border: var(--style-border);\n}\n.top_post_group .top_post_item:hover {border: var(--style-hover-border);}\n.top_post_group .top_post_item .post_cover {\n    width: 100%;\n    height: 110px;\n    position: relative;\n}\n.top_post_group .top_post_item .post_cover img {\n    object-fit: cover;\n    width: 100%;\n    height: 110px;\n    background: var(--mj-secondbg);\n}\n.top_post_group .top_post_item .post_cover .post_cover_info {\n    position: absolute;\n    top: 0;\n    width: 101%;\n    height: 100%;\n    opacity: 0;\n    background-color: rgba(0,0,0,0.7) !important;\n    transition: all 0.3s ease;\n    display: flex;\n} \n.top_post_group .top_post_item:hover .post_cover .post_cover_info{\n    opacity: 1;\n}\n.top_post_group .top_post_item .post_cover .post_cover_info .post_cover_text{\n    color: #fff;\n    padding: 12px 14px;\n    font-size: 15px;\n    font-weight: 400;\n    margin: 20px 0;\n    -webkit-line-clamp: 2;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n}\n.top_post_group .top_post_item:hover .post_info,\n.top_post_group .top_post_item:focus .post_info{\n    /*background: var(--mj-theme);*/\n    box-shadow: inset 0 -60px 0 0 var(--mj-theme);\n}\n.top_post_group .top_post_item .post_info a{\n    color: var(--mj-fontcolor) !important;\n    transition: 0;\n}\n.top_post_group .top_post_item:hover .post_info a{\n    color: var(--mj-white) !important;\n}\n.top_post_group .top_post_item .post_info {\n    padding: .2rem .5rem .3rem .5rem!important;\n    transition: .3s;\n    width: 100%;\n    height: 100%;\n}\n.top_post_group .top_post_item .post_info .article-title {\n    -webkit-line-clamp: 2;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    line-height: 1.4;\n    justify-content: center;\n    align-items: flex-end;\n    align-content: center;\n    font-weight: 600;\n    font-size: .8rem!important;\n    padding: 0!important;\n}\n```\n\n# 2. 创建顶部轮播图\n\n## 2.1 创建`sticky.pug`\n\n在`themes/butterfly/layout/includes`路径下创建`sticky.pug`文件：\n\n```pug\nlink(rel='stylesheet' href='https://unpkg.com/swiper/swiper-bundle.min.css')\n#sticky\n  #stickyList.swiper-container\n    #stickyWrapper.swiper-wrapper\n      .swiper-slide(onclick=`window.open('/random/','_self')`)\n        .grid-img\n          iframe#banner-page(src=\"<这里放iframe地址>\" frameborder=\"0\" loading=\"eager\") // 可以放iframe\n        .grid-title\n          span 随便逛逛\n          i.fas.fa-arrow-right\n      .swiper-slide(onclick=`window.open('/video/','_self')`)\n        .grid-img\n          img.cover.entered.loaded(alt='VLOG' src='https://unpkg.com/justlovesmile-photo/myvlog.gif') // 可以放GIF\n        .grid-title\n          span 看看VLOG\n          i.fas.fa-arrow-right\n      .swiper-slide(onclick=`window.open('/music/','_self')`)\n        .grid-img\n          img.cover.entered.loaded(alt='歌单' src='https://unpkg.com/justlovesmile-img/gitar.jpg') // 可以放图片\n        .grid-title\n          span 听听音乐\n          i.fas.fa-arrow-right\n    //- 分页器\n    .swiper-pagination\n\n.js-pjax\n  script(src='https://unpkg.com/swiper/swiper-bundle.min.js')\n  script(src='/js/sticky.js')\nlink(rel='stylesheet' href='/css/sticky.css')\n```\n\n## 2.2 创建`sticky.js`\n\n在`themes/butterfly/source/js`路径下创建`sticky.js`文件：\n\n```js\nvar mySwiper = new Swiper('#stickyList', {\n      direction: 'horizontal',\n      speed: 600,\n      loop: true,\n      effect : 'fade',\n      loopPreventsSlide: false,\n      autoplay: {\n        delay: 20000,\n      },\n      mousewheel: false,\n      pagination: {\n          el: \".swiper-pagination\",\n          dynamicBullets: true,\n      },\n    })\n```\n\n## 2.3 创建`sticky.css`\n\n在`themes/butterfly/source/css`路径下创建`sticky.css`文件：\n\n```css\n:root{\n    --mj-white: #fff;\n    --mj-card-bg: #fff;\n    --mj-theme: #425AEF;\n}\n#sticky,\n#stickyList,\n#stickyWrapper{\n  width: 100%;\n  height: 100%;\n}\n.swiper-container#stickyList {\n  overflow: hidden;\n}\n#stickyList .swiper-slide {\n  background: var(--mj-card-bg);\n  position: relative;\n  border-radius: 12px;\n  transition: 0.3s;\n  width: 100%;\n  height: 100%;\n}\n#stickyList .swiper-slide .grid-img {\n  overflow: hidden;\n  height: 16.2rem;\n}\n#stickyList .swiper-slide .grid-img img {\n  transition: 0.3s;\n  object-fit: cover;\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n#stickyList .swiper-slide:hover .grid-title{\n  opacity: .8;\n  cursor: pointer !important;\n}\n#stickyList .swiper-slide:hover .grid-img{\n  filter: blur(5px);\n}\n#stickyList .swiper-slide:hover .grid-title span,\n#stickyList .swiper-slide:hover .grid-title i{\n  transform: translateX(0px);\n  transition: .5s;\n}\n#stickyList .swiper-slide .grid-title span,\n#stickyList .swiper-slide .grid-title i{\n  transform: translateX(-100px);\n  transition: .5s;\n}\n#stickyList .swiper-slide .grid-title {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: var(--mj-theme);\n  color: var(--mj-white);\n  padding-left: 1.5rem;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  opacity: 0;\n  transition: .5s;\n}\n#stickyList .swiper-slide .grid-title span {\n  font-size: 5rem;\n  font-weight: 700;\n  line-height: 5rem;\n}\n#stickyList .swiper-slide .grid-title i {\n    font-size: 4rem;\n    opacity: .6;\n}\n@media screen and (max-width: 768px) {\n  #sticky {\n    display: none;\n  }\n}\n```\n\n# 3. 创建文章推荐卡片\n\n## 3.1 创建`slider.yml`\n\n在`hexo\\source\\_data\\`路径下创建`slider.yml`文件，最好准备`6`个推荐文章，例如：\n\n```yml\n#- cover: 封面图片链接\n#  timeline: '2020-10-01' # 日期，需要用''包裹\n#  link: 置顶文章链接，站内文章建议填相对链接\n#  title: 置顶文章标题\n#  description: 置顶文章描述\n- cover: https://unpkg.com/justlovesmile-img/20200715201402.png\n  timeline: '2020-07-15'\n  link: /posts/c8972b63.html\n  title: 必看 | Hexo博客搭建超级指南\n  description: Hexo博客搭建全过程，环境部署，博客魔改等等...\n- cover: https://unpkg.com/justlovesmile-img/090412-1557363852af44.jpg\n  timeline: '2020-04-09'\n  link: /posts/56163.html\n  title: Hexo博客 | 博客中能用到的代码（一）\n  description: 这篇文章介绍了如何使用font awesome图标字体库，使用动态图标，添加网页运行时间，全站变黑白，鼠标点击特效，网页标题的动态效果，网页樱花特效，鼠标触动音乐特效\n- cover: https://unpkg.com/justlovesmile-img/095658-1562983018e455.jpg\n  timeline: '2020-04-09'\n  link: /posts/15391.html\n  title: Hexo博客 | 博客中能用到的代码（二）\n  description: 这篇文章介绍了如何添加旋转小人和每日诗句\n- cover: https://unpkg.com/justlovesmile-img/20220331192754.png\n  timeline: '2022-03-31'\n  link: /posts/a806bebe.html\n  title: 推荐 | 计算机专业，大学课程「笔记归档」\n  description: 本文是博主本科期间的专业课程学习笔记的整理和归档，适合计算机专业的同学阅读。\n- cover: https://unpkg.com/justlovesmile-img/20220318183107.png\n  timeline: '2022-03-18'\n  link: /posts/589ec011.html\n  title: 深度学习 | Detectron2使用指南\n  description: Detectron2是Facebook AI Research的检测和分割框架，其主要基于PyTorch实现，但具有更模块化设计，因此它是灵活且便于扩展的。\n- cover: https://unpkg.com/justlovesmile-img/202109111517311.jpg\n  timeline: '2021-09-11'\n  link: /posts/865c56ba.html\n  title: 目标检测 | 常用数据集标注格式及生成脚本\n  description: 目标检测是计算机视觉任务中的一个重要研究方向，是计算机视觉的根本性问题之一，是其他诸多计算机视觉任务的基础以及前提。本文主要介绍了目标检测数据集的几种标注格式和转换代码。\n```\n\n## 3.2 `css`样式\n\n见`1.2`中`.top_post_group`等样式类，不再赘述...\n\n# 4. 补充：zhheo大佬首页人来人往特效\n\n## 4.1 创建`people`页面\n\n在`hexo\\source\\`路径下创建`people`文件夹，其中创建`index.html`:\n\n```html\n---\nlayout: false\n---\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>MJ's People Page</title>\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0, minimal-ui\" /><!--禁止缩放-->\n\t<link rel=\"stylesheet\" href=\"/people/style.css\">\n</head>\n<body>\n\t<canvas id=\"canvas\" width=\"808\" height=\"244\"></canvas>\n\t<script src=\"https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/gsap/3.9.1/gsap.min.js\"></script>\n\t<script src=\"/people/script.js\"></script></body>\n</html>\n```\n\n## 4.2 创建`css`样式\n\n在`hexo\\source\\people`路径下，创建`style.css`:\n```css\nbody,\nhtml{\n\theight:100%;\n\tbackground-color:#fff;\n}\nbody{\n\tmargin:0;\n}\n#canvas{\n\twidth:100%;\n\theight:100%;\n}\nbody::-webkit-scrollbar{\n\tdisplay:none;\n}\n```\n\n## 4.3 创建`js`文件\n\n在`hexo\\source\\people`路径下，创建`script.js`:\n\n```js\n\"use strict\";function _toConsumableArray(e){return _arrayWithoutHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}function _unsupportedIterableToArray(e,r){if(e){if(\"string\"==typeof e)return _arrayLikeToArray(e,r);var t=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===t&&e.constructor&&(t=e.constructor.name),\"Map\"===t||\"Set\"===t?Array.from(e):\"Arguments\"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(e,r):void 0}}function _iterableToArray(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)}function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}function _arrayLikeToArray(e,r){(null==r||r>e.length)&&(r=e.length);for(var t=0,a=new Array(r);t<r;t++)a[t]=e[t];return a}function _classCallCheck(e,r){if(!(e instanceof r))throw new TypeError(\"Cannot call a class as a function\")}function _defineProperties(e,r){for(var t=0;t<r.length;t++){var a=r[t];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),e}var config={src:\"https://unpkg.com/guli-heo/others/open-peeps-sheet.png\",rows:15,cols:7},randomRange=function(e,r){return e+Math.random()*(r-e)},randomIndex=function(e){return 0|randomRange(0,e.length)},removeFromArray=function(e,r){return e.splice(r,1)[0]},removeItemFromArray=function(e,r){return removeFromArray(e,e.indexOf(r))},removeRandomFromArray=function(e){return removeFromArray(e,randomIndex(e))},getRandomFromArray=function(e){return e[0|randomIndex(e)]},resetPeep=function(e){var r,t,a=e.stage,n=e.peep,o=.5<Math.random()?1:-1,i=100-250*gsap.parseEase(\"power2.in\")(Math.random()),s=a.height-n.height+i;return 1==o?(r=-n.width,t=a.width,n.scaleX=1):(r=a.width+n.width,t=0,n.scaleX=-1),n.x=r,n.y=s,{startX:r,startY:n.anchorY=s,endX:t}},normalWalk=function(e){var r=e.peep,t=e.props,a=(t.startX,t.startY),n=t.endX,o=gsap.timeline();return o.timeScale(randomRange(.5,1.5)),o.to(r,{duration:10,x:n,ease:\"none\"},0),o.to(r,{duration:.25,repeat:40,yoyo:!0,y:a-10},0),o},walks=[normalWalk],Peep=function(){function a(e){var r=e.image,t=e.rect;_classCallCheck(this,a),this.image=r,this.setRect(t),this.x=0,this.y=0,this.anchorY=0,this.scaleX=1,this.walk=null}return _createClass(a,[{key:\"setRect\",value:function(e){this.rect=e,this.width=e[2],this.height=e[3],this.drawArgs=[this.image].concat(_toConsumableArray(e),[0,0,this.width,this.height])}},{key:\"render\",value:function(e){e.save(),e.translate(this.x,this.y),e.scale(this.scaleX,1),e.drawImage.apply(e,_toConsumableArray(this.drawArgs)),e.restore()}}]),a}(),img=document.createElement(\"img\");img.onload=init,img.src=config.src;var canvas=document.querySelector(\"#canvas\"),ctx=canvas.getContext(\"2d\"),stage={width:0,height:0},allPeeps=[],availablePeeps=[],crowd=[];function init(){createPeeps(),resize(),gsap.ticker.add(render),window.addEventListener(\"resize\",resize)}function createPeeps(){for(var e=config.rows,r=config.cols,t=e*r,a=img.naturalWidth/e,n=img.naturalHeight/r,o=0;o<t;o++)allPeeps.push(new Peep({image:img,rect:[o%e*a,(o/e|0)*n,a,n]}))}function resize(){stage.width=canvas.clientWidth,stage.height=canvas.clientHeight,canvas.width=stage.width*devicePixelRatio,canvas.height=stage.height*devicePixelRatio,crowd.forEach(function(e){e.walk.kill()}),crowd.length=0,availablePeeps.length=0,availablePeeps.push.apply(availablePeeps,allPeeps),initCrowd()}function initCrowd(){for(;availablePeeps.length;)addPeepToCrowd().walk.progress(Math.random())}function addPeepToCrowd(){var e=removeRandomFromArray(availablePeeps),r=getRandomFromArray(walks)({peep:e,props:resetPeep({peep:e,stage:stage})}).eventCallback(\"onComplete\",function(){removePeepFromCrowd(e),addPeepToCrowd()});return e.walk=r,crowd.push(e),crowd.sort(function(e,r){return e.anchorY-r.anchorY}),e}function removePeepFromCrowd(e){removeItemFromArray(crowd,e),availablePeeps.push(e)}function render(){canvas.width=canvas.width,ctx.save(),ctx.scale(devicePixelRatio,devicePixelRatio),crowd.forEach(function(e){e.render(ctx)}),ctx.restore()}\n```\n\n# 5. 参考文章\n\n[张洪Heo - 分享设计与科技生活](https://blog.zhheo.com/)\n[Butterfly主题美化魔改集锦 | Hassan's Blog](https://hassanwong.top/posts/9d49f75f/#%E9%A6%96%E9%A1%B5%E7%BD%AE%E9%A1%B6%E6%96%87%E7%AB%A0%E8%BD%AE%E6%92%AD%E7%BB%84%E4%BB%B6)","tags":["Hexo","前端","JS"],"categories":["博客相关"]},{"title":"Hexo博客 | 视频点播页面，如何在博客上优雅地展示B站等平台视频","slug":"博客相关-视频点播页面","url":"/posts/7127424c.html","content":"\n\n>之前考虑到自己剪了一些vlog，但是直接用`iframe`嵌入的话页面会很长，而且点开这个页面会自动加载全部视频，感觉很奇怪，并且不能很好的展示，于是写了一个视频点播页面\n\n## 1. 新建路径页面\n\n首先使用命令新建一个页面：\n```bash\nhexo new page video\n```\n\n在`index.md`里面写入一下内容：\n```html\n---\ntitle: 我的视频\ndate: 2020-07-17 20:54:09\ncomment: true\ntop_img: false\nshowToc: true\naside: false\ntype: \"video\"\n---\n\n<script src=\"https://unpkg.com/jquery@latest/dist/jquery.min.js\"></script>\n<script>\nfunction selectVideo(id){\n    var src=$(\"#video-item-\"+id).attr(\"data-src\");\n    $(\"#video-select\").html(\"<iframe id='video-iframe' src='\"+src+\"' scrolling='no' border='0' frameborder='no' framespacing='0' allowfullscreen='true'> </iframe>\");\n    var iframe = document.getElementById(\"video-select\")\n    if(iframe.attachEvent){\n      iframe.attachEvent(\"onreadystatechange\", function() {\n        if (iframe.readyState === \"complete\" || iframe.readyState == \"loaded\") {\n          iframe.detachEvent(\"onreadystatechange\", arguments.callee);\n        if (document.getElementsByClassName('video-mirror').length>0) {\n          console.log(\"1true\")\n          $(\".video-mirror\").attr(\"style\",\"transform:scaleX(-1);\")\n          }\n        }\n      });\n    }else{\n      iframe.addEventListener(\"load\", function() {\n        this.removeEventListener(\"load\", arguments.call, false);\n      if (document.getElementsByClassName('video-mirror').length>0) {\n        console.log(\"2true\")\n        $(\".video-mirror\").attr(\"style\",\"transform:scaleX(-1);\")\n      }\n      }, false);\n    }\n}\n$(document).ready(selectVideo(0));\n</script>\n```\n\n## 2. 新建主题页面\n\n在主题路径`themes\\butterfly-dev\\layout\\includes\\page`下新建`video.pug`：\n\n```pug\n//if top_img === false\n//  h1.page-title= page.title\n#video-select.video-select\nhr\nh3= 视频列表\n.videos\n  if site.data.video\n    each i,index in site.data.video\n      div(class=\"myvideo\" onclick=`javascipt:selectVideo(`+index+`)`)\n        div(id=`video-item-`+index class=\"video-item\" data-src=url_for(i.link))\n          a(href=\"#video-select\")\n            img.video-item-cover(src=url_for(i.cover))\n        .video-desc\n          .video-title\n            a(href=\"#video-select\")= i.title\n          .video-info= i.description\n\nstyle.\n  .videos{\n    display: grid;\n    grid-template-columns: repeat(4, 1fr);\n    grid-column-gap: 20px;\n    grid-row-gap: 20px;\n  }\n  @media screen and (max-width: 1200px){\n    .videos{\n      display: grid;\n      grid-template-columns: repeat(3, 1fr);\n      grid-column-gap: 20px;\n      grid-row-gap: 20px;\n    }\n  }\n  @media screen and (max-width: 900px){\n    .videos{\n      display: grid;\n      grid-template-columns: repeat(2, 1fr);\n      grid-column-gap: 20px;\n      grid-row-gap: 20px;\n    }\n  }\n  @media screen and (max-width: 600px){\n    .videos{\n      display: grid;\n      grid-template-columns: repeat(1, 1fr);\n      grid-column-gap: 20px;\n      grid-row-gap: 20px;\n    }\n  }\n  .myvideo{\n    position: relative;\n    width: 100%;\n    border: 1px solid var(--mj-card-border);\n    border-radius: 12px;\n  }\n  .video-item{\n    overflow: hidden;\n    height: 160px;\n    border-top-left-radius: 12px;\n    border-top-right-radius: 12px;\n  }\n  .video-item img {\n    position: relative;\n    width: 100%;\n    margin: 0 !important;\n    height: 100%;\n    transform: scale(1.0);\n    transition: .3s;\n    object-fit: cover;\n  }\n  .myvideo:hover .video-item img {\n    transition: .3s;\n    transform: scale(1.1);\n  }\n  .video-title{\n    padding: 5px 10px;\n    font-size: 18px;\n    font-weight: bold;\n  }\n  .video-info{\n    font-size: 14px;\n    padding: 0 10px;\n    color: var(--mj-secondtext);\n  }\n  .video-select{\n    position:relative;\n    width:100%;\n    height:0;\n    padding-bottom:75%;\n  }\n  .video-select iframe{\n    position:absolute;\n    width:100%;\n    height:100%;\n    left:0;\n    top:0;\n    border-radius: 12px;\n  }\n!= page.content\n```\n\n## 3. 注册video页面\n\n在主题路径`butterfly/layout/`的`page.pug`文件中注册上述页面模板：\n\n```pug\nextends includes/layout.pug\n\nblock content\n  #page\n    if top_img === false\n      h1.page-title= page.title\n\n    case page.type\n      when 'tags'\n        include includes/page/tags.pug\n      when 'link'\n        include includes/page/flink.pug\n      when 'categories'\n        include includes/page/categories.pug\n+     when 'video'\n+       include includes/page/video.pug\n      default\n        include includes/page/default-page.pug\n\n    if page.comments !== false && theme.comments && theme.comments.use\n      - var commentsJsLoad = true\n      !=partial('includes/third-party/comments/index', {}, {cache: true})\n```\n\n\n## 4. 获取B站等平台视频嵌入代码\n\n在视频播放页面通常会有分享按钮，并且一般会提供链接和`iframe`嵌入两种分享方式，例如我的（顺便求一波[关注](https://www.bilibili.com/video/BV18T4y1D7wj?zw)）：\n![](https://unpkg.com/justlovesmile-img/20220504105540.png)\n\n复制`iframe`代码，如下：\n\n```html\n<iframe src=\"//player.bilibili.com/player.html?aid=937145035&bvid=BV18T4y1D7wj&cid=545915013&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n```\n\n## 5. 新建data文件\n\n在`hexo\\source\\_data`路径下(没有就创建一个文件夹)新建一个数据文件`video.yml`，把刚才的`iframe`代码内容转换成：\n\n```yml\n- cover: https://unpkg.com/justlovesmile-img/33f7ad7c55b5df1e5bdb6a6ea3eb35b.jpg\n  time: 2022/03/10\n  link: //player.bilibili.com/player.html?aid=937145035&bvid=BV18T4y1D7wj&cid=545915013&page=1\n  title: 雷神池，璃月雷神前来报道\n  description: 【原神】20220310\n```\n\n## 6. 结语\n\n至此，一个视频点播页面就做好了，该方法适用于一切提供iframe嵌入的视频平台，页面展示如下：\n\n![](https://unpkg.com/justlovesmile-img/20220504110304.png)","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"旋转目标检测 | R3Det，基于特征精炼的单阶段检测模型","slug":"人工智能-R3Det论文笔记","url":"/posts/809258ef.html","content":"\n# 1. 论文信息\n\n论文标题： R3det: Refined single-stage detector with feature refinement for rotating object\n\n>论文发表：AAAI 2021\n>论文链接：[https://ojs.aaai.org/index.php/AAAI/article/view/16426/16233](https://ojs.aaai.org/index.php/AAAI/article/view/16426/16233)\n>论文代码：[https://github.com/Thinklab-SJTU/R3Det_Tensorflow](https://github.com/Thinklab-SJTU/R3Det_Tensorflow)\n\n![](https://unpkg.com/justlovesmile-img/20220322100025.png)\n\n```bib\n@article{yang2019r3det,\n  title={R3det: Refined single-stage detector with feature refinement for rotating object},\n  author={Yang, Xue and Liu, Qingqing and Yan, Junchi and Li, Ang and Zhang, Zhiqiang and Yu, Gang},\n  journal={arXiv preprint arXiv:1908.05612},\n  volume={2},\n  number={4},\n  pages={2},\n  year={2019},\n  publisher={Aug}\n}\n```\n\n# 2. 归纳总结\n\n| 标签  | 目的                                                | 方法                         | 总结 |\n| ----- | --------------------------------------------------- | ---------------------------- | ---- |\n| #遥感 #单阶段 #Anchor | 针对单阶段精炼检测器特征未对齐的问题，提出了FRM模块 | RRetinaNet Based,FRM,SkewIou | 精炼 | \n\n# 3. 问题背景\n\n作者称对于旋转目标检测存在三个挑战：\n- 大宽高比\n- 密集排列\n- 方向任意\n\n# 4. 主要工作\n\n针对上述问题，作者提出了R3Det，其主要工作如下：\n- progressive regression： 作者发现旋转框在密集场景下的能有较好的目标检测精度，而水平框能达到更好的召回率，因此使用了这两种形式的框进行组合，具体做法是第一阶段检测水平框，从而提升检测速度，提高召回率，第二阶段也就是精炼阶段（refinement stage）检测旋转框，以适应密集目标的检测。\n- feature refinement module：针对现有的单阶段refined detector，作者发现他们存在特征没对齐的问题，因此设计了一个特征精炼模块，使用特征插值来获取精炼的位置信息并重建特征图实现特征对齐，并且该模块还可以减少精炼边界框的数量，提升检测速度。\n- approximate SkewIoU loss：为解决Skew IoU计算不可微的问题，设计了一种近似SkewIoU损失，以获得更精确的旋转估计。\n\n## 4.1 模型结构\n\nR3Det主要基于 RetinaNet 实现，结构如下：\n\n![](https://unpkg.com/justlovesmile-img/20220322120220.png)\n\n## 4.2 边界框定义\n\n对于边界框$(x,y,w,h,\\theta)$，其中x，y代表中心点坐标，w，h代表宽和高，$\\theta \\in [-\\frac{\\pi}{2},0)$代表角度，边界框回归的值为：\n![](https://unpkg.com/justlovesmile-img/20220323144748.png)\n\n其中$x,x_a,x'$分别代表gt，anchor以及预测值，其余同上。\n\n损失函数为：\n![](https://unpkg.com/justlovesmile-img/20220323144809.png)\n\n其中$v'$为预测的偏移量向量，v代表gt的偏移量向量。其中N表示Anchor的数目,超参数 $\\lambda_1$， $\\lambda_2$ 控制着这两个损失的平衡，并且默认值为1。$L_{cls}$ 和 $L_{reg}$ 分别是Focal Loss和smooth L1 Loss。\n\n## 4.3 精炼检测\n\nSkew IoU对于角度十分敏感，因此作者在第一阶段使用0.5为前景阈值，0.4为背景阈值，在精炼的第一阶段使用0.6为前景阈值，0.5为背景阈值，如果有多段精炼阶段，使用0.7以及0.6为阈值。总损失：\n$$L_{total}=\\sum_{i=1}^N\\alpha_iL_i$$\n其中$L_i$为第i个精炼阶段的损失，$\\alpha_i$为平衡系数，默认为1.\n\n## 4.4 特征精炼模块\n\n![](https://unpkg.com/justlovesmile-img/20220323154129.png)\n\n许多精炼检测器仍然使用相同的特征图来执行多个分类和回归，而没有考虑边界框位置变化引起的特征未对齐。因此作者提出将当前精炼边界框(橙色矩形)的位置信息重新编码为对应的特征点(红色点)，从而以逐像素的方式**重构整个特征图**，实现**特征对齐**。整个过程如上图（c）所示。为了准确地获取精炼后的包围框对应的位置特征信息，采用了双线性特征插值方法，如上图（a）所示。特征插值可以表示为:\n![](https://unpkg.com/justlovesmile-img/20220323154551.png)\n其中A代表图（a）中的区域，$F\\in \\mathbb{R}^{C\\times 1\\times 1}$代表特征图上点的特征向量。\n\n算法流程：\n![](https://unpkg.com/justlovesmile-img/20220323154753.png)\n\n\n# 5. 实验结果\n\n![](https://unpkg.com/justlovesmile-img/20220323155610.png)\n","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"记录 | 博客运行超过1000天啦，继续砥砺前行","slug":"博客相关-博客运行1000天啦","url":"/posts/d90df99b.html","content":"\n就在刚刚，我在整理阅读笔记、准备发到博客上的时候，突然瞟到博客右下角的运行时间，惊喜地发现博客已经运行超过1000天啦，心中突然有一种又开心又欣慰的情绪在弥漫...\n\n![](https://unpkg.com/justlovesmile-img/20220408143144.png)\n\n## 从wordpress到hexo\n\n时间过得真快呀，我还记得自己第一次建立博客那天，刚考完期末考试，回到寝室，室友说他发现了一个特别好看的个人网站，我看着那个网站，心中萌发出我也要拥有一个自己的博客的想法，于是在当天我搜索了很多建立个人网站的教程，最后因为自己课设用过python的flask框架并且写过静态的HTML，于是决定在阿里云上购买了一个轻量应用服务器（学生有优惠），然后自己写一个博客网页，因此当时的博客非常简单（并且非常丑）。\n\n直到假期里我看见知乎上有人推荐wordpress，并且也是可以直接在阿里云的轻量应用服务器上直接部署的，因此我果断的开始了wordpress的踩坑之旅，中途先后使用了多个wordpress官网推荐的主题，一直没有找到自己喜欢的，后来还是在知乎上，看见了`sakura`主题，非常的漂亮，并且封面图也很好看，如下：\n\n![](https://unpkg.com/justlovesmile-img/20220408144439.png)\n\n并且在部署的过程中，从作者的博客友链看到了很多大佬的博客，也是第一次知道了原来博客还有[友链](/friends/)这种东西...\n\n再到假期末尾，又是我的室友（还是他😂），他给我看了他的博客，虽然只有一个首页（就是Hexo默认的主题）我突然感觉好像也不错，而且他告诉我这个不用租服务器，我突然感觉自己好像打开了新世界的大门，原来还有Hexo这种静态博客生成器...\n\n于是我又开始了Hexo的踩坑之旅，先后用过了`yilia`、`Sakura-Hexo`、`Ayer`、以及现在的`Butterfly`主题，他们都是非常优秀的主题，如下图：\n\n![](https://unpkg.com/justlovesmile-img/20220408150617.png)\n\n除了主题外，自己还添加又卸载了很多插件（如live2d，我用的是下面这个👇），最后发现还是简单实用比较适合我。\n\n![](https://unpkg.com/justlovesmile-img/20220408145334.png)\n\n## 域名:justlovesmile.top\n\n从2019年9月6日开始，我的博客终于有了自己的域名，而为什么要买这个域名呢，主要是因为我的游戏id基本上都是这个，比如：`Justlovesmile`，`Just微笑`，`Justlove微笑`等等.\n\n![](https://unpkg.com/justlovesmile-img/20220408152830.png)\n\n## 博客魔改\n\n直到换到`Butterfly`主题，我突然发现他能满足我绝大部分的需求，不仅适配了黑暗模式，各个模块也写的非常简单明了，非常适合魔改，并且在不同博客的友链中找啊看啊，发现了很多非常棒非常好看的博客，还加入了Butterfly主题的QQ群（后来因为我基本上不聊天所以被踢了qwq），认识了很多大佬，也从他们的博客学到了很多东西，得到了很多帮助，如[zhheo博主](https://blog.zhheo.com/)、[小冰博主](https://zfe.space/)、[Akilar博主](https://akilar.top/)等等，因此我的友链中专门开了一个模块~~保存~~（供奉）着他们博客。\n\n![](https://unpkg.com/justlovesmile-img/20220408152000.png)\n\n在看了很多[博客魔改和优化](/posts/c8972b63.html)的文章以及自己一点一点[修改](/update/)之后，我的博客现在是这个样子的：\n\n![](https://unpkg.com/justlovesmile-img/20220408152620.png)\n\n## 博客统计\n\n从2019年7月10日至今，博客总共发布了[文章](/archives/)85篇，[标签](/tags/)57个，[分类](/categories/)6个，详细见[统计页面](/charts/)：\n\n![](https://unpkg.com/justlovesmile-img/20220408153407.png)\n\n其中2019年24篇，2020年39篇，2021年8篇，2022年目前14篇：\n\n![](https://unpkg.com/justlovesmile-img/20220408153707.png)\n\n博客共有[友链](/friends/)51个，[打赏](/donate/)2次。\n\n博客共有评论355条，也随时欢迎大家能在[留言板](/guestbook/)中留言。\n\n## 结语\n\n本文是纪念、也是总结，纪念这1000个日日夜夜在个人博客分享学习笔记或者主题美化的时光，总结我的博客这1000天的一些数据统计。希望在下一个1000天里我的博客能变得越来越好、越来越合我心意。","tags":["Hexo"],"categories":["博客相关"]},{"title":"目标检测 | FPN，多尺度目标检测经典Backbone","slug":"人工智能-FPN论文笔记","url":"/posts/4c29d81e.html","content":"\n# 1. 论文信息\n\n论文标题： Feature Pyramid Networks for Object Detection\n\n>论文发表：CVPR2017\n>论文链接：[CVPR2017 open access](http://openaccess.thecvf.com/content_cvpr_2017/html/Lin_Feature_Pyramid_Networks_CVPR_2017_paper.html)\n\n![](https://unpkg.com/justlovesmile-img/20220408112206.png)\n\n```bib\n@inproceedings{lin2017feature,\n  title={Feature pyramid networks for object detection},\n  author={Lin, Tsung-Yi and Doll{\\'a}r, Piotr and Girshick, Ross and He, Kaiming and Hariharan, Bharath and Belongie, Serge},\n  booktitle={Proceedings of the IEEE conference on computer vision and pattern recognition},\n  pages={2117--2125},\n  year={2017}\n}\n```\n\n# 2. 归纳总结\n\n| Name | Value                                                        |\n| ---- | ------------------------------------------------------------ |\n| 标签 | #多尺度                                                      |\n| 目的 | 针对目标检测任务中，目标尺度变化的问题，设计了特征金字塔网络 |\n| 方法 | 构建多层特征图之间的联系，合理利用高层语义信息和底层位置信息 |\n| 总结 | 是目标检测模型的标配，较好地解决了多尺度检测问题             | \n\n# 3. 问题背景\n\n作者提到，在2017年以前，目标检测中的一个基本挑战就是目标检测模型在处理目标多尺度变化问题的不足，因为在当时很多网络都使用了利用单个高层特征，(比如说Faster R-CNN利用下采样四倍的卷积层——Conv4，进行后续的物体的分类和bounding box的回归)，但是这样做有一个明显的缺陷，即小物体本身具有的像素信息较少，在下采样的过程中极易被丢失，而之前的图像金字塔结构虽然也能解决多尺度问题，但计算量大，内存消耗大，因此作者提出了特征金字塔结构，能在增加极小的计算量的情况下，处理好物体检测中的多尺度变化问题。\n\n# 4. 主要工作\n\n针对上诉问题，提出了一个利用深度卷积神经网络固有的多尺度金字塔结构来以极小的计算量构建特征金字塔的网络结构，即FPN。\n\n## 4.1 模型结构\n\n![](https://unpkg.com/justlovesmile-img/20220408115456.png)\n作者对比了多种金字塔结构，其中：\n- 图（a）所示的是经典的图像金字塔结构，其通过对不同尺度的图像提取特征，来构建特征金字塔，因此其需要对不同尺度图像分别提取特征，计算量大且消耗内存多；\n- 图（b）所示的是2017年常见的利用最后一层（高层）特征图检测目标的模型结构，其对于多尺度目标的检测能力不足；\n- 图（c）是一种利用卷积神经网络固有的多尺度特征图构建的多尺度检测模型（如SSD），但是其没有结合高层语义信息和底层位置信息，因此检测精度一般；\n- 图（d）即FPN结构，是一种具有侧向连接（lateral connections）的自上而下的网络结构，用来构建不同尺寸的具有高级语义信息的特征图，并且很好的利用了不同层特征的信息。\n\n下图是FPN的网络结构：\n![](https://unpkg.com/justlovesmile-img/20220408120130.png)\n\n![](https://unpkg.com/justlovesmile-img/20220408122428.png)\n\n其主要包含两个部分：\n- 自下而上的特征提取：即常规的前馈Backbone网络，以Faster R-CNN为例，假设选择ResNet每级最后一个Residual Block的输出，记为{C1,C2,C3,C4,C5}，那么FPN用2-5级参与预测，其中C2, C3, C4, C5表示conv2，conv3，conv4和conv5的输出层(最后一个残差block层)作为FPN的特征，分别对应于输入图片的下采样倍数为{4，8，16，32}。\n- 自上而下的特征融合以及横向连接：即将高层的语义信息和本层的细节信息相融合。自上而下的过程通过上采样（Up-Sampling）实现，上采样的方法是**最近邻插值法**，如下图所示。具体过程为：C5层先经过1 x 1卷积，改变特征图的通道数(文章中设置d=256，与Faster R-CNN中RPN层的维数相同便于分类与回归)。然后通过上采样，再加上(特征图中每一个相同位置元素直接相加)C4经过1 x 1卷积后的特征图M4（固定通道256）。这个过程再做两次，分别得到C3对应的特征图M3（固定通道256）以及C2对应的特征图M2（固定通道256）。M层特征图再经过3 x 3卷积(减轻最近邻近插值带来的混叠影响，周围的数都相同)，得到最终的P2，P3，P4，P5层特征。\n\n![](https://unpkg.com/justlovesmile-img/20220408122814.png)\n图片来自[【论文笔记】FPN —— 特征金字塔 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/92005927)\n\n## 4.2 代码\n可参考Pytorch官方的代码[https://github.com/pytorch/vision](https://github.com/pytorch/vision)\n\n# 5. 实验结果\n\n![](https://unpkg.com/justlovesmile-img/20220408123357.png)\n\n# 6. 参考文献\n\n[【论文笔记】FPN —— 特征金字塔 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/92005927)","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"小样本学习 | ProtoNet，基于度量的Few-Shot分类网络","slug":"人工智能-ProtoNet论文笔记","url":"/posts/286eabe4.html","content":"\n# 1. 论文信息\n\n论文标题：Prototypical Networks for Few-shot Learning\n\n>论文发表：Advances in neural information processing systems, 2017\n>论文链接：[https://proceedings.neurips.cc/paper/6996-prototypical-networks-for-few-shot-learning](https://proceedings.neurips.cc/paper/6996-prototypical-networks-for-few-shot-learning)\n\n![image-20211202215720417](https://unpkg.com/justlovesmile-img/image-20211202215720417.png)\n\n```bib\n@article{snell2017prototypical,\n  title={Prototypical networks for few-shot learning},\n  author={Snell, Jake and Swersky, Kevin and Zemel, Richard},\n  journal={Advances in neural information processing systems},\n  volume={30},\n  year={2017}\n}\n```\n\n# 2. 归纳总结\n\n| 标签                | 目的           | 方法                 | 总结                     |\n| ------------------- | -------------- | -------------------- | ------------------------ |\n| #度量学习 #嵌入网络 | 解决小样本问题 | 学习一个低纬嵌入空间 | 将分类问题转换成度量问题 | \n\n# 3. 主要工作\n\nProtoNet，即原型网络，其想法非常直接但有效，即对每张图像都先用神经网络得到一个特征表示，然后对支持集中每个类别的所有特征取一个平均，作为这个类别的类中心，最后比较查询集和各个类中心之间的距离，取最近的一个类别作为预测结果。\n\n作者的思想是构建一个映射函数，可以将每一类映射到一个简单的原型特征点集中。因此作者使用神经网络学习了一个非线性映射，将输入映射到嵌入空间中，并且规定每一类的原型特征为每个嵌入空间的均值。之后就可以将分类任务看作是在嵌入空间中寻找距离最近的原型特征。\n\n![image-20211007160201702](https://unpkg.com/justlovesmile-img/202110071602172.png)定义样本为S，类别为k，原型特征为$c_k=\\frac{1}{S_k}\\sum_{(x_i,y_i)\\in{S_k}}f_{\\phi}(x_i)$，衡量距离的函数为d，那么对于输入样本，其在嵌入空间的分布为$p_\\phi(y=k|x)=\\frac{\\exp(-d(f_\\phi(x),c_k))}{\\sum_{k^\\prime}\\exp(-d(f_\\phi(x),c_{k^{\\prime}}))}$，学习的过程就是最小化负对数损失$J(\\phi)=-\\log{p_\\phi(y=k|x)}$。\n\n![image-20211027160339284](https://unpkg.com/justlovesmile-img/202110271603163.png)\n\n# 4. 实验结果\n\n其实验结果如下：\n\n![image-20211202220308120](https://unpkg.com/justlovesmile-img/image-20211202220308120.png)\n\n![image-20211202220326742](https://unpkg.com/justlovesmile-img/image-20211202220326742.png)\n","tags":["深度学习","论文笔记","小样本学习"],"categories":["人工智能"]},{"title":"推荐 | 计算机专业，大学课程「笔记归档」","slug":"学习笔记-大学课程笔记目录","url":"/posts/a806bebe.html","content":"\n>题外话：时光荏苒，青春在时间的河岸慢慢行走，不知不觉中，博主的大学生活渐行渐远，带走的是那四年青春的美好回忆，而留下的是那厚厚的、考试前兢兢业业记录下来的学习笔记，看着一篇篇动辄上W字数的笔记，脑海中还能会想起当时的场景。\n\n本文是博主本科期间的专业课程学习笔记的整理和归档，适合计算机专业的同学阅读。\n\n## 一、数据库原理\n\n1. [《数据库原理》笔记](/posts/41347.html)，字数总计:18.3k，阅读时长:59分钟\n2. [基于MYSQL的BBS论坛管理系统](https://github.com/Justlovesmile/database_program)，第一次接触Flask和前端，在自己电脑上做的数据库课设\n\n## 二、软件工程基础\n\n1. [《软件工程基础》知识点](/posts/38368.html)，字数总计:5.9k，阅读时长:17分钟\n\n## 三、计算机网络\n\n1. [《计算机网络》学习笔记](/posts/28758.html)，字数总计:35.3k，阅读时长:108分钟\n\n## 四、操作系统\n\n1. [计算机《操作系统》笔记](/posts/8398.html)，字数总计:20.1k，阅读时长:61分钟\n\n## 五、编译原理\n\n1. [《编译原理》知识点](/posts/50753.html)，字数总计:4.5k，阅读时长:13分钟\n\n## 六、算法分析与设计\n\n1. [《算法分析与设计》笔记](/posts/16050.html)，字数总计:14k，阅读时长:62分钟，主要是动手敲敲代码，看看算法如何实现\n\n## 七、计算机组成原理\n\n1. [《计算机组成原理》笔记](/posts/51917.html)，字数总计:1.9k，阅读时长:5分钟，说实话这门课我没学好\n\n## 八、计算机系统结构\n\n1. [《计算机系统结构》笔记](/posts/50754.html)，字数总计:12k，阅读时长:35分钟\n2. [《计算机系统结构》精简知识点](/posts/651e6a0b.html)，字数总计:8k，阅读时长:24分钟\n3. [基于WINDLX的系统结构实验](/posts/47699.html)，字数总计:2.9k，阅读时长:10分钟，随机输入n个数，求数i的概率\n\n## 九、计算机图形学\n\n1. [基于MFC和二维变换的画图软件](/posts/16593.html)，字数总计:4.2k，阅读时长:14分钟，基于MFC完成的一个画图软件，并且为了完成老师的要求，强行加了二维变换动画\n\n## 十、嵌入式技术课程设计\n\n1. [嵌入式智能大棚监测管理系统](/posts/14495.html)，字数总计:5.5k，阅读时长:17分钟，基于Proteus，Arduino，Flask搭建的智能大棚管理系统\n\n## 十一、微机原理与接口技术\n\n1. [《微机原理与接口技术》笔记](/posts/43666.html)，字数总计:12.9k，阅读时长:41分钟，有一说一，这篇文章在CSDN阅读1w+是我没想到的\n\n\n>人生的长短不是时间衡量的，而是以思想和行为去衡量，且行且珍惜！","tags":["大学课程"],"categories":["学习笔记"]},{"title":"博客相关 | 如何提取图片主题色并自动选择标题字体颜色","slug":"博客相关-根据图片主题色修改字体颜色","url":"/posts/b16c0eda.html","content":"\n今天在写博客的时候，做了一个封面图，然后`hexo cl && hexo g && gulp && hexo s`一键生成，点开后却发现这个标题的字体颜色亮瞎我的眼睛：\n\n![](https://unpkg.com/justlovesmile-img/20220328124305.png)\n\n于是试了很多帖子，终于把它改好了：\n\n![](https://unpkg.com/justlovesmile-img/20220328124527.png)\n\n提取主题色的js:[https://github.com/briangonzalez/rgbaster.js](https://github.com/briangonzalez/rgbaster.js)\n\n处理配色js如下：\n\n```js\nif (document.getElementById('post-cover')) {\n  const img = document.getElementById('post-cover').getAttribute('data-lazy-src')\n  RGBaster.colors(img, {\n      paletteSize: 30,\n      exclude: [\"rgb(255,255,255)\", \"rgb(0,0,0)\", \"rgb(254,254,254)\"],\n      success: function(t) {\n        if (t.dominant != 'rgb()'){\n          const c = t.dominant.match(/\\d+/g);\n          const Color = `rgba(${c[0]},${c[1]},${c[2]},0.8)`;\n          let fontColor;\n          //const grayLevel = c[0] * 0.299 + c[1] * 0.587 + c[2] * 0.114;\n          const grayLevel = c[0] * 0.213 + c[1] * 0.715 + c[2] * 0.072;\n          //if (grayLevel >= 190) {\n          if (grayLevel >= 255/2) {\n            // 若为浅色，把文字设置为黑色\n            fontColor = '#000';\n            metaColor = '#1C1C1C';\n          } else {\n            fontColor = '#fff';\n            metaColor = '#eee';\n          }\n          document.styleSheets[0].addRule(\":root\", \"--mj-main:\" + Color + \"!important\")\n          document.styleSheets[0].addRule(\":root\", \"--mj-titlecolor:\" + fontColor + \"!important\")\n          document.styleSheets[0].addRule(\":root\", \"--mj-metacolor:\" + metaColor + \"!important\")\n        } else {\n          document.styleSheets[0].addRule(\":root\", \"--mj-main: rgba(255,250,240,0.5) !important\")\n          document.styleSheets[0].addRule(\":root\", \"--mj-titlecolor: #000 !important\")\n          document.styleSheets[0].addRule(\":root\", \"--mj-metacolor: #1C1C1C !important\")\n        }\n      },\n      error: function() {\n          document.styleSheets[0].addRule(\":root\", \"--mj-main: rgba(255,250,240,0.5) !important\")\n          document.styleSheets[0].addRule(\":root\", \"--mj-titlecolor: #000 !important\")\n          document.styleSheets[0].addRule(\":root\", \"--mj-metacolor: #1C1C1C !important\")\n      }\n  })\n} else {\n  document.styleSheets[0].addRule(\":root\", \"--mj-main: transparent !important\")\n  document.styleSheets[0].addRule(\":root\", \"--mj-titlecolor: var(--light-grey) !important\")\n}\n```\n\n参考：\n- [https://juejin.cn/post/6844903511956815885](https://juejin.cn/post/6844903511956815885)\n- [https://blog.realwds.com/posts/84339efc.html](https://blog.realwds.com/posts/84339efc.html)","tags":["Hexo","前端","JS"],"categories":["博客相关"]},{"title":"目标检测 | YOLOv1，经典单阶段Anchor-Free目标检测模型","slug":"人工智能-YOLOv1阅读笔记","url":"/posts/d50da5ec.html","content":"\n>PS:参考YOLO官网的配色和logo做的封面图，感觉还挺好看的，hhhh\n\n# 1. 论文信息\n\n论文标题：You Only Look Once: Unified, Real-Time Object Detection\n\n>论文发表：CVPR 2016\n>论文链接：[You Only Look Once: Unified, Real-Time Object Detection (cv-foundation.org)](https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Redmon_You_Only_Look_CVPR_2016_paper.pdf)\n>论文官网：[YOLO: Real-Time Object Detection (pjreddie.com)](https://pjreddie.com/darknet/yolo/)\n\n![](https://unpkg.com/justlovesmile-img/1648433292(1).png)\n\n```bib\n@inproceedings{redmon2016you,\n  title={You only look once: Unified, real-time object detection},\n  author={Redmon, Joseph and Divvala, Santosh and Girshick, Ross and Farhadi, Ali},\n  booktitle={Proceedings of the IEEE conference on computer vision and pattern recognition},\n  pages={779--788},\n  year={2016}\n}\n```\n\n# 2. 归纳总结\n\n| 标签         | 目的                       | 方法                                 | 总结           |\n| ------------ | -------------------------- | ------------------------------------ | -------------- |\n| #Anchor-Free | 解决两阶段算法检测慢的问题 | 将目标检测（cls和reg）都视为回归问题 | 经典单阶段算法 | \n\n# 3. 问题背景\n\n随着深度学习的大火，在YOLO提出那一年，主流的目标检测算法框架主要分为两类：\n- 两阶段算法：基于Region Proposal的RCNN系列算法，先生成Proposal，再分类回归\n- 单阶段算法：直接预测不同目标的类别和位置\n这两种算法各有优点，一般而言，两阶段算法准确度高，但速度慢；单阶段算法速度快，但准确度相对低。\n\n作者认为人可以一眼看到目标在哪，并且能立即知道是什么，并且对于很多实际场景而言，如自动驾驶，实时性和准确性都是非常重要的。\n\n# 4. 主要工作\n\n针对上述问题，作者提出了经典的YOLO算法，它是一个统一的，端到端的单阶段目标检测算法。YOLO具体做法是，首先将输入图片缩放到448x448，然后送入CNN网络，最后使用NMS过滤网络预测结果得到检测的目标。\n\n![](https://unpkg.com/justlovesmile-img/20220328103035.png)\n\n而在CNN网络里，它首先将图片划分为S×S大小的网格，然后每个单元格负责检测中心点落在该格子的目标，如下图，每个单元格会输出B个边界框（每个边界框输出5个预测值：x, y, w, h, confidence）以及边界框类别概率C，例如：作者在PASCAL VOC的检测实验里使用S=7，B=2，C=类别数量20，一共预测7×7×(2×5+20)个向量。同时这里的confidence代表边界框置信度，它的定义为: \n\n$$Pr(object)\\times IoU_{pred}^{truth}$$\n\n其中边界框包含目标时，$Pr(object)=1$，否则为0。而C代表每个类别的置信度，即：\n\n$$Pr(Class_i|Object)\\times Pr(objec) \\times IoU_{pred}^{truth}=Pr(class_i)\\times IoU_{pred}^{truth}$$\n\n![](https://unpkg.com/justlovesmile-img/20220328103753.png)\n\n## 4.1 模型结构\n\nYOLO采用卷积网络来提取特征，然后使用全连接层来得到预测值。网络结构参考GooLeNet模型，包含24个卷积层和2个全连接层。对于卷积层，主要使用1x1卷积来做channle reduction，然后紧跟3x3卷积。对于卷积层和全连接层，采用Leaky ReLU激活函数$max(x,0.1x)$，但是最后一层却采用线性激活函数。\n\n![](https://unpkg.com/justlovesmile-img/20220328103101.png)\n\n## 4.2 模型训练\n\n在训练之前，先在ImageNet上进行了预训练，其预训练的分类模型采用图8中前20个卷积层，然后添加一个average-pool层和全连接层。预训练之后，在预训练得到的20层卷积层之上加上随机初始化的4个卷积层和2个全连接层。由于检测任务一般需要更高清的图片，所以将网络的输入从224x224增加到了448x448。\n\n## 4.3 模型损失\n\n![](https://unpkg.com/justlovesmile-img/20220328110113.png)\n\nYolo算法将目标检测看成回归问题，所以采用的是均方差损失函数。但是对不同的部分采用了不同的权重值。首先区分定位误差和分类误差。对于定位误差，即边界框坐标预测误差，采用较大的权重 $\\lambda_{coord}=5$ 。然后其区分不包含目标的边界框与含有目标的边界框的置信度，对于前者，采用较小的权重值 $\\lambda_{noobj}=0.5$ 。其它权重值均设为1。然后采用均方误差，其同等对待大小不同的边界框，但是实际上较小的边界框的坐标误差应该要比较大的边界框要更敏感。为了保证这一点，将网络的边界框的宽与高预测改为对其平方根的预测，即预测值变为$(x,y,\\sqrt{w},\\sqrt{h})$。\n\n损失函数中，第一项为边界框中心坐标的误差项，$\\mathbb{1} _ {ij}^{obj}$ 是指第 i 个单元格存在目标，且该单元格中的第 j 个边界框负责预测该目标，第二项是边界框的高与宽的误差项。第三项是包含目标的边界框的置信度误差项。第四项是不包含目标的边界框的置信度误差项。最后一项是包含目标的单元格的分类误差项，$\\mathbb{1} _ {i}^{obj}$值是指第 i 个单元格存在目标。\n\n# 5. 实验结果\n\n![](https://unpkg.com/justlovesmile-img/20220328105647.png)\n\n![](https://unpkg.com/justlovesmile-img/20220328105758.png)\n\n![](https://unpkg.com/justlovesmile-img/20220328105711.png)\n\n# 6. 参考文献\n\n[目标检测|YOLO原理与实现 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/32525231)","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"目标检测 | SSD，经典单阶段Anchor-Based目标检测模型","slug":"人工智能-SSD阅读笔记","url":"/posts/8163bb15.html","content":"\n# 1. 论文信息\n\n论文标题： 《SSD: Single Shot MultiBox Detector》\n\n>论文发表：2016\n>论文链接：[SSD: Single Shot MultiBox Detector | SpringerLink](https://link.springer.com/chapter/10.1007/978-3-319-46448-0_2)\n\n![](https://unpkg.com/justlovesmile-img/20220305111710.png)\n\n```bib\n@inproceedings{liu2016ssd,\n  title={Ssd: Single shot multibox detector},\n  author={Liu, Wei and Anguelov, Dragomir and Erhan, Dumitru and Szegedy, Christian and Reed, Scott and Fu, Cheng-Yang and Berg, Alexander C},\n  booktitle={European conference on computer vision},\n  pages={21--37},\n  year={2016},\n  organization={Springer}\n}\n```\n\n# 2. 归纳总结\n\n| 标签            | 目的                                         | 方法             | 总结           |\n| --------------- | -------------------------------------------- | ---------------- | -------------- |\n| #Anchor #单阶段 | 实现多尺度以及卷积预测，进一步提升精度和速度 | MultiBox，Anchor | 经典单阶段算法 |\n\n# 3. 引言\n\nSSD算法，其英文全名是Single Shot MultiBox Detector, SSD的优势在于消除了bounding box proposal和pixel or feature resampling，并使用了multi-scale，因此达到了比faster rcnn和yolo更高的检测精度和更快的检测速度。\n\n![](https://unpkg.com/justlovesmile-img/20220328121925.png)\n\n图片来自[目标检测|SSD原理与实现 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33544892)\n\n# 4. SSD模型\n\nSSD采用VGG16作为基础模型，然后在VGG16的基础上新增了卷积层来获得更多的特征图以用于检测，模型结构如下图：\n\n![](https://unpkg.com/justlovesmile-img/20220305114612.png)\n\nSSD和Yolo一样都是采用一个CNN网络来进行检测，但是却采用了多尺度的特征图，网络的核心点：\n- 使用小的卷积核预测类别和边界框偏移量\n- 对多个（多尺度）特征图进行检测\n- 设置不同比例的先验框，如下图\n\n![](https://unpkg.com/justlovesmile-img/20220305115052.png)\n\nSSD将背景也当做了一个特殊的类别，如果检测目标共有c个类别，SSD其实需要预测c+1个置信度值，其中第一个置信度指的是不含目标或者属于背景的评分。在预测过程中，置信度最高的那个类别就是边界框所属的类别，特别地，当第一个置信度值最高时，表示边界框中并不包含目标。第二部分就是边界框的location，包含4个值(cx,cy,w,h)，分别表示边界框的中心坐标以及宽高。但是真实预测值其实只是边界框相对于先验框的转换值。先验框位置用$d=(d^{cx},d^{cy},d^{w},d^{h})$表示，其对应边界框用$b=(b^{cx},b^{cy},b^{w},b^{h})$表示，那么边界框的预测值$l$其实是b相对于d的转换值：\n![](https://unpkg.com/justlovesmile-img/20220328114611.png)\n\n# 5. 模型训练\n\n## 5.1 正负样本划分\n\n首先，对于图片中每个ground truth，找到与其IOU最大的先验框，该先验框与其匹配，这样，可以保证每个ground truth一定与某个先验框匹配。通常称与ground truth匹配的先验框为正样本，其次，通过判断先验框和ground truth之间的IoU值是否大于阈值（如0.5），大于则为正样本\n\n## 5.2 损失计算\n损失包含两个部分：定位损失和分类损失\n\n$$L(x,c,l,g)=\\frac{1}{N}(L_{conf}(x,c)+\\alpha L_{loc}(x,l,g))$$\n\n其中N代表所匹配的正负样本数量，`l`代表预测框，`g`代表真实框，和faster rcnn相似，回归的偏移量的值是边界框的中心坐标(cx,cy)和框的宽度w和高度h。\n\n$$\\hat{g} _ {j}^{cx}=(g _ {j}^{cx}-d _ {i}^{cx})/d _ {i}^{w}$$\n\n$$\\hat{g} _ {j}^{cy}=(g_{j}^{cy}-d_{i}^{cy})/d_{i}^{h}$$\n\n$$\\hat{g} _ {j}^{w}=\\log(\\frac{g_{j}^{w}}{d_{i}^{w}})$$\n\n$$\\hat{g} _ {j}^{h}=\\log(\\frac{g_{j}^{h}}{d_{i}^{h}})$$\n\n因此定位损失函数为：$L_{loc}(x,l,g)=\\sum_{i \\in Pos}^N \\sum_{m\\in \\{cx,cy,w,h\\}}x_{ij}^{k}smooth_{L1}(l_i^m-\\hat{g} _ j^m)$\n分类损失是一个softmax损失：$L_{conf}(x,c)=-\\sum_{i\\in Pos}^{N}x_{ij}^p\\log(\\hat{c} _ i^p)-\\sum _ {i\\in Neg}log(\\hat{c} _ i^0)$\n其中$\\hat{c} _ i^p=\\frac{exp(c_i^p)}{\\sum_p(exp(c_i^p))}$\n\n\n# 6. 参考文献\n\n[目标检测|SSD原理与实现 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33544892)","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"目标检测 | FCOS，经典单阶段Anchor-Free目标检测模型","slug":"人工智能-FCOS论文笔记","url":"/posts/bc226294.html","content":"\n\n# 1. 论文信息\n\n论文标题：` 《FCOS: Fully Convolutional One-Stage Object Detection》`\n\n>论文来源：ICCV2019\n>论文链接：[https://arxiv.org/abs/1904.01355](https://arxiv.org/abs/1904.01355)\n>论文代码：[https://github.com/tianzhi0549/FCOS/](https://github.com/tianzhi0549/FCOS/)\n\n![20211119114214](https://unpkg.com/justlovesmile-img/20211119114214.png)\n\n```bib\n@inproceedings{tian2019fcos,\n  title={Fcos: Fully convolutional one-stage object detection},\n  author={Tian, Zhi and Shen, Chunhua and Chen, Hao and He, Tong},\n  booktitle={Proceedings of the IEEE/CVF international conference on computer vision},\n  pages={9627--9636},\n  year={2019}\n}\n```\n\n# 2. 归纳总结\n\n| 标签                 | 目的                                              | 方法              | 总结                |\n| -------------------- | ------------------------------------------------- | ----------------- | ------------------- |\n| #Anchor-Free #单阶段 | 解决Anchor-Base算法超参数设置复杂，计算量大的问题 | FCN，Center-ness | Anchor-Free经典算法 | \n\n# 3. 主要工作\n\nFCOS是一种基于全卷积的单阶段目标检测算法，并且是一种Anchor box free的算法。其实现了无Anchor，无Proposal，并且提出了Center-ness的思想，极大的提升了Anchor-Free目标检测算法的性能。\n\nAnchor free的好处是：\n\n- 避免了Anchor Box带来的复杂计算，如计算重合度IoU；\n- 避免了Anchor Box相关的超参数设置，其对性能影响较大；\n\n因此，FCOS的优点是：\n\n- 其可以和其他使用FCN结构的任务相统一，方便其他任务方法之间的re-use\n- proposal free和anchor free，减少了超参数数量，更简单\n- 减少了计算复杂度，如IoU计算\n- FCOS在单阶段算法中性能不错，并且证明了FCOS替换两阶段算法里的RPNs也可以取得更好的性能\n- 适用于各种instance-wise的预测问题\n\n## 3.1 模型结构\n\n模型结构如下图：\n\n![image-20211119160053912](https://unpkg.com/justlovesmile-img/image-20211119160053912.png)\n\nFCOS包含三个大模块：\n\n- Backbone：提取图像特征，如结构图左侧所示，其中特征图尺寸逐层减半，如左侧$H×W$所示，$s=\\frac{W^*}{W}$代表步长。对于坐标为$(x,y)$的位置，其映射回原图为$(\\lfloor\\frac{s}{2}\\rfloor + xs,\\lfloor\\frac{s}{2}\\rfloor+ys)$;\n- FPN：多层级预测，提高检测器对不同尺寸目标的检测性能；与Anchor Based不同的是，FCOS通过限制不同层级边界框回归范围来分配层级\n- Classification+Center-ness+Regression Head\n\n![image-20211119155237711](https://unpkg.com/justlovesmile-img/image-20211119155237711.png)\n\n对于FCOS，其直接将每个位置$(x,y)$视为训练样本，其需要回归的值为一个4维向量$t=(l,t,r,b)$，如上图所示。\n由于一张图片中的目标数量有限，所以导致基于Anchor的算法会产生更多的负样本，因此FCOS对于每个像素点只回归一组值（可以理解为Anchor数量为1），可以利用更多的前景（正）样本信息去训练。如果坐标落在任何ground-truth box中即为正样本，且该位置的类别为这个gt box的类别$c^{ * }$ ，否则为负样本（即背景，类别为0），如果落在多个gt box中，则认为其是一个歧义样本（ambiguous sample），针对这种情况，可通过FPN解决。计算 $(l^*, t^*, r^*, b^*)$，$m_i$为每个特征层最大距离（论文里作者设置$m_2$ ~ $m_7$分别为0，64，128，256，512，$\\infty$），如果$\\max(l^*, t^*, r^*, b^*) > m _ i$ 或者 $\\max(l^*, t^*, r^*, b^*) < m _ {i−1}$,则此位置为负样本，不进行计算；对于大小相近又存在重叠的gt box，FPN无法区别，则选择面积最小的gt box为回归目标。\n\n## 3.2 正负样本定义\n\n一个目标检测算法性能的优异性，最大影响因素就是**如何定义正负样本**。而FCOS的定义方式非常通俗易懂。主要分为两步：\n**(1) 设置regress_ranges=((-1, 64), (64, 128), (128, 256), (256, 512),(512, INF)，用于将不同大小的bbox分配到不同的FPN层进行预测即距离4条边的最大值在给定范围内**\n**(2) 设置center_sampling_ratio=1.5,用于确定对于任意一个输出层距离bbox中心多远的区域属于正样本（基于gt bbox中心点进行扩展出正方形，扩展范围是center_sample_radius×stride，正方形区域就当做新的gt bbox），该值越大，扩张比例越大，选择正样本区域越大；（细节：如果扩展比例过大，导致中心采样区域超过了gt bbox本身范围了，此时需要截断操作）**\n\n## 3.3 损失函数\n\nFCOS的损失函数为：\n\n![image-20211119173209315](https://unpkg.com/justlovesmile-img/image-20211119173209315.png)\n\n其中$L_{cls}$是focal loss，$L_{reg}$是IoU loss，$N_{pos}$代表正样本数量，$\\lambda$用于平衡$L_{reg}$的权重；$\\mathbb{1} _ {c^{ * }_{i}}$当$c^{ * }_{i}>0$时为1，否则为0；\n\n为了减少低质量检测框，减少误检，FCOS增加了一个一层的分支，用于预测Center-ness，其描绘了位置到目标中心的归一化距离，下图展示了使用Center-ness（左）和不使用Center-ness（右）的区别。\n\n![image-20211119175758242](https://unpkg.com/justlovesmile-img/image-20211119175758242.png)\n\nCenter-ness的计算公式如下，其范围为0-1，训练阶段使用BCE Loss并和之前的损失函数相加，测试阶段用于加权预测得分：\n\n![image-20211119180027086](https://unpkg.com/justlovesmile-img/image-20211119180027086.png)\n\n\n\n# 4. 实验结果\n\n对比实验结果：\n\n![image-20211119180536280](https://unpkg.com/justlovesmile-img/image-20211119180536280.png)\n\n有无Center-ness分支的消融实验：\n\n![](https://unpkg.com/justlovesmile-img/20220326134621.png)\n\n替换RPN的消融实验：\n\n![](https://unpkg.com/justlovesmile-img/20220326134721.png)\n\n\n# 5. 参考文献\n\n[mmdetection最小复刻版(六)：FCOS深入可视化分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/267346645)","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"人工智能 | 测评推荐好用的GPU算力平台","slug":"人工智能-GPU算力平台","url":"/posts/80a64b4b.html","content":"\n# 一、免费GPU算力平台\n\n## 1. Google Colab\n\n### 1.1 简介\nColab全称为Colaboratory，是Google提供的免费Jupyter notebook运行环境，并且完全在云端运行。\n优点：\n- 可以免费使用\n- 不需要自己去装深度学习的环境\n- 数据可以通过谷歌网盘拉取\n缺点：\n- 需要翻墙，因此网络不稳定，容易断开连接\n- 前台连接训练，如果需要后台训练需要购买Colab Pro\n- 免费版GPU的挂载有时长限制（12h），超时需要重新挂载，注意保存训练结果\n\n### 1.2 使用指南\n\n#### 1.2.1 连接GPU\n进入Colab，官网地址：[欢迎使用 Colaboratory - Colaboratory (google.com)](https://colab.research.google.com/)，创建一个jupyter notebook：\n\n![](https://unpkg.com/justlovesmile-img/20220322172825.png)\n\n编写代码，连接Colab的GPU：点击左上角“修改-笔记本设置-GPU”\n\n![](https://unpkg.com/justlovesmile-img/20220322173142.png)\n\n更换成功后，可在notebook输入`!nvidia-smi`以查看GPU信息：\n\n![](https://unpkg.com/justlovesmile-img/20220322173421.png)\n\n#### 1.2.2 获取数据集\n\n首先将数据集上传至谷歌网盘，地址：[Google 云端硬盘](https://drive.google.com/drive/)，然后在notebook中绑定硬盘：\n\n```python\nfrom google.colab import drive\n\ndrive.mount('/content/drive/')\n```\n\n然后可以通过代码处理数据集或者数据集压缩包。\n\n其他的使用和服务器是一样的，可以参考detectron2给的[Colab](https://colab.research.google.com/drive/16jcaJoc6bCFAQ96jDe2HwtXj7BMD_-m5)代码。\n\n![](https://unpkg.com/justlovesmile-img/20220323112055.png)\n\n\n## 2. Kaggle\n\n### 2.1 简介\nKaggle是由 Anthony Goldbloom 2010年在墨尔本创立的，主要为开发商和数据科学家提供举办机器学习竞赛、托管数据库、编写和分享代码的平台。每周有30-43小时的GPU使用时长。\n\n官网:[Kaggle: Your Home for Data Science](https://www.kaggle.com/)\n\n### 2.2 使用指南\n\n数据集可以直接引用别人上传的数据集,也可以自己上传打包好的数据集。\n\n点击工具栏中Data，在右方出现的界面中，点击New Dataset\n\n![](https://unpkg.com/justlovesmile-img/20220323113136.png)\n\n之后建立Notebook:\n![](https://unpkg.com/justlovesmile-img/20220323113427.png)\n\n可以选择运算资源:\n![](https://unpkg.com/justlovesmile-img/20220323113555.png)\n\n## 3. 阿里天池GPU\n\n阿里云天池GPU平台提供在线 Jupyter notebook , 每次连接可以使用 8 小时的GPU算力，官网: [天池大数据众智平台-阿里云天池 (aliyun.com)](https://tianchi.aliyun.com/)\n\n![](https://unpkg.com/justlovesmile-img/20220323114733.png)\n\n\n## 4. 华为NAIE\n\n网络人工智能引擎iMaster NAIE是自动驾驶网络的网络AI设计和开发基础平台，支持对上传到云端的各种网络数据，持续进行AI训练和知识提取，生成AI模型和网络知识成果。最开始注册可以免费使用三个月(不过现在好像只能免费使用几天).\n\n官网:[网络人工智能引擎 (hwtelcloud.com)](https://www.hwtelcloud.com/)\n\n![](https://unpkg.com/justlovesmile-img/20220323115017.png)\n\n值得注意的是,该平台需要使用NAIE自带的包来处理数据加载和保存.\n\n## 5. 百度飞桨Ai Studio\n\n只能用PaddlePaddle框架,运行项目或者学习课程可以免费白嫖算力卡,官网:[飞桨AI Studio - 人工智能学习实训社区 (baidu.com)](https://aistudio.baidu.com/aistudio/index)\n![](https://unpkg.com/justlovesmile-img/20220323120131.png)\n\n# 二、付费GPU算力平台\n\n## 1. 矩池云\n\n### 1.1 简介\n\n矩池云是一个 GPU 云共享平台，可以按需租用到性价比极高的 GPU 云主机，并且注册并绑定公众号即可免费体验2小时GPU服务以及5元代金券，官网：[矩池云 - 专注于人工智能领域的云服务商 (matpool.com)](https://matpool.com/)\n\n![](https://unpkg.com/justlovesmile-img/20220323103316.png)\n\n### 1.2 使用指南\n\n首先将数据集打包上传至矩池云网盘，默认最大容量为5G，数据集太大的话可以购买容量。\n\n然后可以在官网充值，学生或老师有优惠，充值后直接在GPU主机市场租用服务器，系统镜像丰富，选择自己需要的就行。\n![](https://unpkg.com/justlovesmile-img/20220323103526.png)\n\n租用后即可在“我的租用”列表里看见服务器，启动后有三种连接方式：\n- SSH\n- VNC\n- Jupyter Lab\n\n连接后就可以正常使用了，值得注意的是结束训练后记得保存环境，停止并释放资源。保存的环境会存储在网盘中，注意查看网盘容量。\n\n## 2. 恒源云\n\n恒源云是一个专注 AI 行业的共享算力平台，旨在为用户提供高性价比的GPU云主机和存储服务，让用户拥有高效的云端编程和训练体验，不再担忧硬件迭代/环境搭建/数据存储等一系列问题。其价格相比较矩池云更便宜。官网：[恒源云_GPUSHARE-恒源智享云](https://gpushare.com/)\n\n![](https://unpkg.com/justlovesmile-img/20220323104206.png)\n\n## 3. AutoDL\n\nAutoDL针对不同会员等级有不同的优惠，学生可以免费升级会员，性价比较高。官网：[AutoDL-品质GPU租用平台-租GPU就上AutoDL](https://www.autodl.com/home)\n\n![](https://unpkg.com/justlovesmile-img/20220323105140.png)\n\n## 4. 智星云\n\n智星云提供了弹性灵活的分时租用方式，分时租用在服务器启动时开始计费并每分钟扣费。例如RTX2080Ti分时租用价格为3元/小时，系统会按照3除以60的金额每分钟扣费0.05元并在1小时总共扣除3元。官网：[智星云 AI Galaxy | GPU云服务器 (ai-galaxy.cn)](http://gpu.ai-galaxy.cn/store)\n\n\n![](https://unpkg.com/justlovesmile-img/20220323104607.png)\n\n## 5. FEATURIZE\n\n官网：[Featurize](https://featurize.cn/)\n![](https://unpkg.com/justlovesmile-img/20220323110835.png)\n\n## 6. 滴滴云\n\n目前提供P4，P40，P100，T4四种机型，官网：[GPU云服务器-滴滴出行的云计算服务 (didiyun.com)](https://www.didiyun.com/production/gpu.html)\n\n![](https://unpkg.com/justlovesmile-img/20220323111514.png)\n\n## 7. 其他\n\n![](https://unpkg.com/justlovesmile-img/20220323111747.png)\n图片来自机器之心\n\n# 三、云计算巨头\n\n## 1. 阿里云GPU服务器\n\n官网：[GPU云服务器_GPU云计算_异构计算_弹性计算-阿里云 (aliyun.com)](https://www.aliyun.com/product/ecs/gpu)\n\n![](https://unpkg.com/justlovesmile-img/20220323105342.png)\n\n## 2. 腾讯云GPU服务器\n\n官网：[GPU云服务器_并行计算_弹性计算_人工智能_深度学习 (tencent.com)](https://cloud.tencent.com/product/gpu)\n\n![](https://unpkg.com/justlovesmile-img/20220323105639.png)\n\n## 3. 华为云GPU服务器\n\n官网：[GPU加速云服务器_GPU云服务器_GPU云主机-华为云 (huaweicloud.com)](https://www.huaweicloud.com/product/gpu.html)\n\n![](https://unpkg.com/justlovesmile-img/20220323105856.png)\n","tags":["深度学习","GPU"],"categories":["人工智能"]},{"title":"深度学习 | Detectron2使用指南","slug":"人工智能-Detectron2使用指南","url":"/posts/589ec011.html","content":"\n`Detectron2`是`Facebook AI Research`的检测和分割框架，其主要基于`PyTorch`实现，但具有更模块化设计，因此它是灵活且便于扩展的，具体简介可见[Github库](https://github.com/facebookresearch/detectron2)和[Meta AI Blog Post](https://ai.facebook.com/blog/-detectron2-a-pytorch-based-modular-object-detection-library-/)。\n\n```bibTex\n@misc{wu2019detectron2,\n  author =       {Yuxin Wu and Alexander Kirillov and Francisco Massa and\n Wan-Yen Lo and Ross Girshick},\n  title =        {Detectron2},\n  howpublished = {\\url{https://github.com/facebookresearch/detectron2}},\n  year =         {2019}\n}\n```\n\n\n# 1. Detectron2安装\n\n>首先官方要求的环境条件如下：\n>- Linux or macOS with Python ≥ 3.6\n>- PyTorch ≥ 1.8 and [torchvision](https://github.com/pytorch/vision/) that matches the PyTorch installation. Install them together at [pytorch.org](https://pytorch.org/) to make sure of this\n>- OpenCV is optional but needed by demo and visualization\n>-  gcc & g++ ≥ 5.4 are required\n>- [ninja](https://ninja-build.org/) is optional but recommended for faster build\n>- Cuda & Cudnn\n\n因此想要安装并使用Detectron2，需要有：\n- 环境：Python，Cuda，Cudnn，gcc&g++\n- Python包：pytorch，torchvision，python-opencv\n- 推荐：Anaconda\n\n## 1.1 Linux\n\nLinux安装直接按照[官方文档](https://detectron2.readthedocs.io/en/latest/tutorials/install.html)的安装步骤即可\n\n```shell\npython -m pip install 'git+https://github.com/facebookresearch/detectron2.git'\n# (add --user if you don't have permission)\n\n# Or, to install it from a local clone:\ngit clone https://github.com/facebookresearch/detectron2.git\npython -m pip install -e detectron2\n\n# On macOS, you may need to prepend the above commands with a few environment variables:\nCC=clang CXX=clang++ ARCHFLAGS=\"-arch x86_64\" python -m pip install ...\n```\n\n如果以上安装失败，可以尝试直接安装预编译文件，同样在[官方文档有提供](https://detectron2.readthedocs.io/en/latest/tutorials/install.html)\n\n## 1.2 Windows\n\n### 1.2.1 VS2019 C++编译环境\nWindows想要安装Detectron2，需要提前安装**Microsoft Visual Studio 2019**，然后选择安装“**使用C++的桌面开发**”，其他均默认即可。\n\n![](https://unpkg.com/justlovesmile-img/20220316165420.png)\n\n### 1.2.2 pycocotools\n\n安装方法一：\n\n```shell\npip install git+https://github.com/philferriere/cocoapi.git#subdirectory=PythonAPI\n```\n\n安装方法二：\n\n```shell\ngit clone https://github.com/pdollar/coco.git\n\ncd coco/PythonAPI\n\npython setup.py build_ext --inplace\npython setup.py build_ext install\n```\n\n如果安装失败（一般都会失败），尝试下载“Microsoft Visual C++ Build Tools.exe” ，官网链接：[https://go.microsoft.com/fwlink/?LinkId=691126](https://go.microsoft.com/fwlink/?LinkId=691126)。\n\n![](https://unpkg.com/justlovesmile-img/20220316171845.png)\n\n如果在安装的过程中因网络问题失败，可以使用离线包，网盘链接：[https://pan.baidu.com/s/1GeJ2c8MxnZP8lAYAwQACzg](https://pan.baidu.com/s/1GeJ2c8MxnZP8lAYAwQACzg)，提取码`1114`。\n\n### 1.2.3 Detectron2\n\n使用Conda（推荐！之前有过同一个包使用conda安装的好用而pip安装的不好用的经历）或者pip下载包：\n\n```shell\nconda install cython\nconda install ninja\nconda install pywin32\n```\n\n下载Detectron2到本地:\n\n```bash\ngit clone https://github.com/facebookresearch/detectron2.git\npython -m pip install -e detectron2\n```\n\n或者\n\n```shell\ngit clone https://github.com/facebookresearch/detectron2.git\ncd detectron2 \npython setup.py build develop\n```\n\n# 2.  自定义数据集\n\n## 2.1 关于COCO格式\nDetectron2已经写好了COCO格式的数据集图像和标注的读取，因此通常减少工作量，可以自己写一个脚本将**数据集转为COCO格式**的标注。\n\nCOCO的文件目录如下：\n```txt\n-coco/\n    |-train2017/\n    \t|-1.jpg\n    \t|-2.jpg\n    |-val2017/\n    \t|-3.jpg\n    \t|-4.jpg\n    |-test2017/\n    \t|-5.jpg\n    \t|-6.jpg\n    |-annotations/\n    \t|-instances_train2017.json\n    \t|-instances_val2017.json\n    \t|-*.json\n```\n\n其中标注文件（json）最为重要，其格式如下：\n\n```json\n{\n\t\"info\": {//数据集信息，对于训练而言不重要\n\t\t\"year\": int, \n\t\t\"version\": str, \n\t\t\"description\": str, \n\t\t\"contributor\": str, \n\t\t\"url\": str, \n\t\t\"date_created\": datetime,\n\t}, \n\t\"images\": [{\n\t\t\"id\": int, //必要\n\t\t\"width\": int, //必要\n\t\t\"height\": int, //必要\n\t\t\"file_name\": str, //必要\n\t\t\"license\": int,\n\t\t\"flickr_url\": str,\n\t\t\"coco_url\": str,\n\t\t\"date_captured\": datetime, \n\t},{...}], //列表\n\t\"annotations\": [{\n\t\t\"id\": int, //标注id\n\t\t\"image_id\": int, //所属图像id\n\t\t\"category_id\": int, //类别id\n\t\t\"segmentation\": RLE or [polygon], //图像分割标注\n\t\t\"area\": float, //区域面积\n\t\t\"bbox\": [x,y,width,height], //目标框左上角坐标以及宽高\n\t\t\"iscrowd\": 0 or 1, //是否密集\n\t},{...}], //列表\n\t\"categories\": [{\n\t\t\"id\": int, //类别序号\n\t\t\"name\": str, //类别名称\n\t\t\"supercategory\": str, //父类别\n\t}], //列表\n\t\"licenses\": [{//对于训练，不重要\n\t\t\"id\": int, \n\t\t\"name\": str, \n\t\t\"url\": str,\n\t}], //列表\n}\n```\n\n## 2.2 注册数据集\n\n```python\nimport os\n\nfrom detectron2.data import DatasetCatalog, MetadataCatalog\nfrom detectron2.data.datasets.register_coco import register_coco_instances\n\n\nDATA_ALL_CATEGORIES = [\n {'id': 1, 'name': 'airplane'},\n {'id': 2, 'name': 'ship'},\n {'id': 3, 'name': 'storage tank'},\n {'id': 4, 'name': 'baseball diamond'},\n {'id': 5, 'name': 'tennis court'},\n {'id': 6, 'name': 'basketball court'},\n {'id': 7, 'name': 'ground track field'},\n {'id': 8, 'name': 'harbor'},\n {'id': 9, 'name': 'bridge'},\n {'id': 10, 'name': 'vehicle'}\n]\n\nDATA_SPLITS = {}\nDATA_SPLITS['nwpu_all'] = {\n\t'nwpu_all_trainval': (\n\t\tos.path.join(DATA_ROOT,\"positive image set\"),\n\t\tos.path.join(DATA_ROOT,'trainval.json')\n\t),\n\t'nwpu_all_test': (\n\t\tos.path.join(DATA_ROOT,\"positive image set\"),\n\t\tos.path.join(DATA_ROOT,'test.json')\n\t)\n}\n\ndef _get_data_all_instance_meta():\n    thing_ids = [k[\"id\"] for k in DATA_ALL_CATEGORIES]\n    thing_dataset_id_to_contiguous_id = {k: i for i, k in enumerate(thing_ids)}\n    thing_classes = [k[\"name\"] for k in DATA_ALL_CATEGORIES]\n    ret = {\n        \"thing_dataset\": thing_dataset_id_to_contiguous_id,\n        \"thing_classes\": thing_classes,\n    }\n    return ret\n\ndef _get_builtin_metadata(dataset_name):\n    if dataset_name == \"nwpu_all\":\n        return _get_data_instance_meta(DATA_ALL_CATEGORIES)\n\ndef register_all(root):\n    for dataset_name, splits_per_dataset in DATA_SPLITS.items():\n        for key, (image_root, json_file) in splits_per_dataset.items():\n            assert os.path.exists(os.path.join(root, json_file))\n            register_coco_instances(\n                key,\n                _get_builtin_metadata(dataset_name),\n                os.path.join(root, json_file) if \"://\" not in json_file else json_file,\n                os.path.join(root, image_root),\n            )\n\nDATA_ROOT = \"D:/GISP/XIEMINGJIE/Code/Detection/dataset/NWPU VHR-10 dataset/\"\n\nregister_all(DATA_ROOT)\n```\n\n此时已完成`nwpu_all_trainval`以及`nwpu_all_test`数据集的注册，可以通过代码查看：\n\n```python\nprint(DatasetCatalog.get(\"nwpu_all_trainval\"))\nprint(DatasetCatalog.get(\"nwpu_all_test\"))\n```\n\n当然，如果不想要使用COCO格式数据集也可以自定义注册函数，可以参考`register_coco_instances`的代码：\n\n```python\ndef register_coco_instances(name, metadata, json_file, image_root):\n    \"\"\"\n    Args:\n        name (str): the name that identifies a dataset, e.g. \"coco_2014_train\".\n        metadata (dict): extra metadata associated with this dataset.  You can\n            leave it as an empty dict.\n        json_file (str): path to the json instance annotation file.\n        image_root (str or path-like): directory which contains all the images.\n    \"\"\"\n    assert isinstance(name, str), name\n    assert isinstance(json_file, (str, os.PathLike)), json_file\n    assert isinstance(image_root, (str, os.PathLike)), image_root\n    # 1. register a function which returns dicts\n    DatasetCatalog.register(name, lambda: load_coco_json(json_file, image_root, name))\n\n    # 2. Optionally, add metadata about this dataset,\n    # since they might be useful in evaluation, visualization or logging\n    MetadataCatalog.get(name).set(\n        json_file=json_file, image_root=image_root, evaluator_type=\"coco\", **metadata\n    )\n```\n\n其中`load_coco_json`函数的功能是读取数据集标注文件，并以固定的形式返回，详细可见[官网](https://detectron2.readthedocs.io/en/latest/tutorials/datasets.html#register-a-dataset)：\n\n```python\n# load_coco_json返回的是一个列表\n# 返回格式如下：\ndef load_coco_json(json_file, image_root, dataset_name=None, extra_annotation_keys=None):\n\t# read and do something\n\t# ...\n\t# generate dataset_dicts like: ↓\n    dataset_dicts = [{'file_name': '...\\\\images\\\\001.jpg', 'height': 939, 'width': 1356, 'image_id': 0, 'annotations': [{'iscrowd': 0, 'bbox': [903, 57, 129, 123], 'category_id': 0, 'bbox_mode': <BoxMode.XYWH_ABS: 1>}]}, {...}]\n    \n    return dataset_dicts\n```\n\n## 2.3 可视化工具\n\n```python\nimport random\nimport cv2\n\nfrom detectron2.data import MetadataCatalog\nfrom detectron2.data import detection_utils as utils\nfrom detectron2.utils.visualizer import Visualizer\n\ndatasets_dicts = DatasetCatalog.get(\"nwpu_all_trainval_1shot\")\n\nfor data in random.sample(datasets_dicts, 1):\n    img = utils.read_image(data[\"file_name\"])\n    visual = Visualizer(img, metadata=MetadataCatalog.get(\"nwpu_all_trainval\"),scale=0.5)\n    vis = visual.draw_dataset_dict(data)\n    cv2.imshow(\"window\", vis.get_image()[:, :, ::-1])\n    cv2.waitKey()\n```\n\n\n![](https://unpkg.com/justlovesmile-img/20220316211311.png)\n\n## 2.4 自定义数据增强\n\n在注册了数据集之后就可以用`detectron2.data.build_detection_train_loader`和`detectron2.data.build_detection_test_loader`构建`Dataloader`，即数据集的加载方式。\n\n```python\nfrom detectron2.config import get_cfg\nimport detectron2.data.transforms as T\nfrom detectron2.model_zoo import model_zoo\nfrom detectron2.data import build_detection_train_loader\nfrom detectron2.data import DatasetMapper   # the default mapper\n\ncfg = get_cfg()\ncfg.merge_from_file(model_zoo.get_config_file(\"COCO-Detection/retinanet_R_50_FPN_1x.yaml\"))\ncfg.DATASETS.TRAIN = (\"nwpu_all_trainval\",)\n\nmapper = DatasetMapper(cfg,is_train=True,augmentations=[T.Resize((800, 800))])\ntrain_loader = build_detection_train_loader(cfg,mapper=mapper)\n```\n\n`build_detection_train_loader()`的参数如下：\n\n```python\nbuild_detection_train_loader(\n    dataset,\n    *,\n    mapper,\n    sampler=None,\n    total_batch_size,\n    aspect_ratio_grouping=True,\n    num_workers=0,\n    collate_fn=None,\n)\n```\n\n其中`mapper`对应的就是数据增强部分，默认为`detectron2.data.DatasetMapper`，`sampler`对应的采样策略部分，通常只需要关注`mapper`即可。\n\n```python\nclass DatasetMapper:\n    @configurable\n    def __init__(self,is_train: bool):\n        pass\n\n    @classmethod\n    def from_config(cls, cfg, is_train: bool = True):\n        pass\n\n    def _transform_annotations(self, dataset_dict, transforms, image_shape):\n        pass\n\n    def __call__(self, dataset_dict):\n        pass\n        return dataset_dict\n```\n\n官方给的自定义简化DataMapper：\n\n```python\nfrom detectron2.data import detection_utils as utils\nimport detectron2.data.transforms as T\n\ndef mapper(dataset_dict):\n    dataset_dict = copy.deepcopy(dataset_dict)  # it will be modified by code below\n    # can use other ways to read image\n    image = utils.read_image(dataset_dict[\"file_name\"], format=\"BGR\")\n    # \"Data Augmentation\"\n    auginput = T.AugInput(image)\n    transform = T.Resize((800, 800))(auginput)\n    image = torch.from_numpy(auginput.image.transpose(2, 0, 1))\n    annos = [\n        utils.transform_instance_annotations(annotation, [transform], image.shape[1:])\n        for annotation in dataset_dict.pop(\"annotations\")\n    ]\n    return {\n       # create the format that the model expects\n       \"image\": image,\n       \"instances\": utils.annotations_to_instances(annos, image.shape[1:])\n    }\n\ndataloader = build_detection_train_loader(cfg, mapper=mapper)\n```\n\n因此自定义的数据增强需要满足，输入为`dataset_dict`，输出为：\n\n```python\n{\n \"images\": image_tensor,\n \"instances\": utils.annotations_to_instances => Instances类\n}\n```\n\n# 3. 自定义模型\n\nDetectron2的模型是分模块的，它将目标检测模型拆分为了4个核心模块：`backbone`，`proposal_generator`，`roi_heads`以及`meta_arch`。\n\n## 3.1 特征提取网络（backbone）\n\n在`detectron2.modeling.backbone`路径下可以看到，目前只有`ResNet`、`FPN`和`RegNet`\n\n可直接使用的`backbone`：\n```txt\nbuild_resnet_backbone\nbuild_resnet_fpn_backbone\nbuild_retinanet_resnet_fpn_backbone\n```\n\n官方的自定义`backbone`的案例：\n```python\nfrom detectron2.modeling import BACKBONE_REGISTRY, Backbone, ShapeSpec\n\n@BACKBONE_REGISTRY.register()\nclass ToyBackbone(Backbone):\n  def __init__(self, cfg, input_shape):\n    super().__init__()\n    # create your own backbone\n    self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=16, padding=3)\n\n  def forward(self, image):\n    return {\"conv1\": self.conv1(image)}\n\n  def output_shape(self):\n    return {\"conv1\": ShapeSpec(channels=64, stride=16)}\n```\n\n## 3.2 候选框生成器（proposal_generator）\n\n同样可以自定义注册\n```python\n@PROPOSAL_GENERATOR_REGISTRY.register()\nclass ToyRPN(RPN):\n\tdef __init__(self,*args, **kwargs):\n\t\tsuper().__init__()\n\t    pass\n\n@RPN_HEAD_REGISTRY.register()\nclass ToyRPNHead(StandardRPNHead):\n\tdef __init__(self,*args, **kwargs):\n\t    super().__init__()\n\t    pass\n```\n\n## 3.3 检测器（roi_heads）\n\n```python\n@ROI_MASK_HEAD_REGISTRY.register()\n@ROI_KEYPOINT_HEAD_REGISTRY.register()\n@ROI_HEADS_REGISTRY.register()\n@ROI_BOX_HEAD_REGISTRY.register()\n```\n\n## 3.4 模型框架（meta_arch）\n\n```python\n@META_ARCH_REGISTRY.register()\nclass ToyNet(nn.Module):\n    @configurable\n    def __init__(self,*args, **kwargs):\n        super().__init__()\n        pass\n\n    @classmethod\n    def from_config(cls, cfg):\n        pass\n\n    def forward_training(self,*args, **kwargs):\n        pass\n\n    def loss(self,*args, **kwargs):\n        pass\n\n    @torch.no_grad()\n    def label_anchors(self,*args, **kwargs):\n        pass\n        \n    def forward_inference(self,*args, **kwargs):\n        pass\n\n    def inference_single_image(self,*args, **kwargs):\n        pass\n```\n\n具体可参考官方复现的[projects](https://github.com/facebookresearch/detectron2/tree/main/projects)\n\n# 4. 模型训练\n\n## 4.1 默认训练\n\n一般而言，我们可以继承使用默认的目标检测任务训练器`DefalutTrainer`，而`DefalutTrainer`又是继承自`TrainerBase`，`TrainerBase`中又使用到了`HookBase`。我的理解是`HookBase`和`TrainerBase`是将一个训练过程抽象并拆分成阶段步骤的过程，先看`HookBase`：\n\n```python\nclass HookBase:\n    def before_train(self):\n        \"\"\"\n        Called before the first iteration.\n        \"\"\"\n        pass\n\n    def after_train(self):\n        \"\"\"\n        Called after the last iteration.\n        \"\"\"\n        pass\n\n    def before_step(self):\n        \"\"\"\n        Called before each iteration.\n        \"\"\"\n        pass\n\n    def after_step(self):\n        \"\"\"\n        Called after each iteration.\n        \"\"\"\n        pass\n\n    def state_dict(self):\n        return {}\n```\n\n对于训练而言，它将一个完整的训练拆分成：\n\n```python\nclass TrainerBase:\n    def __init__(self):\n        self._hooks: List[HookBase] = []\n\n    def register_hooks(self, hooks: List[Optional[HookBase]]) -> None:\n        hooks = [h for h in hooks if h is not None]\n        for h in hooks:\n            assert isinstance(h, HookBase)\n            h.trainer = weakref.proxy(self)\n        self._hooks.extend(hooks)\n\n    def train(self, start_iter: int, max_iter: int):\n        self.iter = self.start_iter = start_iter\n        self.max_iter = max_iter\n        with EventStorage(start_iter) as self.storage:\n            try:\n                self.before_train()\n                for self.iter in range(start_iter, max_iter):\n                    self.before_step()\n                    self.run_step()\n                    self.after_step()\n            finally:\n                self.after_train()\n\n    def before_train(self):\n        for h in self._hooks:\n            h.before_train()\n\n    def after_train(self):\n        self.storage.iter = self.iter\n        for h in self._hooks:\n            h.after_train()\n\n    def before_step(self):\n        self.storage.iter = self.iter\n        for h in self._hooks:\n            h.before_step()\n\n    def after_step(self):\n        for h in self._hooks:\n            h.after_step()\n\n    def run_step(self):\n        raise NotImplementedError\n\n    def state_dict(self):\n        pass\n\n    def load_state_dict(self, state_dict):\n        pass\n```\n\n简化一点，它将一个训练过程抽象成：\n```python\nhook.before_train()\nfor iter in range(start_iter, max_iter):\n    hook.before_step()\n    trainer.run_step()\n    hook.after_step()\niter += 1\nhook.after_train()\n```\n\n具体到目标检测任务，`DefaultTrainer`：\n\n```python\nclass DefaultTrainer(TrainerBase):\n    def __init__(self, cfg):\n        super().__init__()\n        pass\n\n    def build_hooks(self):\n        pass\n\n    def build_writers(self):\n        pass\t\n\n    def train(self):\n        pass\n\n    @classmethod\n    def test(cls, cfg, model, evaluators=None):\n        pass\n    # \n    # a lot of\n    # def ...(...):\n    #     .....\n    # \n\n    @classmethod\n    def build_train_loader(cls, cfg):\n        return build_detection_train_loader(cfg)\n\n    @classmethod\n    def build_test_loader(cls, cfg, dataset_name):\n        return build_detection_test_loader(cfg, dataset_name)\n\n    @classmethod\n    def build_evaluator(cls, cfg, dataset_name):\n        pass\n```\n\n## 4.2 自定义训练\n\n由于Detectron2已经将训练过程模块化，因此只需要修改对应模块即可，而一般而言，我们只需要修改数据加载和`evaluate`部分：\n\n```python\nfrom detectron2.engine import DefaultTrainer\nclass Trainer(DefaultTrainer):\n    @classmethod\n    def build_evaluator(cls, cfg, dataset_name, output_folder=None):\n        evaluator_list = []\n        pass\n        return DatasetEvaluators(evaluator_list)\n\n    @classmethod\n    def build_test_loader(cls, cfg, dataset_name):\n        return build_detection_test_loader(cfg, dataset_name, mapper=my_mapper(cfg,\"test\"))\n\n    @classmethod\n    def build_train_loader(cls, cfg):\n        return build_detection_train_loader(cfg, mapper=my_mapper(cfg, \"train\"))\n```\n\n## 4.3 完整训练流程\n\n参考`tools/train_net.py`或者`tools/plain_train_net.py`，已经写的非常详细了👍，注意别忘了导入自己写好的注册数据集以及注册模型的文件，只要导入了就会自动注册，就可以在配置文件中使用。\n\n# 5. 配置文件\n\n参考`configs`文件夹下的`yaml`文件格式，，可以通过`__BASE__`继承基础配置文件，还可以直接覆盖之前的配置，如`retinanet_R_50_FPN_3x.yaml`：\n\n```yaml\n_BASE_: \"../Base-RetinaNet.yaml\"\nMODEL:\n  WEIGHTS: \"detectron2://ImageNetPretrained/MSRA/R-50.pkl\"\n  RESNETS:\n    DEPTH: 50\nSOLVER:\n  STEPS: (210000, 250000)\n  MAX_ITER: 270000\n```\n\n查看全部配置项：\n\n```python\nfrom detectron2.config import get_cfg\ncfg = get_cfg()\n\nprint(cfg)\n# 或者\nprint(cfg.dump())\n```\n\n在python文件中修改配置：\n\n```python\ncfg.SOLVER.BASE_LR = 0.001\n# 或者\ncfg.merge_from_list([\"SOLVER.BASE_LR\", \"0.001\"])\n```\n\n合并多个文件中的配置项：\n\n```python\ncfg.merge_from_file(\"my_cfg.yaml\")\n```\n\n由于配置项本质上还是转换成了字典类型，因此可以直接从python文件导入配置，并且也提供了python格式的配置文件该怎么进行训练的示例，参考`tools/lazyconfig_train_net.py`：\n\n```python\n# config.py\nNEW_MODEL = dict(NUM=1,SIZE=dict(W=2,H=3))\nNEW_OPT = dict(NAME=\"hhhh\")\n\n# ---\nfrom detectron2.config import LazyConfig\ncfg = LazyConfig.load(\"config.py\")\nassert cfg.NEW_MODEL.SIZE.W==2\n# cfg = LazyConfig.load(args.config_file)\n# cfg = LazyConfig.apply_overrides(cfg, args.opts)\n```\n\n并且Detectron2还提供了一个帮助创建配置字典的函数，`LazyCall`：\n\n```python\nfrom detectron2.config import LazyCall as L\nfrom detectron2.modeling.backbone import RegNet\nfrom detectron2.modeling.backbone.regnet import SimpleStem, ResBottleneckBlock\n\nbottom_up = L(RegNet)(\n    stem_class=SimpleStem,\n    stem_width=32,\n    block_class=ResBottleneckBlock,\n    depth=23,\n    w_a=38.65,\n    w_0=96,\n    w_m=2.43,\n    group_width=40,\n    norm=\"SyncBN\",\n    out_features=[\"s1\", \"s2\", \"s3\", \"s4\"],\n)\n\nprint(bottom_up)\n```","tags":["深度学习","Detectron2"],"categories":["人工智能"]},{"title":"Hexo博客 | 如何让Butterfly主题导航栏居中","slug":"博客相关-Butterfly主题导航栏居中","url":"/posts/56b0563d.html","content":"\n最近有很多小伙伴留言问我ButterFly主题的**导航栏是怎么居中的**，说实话我的博客样式其实都是一点一点从其他博主的博客那模仿来的（如果我没记错的话，导航栏应该是看的[Heo大佬](https://blog.zhheo.com/)的），所以样式修改的时间跨度有点长，我自己也不太清楚具体改了哪些地方，但是鉴于问的小伙伴太多，我决定把导航栏文件全部展示出来，至于CSS可以参考我的[css文件](/css/justlovesmile.css)第168到434行（当前时间2022/3/15，不排除之后我又改了）......\n\n## 主题模板文件\n\n### index.pug\n\n`themes\\butterfly\\layout\\includes\\header\\index.pug`\n\n```pug\nif !theme.disable_top_img && page.top_img !== false\n  if is_post()\n    - var top_img = page.top_img || page.cover || page.randomcover\n  else if is_page()\n    - var top_img = page.top_img || theme.default_top_img\n  else if is_tag()\n    - var top_img = theme.tag_per_img && theme.tag_per_img[page.tag] \n    - top_img = top_img ? top_img : (theme.tag_img !== false ? theme.tag_img || theme.default_top_img : false)\n  else if is_category()\n    - var top_img = theme.category_per_img && theme.category_per_img[page.category]\n    - top_img = top_img ? top_img : (theme.category_img !== false ? theme.category_img || theme.default_top_img : false)\n  else if is_home()\n    - var top_img = theme.index_img !== false ? theme.index_img || theme.default_top_img : false\n  else if is_archive()\n    - var top_img = theme.archive_img !== false ? theme.archive_img || theme.default_top_img : false\n  else\n    - var top_img = page.top_img || theme.default_top_img\n\n  if top_img !== false\n    - var imgSource = top_img && top_img.indexOf('/') !== -1 ? `background-image: url('${url_for(top_img)}')` : `background: ${top_img}`\n    - var bg_img = top_img ? imgSource : ''\n    - var site_title = is_archive() ? fragment_cache('findArchivesTitle', function(){return findArchivesTitle(theme.menu);}) : page.title || page.tag || page.category || config.title\n    - var isHomeClass = is_home() ? 'full_page' : 'not-home-page'\n    - is_post() ? isHomeClass = 'post-bg' : isHomeClass\n  else\n    - var isHomeClass = 'not-top-img'\nelse\n  - var top_img = false\n  - var isHomeClass = 'not-top-img'\n\nheader#page-header(class=isHomeClass style=bg_img)\n  !=partial('includes/header/nav', {}, {cache: true})\n  if top_img !== false\n    if is_post()\n      #coverdiv.coverdiv\n        img#post-cover.cover.entered.loading(alt='cover' src=`${top_img}`)\n      include ./post-info.pug\n    else if is_home() \n      #site-info\n        h1#site-title=site_title\n        if theme.subtitle.enable\n          - var loadSubJs = true\n          #site-subtitle\n            span#subtitle\n        if(theme.social)\n          #site_social_icons\n            !=fragment_cache('social', function(){return partial('includes/header/social')})\n      #scroll-down\n        i.fas.fa-angle-down.scroll-down-effects\n    else\n      #coverdiv.coverdiv\n        img#post-cover.cover.entered.loading(alt='cover' src=`${top_img}`)\n      #page-site-info\n        h1#site-title=site_title\n```\n\n### nav.pug\n\n`themes\\butterfly\\layout\\includes\\header\\nav.pug`\n\n```pug\nnav#nav\n  #nav-group\n    #blog_name\n      a#site-name(href=url_for('/')) #[=config.author]\n\n    #menus\n      !=partial('includes/header/menu_item', {}, {cache: true})\n\n    #nav-right\n      if (theme.algolia_search.enable || theme.local_search.enable)\n        #search-button\n          a.nav-rightbutton.site-page.social-icon.search\n            i.fas.fa-search.fa-fw\n      #darkmode_navswitch\n        a.nav-rightbutton.site-page.darkmode_switchbutton(onclick=\"switchDarkMode()\")\n          i.fas.fa-adjust\n      #toggle-menu\n        a.nav-rightbutton.site-page\n          i.fas.fa-bars.fa-fw\n```\n\n上面提到的`switchDarkMode()`\n\n```js\nfunction switchDarkMode() { // Switch Between Light And Dark Mode\n      const nowMode = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'\n      if (nowMode === 'light') {\n        activateDarkMode()\n        saveToLocal.set('theme', 'dark', 2)\n        GLOBAL_CONFIG.Snackbar !== undefined && btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night)\n      } else {\n        activateLightMode()\n        saveToLocal.set('theme', 'light', 2)\n        GLOBAL_CONFIG.Snackbar !== undefined && btf.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day)\n      }\n      // handle some cases\n      typeof utterancesTheme === 'function' && utterancesTheme()\n      typeof FB === 'object' && window.loadFBComment()\n      window.DISQUS && document.getElementById('disqus_thread').children.length && setTimeout(() => window.disqusReset(), 200)\n    }\n```\n\n## CSS\n\n请自行F12查看，截至目前（2022/3/15）导航栏相关css样式是在[/css/justlovesmile.css](/css/justlovesmile.css)第168到434行....\n\n其他的之后再补充，有问题的欢迎留言提问","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"目标检测 | RetinaNet，经典单阶段Anchor-Based目标检测模型","slug":"人工智能-RetinaNet论文解读","url":"/posts/bb608df3.html","content":"\n# 1. 论文信息\n\n论文标题：Focal Loss for Dense Object Detection\n\n>论文来源：IEEE Transactions on Pattern Analysis and Machine Intelligence 2020\n>论文链接：[Focal Loss for Dense Object Detection | IEEE Xplore](https://ieeexplore.ieee.org/document/8417976)\n>论文代码：[https://github.com/facebookresearch/Detectron](https://github.com/facebookresearch/Detectron)\n\n![image-20211119213555220](https://unpkg.com/justlovesmile-img/image-20211119213555220.png)\n\n```bib\n@inproceedings{lin2017focal,\n  title={Focal loss for dense object detection},\n  author={Lin, Tsung-Yi and Goyal, Priya and Girshick, Ross and He, Kaiming and Doll{\\'a}r, Piotr},\n  booktitle={Proceedings of the IEEE international conference on computer vision},\n  pages={2980--2988},\n  year={2017}\n}\n```\n\n# 2. 归纳总结\n\n| 标签            | 目的                         | 方法       | 总结                  |\n| --------------- | ---------------------------- | ---------- | --------------------- |\n| #Anchor #单阶段 | 解决正负样本严重不均衡的问题 | retinanet和focal loss | 针对训练过程中的实际问题，修改损失函数以达到优化的目的 | \n\n# 3. 主要工作\n\n作者认为之前的单阶段检测算法精度不高的原因可能是前后景类别（正负样本）严重不均衡导致的。因此作者重新设计了一个损失：Focal Loss，其能降低可以较好分类的样本的损失权重，防止训练过程中大量的easy negatives给检测器带来的压制影响，并基于Focal Loss设计提出并训练了RetinaNet。\n\n## 3.1 网络结构\nRetinaNet的结构如下图：\n\n![image-20211120135540595](https://unpkg.com/justlovesmile-img/image-20211120135540595.png)\n\n主要包括三个部分：\n\n- Backbone：使用了ResNet+FPN，用于生成多尺度{p3~p7}卷积特征图\n- Anchor：p3-p7特征图的base_size设置为$[32^2,64^2,128^2,256^2,512^2]$，在每一层特征图针对denser scale coverage，设置{${2^0,2^{1/3},2^{2/3}}$}三种不同的anchor size，比例为{1:2,1:1,2:1}，即每个位置9种Anchor。\n- subnets：用于分类和回归，结构相同但参数不共享的小型FCN结构\n\n![image-20211120135222791](https://unpkg.com/justlovesmile-img/image-20211120135222791.png)\n\n## 3.2 Focal Loss\n\n作者提到基于R-CNN模式的两阶段算法在解决训练过程中的正负样本不均衡的方法是：\n- 两阶段级联：在proposal阶段过滤掉大量负样本\n- 启发式采样：例如固定正负样本比例（例如1:3）或者在线难样本挖掘（Online Hard Example Mining，OHEM）\n\nFocal loss的做法是设置一个sacling factor，如下图的$(1-p_t)^{\\gamma}$，其可以自动的对easy example进行降权，从而使模型更关注hard example。\n\n![image-20211120135146831](https://unpkg.com/justlovesmile-img/image-20211120135146831.png)\n\n首先，对于二分类任务，普通的交叉熵如下：\n\n![image-20211120132951497](https://unpkg.com/justlovesmile-img/image-20211120132951497.png)\n\n如果定义$p_t$：\n\n![image-20211120133459396](https://unpkg.com/justlovesmile-img/image-20211120133459396.png)\n\n那么交叉熵可以写成$CE(p,y)=CE(p_t)=-log(p_t)$\n\n有一种常见的用于解决类别不均衡的方法是添加一个权重变量$\\alpha \\in [0,1]$：\n\n![image-20211120133655071](https://unpkg.com/justlovesmile-img/image-20211120133655071.png)\n\nFocal Loss的做法是添加了一个权重变量$(1-p_t)^{\\gamma}$：\n\n![image-20211120133916235](https://unpkg.com/justlovesmile-img/image-20211120133916235.png)\n\n因此当$p_t$趋近于1时，可以较好分类的样本被降权；而$\\gamma$可以用来调节权重比率。除此之外，还可以将$\\alpha$和FL损失相结合：\n\n![image-20211120134227038](https://unpkg.com/justlovesmile-img/image-20211120134227038.png)\n\n除此之外还有其他的Focal Loss变种形式。\n\n# 4. 实验结果\n\n![image-20211120141212266](https://unpkg.com/justlovesmile-img/image-20211120141212266.png)","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"目标检测 | Faster R-CNN，经典两阶段检测模型","slug":"人工智能-Faster-R-CNN","url":"/posts/fc798de3.html","content":"\n# 1. 论文信息\n\n论文标题：`《Faster R-CNN: Towards Real-Time ObjectDetection with Region Proposal Networks》`\n\n>论文发表：2015\n>论文链接：[https://arxiv.org/abs/1506.01497](https://arxiv.org/abs/1506.01497)\n>论文代码：[https://github.com/rbgirshick/py-faster-rcnn](https://github.com/rbgirshick/py-faster-rcnn)\n\n![image-20211120141803069](https://unpkg.com/justlovesmile-img/image-20211120141803069.png)\n\n```bib\n@article{ren2015faster,\n  title={Faster r-cnn: Towards real-time object detection with region proposal networks},\n  author={Ren, Shaoqing and He, Kaiming and Girshick, Ross and Sun, Jian},\n  journal={Advances in neural information processing systems},\n  volume={28},\n  pages={91--99},\n  year={2015}\n}\n```\n\n# 2. 归纳总结\n\n| 标签            | 目的 | 方法 | 总结                |\n| --------------- | ---- | ---- | ------------------- |\n| #Anchor #两阶段 | -    | RPN  | 首次提出RPN和Anchor |\n\n# 3. 主要工作\n\nFaster R-CNN是在R-CNN和Fast R-CNN的基础上提出的一种两阶段目标检测算法，其主要包括：\n\n- 特征提取网络（Backbone）\n- RPN（Region Proposal Networks）\n- RoI Pooling（Region of Interesting Pooling）\n- 分类回归（Classification and Regression）\n\n论文中的结构图如下：\n\n![image-20211120142753845](https://unpkg.com/justlovesmile-img/image-20211120142753845.png)\n\n自己画的训练流程图如下：\n\n![image-20211120143345989](https://unpkg.com/justlovesmile-img/image-20211120143345989.png)\n\n网上找的训练流程图如下：\n\n![fasterRCNN](https://unpkg.com/justlovesmile-img/fasterRCNN.png)\n>图片来自[WZMIAOMIAO/deep-learning-for-image-processing (github.com)](https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_object_detection/faster_rcnn)\n\n对于Backbone生成的特征图，首先输入到RPN结构中，用于生成Proposal。RPN，即区域推荐网络，对于目标检测任务而言，不仅需要对目标分类还需要对目标定位，因此Faster RCNN模型提出了Anchor机制，其中的做法是，在特征图的每个像素位置预设一组多尺度的先验框，即Anchor（作者使用了3种尺寸（128，256，512），3种比例（1:1，1:2，2:1）的Anchor，共9种）：\n\n![image-20211120143554871](https://unpkg.com/justlovesmile-img/image-20211120143554871.png)\n\n如果输入一张800×600的图片，经过Backbone后被下采样16倍，那么这个特征图的尺寸为$\\frac{800}{16}×\\frac{600}{16}=1900$个像素，那么这个特征图上需要设置1900×9=17100个Anchor。但这一步得到的Anchor肯定不可能全部当作候选区域，因此在预设了Anchor之后，为了筛选有意义的proposal，还设置了一个3×3的卷积层后接两个1×1的卷积层来预测该区域是否包含目标(cls)以及偏移量预测(reg)，如果包含目标则需要根据预测的偏移量对该Anchor进行微调。\n\n![image-20211120143818038](https://unpkg.com/justlovesmile-img/image-20211120143818038.png)\n\n这两个1×1的卷积层的输出维度分别为2k和4k，其中k为每个位置的Anchor数量，2代表包含目标和不包含目标的概率，4代表对目标框坐标值（x,y,w,h）的偏移量预测：\n\n![image-20211120144113585](https://unpkg.com/justlovesmile-img/image-20211120144113585.png)\n\n![image-20211120144227681](https://unpkg.com/justlovesmile-img/image-20211120144227681.png)\n\n可以根据上述公式，计算出候选区域的坐标。并且当我们得到了该区域包含目标的概率之后，我们就可以进行一个简单的筛选，按照包含目标可能性排序，只保留前2000个作为候选区域，并且对于超出图片边界的边框还需要进行一个裁剪处理。\n\n尽管我们筛选出了2000个候选区域，但我们在计算Loss的时候并不是拿这2000个候选区域来计算，这里Faster RCNN定义了正负样本的概念，首先我们需要将特征图上的Anchor映射回原始图像，因为我们的Ground-Truth是在原始图像上标注的，RPN需要根据这个来进行学习，其次还需要了解IoU这个概念，IoU可以用来计算两个框之间的重合度，其值为两个框的交集与并集的比值。\n\n![image-20211120151522563](https://unpkg.com/justlovesmile-img/image-20211120151522563.png)\n\n那么我们就可以定义候选区域和ground-truth的IoU值大于0.7的为正样本，小于0.3的为负样本，其他的都不用于计算损失，然后从中分别随机抽取128个正负样本。RPN的损失函数如下：\n\n![image-20211120144312326](https://unpkg.com/justlovesmile-img/image-20211120144312326.png)\n\nRoI Pooling的作用是将 RPN 输出的大小不等的候选框缩放到统一的尺寸。具体做法是，假设需要固定候选区域为7×7大小，那么就可以将其划分为7×7个块，然后对每个块进行最大值池化，最后输出的大小就是所需要的。\n\n![image-20211120144459517](https://unpkg.com/justlovesmile-img/image-20211120144459517.png)\n\n这样，将所有的候选区域统一大小后，将其展平为49×1大小，通道数为256的向量，输入到两个全连接层隐藏层，最后再分别接两个输出大小为类别数以及类别数×4的全连接层。来实现对候选区域包含目标所属类别概率以及对该目标框的偏移量的预测。分类回归的损失函数和之前RPN的损失函数类似，只是分类损失不再是二分类交叉熵而是多分类交叉熵。预测框的坐标计算也和之前RPN部分的一样。\n\n![image-20211120151313142](https://unpkg.com/justlovesmile-img/image-20211120151313142.png)\n\n而在得到了预测目标框和类别概率之后，还需要进一步筛选，因为之前保留了2000个候选区域，而实际场景中目标数量根本达不到那么多，因此我们使用了NMS算法对重叠目标框进行去重。NMS算法的流程如下图所示：\n\n![image-20211120151353580](https://unpkg.com/justlovesmile-img/image-20211120151353580.png)\n\n![image-20211120151446230](https://unpkg.com/justlovesmile-img/image-20211120151446230.png)\n\n首先对同一个类别所有的目标框进行排序，（这里默认之前预测的分类概率最大的类别为目标所属类别），然后从大到小依次选择一个目标框和其他剩余目标框计算IoU值，如果IoU值大于设定的阈值如0.5，就代表重叠，此时舍去得分小的目标框，否则就保留，然后依次比较之后，就能实现对重叠目标的去重处理。\n\n论文里的实验结果：\n\n![image-20211120151656814](https://unpkg.com/justlovesmile-img/image-20211120151656814.png)\n\n# 4. 参考文献\n\n[一文读懂Faster RCNN - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/31426458)\n\n","tags":["深度学习","论文笔记","目标检测"],"categories":["人工智能"]},{"title":"深度学习 | 小样本学习基础概念","slug":"人工智能-小样本学习基础概念","url":"/posts/d150f284.html","content":"\n# 小样本学习\n\n人类非常擅长通过极少量的样本识别一个新物体，比如小孩子只需要书中的一些图片就可以认识什么是“斑马”，什么是“犀牛”。在人类的快速学习能力的启发下，研究人员希望机器学习模型在学习了一定类别的大量数据后，对于新的类别，只需要少量的样本就能快速学习，这就是 Few-shot Learning 要解决的问题。Few-shot learning (FSL) 在机器学习领域具有重大意义和挑战性，是否拥有从少量样本中学习和概括的能力，是将人工智能和人类智能进行区分的明显分界点，因为人类可以仅通过一个或几个示例就可以轻松地建立对新事物的认知，而机器学习算法通常需要成千上万个有监督样本来保证其泛化能力。\n\n## 1.基础概念\n\n机器学习定义：A computer program is said to learn from experience `E` with respect to some classes of task `T` and performance measure `P` if its performance can improve with `E` on `T` measured by `P`.\n\n![image-20210920132843364](https://unpkg.com/justlovesmile-img/202109201329876.png)\n\n小样本学习定义：Few-Shot Learning (FSL) is a type of machine learning problems (specified by `E`, `T` and `P`), where `E` contains only a limited number of examples with supervised information for the target `T`.\n\n![image-20210920132907931](https://unpkg.com/justlovesmile-img/202109201329400.png)\n\n小样本学习（Few-shot learning），或者称为少样本学习（Low-shot learning），包含了n-shot learning，其中`n`代表样本数量，`n=1`的情况下，也被称One-shot learning，而`n=0`的情况下，被称为Zero-shot learning。\n\n![image-20210920134843156](https://unpkg.com/justlovesmile-img/202109201348334.png)\n\n小样本学习的主要思想是利用先验知识使其快速适用于只包含少量带有监督信息的样本的任务中。\n\n## 2. 方法分类\n\n![image-20210920133613257](https://unpkg.com/justlovesmile-img/202109201336741.png)\n\n\n\n小样本学习问题的解决方法可以根据先验知识的利用方式分为三类：\n\n- 数据：此类方法利用先验知识来增强训练数据集或者增加样本数量（从样本量的角度）\n  - ![image-20211005154338367](https://unpkg.com/justlovesmile-img/202110051544192.png)\n  - 1.使用旋转，翻转，裁剪等方法对训练集图像增强\n  - 2.从其他数据集获取图像用于扩充训练集\n  - 3.使用GAN来生成具有相似分布的数据用于扩充训练集\n- 模型：此类方法利用先验知识来限制假设空间的复杂性（从模型训练的角度）\n  - ![image-20211005154419771](https://unpkg.com/justlovesmile-img/202110051544913.png)\n  - 1.多任务学习（同时进行多个相关任务训练，共享表示，以获得更好的泛化能力）与迁移学习不同（将源任务中学到的知识运用到目标任务中）\n    - parameter sharing：多任务间共享参数（例如最开始几层网络结构共享，最后输出层单独训练）\n    - parameter typing：对不同任务的参数正则化处理，使其参数相似（encourages parameters of different tasks to be similar using regularization）\n  - 2.嵌入学习（将样本映射（嵌入）到低纬度空间后，相似样本距离更近，不相似样本距离远）\n    - ![image-20211005202850882](https://unpkg.com/justlovesmile-img/202110052028366.png)\n    - Task-Specific Embedding Model:只使用来自任务的信息学习一个定制的嵌入函数\n    - Task-Invariant Embedding Model：将从其他充足样本中学到的信息直接利用到小样本学习任务中\n      - ![image-20211006224637164](https://unpkg.com/justlovesmile-img/202110062246351.png)\n      - Matching Nets\n      - Prototypical Networks(ProtoNet)\n    - Hybrid Embedding Model: 前两种方法的结合，使用小样本任务中的task specific信息运用到从先验知识学到的task invariant嵌入模型\n      - ![image-20211006224925493](https://unpkg.com/justlovesmile-img/202110062249691.png)\n  - 3.带有存储的模型，构建键值存储，并优化内存，每个新样本都可以由内存中提取出的内容的加权平均值表示（通过查询相似性），进一步限制假设空间。\n    - ![image-20211005202918521](https://unpkg.com/justlovesmile-img/202110052104077.png)\n    - ![image-20211005203314132](https://unpkg.com/justlovesmile-img/202110052033347.png)\n    - 优化表征（representation）\n    - 优化参数（parameter）\n  - 4.生成模型，对于样本x在先验知识的帮助下可以估计其分布p(x)：假设x的分布可以表示为受$\\theta$约束的$p(x;\\theta)$，并且通常还存在潜在变量$z \\sim p(z;y)$，因此$x \\sim \\int p(x|z;\\theta)p(z;y)dz$，即在先验分布$p(z;y)$的帮助下，可以进一步缩小假设空间的大小.\n    - ![image-20211005204829440](https://unpkg.com/justlovesmile-img/202110052048660.png)\n    - Decomposable Components：训练可分解组件模型，在不同任务间共享分解组件的信息，最后再找到分解组件的组合方式（模型层面？）\n    - Groupwise Shared Prior：使用无监督学习将数据集分组，对于新类别，首先查询其所属组，再根据其所属组的先验概率建模（相似的任务拥有相似的先验概率）\n    - Parameters of Inference Networks：找到最佳的$\\theta$，使得最大化$p(z|x;\\theta,\\gamma)=\\frac{p(x,z;\\theta,\\gamma)}{p(x;\\gamma)}=\\frac{p(x|z;\\theta)p(z;\\gamma)}{\\int p(x|z;\\theta)p(z;\\gamma)dz}$，通常使用从数据中学到的变分分布$q(z;\\delta)$来估计$p(z|x;\\theta,\\gamma)$。（？）\n- 算法：此类方法利用先验知识在假设空间中搜索最优的假设\n  - ![image-20211005210608746](https://unpkg.com/justlovesmile-img/202110052106876.png)\n  - 1.精炼现存参数\n    - 使用预训练模型，通过正则化进行微调\n      - ![image-20211005211532604](https://unpkg.com/justlovesmile-img/202110052115770.png)\n      - Early-stopping\n      - Selectively updating parameters\n      - Updating related parts of parameters together\n      - Using a model regression network\n    - 聚集子任务的参数（参数层面？）\n      - ![image-20211005210954883](https://unpkg.com/justlovesmile-img/202110052109091.png)\n    - 使用新参数微调现有参数：给模型参数扩充一个$\\delta$，使其参数为$\\theta=\\{\\theta_0,\\delta\\}$，然后通过学习$\\delta$来微调初始参数$\\theta_0$。\n  - 2.精炼Meta-Learned参数\n    - ![image-20211007153301984](https://unpkg.com/justlovesmile-img/202110071533336.png)\n  - 3.学习优化器：不使用梯度下降来更新参数，而是通过学习一个优化器来输出参数的更新，即$\\Delta{\\theta^{i-1}}$\n    - ![image-20211007154007652](https://unpkg.com/justlovesmile-img/202110071540903.png)\n\n## 3. 小样本学习常用数据集\n\n小样本常用Benchmark图像数据集：\n\n- Omniglot\n- Mini-Imagenet\n- CU-Birds\n","tags":["深度学习","小样本学习"],"categories":["人工智能"]},{"title":"Jupyter Lab | 安装、配置、插件推荐、多用户使用教程","slug":"折腾记录-Jupyter-Lab安装","url":"/posts/e05a9ab6.html","content":"\n首先相信很多使用过python的人都或多或少地了解过`Jupyter Notebook`这个应用。`Jupyter Notebook`是一个开源Web应用程序，可让用户创建和共享包含实时代码、公式、可视化和叙述文本的文档。 用途包括：数据清理和转换、数值模拟、统计建模、数据可视化、机器学习等等。\n\n而`Jupyter Lab`则是Jupyter的下一代笔记本界面。`Jupyter Lab` 是一个基于Web的交互式开发环境，用于Jupyter notebook、代码和数据。 `Jupyter Lab` 非常灵活，可支持数据科学、科学计算和机器学习领域的广泛工作。 `Jupyter Lab` 是可扩展和模块化的,其可编写插件来添加新组件并与现有组件相集成。\n\n![image-20211125180351537](https://unpkg.com/justlovesmile-img/image-20211125180351537.png)\n\n# Jupyter Lab安装和配置\n\n## 1.Jupyter Lab安装\n\n首先进入自己的`Python`环境或者其他`Conda`虚拟环境：\n\n```shell\nsource activate XXXXXXX\n```\n\n然后在`terminal`或者`cmd`输入安装命令：\n\n```shell\npip install jupyterlab\n//或者\nconda install -c conda-forge jupyterlab\n```\n\n等待安装完成！\n\n## 2.Jupyter Lab配置\n\n使用命令创建配置文件，其会生成`C:\\Users\\用户名\\.jupyter\\jupyter_notebook_config.py`或者`/home/用户名/.jupyter/jupyter_notebook_config.py`\n\n```shell\njupyter lab --generate-config\n```\n\n使用编辑器打开配置文件，在文件上方添加：\n\n```python\nc.ServerApp.ip = '*'\nc.ServerApp.port = 8000\nc.ServerApp.open_browser = False\nc.ServerApp.root_dir = '/xxxx/xxxx/xxx' \nc.ServerApp.password_required = True\nc.ServerApp.password = 'xxxxxxx'\n```\n\n其中`ip`代表允许访问的ip，`*`代表全部，`port`用于设置端口，`open_browser`用于设置启动lab时是否打开浏览器，`root_dir`用于设置lab启动文件夹根路径，`password_required`用于设置是否需要密码，`password`用于设置（加密）密码，这个加密密码的获取方式如下：\n\n```python\n#打开python或者ipython环境\n\nfrom notebook.auth import passwd\npasswd()\n#Enter password: \n#Verify password: \n#Out[2]: 'argon2:f704bjkasjdfkjasdjfkasjdkjfklmasjdfkalflakdkf'\n```\n\n复制上方输出的加密密码即可。\n\n当然也可以在`Terminal`强制设置/修改密码：\n\n```shell\njupyter lab password\n```\n\n更多配置可以查看默认配置文件下方的注释！\n\n![image-20211120214858878](https://unpkg.com/justlovesmile-img/image-20211120214858878.png)\n\n## 3. Jupyter Lab启动\n\n在`Terminal`输入:\n\n```shell\njupyter lab -p 9090 --no-browser\n```\n\n更多启动命名可通过`jupyter lab --help`查看，启动之后即可在浏览器输入：ip+端口 ，进行访问，如：`127.0.0.0:9090`。\n\n![image-20211120215159090](https://unpkg.com/justlovesmile-img/image-20211120215159090.png)\n\n## 4. Jupyter Lab插件推荐\n\n首先启动Jupyter Lab，在Lab中打开菜单栏的`Setting`里的`Advanced Setting Editor`，接着找到`Extension Manager`，并在右边填入`{'enabled':true}`\n\n![image-20211120215625334](https://unpkg.com/justlovesmile-img/image-20211120215625334.png)\n\n然后即可在左边菜单栏找到插件安装符号，在里面就可以搜索插件，推荐如下：\n\n![image-20211120215754890](https://unpkg.com/justlovesmile-img/image-20211120215754890.png)\n\n- theme-darcula：一个好看的主题配色\n- jupyterlab_go_to_definition：跳转到定义\n- jupyterlab_lsp：代码跳转+代码补全\n- 还有很多如：latex，git，html，plotly，bokeh，matplotlib，drawio等等\n\n## 5. Jupyter Lab多用户使用\n\n复制配置文件到指定位置，例如:\n\n```shell\ncp /home/admin555/.jupyter/jupyter_notebook_config.py /指定位置/jupyter_notebook_config.py\n```\n\n之后启动时，使用命令：\n\n ```shell\n jupyter lab --config /指定位置/jupyter_notebook_config.py\n ```\n\n 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：[https://cloud.tencent.com/developer/support-plan?invite_code=1izx0kxkb2lzz](https://cloud.tencent.com/developer/support-plan?invite_code=1izx0kxkb2lzz)","tags":["Jupyter"],"categories":["折腾记录"]},{"title":"目标检测 | 常用数据集标注格式及生成脚本","slug":"人工智能-目标检测常用数据集标注格式","url":"/posts/865c56ba.html","content":"\n\n\n目标检测是计算机视觉任务中的一个重要研究方向，其用于解决对数码图像中特定种类的可视目标实例的检测问题。目标检测作为计算机视觉的根本性问题之一，是其他诸多计算机视觉任务，例如图像描述生成，实例分割和目标跟踪的基础以及前提。而在解决此类问题时，我们常常需要使用自己的脚本或者利用标注工具生成数据集，数据集格式往往会多种多样，因此对于目标检测任务而言，为了更好地兼容训练，大多数目标检测模型框架会默认支持几种常用的数据集标注格式，常见的分别是COCO，Pascal VOC，YOLO等等。本文主要介绍上述几种数据集格式以及我写的Python脚本（一般需要根据实际情况再改改）。\n\n# 1. COCO\n\n## 1.1 COCO数据集格式\nCOCO（Common Objects in COtext）数据集，是一个大规模的，适用于目标检测，图像分割，Image Captioning任务的数据集，其标注格式是最常用的几种格式之一。目前使用较多的是COCO2017数据集。其官网为[COCO - Common Objects in Context (cocodataset.org)](https://cocodataset.org)。\n\n![image-20210911153516753](https://unpkg.com/justlovesmile-img/202109111535004.png)\n\nCOCO数据集主要包含图像（jpg或者png等等）和标注文件（json），其数据集格式如下(`/`代表文件夹)：\n\n```txt\n-coco/\n    |-train2017/\n    \t|-1.jpg\n    \t|-2.jpg\n    |-val2017/\n    \t|-3.jpg\n    \t|-4.jpg\n    |-test2017/\n    \t|-5.jpg\n    \t|-6.jpg\n    |-annotations/\n    \t|-instances_train2017.json\n    \t|-instances_val2017.json\n    \t|-*.json\n```\n\n`train2017`以及`val2017`这两个文件夹中存储的是训练集和验证集的图像，而`test2017`文件夹中存储的是测试集的信息，可以只是图像，也可以包含标注，一般是单独使用的。\n\n`annotations`文件夹中的文件就是标注文件，如果你有`xml`文件，通常需要转换成`json`格式，其格式如下（更详细的可以参考[官网](https://cocodataset.org/#format-data)）：\n\n```json\n{\n\t\"info\": info, \n\t\"images\": [image], //列表\n\t\"annotations\": [annotation], //列表\n\t\"categories\": [category], //列表\n\t\"licenses\": [license], //列表\n}\n```\n\n其中`info`为整个数据集的信息，包括年份，版本，描述等等信息，如果只是完成训练任务，其实不太重要，如下所示：\n\n```json\n//对于训练，不是那么的重要\ninfo{\n\t\"year\": int, \n\t\"version\": str, \n\t\"description\": str, \n\t\"contributor\": str, \n\t\"url\": str, \n\t\"date_created\": datetime,\n}\n```\n\n其中的`image`为图像的基本信息，包括序号，宽高，文件名等等信息，其中的序号（`id`）需要和后面的`annotations`中的标注所属图片序号对应如下所示：\n\n```json\nimage{\n\t\"id\": int, //必要\n\t\"width\": int, //必要\n\t\"height\": int, //必要\n\t\"file_name\": str, //必要\n\t\"license\": int,\n\t\"flickr_url\": str,\n\t\"coco_url\": str,\n\t\"date_captured\": datetime, \n}\n```\n\n其中的`annotation`是最重要的标注信息，包括序号，所属图像序号，类别序号等等信息，如下所示：\n\n```json\nannotation{\n\t\"id\": int, //标注id\n\t\"image_id\": int, //所属图像id\n\t\"category_id\": int, //类别id\n\t\"segmentation\": RLE or [polygon], //图像分割标注\n\t\"area\": float, //区域面积\n\t\"bbox\": [x,y,width,height], //目标框左上角坐标以及宽高\n\t\"iscrowd\": 0 or 1, //是否密集\n}\n```\n\n其中的`category`代表类别信息，包括父类别，类别序号以及类别名称，如下所示：\n\n```json\ncategory{\n\t\"id\": int, //类别序号\n\t\"name\": str, //类别名称\n\t\"supercategory\": str, //父类别\n}\n```\n\n其中的`license`代表数据集的协议许可信息，包括序号，协议名称以及链接信息，如下所示：\n\n```json\n//对于训练，不重要\nlicense{\n\t\"id\": int, \n\t\"name\": str, \n\t\"url\": str,\n}\n```\n\n接下来，我们来看一个简单的示例：\n\n```json\n{\n\"info\": {略}, \"images\": [{\"id\": 1, \"file_name\": \"1.jpg\", \"height\": 334, \"width\": 500}, {\"id\": 2, \"file_name\": \"2.jpg\", \"height\": 445, \"width\": 556}], \"annotations\": [{\"id\": 1, \"area\": 40448, \"iscrowd\": 0, \"image_id\": 1, \"bbox\": [246, 61, 128, 316], \"category_id\": 3, \"segmentation\": []}, {\"id\": 2, \"area\": 40448, \"iscrowd\": 0, \"image_id\": 1, \"bbox\": [246, 61, 128, 316], \"category_id\": 2, \"segmentation\": []}, {\"id\": 3, \"area\": 40448, \"iscrowd\": 0, \"image_id\": 2, \"bbox\": [246, 61, 128, 316], \"category_id\": 1, \"segmentation\": []}], \"categories\": [{\"supercategory\": \"none\", \"id\": 1, \"name\": \"liner\"},{\"supercategory\": \"none\", \"id\": 2, \"name\": \"containership\"},{\"supercategory\": \"none\", \"id\": 3, \"name\": \"bulkcarrier\"}], \"licenses\": [{略}]\n}\n```\n\n## 1.2 COCO转换脚本\n\n`Python转换脚本`如下所示，需要准备`图像`和`xml`标注文件：\n\n```python\n# -*- coding: utf-8 -*-\n# @Author    : justlovesmile\n# @Date      : 2021/9/8 15:36\nimport os, random, json\nimport shutil as sh\nfrom tqdm.auto import tqdm\nimport xml.etree.ElementTree as xmlET\n\ndef mkdir(path):\n    if not os.path.exists(path):\n        os.makedirs(path)\n        return True\n    else:\n        print(f\"The path ({path}) already exists.\")\n        return False\n\ndef readxml(file):\n    tree = xmlET.parse(file)\n    #图片尺寸字段\n    size = tree.find('size')\n    width = int(size.find('width').text)\n    height = int(size.find('height').text)\n    #目标字段\n    objs = tree.findall('object')\n    bndbox = []\n    for obj in objs:\n        label = obj.find(\"name\").text\n        bnd = obj.find(\"bndbox\")\n        xmin = int(bnd.find(\"xmin\").text)\n        ymin = int(bnd.find(\"ymin\").text)\n        xmax = int(bnd.find(\"xmax\").text)\n        ymax = int(bnd.find(\"ymax\").text)\n        bbox = [xmin, ymin, xmax, ymax, label]\n        bndbox.append(bbox)\n    return [[width, height], bndbox]\n\ndef tococo(xml_root, image_root, output_root,classes={},errorId=[],train_percent=0.9):\n    # assert\n    assert train_percent<=1 and len(classes)>0\n    # define the root path\n    train_root = os.path.join(output_root, \"train2017\")\n    val_root = os.path.join(output_root, \"val2017\")\n    ann_root = os.path.join(output_root, \"annotations\")\n    # initialize train and val dict\n    train_content = {\n        \"images\": [],  # {\"file_name\": \"09780.jpg\", \"height\": 334, \"width\": 500, \"id\": 9780}\n        \"annotations\": [],# {\"area\": 40448, \"iscrowd\": 0, \"image_id\": 1, \"bbox\": [246, 61, 128, 316], \"category_id\": 5, \"id\": 1, \"segmentation\": []}\n        \"categories\": []  # {\"supercategory\": \"none\", \"id\": 1, \"name\": \"liner\"}\n    }\n    val_content = {\n        \"images\": [],  # {\"file_name\": \"09780.jpg\", \"height\": 334, \"width\": 500, \"id\": 9780}\n        \"annotations\": [],# {\"area\": 40448, \"iscrowd\": 0, \"image_id\": 1, \"bbox\": [246, 61, 128, 316], \"category_id\": 5, \"id\": 1, \"segmentation\": []}\n        \"categories\": []  # {\"supercategory\": \"none\", \"id\": 1, \"name\": \"liner\"}\n    }\n    train_json = 'instances_train2017.json'\n    val_json = 'instances_val2017.json'\n    # divide the trainset and valset\n    images = os.listdir(image_root)\n    total_num = len(images)\n    train_percent = train_percent\n    train_num = int(total_num * train_percent)\n    train_file = sorted(random.sample(images, train_num))\n    if mkdir(output_root):\n        if mkdir(train_root) and mkdir(val_root) and mkdir(ann_root):\n            idx1, idx2, dx1, dx2 = 0, 0, 0, 0\n            for file in tqdm(images):\n                name=os.path.splitext(os.path.basename(file))[0]\n                if name not in errorId:\n                    res = readxml(os.path.join(xml_root, name + '.xml'))\n                    if file in train_file:\n                        idx1 += 1\n                        sh.copy(os.path.join(image_root, file), train_root)\n                        train_content['images'].append(\n                            {\"file_name\": file, \"width\": res[0][0], \"height\": res[0][1], \"id\": idx1})\n                        for b in res[1]:\n                            dx1 += 1\n                            x = b[0]\n                            y = b[1]\n                            w = b[2] - b[0]\n                            h = b[3] - b[1]\n                            train_content['annotations'].append(\n                                {\"area\": w * h, \"iscrowd\": 0, \"image_id\": idx1, \"bbox\": [x, y, w, h],\n                                 \"category_id\": classes[b[4]], \"id\": dx1, \"segmentation\": []})\n                    else:\n                        idx2 += 1\n                        sh.copy(os.path.join(image_root, file), val_root)\n                        val_content['images'].append(\n                            {\"file_name\": file, \"width\": res[0][0], \"height\": res[0][1], \"id\": idx2})\n                        for b in res[1]:\n                            dx2 += 1\n                            x = b[0]\n                            y = b[1]\n                            w = b[2] - b[0]\n                            h = b[3] - b[1]\n                            val_content['annotations'].append(\n                                {\"area\": w * h, \"iscrowd\": 0, \"image_id\": idx2, \"bbox\": [x, y, w, h],\n                                 \"category_id\": classes[b[4]], \"id\": dx2, \"segmentation\": []})\n            for i, j in classes.items():\n                train_content['categories'].append({\"supercategory\": \"none\", \"id\": j, \"name\": i})\n                val_content['categories'].append({\"supercategory\": \"none\", \"id\": j, \"name\": i})\n            with open(os.path.join(ann_root, train_json), 'w') as f:\n                json.dump(train_content, f)\n            with open(os.path.join(ann_root, val_json), 'w') as f:\n                json.dump(val_content, f)\n    print(\"Number of Train Images:\", len(os.listdir(train_root)))\n    print(\"Number of Val Images:\", len(os.listdir(val_root)))\n    \n    \ndef test():\n    box_root = \"E:/MyProject/Dataset/hwtest/annotations\" #xml文件夹\n    image_root = \"E:/MyProject/Dataset/hwtest/images\" #image文件夹\n    output_root = \"E:/MyProject/Dataset/coco\" #输出文件夹\n    classes = {\"liner\": 0,\"bulk carrier\": 1,\"warship\": 2,\"sailboat\": 3,\"canoe\": 4,\"container ship\": 5,\"fishing boat\": 6} #类别字典\n    errorId = [] #脏数据id\n    train_percent = 0.9 #训练集和验证集比例\n    tococo(box_root, image_root, output_root,classes=classes,errorId=errorId,train_percent=train_percent)\n\nif __name__ == \"__main__\":\n    test()\n```\n\n# 2. VOC\n\n## 2.1 VOC数据集格式\n\nVOC（Visual Object Classes）数据集来源于PASCAL VOC挑战赛，其主要任务有`Object Classification` 、`Object Detection`、`Object Segmentation`、`Human Layout`、`Action Classification`。其官网为[The PASCAL Visual Object Classes Homepage (ox.ac.uk)](http://host.robots.ox.ac.uk/pascal/VOC/)。其主要数据集有VOC2007以及VOC2012。\n\n![image-20210911193933398](https://unpkg.com/justlovesmile-img/202109111939729.png)\n\nVOC数据集主要包含图像（jpg或者png等等）和标注文件（xml），其数据集格式如下(`/`代表文件夹)：\n\n```txt\n-VOC/\n\t|-JPEGImages/\n\t\t|-1.jpg\n\t\t|-2.jpg\n\t|-Annotations/\n\t\t|-1.xml\n\t\t|-2.xml\n\t|-ImageSets/\n\t\t|-Layout/\n\t\t\t|-*.txt\n\t\t|-Main/\n\t\t\t|-train.txt\n\t\t\t|-val.txt\n\t\t\t|-trainval.txt\n\t\t\t|-test.txt\n\t\t|-Segmentation/\n\t\t\t|-*.txt\n\t\t|-Action/\n\t\t\t|-*.txt\n\t|-SegmentationClass/\n\t|-SegmentationObject/\n```\n\n其中对于目标检测任务而言，最常用的以及必须的文件夹包括：`JPEGImages`，`Annotations`，`ImageSets/Main`。\n\n`JPEGImages`里存放的是图像，而`Annotations`里存放的是`xml`标注文件，文件内容如下：\n\n```txt\n<annotation>\n\t<folder>VOC</folder>            # 图像所在文件夹\n\t<filename>000032.jpg</filename> # 图像文件名\n\t<source>                        # 图像源\n\t\t<database>The VOC Database</database>\n\t\t<annotation>PASCAL VOC</annotation>\n\t\t<image>flickr</image>\n\t</source>\n\t<size>                          # 图像尺寸信息\n\t\t<width>500</width>    # 图像宽度\n\t\t<height>281</height>  # 图像高度\n\t\t<depth>3</depth>      # 图像通道数\n\t</size>\n\t<segmented>0</segmented>  # 图像是否用于分割，0代表不适用，对目标检测而言没关系\n\t<object>                  # 一个目标对象的信息\n\t\t<name>aeroplane</name>    # 目标的类别名\n\t\t<pose>Frontal</pose>      # 拍摄角度，若无一般为Unspecified\n\t\t<truncated>0</truncated>  # 是否被截断，0表示完整未截断\n\t\t<difficult>0</difficult>  # 是否难以识别，0表示不难识别\n\t\t<bndbox>            # 边界框信息\n\t\t\t<xmin>104</xmin>  # 左上角x\n\t\t\t<ymin>78</ymin>   # 左上角y\n\t\t\t<xmax>375</xmax>  # 右下角x\n\t\t\t<ymax>183</ymax>  # 右下角y\n\t\t</bndbox>\n\t</object>\n    # 下面是其他目标的信息，这里略掉\n\t<object>\n        其他object信息，这里省略\n\t</object>\n</annotation>\n```\n\n## 2.2 VOC转换脚本\n\n下面这个脚本，只适用于有图像和xml文件的情况下，coco转voc格式以后有需要再写：\n\n```python\n# -*- coding: utf-8 -*-\n# @Author    : justlovesmile\n# @Date      : 2021/9/8 21:01\nimport os,random\nfrom tqdm.auto import tqdm\nimport shutil as sh\n\ndef mkdir(path):\n    if not os.path.exists(path):\n        os.mkdir(path)\n        return True\n    else:\n        print(f\"The path ({path}) already exists.\")\n        return False\n\ndef tovoc(xmlroot,imgroot,saveroot,errorId=[],classes={},tvp=1.0,trp=0.9):\n    '''\n    参数：\n        root：数据集存放根目录\n    功能：\n        加载数据，并保存为VOC格式\n    加载后的格式：\n    VOC/\n      Annotations/\n        - **.xml\n      JPEGImages/\n        - **.jpg\n      ImageSets/\n        Main/\n          - train.txt\n          - test.txt\n          - val.txt\n          - trainval.txt\n    '''\n    # assert\n    assert len(classes)>0\n    # init path\n    VOC = saveroot\n    ann_path = os.path.join(VOC, 'Annotations')\n    img_path = os.path.join(VOC,'JPEGImages')\n    set_path = os.path.join(VOC,'ImageSets')\n    txt_path = os.path.join(set_path,'Main')\n    # mkdirs \n    if mkdir(VOC):\n        if mkdir(ann_path) and mkdir(img_path) and mkdir(set_path):\n            mkdir(txt_path)\n\n    images = os.listdir(imgroot)\n    list_index = range(len(images))\n    #test and trainval set\n    trainval_percent = tvp\n    train_percent = trp\n    val_percent = 1 - train_percent if train_percent<1 else 0.1\n    total_num = len(images)\n    trainval_num = int(total_num*trainval_percent)\n    train_num = int(trainval_num*train_percent)\n    val_num = int(trainval_num*val_percent) if train_percent<1 else 0\n\n    trainval = random.sample(list_index,trainval_num)\n    train = random.sample(list_index,train_num)\n    val = random.sample(list_index,val_num)\n    \n    for i in tqdm(list_index):\n        imgfile = images[i]\n        img_id = os.path.splitext(os.path.basename(imgfile))[0]\n        xmlfile = img_id+\".xml\"\n        sh.copy(os.path.join(imgroot,imgfile),os.path.join(img_path,imgfile))\n        sh.copy(os.path.join(xmlroot,xmlfile),os.path.join(ann_path,xmlfile))\n        if img_id not in errorId:\n            if i in trainval:\n                with open(os.path.join(txt_path,'trainval.txt'),'a') as f:\n                    f.write(img_id+'\\n')\n                if i in train:\n                    with open(os.path.join(txt_path,'train.txt'),'a') as f:\n                        f.write(img_id+'\\n')\n                else:\n                    with open(os.path.join(txt_path,'val.txt'),'a') as f:\n                        f.write(img_id+'\\n')\n                if train_percent==1 and i in val:\n                    with open(os.path.join(txt_path,'val.txt'),'a') as f:\n                        f.write(img_id+'\\n')          \n            else:\n                with open(os.path.join(txt_path,'test.txt'),'a') as f:\n                    f.write(img_id+'\\n')\n    \n    # end\n    print(\"Dataset to VOC format finished!\")\n\ndef test():\n    box_root = \"E:/MyProject/Dataset/hwtest/annotations\"\n    image_root = \"E:/MyProject/Dataset/hwtest/images\"\n    output_root = \"E:/MyProject/Dataset/voc\"\n    classes = {\"liner\": 0,\"bulk carrier\": 1,\"warship\": 2,\"sailboat\": 3,\"canoe\": 4,\"container ship\": 5,\"fishing boat\": 6}\n    errorId = []\n    train_percent = 0.9\n    tovoc(box_root,image_root,output_root,errorId,classes,trp=train_percent)\n\nif __name__ == \"__main__\":\n    test()\n```\n\n# 3. YOLO\n\n## 3.1 YOLO数据集格式\n\n`YOLO`数据集格式的出现主要是为了训练`YOLO`模型，其文件格式没有固定的要求，因为可以通过修改模型的配置文件进行数据加载，唯一需要注意的是`YOLO`数据集的标注格式是将目标框的位置信息进行归一化处理（此处归一化指的是除以图片宽和高），如下所示：\n\n```txt\n{目标类别} {归一化后的目标中心点x坐标} {归一化后的目标中心点y坐标} {归一化后的目标框宽度w} {归一化后的目标框高度h}\n```\n\n## 3.2 YOLO转换脚本\n\n`Python`转换脚本如下所示：\n\n```python\n# -*- coding: utf-8 -*-\n# @Author    : justlovesmile\n# @Date      : 2021/9/8 20:28\nimport os\nimport random\nfrom tqdm.auto import tqdm\nimport shutil as sh\ntry:\n    import xml.etree.cElementTree as et\nexcept ImportError:\n    import xml.etree.ElementTree as et\n\ndef mkdir(path):\n    if not os.path.exists(path):\n        os.makedirs(path)\n        return True\n    else:\n        print(f\"The path ({path}) already exists.\")\n        return False  \n\ndef xml2yolo(xmlpath,savepath,classes={}):\n    namemap = classes\n    #try:\n    #    with open('classes_yolo.json','r') as f:\n    #        namemap=json.load(f)\n    #except:\n    #    pass\n    rt = et.parse(xmlpath).getroot()\n    w = int(rt.find(\"size\").find(\"width\").text)\n    h = int(rt.find(\"size\").find(\"height\").text)\n    with open(savepath, \"w\") as f:\n        for obj in rt.findall(\"object\"):\n            name = obj.find(\"name\").text\n            xmin = int(obj.find(\"bndbox\").find(\"xmin\").text)\n            ymin = int(obj.find(\"bndbox\").find(\"ymin\").text)\n            xmax = int(obj.find(\"bndbox\").find(\"xmax\").text)\n            ymax = int(obj.find(\"bndbox\").find(\"ymax\").text)\n            f.write(\n                f\"{namemap[name]} {(xmin+xmax)/w/2.} {(ymin+ymax)/h/2.} {(xmax-xmin)/w} {(ymax-ymin)/h}\"\n                + \"\\n\"\n            )\n\ndef trainval(xmlroot,imgroot,saveroot,errorId=[],classes={},tvp=1.0,trp=0.9):\n    # assert\n    assert tvp<=1.0 and trp <=1.0 and len(classes)>0\n    # create dirs\n    imglabel = ['images','labels']\n    trainvaltest = ['train','val','test']\n    mkdir(saveroot)\n    for r in imglabel:\n        mkdir(os.path.join(saveroot,r))\n        for s in trainvaltest:\n            mkdir(os.path.join(saveroot,r,s))\n    #train / val\n    trainval_percent = tvp\n    train_percent = trp\n    val_percent = 1 - train_percent if train_percent<1.0 else 0.15\n    \n    total_img = os.listdir(imgroot)\n    num = len(total_img)\n    list_index = range(num)\n    tv = int(num * trainval_percent)\n    tr = int(tv * train_percent)\n    va = int(tv * val_percent)\n    trainval = random.sample(list_index, tv) # trainset and valset\n    train = random.sample(trainval, tr) # trainset\n    val = random.sample(trainval, va) #valset, use it only when train_percent = 1 \n\n    print(f\"trainval_percent:{trainval_percent},train_percent:{train_percent},val_percent:{val_percent}\")\n    for i in tqdm(list_index):\n        name = total_img[i]\n        op = os.path.join(imgroot,name)\n        file_id = os.path.splitext(os.path.basename(name))[0]\n        if file_id not in errorId:\n            xmlp = os.path.join(xmlroot,file_id+'.xml')\n            if i in trainval:\n                # trainset and valset\n                if i in train:\n                    sp = os.path.join(saveroot,\"images\",\"train\",name)\n                    xml2yolo(xmlp,os.path.join(saveroot,\"labels\",\"train\",file_id+'.txt'),classes)\n                    sh.copy(op,sp)\n                else:\n                    sp = os.path.join(saveroot,\"images\",\"val\",name)\n                    xml2yolo(xmlp,os.path.join(saveroot,\"labels\",\"val\",file_id+'.txt'),classes)\n                    sh.copy(op,sp)\n                if (train_percent==1.0 and i in val):\n                    sp = os.path.join(saveroot,\"images\",\"val\",name)\n                    xml2yolo(xmlp,os.path.join(saveroot,\"labels\",\"val\",file_id+'.txt'),classes)\n                    sh.copy(op,sp)\n            else:\n                # testset\n                sp = os.path.join(saveroot,\"images\",\"test\",name)\n                xml2yolo(xmlp,os.path.join(saveroot,\"labels\",\"test\",file_id+'.txt'),classes)\n                sh.copy(op,sp)\n\ndef maketxt(dir,saveroot,filename):\n    savetxt = os.path.join(saveroot,filename)\n    with open(savetxt,'w') as f:\n        for i in tqdm(os.listdir(dir)):\n            f.write(os.path.join(dir,i)+'\\n')\n                           \ndef toyolo(xmlroot,imgroot,saveroot,errorId=[],classes={},tvp=1,train_percent=0.9):\n    # toyolo main function\n    trainval(xmlroot,imgroot,saveroot,errorId,classes,tvp,train_percent)\n    maketxt(os.path.join(saveroot,\"images\",\"train\"),saveroot,\"train.txt\")\n    maketxt(os.path.join(saveroot,\"images\",\"val\"),saveroot,\"val.txt\")\n    maketxt(os.path.join(saveroot,\"images\",\"test\"),saveroot,\"test.txt\")\n    print(\"Dataset to yolo format success.\")\n\ndef test():\n    box_root = \"E:/MyProject/Dataset/hwtest/annotations\"\n    image_root = \"E:/MyProject/Dataset/hwtest/images\"\n    output_root = \"E:/MyProject/Dataset/yolo\"\n    classes = {\"liner\": 0,\"bulk carrier\": 1,\"warship\": 2,\"sailboat\": 3,\"canoe\": 4,\"container ship\": 5,\"fishing boat\": 6}\n    errorId = []\n    train_percent = 0.9\n    toyolo(box_root,image_root,output_root,errorId,classes,train_percent=train_percent)\n\nif __name__ == \"__main__\":\n    test()\n```\n\n按照此脚本，将会在输出文件夹中生成以下内容：\n\n```txt\n-yolo/\n\t|-images/\n\t\t|-train/\n\t\t\t|-1.jpg\n\t\t\t|-2.jpg\n\t\t|-test/\n\t\t\t|-3.jpg\n\t\t\t|-4.jpg\n\t\t|-val/\n\t\t\t|-5.jpg\n\t\t\t|-6.jpg\n\t|-labels/\n\t\t|-train/\n\t\t\t|-1.txt\n\t\t\t|-2.txt\n\t\t|-test/\n\t\t\t|-3.txt\n\t\t\t|-4.txt\n\t\t|-val/\n\t\t\t|-5.txt\n\t\t\t|-6.txt\n\t|-train.txt\n\t|-test.txt\n\t|-val.txt\n```\n\n","tags":["深度学习","目标检测","Python"],"categories":["代码编程"]},{"title":"Hexo博客 | 动态分类标签条，自动获取全站分类与标签进行展示","slug":"博客相关-Hexo博客之动态分类标签条","url":"/posts/2bfb1caa.html","content":"\n# 1. 前言\n本文是对Heo博主写的[Butterfly魔改：动态分类条，可以根据页面变化而改变的分类列表展示方式](https://blog.zhheo.com/p/bc61964d.html)文章的补充，增加了动态标签条，并且可以自动获取全站分类和标签名称。\n\n# 2. 预览\n\n![image-20210814211626863](https://unpkg.com/justlovesmile-img/202108142116064.png)\n\n![image-20210814212127747](https://unpkg.com/justlovesmile-img/202108142121159.png)\n\n# 3. 配置\n\n## 3.1 新建PUG文件\n\n首先是分类条，在`themes/butterfly/layout/includes/`处新建文件`categoryBar.pug`\n\n```pug\n#category-bar\n  .category-bar-items#category-bar-items\n    !=getarray_bar(\"category\")\n  a.category-bar-more(href=\"/categories/\") 更多\n```\n\n其次是标签条，在`themes/butterfly/layout/includes/`处新建文件`tagBar.pug`，因为样式一样，所以没有更改id和class名称。\n\n```pug\n#category-bar\n  .category-bar-items#category-bar-items\n    !=getarray_bar(\"tag\")\n  a.category-bar-more(href=\"/tags/\") 更多\n```\n\n## 3.2 新建Hexo辅助函数\n\n在`theme/butterfly/scripts/helpers/`中创建`get_arrays.js`\n\n```javascript\nhexo.extend.helper.register('getarray_bar', function (types) {\n  if (!types) {\n    types = \"category\"\n  }\n  const categoriesBar = function (categories) {\n    if (!categories || !categories.length) return ``\n    const categoryArr = []\n    hexo.locals.get('categories').map(function (category) {\n      categoryArr.push({ name: category.name, value: category.length })\n    })\n    categoryArr.sort((a, b) => { return b.value - a.value })\n    let strCategoriesBar = ``\n    for (let i = 0; i < categories.length; i++) {\n      strTemp=`\n      <div class=\"category-bar-item\" id=\"${categoryArr[i].name}\">\n      <a href=\"/categories/${categoryArr[i].name}/\">${categoryArr[i].name}</a>\n      </div>`\n      strCategoriesBar+=strTemp\n    }\n    return strCategoriesBar\n  }\n  const tagsBar = function(tags) {\n    if (!tags || !tags.length) return ``\n    const tagArr = []\n    hexo.locals.get('tags').map(function (tag) {\n      tagArr.push({ name: tag.name, value: tag.length })\n    })\n    tagArr.sort((a, b) => { return b.value - a.value })\n    let strTagsBar = ``\n    for (let i = 0; i < tags.length; i++) {\n      strTemp=`\n      <div class=\"category-bar-item\" id=\"${tagArr[i].name}\">\n      <a href=\"/tags/${tagArr[i].name}/\">${tagArr[i].name}</a>\n      </div>`\n      strTagsBar+=strTemp\n    }\n    return strTagsBar\n  }\n  if (types == \"category\"){\n    return categoriesBar(this.site.categories)\n  }\n  if (types == \"tag\"){\n    return tagsBar(this.site.tags)\n  }\n})\n```\n\n## 3.3 引用模块\n\n在需要的位置引用该模块，例如：\n\n在分类页面引用：找到`theme/butterfly/layout/category.pug`\n\n```pug\nextends includes/layout.pug\n\nblock content\n  if theme.category_ui == 'index'\n    include ./includes/mixins/post-ui.pug\n    #recent-posts.recent-posts.category_ui   \n      +postUI\n      include includes/pagination.pug    \n  else\n    include ./includes/mixins/article-sort.pug\n    #category\n+      .category-in-bar\n+        .category-in-bar-tips\n+          i.fa-fw.fas.fa-folder-open\n+        include includes/categoryBar.pug\n      .article-sort-title= _p('page.category') + ' - ' + page.category\n      +articleSort(page.posts)\n      include includes/pagination.pug\n```\n\n在标签页引用：找到`theme/butterfly/layout/tag.pug`\n\n```pug\nextends includes/layout.pug\n\nblock content\n  if theme.tag_ui == 'index'\n    include ./includes/mixins/post-ui.pug\n    #recent-posts.recent-posts\n      +postUI\n      include includes/pagination.pug\n  else\n    include ./includes/mixins/article-sort.pug\n    #tag\n+      .category-in-bar\n+        .category-in-bar-tips\n+          i.fa-fw.fas.fa-tags\n+        include includes/tagBar.pug\n      .article-sort-title= _p('page.tag') + ' - ' + page.tag\n      +articleSort(page.posts)\n      include includes/pagination.pug\n```\n\n# 4. 引入js和css文件\n\n这一部分和Heo博主的教程[Butterfly魔改：动态分类条，可以根据页面变化而改变的分类列表展示方式 | 张洪Heo (zhheo.com)](https://blog.zhheo.com/p/bc61964d.html)一致。\n\n不过如果添加了标签条，js文件需要增加一个函数\n\n```javascript\n//标签条\nfunction tagsBarActive(){\n  var urlinfo = window.location.pathname;\n  urlinfo = decodeURIComponent(urlinfo)\n  //console.log(urlinfo);\n  //判断是否是首页\n  if (urlinfo == '/'){\n    if (document.querySelector('#tags-bar')){\n      document.getElementById('首页').classList.add(\"select\")\n    }\n  }else {\n    // 验证是否是分类链接\n    var pattern = /\\/tags\\/.*?\\//;\n    var patbool = pattern.test(urlinfo);\n    //console.log(patbool);\n    // 获取当前的标签\n    if (patbool) {\n      var valuegroup = urlinfo.split(\"/\");\n      //console.log(valuegroup[2]);\n      // 获取当前分类\n      var nowTag = valuegroup[2];\n      if (document.querySelector('#category-bar')){\n        document.getElementById(nowTag).classList.add(\"select\");\n      }\n    }\n  } \n}\ntagsBarActive()\n```\n\n","tags":["Hexo","前端","JS"],"categories":["博客相关"]},{"title":"Hexo博客 | 如何让你的博客拥有星空背景和流星特效","slug":"博客相关-Hexo博客美化之星空背景","url":"/posts/6a260bf6.html","content":"\n最近很多小伙伴留言想要`星空和流星特效`，于是写了这篇文章准备介绍如何部署。\n\n> ![](https://unpkg.com/justlovesmile-img/202108121834269.gif)\n\n## 1. 插入Canvas标签\n\n首先打开Butterfly主题的`_config.yml`文件或者使用HTML直接插入，找到配置文件对应的`inject`部分，插入`<canvas id=\"universe\"></canvas>`\n\n![image-20210812175952760](https://unpkg.com/justlovesmile-img/202108121759902.png)\n\n## 2. 创建JS文件\n\n在`butterfly/source/js/`创建一个`universe.js`文件，或者添加到自己的`js`文件中\n\n```javascript\nfunction dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById(\"universe\"),o=!0,a=\"180,184,240\",r=\"226,225,142\",d=\"226,225,224\",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute(\"width\",n),s.setAttribute(\"height\",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle=\"rgba(\"+a+\",\"+this.opacity+\")\",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle=\"rgba(\"+d+\",\"+this.opacity+\")\",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle=\"rgba(\"+d+\",\"+(this.opacity-this.opacity/20*t)+\")\",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle=\"rgba(\"+r+\",\"+this.opacity+\")\",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener(\"resize\",f,!1),function(){h=s.getContext(\"2d\");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};\ndark()\n```\n\n![image-20210812182203080](https://unpkg.com/justlovesmile-img/202108121822274.png)\n\n代码的这一部分要求`data-theme`也就是主题为`dark`暗色主题，因此仅在暗色主题生效，随后将`js`文件添加到配置文件的`inject`处或者其他需要的位置。\n\n## 3. CSS样式\n\n```css\n/* 背景宇宙星光  */\n#universe{\n  display: block;\n  position: fixed;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: -1;\n}\n```\n\n","tags":["Hexo","前端","JS"],"categories":["博客相关"]},{"title":"iOS快捷指令 | iPicGo，随时随地用手机上传图片到图床","slug":"折腾记录-iOS快捷指令版PicGo","url":"/posts/223c1a0c.html","content":"\n# iOS快捷指令版PicGo\n\n> 功能：**上传手机图片到Github，并将其在jsdelivr的CDN图片链接复制到剪切板。**\n>\n> 当然我主要是为了方便发图片链接到[哔哔](/essay/)😀。哔哔来自[木木木木木](https://immmmm.com/bb-by-wechat-pro/)，iOS[哔哔发射](https://www.icloud.com/shortcuts/8e9e01fd2fc14124b1a7cf43a5ea64bd)捷径来自[Heo](https://blog.zhheo.com/p/27be0e44.html)\n\n![image-20210326105717200](https://unpkg.com/justlovesmile-img/20210326105717.png)\n\n## 1. 申请github的personal access token\n\n点击Settings-Developer settings-Personal access tokens-Generate new token-取个名字勾选repo-复制token（!!!）即可获得token\n\n![image-20210326132347250](https://unpkg.com/justlovesmile-img/20210326132347.png)\n\n![image-20210326132516102](https://unpkg.com/justlovesmile-img/20210326132516.png)\n\n![image-20210326132545789](https://unpkg.com/justlovesmile-img/20210326132545.png)\n\n## 2. 使用iOS 的iPicGo捷径\n\n使用手机Safari浏览器打开[快捷指令链接](https://www.icloud.com/shortcuts/7c950e63f0ff4533b125253705e18f7c)，修改第一块`词典`里面的参数。\n\n![06B2762F01E8C962472455EBA7B39F19](https://unpkg.com/justlovesmile-img/20210326130845.png)\n\n其中参数如下：\n\n```json\n{\n    'name': github的用户名,\n    'repo': github图床的仓库名,\n    'path': 你想要上传的子路径名，例如：image或者image/pic，首尾无斜杠,\n    'token': 申请到的github personal access token\n}\n```\n\n其中path部分默认是有子路径的，因为我有😀，所以没有增加判断...可以自行修改url链接，如下图所示URL部分：\n\n![image-20210326131817492](https://unpkg.com/justlovesmile-img/20210326131817.png)\n\n修改完成后即可实现手机图片上传到github的功能。\n\n## 3. 使用iPicGo和哔哔发射\n\n所以现在，我就可以先使用iPicGo捷径上传到github图床，然后捷径会自动返回图片链接到剪切板，再打开哔哔发射，粘贴图片链接，就可以方便哔哔了。当然，木木大佬的哔哔点啥公众号也可以发图片😂。\n\nGif演示：\n\n![20201105174303](https://unpkg.com/justlovesmile-img/20210326134511.gif)\n\n<style>\n    img{max-height: 450px;}\n</style>","tags":["iOS","捷径"],"categories":["折腾记录"]},{"title":"深度学习 | GAN，什么是生成对抗网络","slug":"人工智能-GAN学习笔记","url":"/posts/6a054795.html","content":"\n# GAN学习笔记\n\n## 1. GAN原理\n\n论文链接：[Generative Adversarial Networks](https://arxiv.org/abs/1406.2661)\n\n>生成式对抗网络(GAN, Generative Adversarial Networks)是一种深度学习模型，是近年来复杂分布上无监督学习最具前景的方法之一。模型通过框架中（至少）两个模块：生成模型（Generative Model）和判别模型（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN 理论中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。一个优秀的GAN应用需要有良好的训练方法，否则可能由于神经网络模型的自由性而导致输出不理想。  \nIan J. Goodfellow等人于2014年10月在[Generative Adversarial Networks](https://arxiv.org/abs/1406.2661)中提出了一个通过对抗过程估计生成模型的新框架。框架中同时训练两个模型：捕获数据分布的生成模型G，和估计样本来自训练数据的概率的判别模型D。G的训练程序是将D错误的概率最大化。这个框架对应一个最大值集下限的双方对抗游戏。可以证明在任意函数G和D的空间中，存在唯一的解决方案，使得G重现训练数据分布，而D=0.5。在G和D由多层感知器定义的情况下，整个系统可以用反向传播进行训练。在训练或生成样本期间，不需要任何马尔科夫链或展开的近似推理网络。实验通过对生成的样品的定性和定量评估证明了本框架的潜力。\n  ---- 摘自[百度百科](https://baike.baidu.com/item/Gan/22181905?fr=aladdin)\n\nGAN是由两部分组成的，第一部分是生成，第二部分是对抗。简单来说，就是有一个生成网络G和一个判别网络D，通过训练让两个网络相互竞争，生成网络G接受一个随机噪声z来生成假的数据G(z)，对抗网络D通过判别器去判别真伪概率，最后希望生成器G生成的数据能够以假乱真。在最理想的状态下，D(G(z)) = 0.5。\n\n以上原理的数学公式为：\n\n$$ min_{G}max_{D}V(D,G) = \\mathbb{E} _ {x \\sim p_{data}(x)} [\\log D(x)] + \\mathbb{E} _ {z \\sim p_{z}(z) [\\log (1-D(G(z)))]} $$\n\n式子中，x表示真实数据，z表示噪声，G(z)表示G网络根据z生成的数据，D(x)表示D网络判断真实数据是否为真的概率，因此D(x)接近1越好。而D(G(z))代表D网络判断G网络生成的虚假数据是真实的概率。\n因此，对于D网络(辨别器)：\n- 如果x来自$P_{data}$，那么D(x)要越大越好，可以用$\\log(D(x)) \\uparrow$表示。\n- 如果x来自于$P_{generator}$，那么D(G(z))越小越好，进而表示为$\\log[1−D(G(z))] \\uparrow$。\n- 因此需要最大化$max_D$\n对于G网络(生成器)：\n- $D(G(z))$越大越好，进而表示为log[1−D(G(z))]↓\n- 因此需要最小化$min_{G}$。\n\n![](https://unpkg.com/justlovesmile-img/20210223180633.png)\n\n第一步我们训练D，D是希望V(D,G)越大越好，所以是加上梯度(ascending)。第二步训练G时，V(D,G)越小越好，所以是减去梯度(descending)。整个训练过程交替进行。\n\n## 2. GAN实例\n\n\n```python\nimport torch\nfrom torch import nn,optim\nimport torchvision.transforms as tfs\n\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nfrom tqdm.auto import tqdm\n\ntransforms = tfs.Compose([\n    tfs.Resize((32,32)),\n    tfs.ToTensor(),\n    #tfs.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])\n])\n\nflat_img = 32*32*3\nnoise_dim = 100\n\nimg = Image.open('1.jpg')\nreal_img = transforms(img)\n\ntorch.manual_seed(2)\nfake_img = torch.rand(1,noise_dim)\n\nplt.imshow(np.transpose(real_img.numpy(),(1,2,0)))\n#print(real_img)\n```\n\n![](https://unpkg.com/justlovesmile-img/20210224172221.png)\n\n\n```python\nclass Discriminator(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear = nn.Sequential(\n            nn.Linear(flat_img, 1024),\n            nn.ReLU(),\n            nn.Linear(1024, 2048),\n            nn.ReLU(),\n            nn.Linear(2048, 1),\n            nn.Sigmoid() #sigmoid常用于二分类问题\n        )\n\n    def forward(self, img):\n        img = img.view(1, -1)\n        out = self.linear(img)\n        return out\n```\n\n\n```python\nclass Generator(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear = nn.Sequential(\n            nn.Linear(noise_dim, 1024),\n            nn.LeakyReLU(),\n            nn.Linear(1024, 2048),\n            nn.LeakyReLU(),\n            nn.Linear(2048, flat_img)\n        )\n\n    def forward(self, latent_space):\n        latent_space = latent_space.view(1, -1)\n        out = self.linear(latent_space)\n        return out\n```\n\n\n```python\ndevice = 'cuda:0' if torch.cuda.is_available() else 'cpu'\n\ndiscr = Discriminator().to(device)\ngen = Generator().to(device)\n\nopt_d = optim.SGD(discr.parameters(), lr=0.001, momentum=0.9)\nopt_g = optim.SGD(gen.parameters(), lr=0.001, momentum=0.9)\n\ncriterion = nn.BCELoss()\n```\n\n\n```python\nepochs = 200\ndiscr_e = 4\ngen_e = 4\n\n#whole model training starts here\nfor epoch in range(epochs):\n\n    #discriminator training\n    for k in range(discr_e):\n        out_d1 = discr(real_img.to(device))\n        #loss for real image\n        loss_d1 = criterion(out_d1, torch.ones((1, 1)).to(device))\n\n        out_d2 = gen(fake_img.to(device)).detach()\n        #loss for fake image\n        loss_d2 = criterion(discr(out_d2.to(device)), torch.zeros((1, 1)).to(device))\n\n        opt_d.zero_grad()\n        loss_d = loss_d1+loss_d2\n        loss_d.backward()\n        opt_d.step()\n\n    #generator training\n    for i in range(gen_e):\n        out_g = gen(fake_img.to(device))\n        #Binary cross entropy loss\n        loss_g = criterion(discr(out_g.to(device)), torch.ones(1, 1).to(device))\n        #Loss function in the GAN paper\n        #[log(1 - D(G(z)))]\n        #loss_g = torch.log(torch.ones(1, 1).to(device) - (discr(out_g.to(device))))\n        \n        opt_g.zero_grad()\n        loss_g.backward()\n        opt_g.step()\n    \n    if (epoch+1)%10==0:\n        print('Epoch[{}/{}],d_loss:{:.6f},g_loss:{:.6f}'.format(epoch+1,epochs,loss_d.data.item(),loss_g.data.item()))\n\nout=gen(fake_img.to(device)).detach()\nout_score=discr(out_g.to(device))\nloss = criterion(out_score, torch.ones(1, 1).to(device))\nprint(\"score:\",out_score.item(),\"loss:\",loss.item())\n\nout=out.reshape((3,32,32)).cpu()\n\n#print(out)\nplt.subplot(1,2,1)\nplt.title('fake')\nplt.imshow(np.transpose(out.numpy(),(1,2,0)))\nplt.subplot(1,2,2)\nplt.title('real')\nplt.imshow(np.transpose(real_img.numpy(),(1,2,0)))\n```\n\n![](https://unpkg.com/justlovesmile-img/20210224183510.png)\n\n## 3. DCGAN原理\n\n[https://arxiv.org/pdf/1511.06434.pdf](https://arxiv.org/pdf/1511.06434.pdf)\n  \nDCGAN的原理和GAN是一样的。只不过DCGANs体系结构有所改变：\n- 使用指定步长的卷积层代替池化层\n- 在生成器和鉴别器中使用batch norm。\n- 移除全连接层，以实现更深层次的体系结构，减少参数。\n- 在生成器中使用ReLU激活，但输出使用Tanh。\n- 在鉴别器中使用LeakyReLU激活\n\n![](https://unpkg.com/justlovesmile-img/20210224183753.png)\n\nDCGAN中提到了网络的训练细节：\n- 使用Adam算法更新参数，betas=(0.5, 0.999)；\n- batch size选为128；\n- 权重使用正太分布，均值为0，标准差为0.02；\n- 学习率0.0002。\n\n## 4. DCGAN实例\n\n生成动漫头像，数据集来自[https://www.kaggle.com/soumikrakshit/anime-faces](https://www.kaggle.com/soumikrakshit/anime-faces)\n\n\n```python\nimport os\nimport numpy as np\nimport imageio\nfrom tqdm.auto import tqdm\nimport torch,torchvision\nimport torch.nn as nn\nfrom torch.utils.data import Dataset, DataLoader\nfrom torchvision import transforms, utils\nimport matplotlib.pyplot as plt\n\navatar_img_path = \"E:/python/dataset/anime face/data\"\n```\n\n\n```python\ntrans = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))\n])\n\nnoise_dim = 100\nbatch_size = 16\nbeta1=0.5\n'''\n#自定义数据集\nfile_train=[]\nfor image_name in tqdm(os.listdir(avatar_img_path)):\n    file_train.append(os.path.join(avatar_img_path,image_name))\n\ndef default_loader(path):\n    img = imageio.imread(path)\n    img = img/255\n    img = trans(img)\n    return img\n\nclass trainset(Dataset):\n    def __init__(self, loader=default_loader):\n    #定义好 image 的路径\n        self.images = file_train\n        self.target = 0\n        self.loader = loader\n\n    def __getitem__(self, index):\n        fn = self.images[index]\n        img = self.loader(fn)\n        target = self.target\n        return img,target\n    \n    def __len__(self):\n        return len(self.images)\n'''\nimg_dataset=torchvision.datasets.ImageFolder(\"E:/python/dataset/anime face\", transform=trans)\n#img_dataset=trainset()\nimg_dataloader=DataLoader(img_dataset,batch_size=batch_size,shuffle=True)\n#print(img_dataset)\n```\n\n\n```python\nclass Generator(nn.Module):\n    def __init__(self, z_dim):\n        super(Generator,self).__init__()\n        self.z_dim = z_dim\n        self.generator = nn.Sequential(\n            nn.ConvTranspose2d(self.z_dim,512,4,1,0,bias=False),\n            nn.BatchNorm2d(num_features=512),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(512,256,4,2,1,bias=False),\n            nn.BatchNorm2d(num_features=256),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(256,128,4,2,1,bias=False),\n            nn.BatchNorm2d(num_features=128),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(128,64,4,2,1,bias=False),\n            nn.BatchNorm2d(num_features=64),\n            nn.ReLU(True),\n            nn.ConvTranspose2d(64,3,4,2,1,bias=False),\n            nn.Tanh()\n        )\n        self.weight_init()\n\n    def weight_init(self):\n        for m in self.generator.modules():\n            if isinstance(m, nn.ConvTranspose2d):\n                nn.init.normal_(m.weight.data, 0, 0.02)\n\n            elif isinstance(m, nn.BatchNorm2d):\n                nn.init.normal_(m.weight.data, 0, 0.02)\n                nn.init.constant_(m.bias.data, 0)\n\n    def forward(self, x):\n        out = self.generator(x)\n        return out\n```\n\n\n```python\nclass Discriminator(nn.Module):\n    def __init__(self):\n        \"\"\"\n        initialize\n        \n        :param image_size: tuple (3, h, w)\n        \"\"\"\n        super(Discriminator,self).__init__()\n        self.discriminator = nn.Sequential(\n            nn.Conv2d(3,64,4,2,1,bias=False),\n            nn.BatchNorm2d(num_features=64),\n            nn.LeakyReLU(0.2),\n            nn.Conv2d(64,128,4,2,1,bias=False),\n            nn.BatchNorm2d(num_features=128),\n            nn.LeakyReLU(0.2),\n            nn.Conv2d(128,256,4,2,1,bias=False),\n            nn.BatchNorm2d(num_features=256),\n            nn.LeakyReLU(0.2),\n            nn.Conv2d(256,512,4,2,1,bias=False),\n            nn.BatchNorm2d(num_features=512),\n            nn.LeakyReLU(0.2),\n            nn.Conv2d(512,1,4,2,0,bias=False),\n            nn.Sigmoid()\n        )\n        self.weight_init()\n\n    def weight_init(self):\n        for m in self.discriminator.modules():\n            if isinstance(m, nn.ConvTranspose2d):\n                nn.init.normal_(m.weight.data, 0, 0.02)\n\n            elif isinstance(m, nn.BatchNorm2d):\n                nn.init.normal_(m.weight.data, 0, 0.02)\n                nn.init.constant_(m.bias.data, 0)\n\n    def forward(self, x):\n        out = self.discriminator(x)\n        out = out.view(x.size(0), -1)\n        return out\n```\n\n\n```python\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available else \"cpu\")\n\ngenerator = Generator(noise_dim).to(device)\ndiscriminator = Discriminator().to(device)\n\nbce_loss = nn.BCELoss()\n#optimizer_D = torch.optim.Adam(discriminator.parameters(), lr=0.0002, betas=(beta1, 0.999))\noptimizer_D = torch.optim.Adam(discriminator.parameters(), lr=0.00005, betas=(beta1, 0.999))\noptimizer_G = torch.optim.Adam(generator.parameters(), lr=0.0002, betas=(beta1, 0.999))\n```\n\n\n```python\nepochs=20\n\nfixed_z=torch.randn(batch_size,noise_dim,1,1,device=device)\nfor epoch in range(epochs):\n    for step,(image,_) in enumerate(img_dataloader):\n        batch_size=image.size(0)\n        #=====训练辨别器====\n        optimizer_D.zero_grad()\n        # 计算判别器对真实样本给出为真的概率\n        d_out_real = discriminator(image.type(torch.FloatTensor).to(device))\n        real_loss = bce_loss(d_out_real, torch.ones(size=(batch_size, 1)).to(device))\n        real_scores = d_out_real\n        #real_loss.backward()\n        # 计算判别器对假样本给出为真的概率\n        noise = torch.randn(batch_size,noise_dim,1,1,device=device)\n        fake_img = generator(noise)\n        d_out_fake = discriminator(fake_img.detach())\n        fake_loss = bce_loss(d_out_fake, torch.zeros(size=(batch_size, 1)).to(device))\n        fake_scores = d_out_fake\n        #fake_loss.backward()\n        # 更新判别器参数\n        d_loss = (real_loss + fake_loss)/2\n        d_loss.backward()\n        optimizer_D.step()\n        \n        #=====训练生成器====\n        optimizer_G.zero_grad()\n        # 计算判别器对伪造样本的输出的为真样本的概率值\n        d_out_fake = discriminator(fake_img)\n        # 计算生成器伪造样本不被认为是真的损失\n        g_loss = bce_loss(d_out_fake, torch.ones(size=(batch_size, 1)).to(device))\n        # 更新生成器\n        g_loss.backward()\n        optimizer_G.step()\n\n        # #################################################\n        # 4：打印损失，保存图片\n        if step % 200 == 0:\n            generator.eval()\n            fixed_image = generator(fixed_z)\n            generator.train()\n            print(\"[epoch: {}/{}], [iter: {}], [G loss: {:.3f}], [D loss: {:.3f}], [R Score: {:.3f}], [F Score: {:.3f}]\".format(epoch+1,epochs,step, g_loss.item(), d_loss.item(),real_scores.data.mean(), fake_scores.data.mean()))\n            utils.save_image(fixed_image.detach(), str(epoch+1)+\"fake.jpg\",normalize=True)\n            utils.save_image(image,str(epoch+1)+\"real.jpg\",normalize=True)\n```\n\n结果如下：\n    [epoch: 1/20], [iter: 0], [G loss: 0.699], [D loss: 0.694], [R Score: 0.499], [F Score: 0.500]\n    [epoch: 1/20], [iter: 200], [G loss: 0.803], [D loss: 0.715], [R Score: 0.512], [F Score: 0.529]\n    [epoch: 1/20], [iter: 400], [G loss: 0.734], [D loss: 0.692], [R Score: 0.492], [F Score: 0.491]\n    [epoch: 1/20], [iter: 600], [G loss: 0.730], [D loss: 0.693], [R Score: 0.496], [F Score: 0.496]\n    [epoch: 1/20], [iter: 800], [G loss: 0.748], [D loss: 0.686], [R Score: 0.500], [F Score: 0.492]\n    [epoch: 1/20], [iter: 1000], [G loss: 0.745], [D loss: 0.680], [R Score: 0.514], [F Score: 0.499]\n    [epoch: 1/20], [iter: 1200], [G loss: 0.715], [D loss: 0.701], [R Score: 0.527], [F Score: 0.532]\n    [epoch: 2/20], [iter: 0], [G loss: 0.762], [D loss: 0.679], [R Score: 0.524], [F Score: 0.508]\n    [epoch: 2/20], [iter: 200], [G loss: 0.815], [D loss: 0.686], [R Score: 0.507], [F Score: 0.498]\n    [epoch: 2/20], [iter: 400], [G loss: 0.836], [D loss: 0.665], [R Score: 0.509], [F Score: 0.479]\n    [epoch: 2/20], [iter: 600], [G loss: 0.759], [D loss: 0.694], [R Score: 0.523], [F Score: 0.520]\n    [epoch: 2/20], [iter: 800], [G loss: 0.973], [D loss: 0.646], [R Score: 0.551], [F Score: 0.499]\n    [epoch: 2/20], [iter: 1000], [G loss: 0.926], [D loss: 0.671], [R Score: 0.531], [F Score: 0.495]\n    [epoch: 2/20], [iter: 1200], [G loss: 1.100], [D loss: 0.582], [R Score: 0.497], [F Score: 0.362]\n\n![](https://unpkg.com/justlovesmile-img/20210225180739.png)\n\n第7个epoch：\n![](https://unpkg.com/justlovesmile-img/20210226103604.jpg)\n\nbatch_size以及其他参数可自行调整。\n\n## 5. WGAN原理\n\n论文：[Wasserstein GAN](https://arxiv.org/pdf/1701.07875.pdf)\n[Towards Principled Methods for Training Generative Adversarial Networks](https://arxiv.org/abs/1701.04862)\n\n总所周知，GAN的训练存在很多问题和挑战：\n- 训练困难，需要精心设计模型结构，协调G和D的训练程度\n- G和D的损失函数无法指示训练过程，缺乏一个有意义的指标和生成图片的质量相关联\n- 模式崩坏（mode collapse），生成的图片虽然看起来像是真的，但是缺乏多样性\n\nWGAN相比较于传统的GAN，做了如下修改：\n- D最后一层去掉sigmoid\n- G和D的loss不取log\n- 每次更新D的参数后，将其绝对值截断到不超过一个固定常数c\n- 不要用基于动量的优化算法（包括momentum和Adam），推荐RMSProp，SGD也行\n\n![](https://unpkg.com/justlovesmile-img/20210303105435.png)\n\nG的损失函数原本为$\\mathbb{E} _ {z \\sim p _ z}[\\log(1-D(G(z)))]$ ，其导致的结果是，如果D训练得太好，G将学习不到有效的梯度。但是，如果D训练得不够好，G也学习不到有效的梯度。\n因此以上损失函数导致GAN训练特别不稳定，需要小心协调G和D的训练程度。\n\n>WGAN参考资料：\n[https://zhuanlan.zhihu.com/p/44169714](https://zhuanlan.zhihu.com/p/44169714)\n[https://www.cnblogs.com/Allen-rg/p/10305125.html](https://www.cnblogs.com/Allen-rg/p/10305125.html)","tags":["深度学习","GAN"],"categories":["人工智能"]},{"title":"深度学习 | Wasserstein距离","slug":"人工智能-Wasserstein距离","url":"/posts/ebe3a70b.html","content":"\n# Wasserstein 距离\n\n对于绝大多数的机器学习问题，尤其是预测问题和隐变量模型（`latent factor model`）中，学习到数据集背后所服从的分布往往是模型所要解决的最终问题。在变分推断（`variational inference`）等领域中，往往会先从一个简单的分布引入，比如高斯分布或者多项式分布等；希望由这个简单的分布模型能不断学习进而逼近最终想要的、符合数据背后规律的分布，注意这时候的分布往往可能在形状上与初始假设的分布有所差异。\n\n## KL散度和JS散度\n\n在学习Wasserstein距离，首先回顾在机器学习算法中，衡量两个分布相似程度的指标常常是KL散度（`Kullback-Leibler Divergence`）以及JS散度 （`Jensen-Shannon Divergence`）。\n\n### KL散度\n\nKL散度描述的是，评价训练所得的概率分布p与目标分布q之间的距离，可以表示为：\n\n![image-20210131104033253](https://unpkg.com/justlovesmile-img/20210131104040.png)\n\n机器学习的算法最终的目的是缩小 $D _ {KL}$ 的值，可以看到当 $p(x)==q(x)$ 的时候，KL散度处处为0，达到最优结果。 但同时必须注意的是，由于KL散度中，对数项中$p(x)$与$q(x)$相对位置的关系，决定了KL散度其实是非对称的，即 $D_{KL}(p||q) \\neq D_{KL}(q||p)$ .从物理学参考系的角度可以直观感受出，如果要想评价两个物体（分布）的相似程度，相似程度的值（比如KL散度）应该不能因为选取的参考目标（目标分布）的不同而改变。\n\n### JS散度\n\n既然KL散度不具备对称性，那么依然从参考系的角度出发，那我们直接把所有参考系下计算的距离平均即可（在本文环境下只有目标分布和预测分布两个参考系）。这样便是JS散度的思想，具体的定义为:\n\n![image-20210131104625712](https://unpkg.com/justlovesmile-img/20210131104625.png)\n\n因而JS散度便有了对称性，并且形式上更为平滑，更适合作为最后最大似然的函数，这点在生成对抗网络（GAN）的损失函数取得了不错的成绩。\n\n## Wasserstein距离\n\nWasserstein距离也叫做推土机距离（Earth Mover's distance），这也是由于它的推导过程可以很形象的用挖土填土来解释，这也是因为该距离定义中由一个分布转变为另一个分布所需要的代价和挖土填土的过程十分相似。考虑两个离散的分布P和Q:\n\n- P1 = 3, P2 = 2, P3 = 1, P4 = 4\n\n- Q1 = 1, Q2 = 2, Q3 = 4, Q4 = 3\n\n为了让两个分布相同，我们一个个变量地观察，\n\n- 为了让P1和Q1相同，我们需要P1把手头上的3分2到P2去，这样P1和Q1都等于1，此时P2=4，其他数保持不变，这个过程是不是非常像挖掉P1的土填到P2上\n- 为了让P2和Q2相同，我们也要做类似的挖土填土工作，但注意，此时P2手头上由P1填的2，因此现在P2是4，但是Q2依然是2，因而P2也要挖2分土给P3，保持和Q2一样。\n- P3和Q3也是一样，但此时P3为3，Q3为4，因为我们只能先挖土再填土，因此要Q3挖1分土给Q4，这样P4和Q4也能够一样。\n\n每一步的代价计算公式为$\\delta_{i+1} = \\delta_{i} + P_{i} -Q_i$，第0步我们规定为0，故有\n\n- $\\delta_{0} = 0$\n\n- $\\delta_{1} = 0+3-1 = 2$\n\n- $\\delta_{2} = 2+2-2 = 2$\n\n- $\\delta_{3} = 2+1-4 = -1$\n\n- $\\delta_{4} = -1+4-3 = 0$\n\n  所以最终的总代价，也即Wasserstein距离则为$W=\\sum_i |\\delta_i|=5$\n\n该挖土填土的过程可以由下图表示:(图片来源：[From GAN to WGAN](https://lilianweng.github.io/lil-log/2017/08/20/from-GAN-to-WGAN.html#kullbackleibler-and-jensenshannon-divergence))\n\n![img](https://unpkg.com/justlovesmile-img/20210131105502.jpeg)\n\n由离散情况理解了距离计算以后，针对一般的**连续分布**，Wasserstein距离则变成如下形式:\n\n![image-20210131105656319](https://unpkg.com/justlovesmile-img/20210131105656.png)\n\n其中`inf`指代最大下界，$S(p_r,p_g)$表示的是分布$p_r$和$p_g$中所有可能的联合分布，每一个联合分布$\\gamma \\in S(p_r,p_g)$都是之前提到的“土”，用于刻画连续空间中分布间转换的代价，更具体而言，$\\gamma(x,y)$刻画从x点转移到y点从而让x，y服从相同分布所需要的“土”的百分比。因此$\\gamma$的边缘分布可以表示为$\\sum_x \\gamma(x,y)=p_g(y),\\sum_y \\gamma(x,y)=p_r(x)$\n\n当我们将x作为我们的起始点，y作为我们要逼近的终点时，挖土填土的总量即为$\\gamma(x,y)$，也即上文离散情况下计算的代价$\\delta$，而点与点之间的距离则为||x-y||，因而总代价为$\\sum_{x,y} \\gamma(x,y)||x-y||$,总代价最后可以使用EM等方法求得最小值。\n\n### 为什么Wasserstein距离优于KL和JS散度\n\nP,Q两个分布完全重合，此时这三种距离度量方式均为0。可以看出KL散度在两个分布完全没有任何交集的时候会得出无穷的结果，而JS散度则会有突然的阶跃，并且在0点出不可微，只有Wasserstein距离能够提供更为平滑的结果用于梯度下降法的参数更新。不过值得一提的是，目前主流的分布距离度量依然是KL散度，这是由于KL散度的计算方式简单，计算成本较Wasserstein低，但近年来Wasserstein距离的近似`Sinkhorn distance`以及其他加快距离计算方法的论文也在不断涌现.\n\n> 转自：[https://zhuanlan.zhihu.com/p/84617531](https://zhuanlan.zhihu.com/p/84617531)","tags":["深度学习","损失函数"],"categories":["人工智能"]},{"title":"深度学习 | 论文笔记（Lifelong Zero-Shot Learning）","slug":"人工智能-Lifelong-zero-shot-learning","url":"/posts/f6289062.html","content":"\n# Lifelong Zero-Shot Learning(论文翻译)\n\n**终身零样本学习**\n\n作者：**Kun Wei, Cheng Deng, Xu Yang**\n\n[https://www.ijcai.org/Proceedings/2020/0077.pdf](https://www.ijcai.org/Proceedings/2020/0077.pdf)\n\n## 摘要\n\n零样本学习(Zero-Shot Learning, ZSL)解决了一些测试类别在训练集中从未出现的问题。现有的零样本学习方法是被设计用来从一个固定的训练集中学习的，不具备对多种训练集的知识进行捕获和积累的能力，因此不适合许多现实生活中的应用。在本文中，我们提出了一种新的零样本学习方法，称为终身零样本学习(Lifelong Zero-Shot Learning，LZSL)，其目的是在多种数据集的学习过程中积累知识，并对所有训练数据集的从未出现的类别进行识别。此外，我们提出了一种革新的方法用来实现终身零样本学习，有效地缓解了连续训练过程中的灾难性遗忘。针对包含不同语义嵌入的数据集，我们利用变分自动编码器实现统一的语义表示。然后，在微调整个模型时，我们利用选择性再训练策略来保留先前任务的训练权重，并避免负迁移。最后，利用知识蒸馏，将之前的训练阶段的知识转移到当前阶段。我们还设计了终身零样本学习评估协议和高要求的基准。在这些基准上的大量实验表明，当现有的零样本学习方法失败时，我们的方法有效地解决了零样本学习问题。\n\n## 1. 介绍\n\n在最近几年，零样本学习在计算机视觉和机器学习社区中获得了越来越多的关注。与在训练阶段要求所有类别都有足够的样本的传统的分类任务不同，零样本学习的目标是识别在训练阶段从未出现过的新的类别的样本。在流行的零样本学习方法中，学习模型只在单个数据集的可见类上进行训练，然后在同一数据集的不可见类上进行测试，该数据集的可见类和不可见类是不相交的。然而，在许多现实世界的应用中，识别系统需要具有从获得的训练数据中不断学习的能力，并以终身的方式改进系统。\n\n为了满足这一要求，我们提出了一种更实用的零样本学习方法，称为终身零样本学习(Lifelong Zero-Shot Learning,LZSL)，它要求模型积累不同数据集的知识，并对所有面向数据集的未出现的类别进行识别。如图1所示，该模型在多个学习阶段进行训练，每个阶段都包含来自新数据集的图像和语义嵌入。这些数据集的语义嵌入是多样而复杂的，例如，这些数据集的属性列表是不同的。在完成所有训练阶段后，模型将对所有数据集上的可见的和不可见的测试图像进行评估。\n\n主流的零样本学习方法旨在学习图像之间的映射和相应的语义嵌入。这些方法根据分类空间可分为三种类型，即视觉空间、语义空间和常见嵌入空间。除此之外，还有一些零样本学习方法通过训练生成模型来获取不可见的类别的特征。然后，利用可见类别的视觉特征和生成的不可见类别的视觉特征训练分类器。这些方法将零样本学习任务转换为监督学习任务。然而，这些方法不能有效地处理终身零样本学习问题，因为它们缺乏在没有排查的情况下从之前训练的任务中积累知识的机制。\n\n为了解决上述问题，实现终身零样本学习，我们提出了一种将统一语义嵌入、选择性再训练和知识蒸馏策略无缝集成的新方法。选择交叉和分布对齐变分自编码器(Cross and Distribution Aligned VAE, CACD-VAE)作为基础模型，训练VAEs [Kingma and Welling, 2013]分别对视觉嵌入和语义嵌入的特征进行编码和解码，并使用学习到的潜在特征训练一个零样本学习分类器。为了使CACD-VAE具备终身学习的能力，我们首先利用训练后的VAEs在每个训练阶段获得统一的语义嵌入。利用统一的语义嵌入，分别学习和固定不同任务的潜在空间。为了保证视觉特征能够准确地投射到固定的潜在空间中，利用选择性再训练策略提高了不同任务的分类空间之间的相似性，也避免了在获取新任务知识过程中的负迁移。此外，知识蒸馏被用来将知识从之前的任务转移到当前任务。大量的实验表明，当其他最先进的零样本学习方法无效时，我们的方法可以有效地从之前学习的任务中积累知识并缓解灾难性遗忘。我们的方法的贡献总结如下:\n\n- 据我们所知，我们是第一个提出并解决终身零样本学习问题的。我们以一种新颖的方式设计了终身零样本学习的基准和评估协议。\n\n- 针对不同数据集的异构语义嵌入的挑战，我们采用了可以固定相应任务的潜在空间的VAEs算法去获得统一的语义嵌入。\n\n- 利用选择性再训练提高不同数据集的分类空间之间的相似性，并通过知识蒸馏损失来监督，规范了知识从之前的任务向当前任务转移的过程。\n\n- 在提出的基准上的大量的实验结果证明了我们提出的方法的有效性，它显著优于最先进的零样本学习方法。\n\n![1](https://unpkg.com/justlovesmile-img/20201230132259.png)\n\n图1:终身零样本学习的概述。当新任务到来时，模型按顺序学习新任务，从所有面临的任务中积累知识。将先前任务中的知识转移到当前任务中，可以有效地对不同数据集的不可见的类别进行分类。\n\n## 2. 相关工作\n\n### 2.1 零样本学习\n\n零样本学习已经成为一个热门的研究课题，其目标是在没有任何标记的训练数据的情况下识别不可见的类别。此外，零样本学习是迁移学习的一个子问题，其重点是将知识从可见的类别转移到不可见的类别。在测试阶段，测试样本从视觉空间中获取，而我们只在语义空间中进行不可见的类别的语义嵌入。因此，零样本学习方法的主流方法是构建视觉空间与语义空间的连接。典型的方法是学习将视觉特征和语义特征映射到一个共同的嵌入空间的函数，在这个空间中视觉特征和语义特征的嵌入是匹配的。最近，生成对抗网络(GANs)被提出并成功引入到零样本学习问题中。生成零样本学习方法的任务是根据语义特征生成不可见的类别的视觉特征，将零样本学习转换为传统的监督分类任务。例如，f-CLSWGAN是利用conditional Wasserstein GANs提出的，它生成了差别性的不可见的视觉特征。基于f-CLSWGAN, Cycle-WGAN 重建正则化的目的是，保留转移过程中的类别的不同特征。\n\n然而，上述所有方法都仅在单个数据集上进行训练，因为顺序学习各种数据集的能力有限。据我们所知，我们是第一个提出并解决终身零样本学习问题的。\n\n### 2.2 终身学习\n\n终身学习(Lifelong Learning)是一种学习模式，它要求模型拥有从一系列任务中进行学习，并能将从之前任务中获得的知识转移到后续任务中的能力。终身学习的关键挑战是灾难性遗忘，即当新任务到来时，被训练的模型会忘记之前任务中得到的知识。有很多终身学习的方法被提出，主要分为三部分，即，存储之前任务的训练样本，新任务到来时的正则化参数更新，以及使用额外的生成模型来重现之前任务的训练样本的记忆重现。\n\n与传统的终身学习问题不同的是，在流行的终身学习分类问题中，传统的终身学习问题的训练和测试的类别是相同的，而在终身零样本学习中，这些是不相交的。\n\n![2](https://unpkg.com/justlovesmile-img/20201230132412.png)\n\n图2:我们提出的在$t^{th}$训练阶段上方法框架，该框架由两个VAEs和一个在$(t−1)^{th}$训练阶段训练过的视觉模态编码器组成。给定一张图像,视觉特征提取器可以捕获它的视觉特征$x^t$,映射到的潜在空间作为$\\mu^t_v$和$\\sum^t_v$。同时，相应的语义嵌入$c^t$映射到潜在的空间作为$\\mu^t_a$和$\\sum ^ t _ a$。 为了实现潜在的分布对齐，在训练阶段将潜在分布之间的Wasserstein距离($L _ {DA}$)最小化。然后，利用交叉对齐损失( $L _ {CA}$ )，通过交叉模态重构，来保证潜在分布的对齐。此外，我们利用知识蒸馏( $L _ {KD}$ )将之前任务中获得的知识转移到当前任务中。\n\n## 3. 方法\n\n针对终身零样本学习问题，我们提出终身零样本学习方法，将终身学习和零样本学习无缝结合。我们的方法框架如图2所示。首先，我们利用VAEs实现不同数据集的统一语义嵌入;然后，我们采用选择性再训练策略逼近不同数据集的分类空间，避免负迁移。最后，我们采用知识蒸馏的方法，将先前任务中的知识转移到当前任务中。\n\n### 3.1 问题公式\n\n在第$t^{th}$个训练阶段，给出一个数据集$S^t = \\{(x^t, y^t, c^t)|x^t \\in X^t, y^t \\in Y^t_s, c^t \\in C^t \\}$， 其由一个预训练卷积神经网络(CNN)提取的图像特征$x^t$、可见的类别$Y^t_s$的标签$y^t$和对应类别的语义嵌入$c^t$组成。此外，还有一个可获得的数据集$U^t= \\{(u^t, c^t_u) | u^t \\in Y^t_u, c^t_u \\in C^t \\}$，该数据集包含集合$Y^t_u$中的不可见的类别的标签$u^t$和不可见的类别的语义嵌入$c^t_u$。对于最现实和最具挑战性的广义零学习(Generalized Zero-Learning, GZSL)，其目标是学习一个分类器$f^t_{GZSL}: X^t \\rightarrow Y^t_s\\cup Y^t_u$。然而，我们的方法主要集中在通过顺序训练不同的数据集来学习一个生成模型，然后针对不同的数据集构造几个分类器。\n\n### 3.2 背景: 交叉分布对齐变分自编码器(CACD-VAE)\n\n本文首先介绍了一种最先进的零样本学习方法--交叉分布对齐变分自编码器 (CADA-VAE)，它是我们方法的基本模型。它的目标是搜索一个共同的分类空间，其中嵌入的语义特征和视觉特征是一致的。该模型包含两个VAEs，一个用于语义特征，另一个用于视觉特征，每个都包含一个编码器和一个解码器。每个VAE的目标函数是给定样本的边际似然的变分下界，它可以表述为:\n\n$$ L = \\mathbb{E} _ {q_{\\phi} (z|x)}\\left[\\log p_{\\phi} (x|z)\\right] - \\lambda D_{KL}(q_{\\phi} (z|x)||p_{\\theta} (z)),  (1) $$\n\n其中，第一项为重构损失，第二项为解开的`Kullback-Leibler散度`，对推理模型$q(z|x)$和$p(z)$进行规则化。此外，$\\lambda$被用来加权KL-散度。编码器预测$\\mu$和$\\sum$，所以有$q_{\\phi}(z | x) = N(\\mu, \\sum)$，并且通过应用重新参数化技巧获取一个潜在的向量$z$。编码器被用于将特征投影到公共空间，并且解码器用于重建原始数据。\n整个模型的VAE损失是两个VAE基本损失的总和:\n\n$$ L_{VAE} = L_{VAE}^a + L_{VAE}^v,  (2) $$\n\n其中$L_{VAE}^a$和$L_{VAE}^v$分别表示语义模态和视觉模态的VAE损失。此外，针对语义空间和视觉空间的嵌入在公共空间中的匹配问题，该模型对潜在分布进行了精确对齐，需要一个交叉重建准则来保证。因此，我们设计并应用了交叉对齐损失(CA)和分布对齐损失(DA)。\n\n交叉对齐损失使来自另一个模态的重构特征与原始模态特征相似。交叉对齐损失为:\n\n$$ L_{CA} = \\left| c-D_a(E_v(x)) \\right| + \\left|x-D_v(E_a(x))\\right|,  (3) $$\n\n其中，$c$、$D_a$和$E_a$是语义模态的特征、解码器和编码器，$x$、$D_v$和$E_v$是视觉模态的特征、解码器和编码器。\n\n利用分布对齐损失最小化语义模态的潜在高斯分布与视觉模态的之间的Wasserstein距离，使语义空间和视觉空间的隐性嵌入相匹配。\n距离表示为:\n\n$$ L_{DA} = (||\\mu_a - \\mu_v||_2^2 + ||\\sum^{\\frac{1}{2}}_a-\\sum_a^{frac{1}{2}}||^2_Frobenius)^{frac{1}{2}} ,  (4) $$\n\n其中$\\mu_a$和$\\sum_a$通过编码器$E_a$预测,而$µ_v$和$\\sum_v$通过编码器$E_v$预测。\n目标函数可以表示为:\n\n$$ L_{CACD - VAE} = L_{VAE} + \\gamma L_{CA} + \\delta L_{DA}, (5)  $$\n\n其中，$\\gamma$ 和 $\\delta$ 是交叉对齐和分布对齐损失的超参数，用于权衡这些损失。\n\n### 3.3 统一的语义嵌入\n\n由于不同数据集的属性数量和种类不同，首先需要解决的挑战是不同数据集的语义嵌入是多种多样和复杂的。为了解决这一问题，我们尝试寻找不同数据集的统一语义嵌入。在训练$t^{th}$任务之后,语义嵌入$c^t$被预测为通过$E^t_a$映射的$\\mu^t_a$和$\\sum^t_a$。隐向量z是采用再参数化的技巧生成的,其过程是从点数据生成各种隐向量的过程。生成的隐向量可以作为最终分类器的训练数据，其中包含了对应类的判别信息。在此基础上,我们替换原始语义嵌入$c^t$和$\\mu^t_a$,$\\sum_a^t$,从一个点数据到两个点数据,数据可被视为更具代表性的语义映射。在训练完所有任务后，我们可以利用这些新的语义嵌入再现所有数据集的隐向量，并训练更强健的分类器。\n\n### 3.4 选择性再训练\n\n对于这项新任务，一种自然的方法是对整个模型进行微调。然而，对整个模型进行微调会改变先前任务的权重，导致神经网络的灾难性遗忘。因此，我们采用选择性再训练策略对整个模型进行微调。当获得统一的语义嵌入时，不同数据集的分类空间是固定的，这也是之前任务的潜在空间。因此,模型是从视觉空间到分类空间的投影,是视觉模态的编码器$E_v^t$。我们表示$W^t$作为$E^t_v$和$W^t_l$的参数，被表示为l层的参数，而l层的数量是L。当一个新的任务到达时，我们首先冻结参数$W^{t - 1}_l$，并对模型进行微调，以获得$L - 1$层之间输出单元$o_t$和隐藏单元的连接。然后，我们可以选择在训练过程中受影响的所有单位和权重，并保持与输出单位无关的部分不变。选择操作可以看作是对模型进行初始化，保证优化的方向是保护前一个任务的分类空间。最后，我们只对选定的权值进行微调，记为$W_S^t$。算法1描述了选择性再训练的过程。\n\n\n\n\n\n| **算法1** 选择性再训练的过程                                 |\n| ------------------------------------------------------------ |\n| 输入：数据集$S^t$，之前的参数$W^{t-1}$                       |\n| 输出：选择参数$W_s^t$                                        |\n| 1: 冻结参数$W^{t-1}_L$，$S^t={o_t}$                          |\n| 2: 微调网络                                                  |\n| 3: $\\text{for l = L,...,l do}$                               |\n| 4: 添加神经元$i$到$S^t$，如果存在一些神经元$j \\in S$，且$W_{l,ij}^{t-1}≠0$ |\n| 5: $\\text{end for}$                                          |\n| 6: 微调选择的参数$W^t_S$                                     |\n\n### 3.5 知识蒸馏\n\n通过选择性再训练，选择性神经元发生变化并且其他神经元被冻结，但不能保证整个模型的优化方向，即激励模型保持之前任务的知识。为了将知识从之前的任务中转移到当前任务中，我们采用了知识蒸馏策略。当$t^{th}$任务到达时，我们希望在相同输入$x^t$的情况下，$E^t_v$的输出与$E^{t−1}_v$的输出相似，这样可以保证$t^{th}$任务和$(t-1)^{th}$任务的分类空间近似。在顺序训练所有数据集后,当$E_v^t$输入相同的图像特征$x^t$时，最后的$e_v$有能力预测相似的$\\mu^t_v$和$\\sum^t_v$。蒸馏损失记为:\n\n$$ L_{KD} = ||\\mu_v^t - \\widehat{\\mu _v^t}||_1 + ||\\sum_v^t - \\widehat{\\sum_v^t}||_1 ,  (6) $$\n\n其中$\\mu_v^t$和$\\sum_v^t$通过$E^t_v$预测，而$\\widehat{\\mu_v^t}$和$\\widehat{\\sum_v^t}$通过$E^{t-1}_v$。\n\n当$t>1$时，目标函数表示为：\n\n$$L = L_{CACD-VAE} +\\beta L_{KD},  (7) $$\n\n其中$\\beta$为加权知识蒸馏损失的超参数，设为1。\n\n### 3.6 训练和推理\n\n在训练中，我们对数据集进行顺序训练，并保存所有类别的统一语义嵌入。\n在VAEs的训练阶段结束后，我们利用保存的语义嵌入再现所有类的隐向量。隐向量的生成过程对每个可见类别重复$n_s$次，对每个不可见类别重复$n_u$次。$n_s$和$n_u$分别设置为200和400。这些隐向量包含了这些类别的判别信息。利用不同数据集的隐向量分别训练`softmax分类器`。\n\n在测试阶段，通过视觉模态$E_v$编码器将被测试可见类和不可见类的视觉特征投影为隐向量。然后将测试特征输入到训练好的分类器，得到不同数据集的分类结果。\n\n| 数据集 | 语义维度 | 图像  | 可见类 | 不可见类 |\n| ------ | -------- | ----- | ------ | -------- |\n| APY    | 64       | 15339 | 20     | 12       |\n| AWA1   | 85       | 30475 | 40     | 10       |\n| CUB    | 312      | 11788 | 150    | 50       |\n| SUN    | 102      | 14340 | 645    | 72       |\n\n表1：实验使用的数据集及其统计信息。\n\n\n\n## 4. 实验\n\n在本节中，我们将详细介绍所涉及的数据集、评估指标和实现细节。然后，我们将呈现几个最先进的竞争对手以及我们的方法的实验结果。最后，消融研究将证明我们所提出方法的有效性。\n\n### 4.1 基准和评估标准\n\n我们在四个数据集上评估我们的方法: `Attribute Pascal`和`Yahoo数据集(aPY)`，`Animals with Attributes 1 (AW A1)`，`Caltech-UCSD-Birds 200-2011数据集(CUB)`和`SUN Attribute数据集(SUN)`。数据集统计如表1所示。对于所有数据集，我们使用预先训练的101层的`ResNet`提取2048维视觉特征。训练数据集的顺序为`aPY`, `AWA1`, `CUB`和`SUN`，都是按字母顺序排列的。\n\n遵循广义零样本学习方法，我们对终身零样本学习采用相同的评价指标:\n\n- u：是对每类带有预测标签集的不可见类别的测试图像进行分类的平均准确率，用于衡量识别不可见类的能力。\n\n- s：是对每类带有预测标签集的可见类的测试图像进行分类的平均准确率，用于衡量识别增量可见类的能力。\n\n- H：u和s的调和均值，公式为：$H=\\frac{2×u×s}{u+s}$。\n\n我们任务中最重要的指标是，H平衡u和s指标之间的性能。对所有数据集进行训练后，对三个度量的所有结果进行测量。\n\n### 4.2 实施细则\n\n所有的编码器和解码器都是多层感知机，有一个隐藏层。我们使用了1560个隐藏单元作为图像特征编码器，1660个作为解码器。编码器和解码器的属性分别有1450个和660个隐藏单元。$\\delta$从第6个epoch到第22个epoch以每轮0.54的速率增加，而$\\gamma$从第21个epoch到第75个epoch以每个epoch按0.044的速率增加。KL散度的权重$\\lambda$以每个epoch按照0.0026的速率增加，直到第90个epoch。此外，我们使用L1距离作为重构误差，得到了比L2更好的结果。\n\n对于每个数据集，epoch的数量设置为100，批处理大小(batch size)设置为50。VAEs学习率设置为0.00015，分类器学习率设置为0.001。另外，我们的方法是用`PyTorch`实现的，并通过`ADAM`优化器进行优化。\n\n### 4.3 与现存基准程序的比较\n\n**基线模型**。由于之前没有关于终身零样本学习的研究，我们将结合了CACD-VAE与传统的终身学习方法的基线进行比较。\n(a) 顺序微调(SFT): 当一个新任务按顺序到达时，模型被微调，该模型的参数从在前一个任务训练或微调的模型进行初始化。\n(b) L2正则化(L2): 在每个任务t上，$W_t$初始化为$W_{t−1}$，在$W_t$和$W_{t−1}$之间持续进行L2正则化训练。\n(C) L1正则化(L1): 在每个任务t上，$W_t$初始化为$W_{t−1}$，在$W_t$和$W_{t−1}$之间持续进行L1正则化训练。\n\n**结果和分析**。表2总结了在四个基准数据集上的所有的对比方法以及我们的方法在三个评价指标下的结果。对于GZSL指标上的零样本学习方法，H是评价零样本学习方法性能最重要的指标，它平衡了u和s指标的性能。\n\n表2中的“Base”表示模型在没有任何终身策略的情况下按顺序训练，“Original”表示分别训练数据集的模型。显然，我们可以发现Base的结果获得了之前数据集的最差性能，当新任务到来时，这些数据集不具备积累之前数据集的知识的能力。此外，采用顺序微调策略的模型比不采用该策略的模型的结果更差，这表明了零样本学习中存在灾难性遗忘问题。\n\n与其他基准相比，我们的方法在前三个数据集中获得了三个评价指标的最佳性能。在`aPY数据集`上，我们的模型的u达到了29.11%，s达到了43.29%和H达到了34.81%，其中u提升了2.69%，s提升了13.50%，并且H提升了6.80%。在`AWA1数据集`上，我们的模型的u达到了51.17%，s达到了63.66%和H达到了56.73%，其中u提升了1.53%,s提升了4.59%，并且H提升了3.14%。在`CUB数据集`上，我们的模型的u达到了38.82%,s达到了45.81%和H达到了42.03%，其中u提升了3.29%,s提升了11.07%，并且H提升了7.68%。尽管我们的方法没有在SUN数据集上获得最好的结果，但是与其他数据集的改进相比，结果只下降了很少，这是因为我们的方法更好地平衡了从之前任务积累知识的能力以及当前任务获取知识的能力。我们还计算了这些方法在四个数据集上的平均H值。Base、SFT、L1、L2以及我们方法的平均H值分别为10.2%、36.73%、38.03%、36.73%和42.48%，平均H值提高了4.45%。综上所述，我们的方法在之前任务和当前任务中获得了均衡的性能，并且明显优于基线程序。\n\n![3](https://unpkg.com/justlovesmile-img/20201230134611.png)\n\n### 4.4 消融研究\n\n我们进行了两组消融实验来研究我们方法的有效性。\n\n表3显示了添加了不同模块的基本模型的结果。基本模型为使用了连续微调训练策略的CACD-VAE。在基础模型的基础上，加入知识蒸馏模块和选择性再训练模块，分别用“KD”和“SR”表示。如表3所示，知识蒸馏和选择性再训练都可以提高前三个数据集的性能。加入“KD”的改进表明知识蒸馏可以将前一个任务的知识转移到当前任务中，在一定程度上缓解了灾难性遗忘的不利影响。此外，添加“SR”的改进表明选择性再训练可以保留之前任务中受影响的权重，避免负迁移，因为没有被选择的神经元不会受到再训练过程的影响。当添加所有模块时，我们的方法表现得最好。\n\n我们做了一个实验来讨论数字$n_s$和$n_u$重放的影响，其平均H结果如图3所示。\n当$n_s$和$n_u$被设置为200和400时，可以获得最佳性能。显然，我们可以注意到一个现象：在平均H达到峰值性能之前，平均H随着$n_s$和$n_u$的增加而增加。\n\n![4](https://unpkg.com/justlovesmile-img/20201230134705.png)\n\n图3:不同$n_s$和$n_u$超参数下的平均H结果。\n\n## 5. 结论\n\n据我们所知，本文是第一个尝试介绍和解决终身零样本学习的。首先，我们采用VAEs方法获得统一的语义嵌入，从而弥补了不同数据集语义嵌入之间的差距。然后，利用选择性再训练策略，在很大程度上保留前一训练阶段构造的投影。最后，我们从之前的任务中提炼出知识，并转移到当前的训练阶段。实验结果表明，该方法在4个基准数据集上性能均明显优于以往的方法。","tags":["深度学习","论文笔记","小样本学习"],"categories":["人工智能"]},{"title":"深度学习 | 什么是知识图谱","slug":"人工智能-什么是知识图谱","url":"/posts/ba289ad3.html","content":"\n# 什么是知识图谱\n\n## 1. 来源\n\n2012年5月17日，**Google**正式提出了**知识图谱**（Knowledge Graph）的概念，其初衷是为了优化搜索引擎返回的结果，增强用户搜索质量及体验。\n\n实际上，知识图谱并不是一个全新的概念，早在 2006 年就有文献提出了语义网（Semantic Network）的概念，呼吁推广、完善使用本体模型来形式化表达数据中的隐含语义，RDF（resource description framework，资源描述框架）模式和 OWL（Web ontology language，万维网本体语言）就是基于上述目的产生的。用电子科技大学徐增林教授的论文原文来说：\n\n知识图谱技术的出现正是基于以上相关研究，是对语义网标准与技术的一次扬弃与升华。\n\n目前，随着智能信息服务应用的不断发展，知识图谱已广泛应用于智能搜索，智能问答，个性化推荐等领域。\n\n## 2. 定义\n\n**知识图谱**，本质上，是一种揭示**实体**之间**关系**的语义网络。\n\n看一张简单的知识图谱：\n\n![img](https://unpkg.com/justlovesmile-img/20201223193032.jpg)\n\n如图所示，你可以看到，如果两个节点之间存在关系，他们就会被一条无向边连接在一起，那么这个节点，我们就称为**实体**（Entity），它们之间的这条边，我们就称为**关系**（Relationship）。\n\n如果你看过网络综艺《奇葩说》第五季第17期：你是否支持全人类一秒知识共享，你也许会被辩手陈铭的辩论印象深刻。他在节目中区分了信息和知识两个概念：\n\n信息是指外部的客观事实。举例：这里有一瓶水，它现在是7°。\n\n知识是对外部客观规律的归纳和总结。举例：水在零度的时候会结冰。\n\n“客观规律的归纳和总结” 似乎有些难以实现。Quora 上有另一种经典的解读，区分 “信息” 和 “知识” 。\n\n![img](https://unpkg.com/justlovesmile-img/20201223193045.jpg)\n\n这样我们就很容易理解，在信息的基础上，建立实体之间的联系，就能行成 “知识”，或者称为叫事实（Fact）更为合适。换句话说，知识图谱是由一条条知识组成，每条知识表示为一个SPO**三元组**(Subject-Predicate-Object)。\n\n![img](https://unpkg.com/justlovesmile-img/20201223193127.png)\n\n知识图谱实际上就是如此工作的。曾经知识图谱非常流行**自顶向下**(top-down)的构建方式。自顶向下指的是先为知识图谱定义好本体与数据模式，再将实体加入到知识库。该构建方式需要利用一些现有的结构化知识库作为其基础知识库，例如 Freebase 项目就是采用这种方式，它的绝大部分数据是从维基百科中得到的。\n\n然而目前，大多数知识图谱都采用**自底向上**(bottom-up)的构建方式。自底向上指的是从一些开放链接数据（也就是 “信息”）中提取出实体，选择其中置信度较高的加入到知识库，再构建实体与实体之间的联系。\n\n## 3. 数据类型和存储方式\n\n知识图谱的原始数据类型一般来说有三类（也是互联网上的三类原始数据）：\n\n- 结构化数据（Structed Data）：如关系数据库\n\n- 半结构化数据（Semi-Structed Data）：如XML、JSON、百科\n\n- 非结构化数据（UnStructed Data）：如图片、音频、视频、文本\n\n如何存储上面这三类数据类型呢？一般有两种选择，一个是通过RDF（资源描述框架）这样的规范存储格式来进行存储，还有一种方法，就是使用图数据库来进行存储，常用的有Neo4j等。\n\n## 4. 体系架构\n\n知识图谱的架构主要包括自身的**逻辑结构**以及**体系架构**。\n\n\n\n知识图谱在**逻辑结构**上可分为**模式层**与**数据层**两个层次，**数据层**主要是由一系列的事实组成，而知识将以事实为单位进行存储。如果用（实体1，关系，实体2）、（实体、属性，属性值）这样的三元组来表达事实，可选择图数据库作为存储介质，例如开源的 Neo4j、Twitter 的 FlockDB、JanusGraph 等。**模式层**构建在数据层之上，主要是通过本体库来规范数据层的一系列事实表达。本体是结构化知识库的概念模板，通过本体库而形成的知识库不仅层次结构较强，并且冗余程度较小。\n\n \n\n知识图谱的**体系架构**是指其构建模式的结构，如下图所示：\n\n![img](https://unpkg.com/justlovesmile-img/20201223193136.jpg)\n\n![img](https://unpkg.com/justlovesmile-img/20201223193143.jpg)\n\n大规模知识库的构建与应用需要多种智能信息处理技术的支持。通过知识抽取技术，可以从一些公开的半结构化、非结构化的数据中提取出实体、关系、属性等知识要素。通过知识融合，可消除实体、关系、属性等指称项与事实对象之间的歧义，形成高质量的知识库。知识推理则是在已有的知识库基础上进一步挖掘隐含的知识，从而丰富、扩展知识库。分布式的知识表示形成的综合向量对知识库的构建、推理、融合以及应用均具有重要的意义。\n\n## 5. 知识抽取\n\n知识抽取主要是面向开放的链接数据，通过自动化的技术抽取出可用的知识单元，知识单元主要包括实体(概念的外延)、关系以及属性3个知识要素，并以此为基础，形成一系列高质量的事实表达，为上层模式层的构建奠定基础。知识抽取有三个主要工作：\n\n- **实体抽取**：在技术上，更多称为 NER（named entity recognition，命名实体识别），指的是从原始语料中自动识别出命名实体。由于实体是知识图谱中的最基本元素，其抽取的完整性、准确、召回率等将直接影响到知识库的质量。因此，实体抽取是知识抽取中最为基础与关键的一步；\n\n- **关系抽取**：目标是解决实体间语义链接的问题，早期的关系抽取主要是通过人工构造语义规则以及模板的方法识别实体关系。随后，实体间的关系模型逐渐替代了人工预定义的语法与规则。\n\n- **属性抽取**：属性抽取主要是针对实体而言的，通过属性可形成对实体的完整勾画。由于实体的属性可以看成是实体与属性值之间的一种名称性关系，因此可以将实体属性的抽取问题转换为关系抽取问题。\n\n## 6. 知识表示\n\n近年来，以深度学习为代表的表示学习技术取得了重要的进展，可以将实体的语义信息表示为稠密低维实值向量，进而在低维空间中高效计算实体、关系及其之间的复杂语义关联，对知识库的构建、推理、融合以及应用均具有重要的意义。\n\n## 7. 知识融合\n\n由于知识图谱中的知识来源广泛，存在知识质量良莠不齐、来自不同数据源的知识重复、知识间的关联不够明确等问题，所以必须要进行知识的融合。知识融合是高层次的知识组织，使来自不同知识源的知识在同一框架规范下进行异构数据整合、消歧、加工、推理验证、更新等步骤，达到数据、信息、方法、经验以及人的思想的融合，形成高质量的知识库。知识融合包括两部分内容：**实体链接**，**知识合并**。\n\n- **实体链接**：是指对于从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作。\n\n- **知识合并**：常见的知识合并需求有两个，一个是合并外部知识库，另一个是合并关系数据库。\n\n## 8. 知识加工\n\n事实本身并不等于知识。要想最终获得结构化，网络化的知识体系，还需要经历知识加工的过程。**知识加工**主要包括三方面内容：**本体构建**、**知识推理**和**质量评估**。\n\n## 9. 知识更新\n\n从逻辑上看，知识库的更新包括**概念层的更新**和**数据层的更新**。\n\n- **概念层的更新**是指新增数据后获得了新的概念，需要自动将新的概念添加到知识库的概念层中。\n\n- **数据层的更新**主要是新增或更新实体、关系、属性值，对数据层进行更新需要考虑数据源的可靠性、数据的一致性（是否存在矛盾或冗杂等问题）等可靠数据源，并选择在各数据源中出现频率高的事实和属性加入知识库。\n\n知识图谱的内容更新有两种方式：\n\n-  **全面更新**：指以更新后的全部数据为输入，从零开始构建知识图谱。这种方法比较简单，但资源消耗大，而且需要耗费大量人力资源进行系统维护；\n\n-  **增量更新**：以当前新增数据为输入，向现有知识图谱中添加新增知识。这种方式资源消耗小，但目前仍需要大量人工干预（定义规则等），因此实施起来十分困难。\n\n## 10.   知识图谱应用\n\n知识图谱为互联网上海量、异构、动态的大数据表达、组织、管理以及利用提供了一种更为有效的方式，使得网络的智能化水平更高，更加接近于人类的认知思维。\n\n**智能搜索，智能问答，社交网络，个性化推荐，情报分析，反欺诈**等等\n\n## 11.   总结\n\n从技术来说，知识图谱的难点在于 NLP，因为我们需要机器能够理解海量的文字信息。但在工程上，我们面临更多的问题，来源于知识的获取，知识的融合。搜索领域能做的越来越好，是因为有成千上万（成百万上亿）的用户，用户在查询的过程中，实际也在优化搜索结果，这也是为什么百度的英文搜索不可能超过 Google，因为没有那么多英文用户。知识图谱也是同样的道理，如果将用户的行为应用在知识图谱的更新上，才能走的更远。\n\n知识图谱肯定不是人工智能的最终答案，但知识图谱这种综合各项计算机技术的应用方向，一定是人工智能未来的形式之一。\n\n## 12.   参考资料\n\n[https://www.cnblogs.com/huangyc/p/10043749.html]( https://www.cnblogs.com/huangyc/p/10043749.html)\n\n[https://zhuanlan.zhihu.com/p/71128505](https://zhuanlan.zhihu.com/p/71128505)","tags":["深度学习","知识图谱"],"categories":["人工智能"]},{"title":"深度学习 | 交叉熵损失函数","slug":"人工智能-CrossEntropy","url":"/posts/fdbf585c.html","content":"\n# Cross Entropy Error Function\n\n交叉熵损失函数\n\n## 一，信息量\n\n**信息量：**\n\n任何事件都会承载着一定的信息量，包括已经发生的事件和未发生的事件，只是它们承载的信息量会有所不同。如昨天下雨这个已知事件，因为已经发生，是既定事实，那么它的信息量就为0。如明天会下雨这个事件，因为未有发生，那么这个事件的信息量就大。\n\n从上面例子可以看出信息量是一个与事件发生概率相关的概念，而且可以得出，事件发生的概率越小，其信息量越大。\n\n假设$x$是一个离散型随机变量，其取值集合为$X$，概率分布函数为$p(x)$，则定义事件$x=x_0$的信息量为：$I(x_0)=-\\log(p(x_0))$\n\n## 二，熵\n\n**熵是表示随机变量不确定的度量，是对所有可能发生的事件产生的信息量的期望。**熵值越大，表明这个系统的不确定性就越大。公式如下：\n\n$$H(X)=-\\sum_{i=1}^n p(x_i)\\log(p(x_i))$$\n\n对于0-1分布问题，熵的计算方法可以简化为：\n\n$$H(x)=-\\sum_{i=1}^np(x_i)log(p(x_i))\\\\ =-p(x)\\log(p(x))-(1-p(x))\\log(1-p(x))$$\n\n## 三，相对熵（KL散度）\n\n相对熵又称KL散度，用于衡量对于同一个随机变量x的两个分布p(x)和q(x)之间的差异。在机器学习中，p(x)常用于描述样本的真实分布，例如[1,0,0,0]表示样本属于第一类，而q(x)则常常用于表示预测的分布，例如[0.7,0.1,0.1,0.1]。显然使用q(x)来描述样本不如p(x)准确，q(x)需要不断地学习来拟合准确的分布p(x)。\n\nKL散度的公式如下：\n\n$$D_{KL}(p||q)=\\sum_{i=1}^np(x_i)\\log(\\frac{p(x_i)}{q(x_i)})$$\n\nKL散度的值越小，表示两个分布越接近。在机器学习中，p往往用来表示样本的真实分布，q用来表示模型所预测的分布，那么KL散度就可以计算两个分布的差异，也就是Loss损失值。\n\n## 四，交叉熵\n\n将KL散度的公式进行变形，得到：\n\n$$D_{KL}(p||q)=\\sum_{i=1}^np(x_i)\\log(\\frac{p(x_i)}{q(x_i)})\\\\ =\\sum_{i=1}^np(x_i)\\log(p(x_i))-\\sum_{i=1}^np(x_i)\\log(q(x_i))$$\n\n根据熵的定义，前半部分是$p(x)$的熵$H(x)=-\\sum_{i=1}^np(x_i)\\log(p(x_i))$，而后半部分则是交叉熵，定义为：\n\n$$H(p,q)=-\\sum_{i=1}^np(x_i)\\log(q(x_i))$$\n\n因此$D_{KL}(p||q)=H(p,q)-H(p)$ ，在机器学习中，我们需要评估label和predicts之间的差距，使用KL散度刚刚好，即 $D_{KL}(p|| \\widetilde {q})$ ，由于KL散度中的前一部分$−H(p)$不变，故在优化过程中，只需要关注交叉熵就可以了。\n\n## 五，交叉熵损失函数\n\n在线性回归问题中，常常使用MSE(Mean Squared Error)作为loss函数，而在分类问题中常常使用交叉熵作为loss函数，特别是在神经网络作分类问题时，并且由于交叉熵涉及到计算每个类别的概率，所以交叉熵几乎每次都和sigmoid或者softmax函数一起出现。\n\n**(1)二分类**\n\n在二分的情况下，对于每个类别我们的预测的到的概率为p和1-p。此时表达式为：\n\n$$L=\\frac{1}{N}\\sum_iL_i=\\frac{1}{N}\\sum_i(-[y_i\\log(p_i)+(1-y_i)\\log(1-p_i)])$$\n\n其中：\n- $y_i$表示样本i的label，正类为1，负类为0\n- $p_i$表示样本i预测为正的概率\n\n**(2)多分类**\n\n多分类问题实际上就是对二分类问题的扩展：\n\n$$L=\\frac{1}{N}\\sum_iL_i=\\frac{1}{N}\\sum_i(-\\sum_{j=1}^My_{ij}\\log(p_{ij}))$$\n\n其中：\n- M 表示类别的数量\n- $y_{ij}$表示该类别和样本i类别是否相同，相同为1，不同为0\n- $p_{ij}$表示对于观测样本i属于类别j的预测概率\n\n例如：\n\n|id|predict|label|isCorrect|\n|---|---|---|---|\n|1|0.3 0.3 0.4|0 0 1|1|\n|2|0.3 0.4 0.3|0 1 0|1|\n|3|0.1 0.2 0.7|1 0 0|0|\n\n那么求其Loss：\n$$L_1=-(0\\times \\log 0.3+0\\times \\log 0.3+1\\times \\log 0.4)$$\n$$L_2=-(0\\times \\log 0.3+1\\times \\log 0.4+0\\times \\log 0.3)$$\n$$L_3=-(1\\times \\log 0.1+0\\times \\log 0.2+0\\times \\log 0.7)$$\n对所有样本的Loss求平均\n$$Loss=\\frac{L_1+L_2+L_3}{3}$$\n\n## 参考\n\n[https://zhuanlan.zhihu.com/p/74075915](https://zhuanlan.zhihu.com/p/74075915)\n\n[https://zhuanlan.zhihu.com/p/61944055](https://zhuanlan.zhihu.com/p/61944055)\n\n[https://zhuanlan.zhihu.com/p/35709485](https://zhuanlan.zhihu.com/p/35709485)\n\n[https://blog.csdn.net/b1055077005/article/details/100152102](https://blog.csdn.net/b1055077005/article/details/100152102)","tags":["深度学习","损失函数"],"categories":["人工智能"]},{"title":"深度学习 | 论文笔记（A Review on Generative Adversarial Networks）","slug":"人工智能-A-review-on-GAN","url":"/posts/c63e7cba.html","content":"\n# 1. 论文信息\n\n论文题目：`《A Review on Generative Adversarial Networks: Algorithms, Theory, and Applications》`\n\n![0fe50f6cc4ef45dbaee2e011ea2940bb_th](https://unpkg.com/justlovesmile-img/20201209235414.jpg)\n\n[Arxiv Link : https://arxiv.org/pdf/2001.06937.pdf](https://arxiv.org/pdf/2001.06937.pdf)\n\n# 2. Abstract\n\nGenerative Adversarial Networks (GANs)  have been widely studied since 2014. There are a large number of different GANs variants.\n\n> 生成对抗网络，始于2014年，现在已有很多变种\n\n## Index Terms\n\nDeep Learning ; GANs ; Algorithm ; Theory ; Applications\n\n# 3. Introduction\n\nGANs consists of two models: a generator and a discriminator. These two models are typically implemented by neural networks, but they can be implemented with any form of differentiable system that maps data from one space to the other.\n\n> GANs包括两个模型：一个生成器和一个辨别器。一般是由神经网络实现，但是也可以由不同类型的能映射数据到另一个空间的可微系统实现。\n\nThe generator tries to capture the distribution of true examples for new data example  generation. \n\n> 生成器试图捕获真实示例的分布，以生成新的数据示例。\n\nThe discriminator is usually a binary classifier, discriminating generated examples from the true examples as accurately as possible.\n\n> 鉴别器通常是一个二进制分类器，尽可能准确地将生成的示例与真实的示例区分开来。\n\nThe optimization of GANs is a minimax optimization problem. The goal is to reach Nash equilibrium.\n\n> Nash equilibrium即纳什均衡，对于GANs，其损失是：\n>\n> $$\\min_G \\max_D V(D,G)=\\mathbb{E} _ {x \\sim p_{data}(x)}[\\log D(x)]+\\mathbb{E} _ {z \\sim p_z(z)}[\\log (1-D(G(z)))] $$\n>\n> 生成器G和判别器D两者相互对抗，共同学习，不断优化\n\n# 4. Related Work\n\nGANs belong to generative algorithms\n\n> GANs 属于生成算法\n\n## 4.1 Generative algorithms\n\nGenerative algorithms can be classified into two classes: explicit density model and implicit density model.\n\n> 生成算法可分为两类：显式密度模型和隐式密度模型。\n\n### 4.1.1 Explicit density model\n\nAn explicit density model assumes the distribution and utilizes true data to train the model containing the distribution or fit the distribution parameters. When finished, new examples are produced utilizing the learned model or distribution.\n\n> 显式密度模型假设分布，并利用真实数据训练包含分布的模型或拟合分布参数。完成后，利用学习的模型或分布产生新的示例。\n\nThe explicit density models include maximum likelihood estimation (MLE), approximate inference, and Markov chain method.\n\n> 显式密度模型包括最大似然估计（MLE），近似推断和马尔可夫链方法。\n\n### 4.1.2 Implicit density model\n\nIt produces data instances from the distribution without an explicit hypothesis and utilizes the produced examples to modify the model.\n\n> 它在没有明确假设的情况下从分布中生成数据实例，并利用生成的实例来修改模型。\n\nGANs belong to the directed implicit density model category.\n\n> GANs属于有向隐式密度模型类别。\n\n### 4.1.3 The comparison between GANs and other generative algorithms\n\nThe basic idea behind adversarial learning is that the generator tries to create as realistic examples as possible to deceive the discriminator. The discriminator tries to distinguish fake examples from true examples. Both the generator and discriminator improve through adversarial learning. \n\n> 对抗式学习背后的基本思想是，生成器试图创建尽可能真实的示例来欺骗鉴别器。鉴别器试图区分假例子和真例子。生成器和鉴别器都通过对抗性学习进行改进。\n\n## 4.2 Adversarial idea\n\nAdversarial machine learning is a minimax problem. The defender, who builds the classifier that we want to work correctly, is searching over the parameter space to find the parameters that reduce the cost of the classifier as much as possible. Simultaneously, the attacker is searching over the inputs of the model to maximize the cost.\n\n> 对抗性机器学习是一个极小极大问题。防守者(defender)构建了我们想要正确工作的分类器，他在参数空间中搜索尽可能降低分类器成本（cost）的参数（parameter）。同时，攻击者(attacker)搜索模型的输入以使成本（cost）最大化。\n\n# 5. Algorithms\n\n## 5.1 Generative Adversarial Nets （GANs）\n\nIn order to learn the generator’s distribution $p_g$ over data $x$, a prior on input noise variables is defined as $p_z(z)$ and $z$ is the noise variable. \n\n> 为了了解生成器在数据$x$上的分布$p_g$，将输入噪声变量的先验定义为$p_z(z)$，$z$是噪声变量。\n\nThen, GANs represent a mapping from noise space to data space as $G(z, \\theta_g)$, where G is a differentiable function represented by a neural network with parameters $\\theta_g$. \n\n> GANs将噪声空间到数据空间的映射表示为$G(z, \\theta_g)$，其中G是一个由参数$\\theta_g$的神经网络表示的可微函数\n\nOther than G, the other neural network $D(x, \\theta_d)$ is also defined with parameters $\\theta_d$ and the output of $D(x)$ is a single scalar. $D(x)$ denotes the probability that x was from the data rather than the generator G. \n\n> 除G外，另一个神经网络$D(x, \\theta_d)$ 也根据参数$\\theta_d$定义，$D(x)$的输出为单标量。$D(x)$表示$x$来自数据而不是生成器G的概率。\n\nThe discriminator D is trained to maximize the probability of giving the correct label to both training data and fake samples generated from the generator G. G is trained to minimize $\\log (1 −D (G(z)))$ simultaneously .\n\n> 对鉴别器D进行训练以最大限度地提高对训练数据和从生成器G生成的伪样本给出正确标签的概率。G被训练以同时最小化$\\log(1−D(G(z))$。\n\n### 5.1.1 Objective function\n\n**(1) Original minimax game**\n\nThe objective function of GANs is :\n\n$$\\min_G \\max_D V(D,G)=\\mathbb{E} _ {x \\sim p_{data}(x)}[\\log D(x)]+\\mathbb{E} _ {z \\sim p_z(z)}[\\log (1-D(G(z)))]$$\n\n$\\log D(x)$ is the cross-entropy between $\\begin{bmatrix}1 & 0 \\end{bmatrix}^T$ and $\\begin{bmatrix}D(x) & 1-D(x) \\end{bmatrix}^T$. Similarly, $\\log(1-D(G(z)))$ is the cross-entropy between  $\\begin{bmatrix}0 & 1 \\end{bmatrix}^T$ and $\\begin{bmatrix}D(G(z)) & 1-D(G(z)) \\end{bmatrix}^T$ . \n\n> $\\log D(x)$是$\\begin{bmatrix}1 & 0 \\end{bmatrix}^T$和$\\begin{bmatrix}D(x) & 1-D(x) \\end{bmatrix}^T$之间的[交叉熵](/posts/fdbf585c.html)。同样，$\\log(1-D(G(z)))$是$\\begin{bmatrix}0 & 1 \\end{bmatrix}^T$和$\\begin{bmatrix}D(G(z)) & 1-D(G(z)) \\end{bmatrix}^T$之间的[交叉熵](/posts/fdbf585c.html)。\n","tags":["深度学习","GAN","论文笔记"],"categories":["人工智能"]},{"title":"深度学习 | 如何理解卷积","slug":"人工智能-如何理解卷积","url":"/posts/ef2381bd.html","content":"\n## 1.什么是卷积\n\n对于卷积的定义，如下：\n\n**连续形式**\n\n$$(f×g)(n)=\\int_{-\\infty}^{\\infty}f(\\tau )g(n-\\tau)d\\tau$$\n\n**离散形式**\n\n$$(f×g)(n)=\\sum_{\\tau=-\\infty}^{\\infty}f(\\tau)g(n-\\tau)$$\n\n>先对g函数进行翻转，相当于在数轴上把g函数从右边褶到左边去，也就是卷积的“卷”的由来。\n然后再把g函数平移到n，在这个位置对两个函数的对应点相乘，然后相加，这个过程是卷积的“积”的过程。\n\n上述公式中有一个共同的特征：\n$$n=\\tau + (n - \\tau)$$\n\n对于这个特征，我们可以令$x=\\tau$,$y=n-\\tau$，那么x+y=n就是一些直线\n\n![](https://unpkg.com/justlovesmile-img/v2-8be52f6bada3f7a21cebfc210d2e7ea0_hd.gif)\n\n如果遍历这些直线，就好比，把毛巾沿着角卷起来：\n\n![](https://unpkg.com/justlovesmile-img/v2-1d0c819fc7ca6f8da25435da070a2715_hd.webp)\n\n## 2.通俗易懂的理解卷积\n\n### 2.1离散卷积的例子：丢骰子\n\n**问题：**\n\n把两枚骰子抛出去，两枚骰子点数之和为4的概率是多少\n\n**表示：**\n\n如果用f(x)表示第一枚骰子投出x（x∈{1,2,3,4,5,6}）的概率，g(y)表示第二枚骰子投出y（y∈{1,2,3,4,5,6}）的概率\n\n**结果：**\n\n两枚骰子点数加起来等于4的情况有：\nf(1)g(3)和f(2)g(2)和f(3)g(1)\n\n那么概率为P=f(1)g(3)+f(2)g(2)+f(3)g(1)，符合卷积的定义，把他写成标准形式就是\n$$(f×g)(4)=\\sum_{m=1}^{3}f(m)g(4-m)$$\n\n### 2.2连续卷积的例子：做馒头\n\n**问题：**\n\n如果有一家包子铺，会生产包子，但是包子会坏掉，那么一天后包子总共坏掉了多少？\n\n**表示：**\n\n假设包子生产速度是f(t)，对于包子铺一天生产的包子数量是\n$$\\int_{0}^{24}f(t)dt$$\n假设腐败速度是g(t)，那么n个包子生产出来后，24小时会腐败个数\n$$n * g(t)$$\n\n**结果：**\n\n一天后，包子总共腐败了：\n$$\\int_{0}^{24}f(t)g(24-t)dt$$\n\n### 2.3卷积提取图像特征\n\n![](https://unpkg.com/justlovesmile-img/v2-05f7af4e1d59e82412832c01b1144f52_720w.jpg)\n\n![](https://unpkg.com/justlovesmile-img/v2-c9b00043ba326451979abda5417bfcdf_720w.jpg)\n\n卷积核和图像进行点乘（dot product), 就代表卷积核里的权重单独对相应位置的Pixel进行作用\n\n**这里我想强调一下点乘，虽说我们称为卷积，实际上是位置一一对应的点乘，不是真正意义的卷积**\n\n比如图像位置（1,1）乘以卷积核位置（1,1），仔细观察右上角你就会发现了\n\n例如：对于一张图片\n\n![](https://unpkg.com/justlovesmile-img/20201103204533.png)\n\n\n我们进行手动卷积\n```python\nimport cv2\nimport torch,torchvision\nfrom torchvision import transforms\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom PIL import Image\nimport math\n\npath=\"./1.jpg\"\nimg = Image.open(path)\ntransform = transforms.Compose([transforms.ToTensor()])#totensor 得到（C*H*W)\nim = transform(img)\n\ndef imshow(img):\n    npimg = img\n    plt.imshow(np.transpose(npimg,(1,2,0))) #chw->hwc\n    plt.show()\n\nk = torch.ShortTensor([[0,-4,0],[-4,16,-4],[0,-4,0]])\nstride=2 #步长\npadding=0 # 补0\nf = k.size(0) # 卷积核的形状\nchannels = im.size(0) #输入的图片的通道数\nhin = im.size(1) #输入的图片的高\nwin = im.size(2) #输入的图片的宽\nhout = math.floor((hin-f+2*padding)/stride+1) #输出的图片的高\nwout = math.floor((win-f+2*padding)/stride+1) #输出的图片的宽\nprint(\"input[{},{}],output[{},{}]\".format(hin,win,hout,wout))\noutput=[]\nim = im.numpy()\nk = k.numpy()\nprint(\"Waite for calculating...\")\n# 自定义卷积，一一对应相乘\nfor i in range(channels):\n    lines=[]\n    for j in range(hout):\n        line=[]\n        for n in range(wout):\n            a=[[im[i][j*stride][n*stride],im[i][j*stride][n*stride+1],im[i][j*stride][n*stride+2]],[im[i][j*stride+1][n*stride],im[i][j*stride+1][n*stride+1],im[i][j*stride+1][n*stride+2]],[im[i][j*stride+2][n*stride],im[i][j*stride+2][n*stride+1],im[i][j*stride+2][n*stride+2]]]\n            line.append(sum(sum(a*k)))\n        lines.append(line)\n    output.append(lines)\n\noo=np.array(output)\nprint(oo.shape)\nimshow(oo)\n```\n\n**提取特征效果如下：**\n\n![](https://unpkg.com/justlovesmile-img/20201103211407111.png)\n\n\n部分内容参考[知乎:如何通俗易懂的理解卷积](https://www.zhihu.com/question/22298352/answer/637156871)","tags":["深度学习","卷积"],"categories":["人工智能"]},{"title":"深度学习 | 《深度学习入门之PyTorch》阅读笔记","slug":"人工智能-深度学习入门之PyTorch","url":"/posts/bfa4054.html","content":"\n# 深度学习入门之PyTorch\n\n## 第一章 深度学习介绍\n\n### 1.1 人工智能\n\n1. Artificial Intelligence，人工智能，也称机器智能。\n2. 人工智能分为三大类\n（1）弱人工智能：擅长单方面\n（2）强人工智能：类似人类等级\n（3）超人工智能：全方面胜过人类\n\n### 1.2 数据挖掘，机器学习和深度学习\n\n#### 1.2.1 数据挖掘\n\nKDD（knowledge discovery in database），从数据中获取有意义的信息\n\n#### 1.2.2 机器学习\n\n1. 机器学习是实现人工智能的一种途径，涉及多门学科\n2. 大致分为五个大类\n（1）监督学习：从给定的训练数据集中学习出一个函数，训练集中的目标是由人标注的，常见算法包括回归和分类\n（2）无监督学习：训练集没有人为标注，常见算法如聚类\n（3）半监督学习：介于两者之间\n（4）迁移学习：将已经训练好的模型参数迁移到新的模型来帮助新模型训练数据集\n（5）增强学习：通过观察周围环境来学习\n\n#### 1.2.3 深度学习\n\n1. 机器学习的一个分支，通过模拟人脑来实现数据特征的提取\n2. 常见网络结构：DNN，CNN，RNN，GAN等等\n\n## 第二章 深度学习框架\n\n### 2.1 深度学习框架介绍\n\n1. Tensorflow\nGoogle开源的基于C++开发的数学计算软件\n2. Caffe\n3. Theano\n4. Torch\n支持动态图\n5. MXNet\n\n### 2.2 PyTorch介绍\n\n#### 2.2.1 什么是PyTorch\n\nPython优先的深度学习框架，支持GPU加速和动态神经网络\n\n#### 2.2.2 为什么使用PyTorch\n\n1.多学习一个框架准没错\n2.PyTorch通过一种反向自动求导的技术，可以让你零延迟地改变神经网络\n3.线性，直观，易于使用\n4.代码简洁直观，底层代码友好\n\n### 2.3 配置PyTorch深度学习环境\n\n#### 2.3.1 操作系统\n\nWindows，Linux，Mac\n\n#### 2.3.2 Python开发环境的安装\n\nAnaconda\n\n#### 2.3.3 PyTorch安装\n\n官网或者anaconda\n\nCPU或GPU\n\nCUDA，CuDnn\n\n## 第三章 多层全连接神经网络\n\n### 3.1 PyTorch基础\n\n#### 3.1.1 Tensor张量\n\nTensor相当于多维的矩阵\n\nTensor的数据类型有：(32位浮点型)torch.FloatTensor，（64位浮点型）torch.DoubleTensor，（16位整型）torch.ShortTensor,（32位整型）torch.IntTensor，（64位整型）torch.LongTensor\n\n**导入pytorch**\n\n\n```python\nfrom __future__ import print_function\nimport torch\n```\n\n**创建一个没有初始化的5×3矩阵**\n\n\n```python\nx=torch.empty(5,3)\nprint(x)\n```\n\n**创建一个随机初始化矩阵**\n\n\n```python\n#均匀分布[0,1],rand\nx=torch.rand(5,3)\nprint(x)\n\n#正态分布，randn\nx=torch.randn(5,3)\nprint(x)\n```\n\n**构造一个0矩阵，且数据类型为long**\n\n\n```python\nx=torch.zeros(5,3,dtype=torch.long)\nprint(x)\n```\n\n**直接根据数据构造张量**\n\n\n```python\nx=torch.tensor([5.5,3])\nprint(x)\n```\n\n**创建一个全为1的矩阵，且数据类型为double**\n\n\n```python\nx=torch.ones(5,3)\nprint(x)\n\nx=x.new_ones(5,3,dtype=torch.double)\nprint(x)\n```\n\n**根据已有tensor建立新的tensor，且除非提供新值，将重用所给张量属性**\n\n\n```python\nx=x.new_ones(5,3,dtype=torch.double)\nprint(x)\n\nx=torch.randn_like(x,dtype=torch.float)\nprint(x)\n```\n\n**获取张量的形状**\n\n\n```python\nprint(x.size())\n```\n\n>**注意**\n`torch.Size`本质上还是tuple，所以支持tuple的一切操作\n\n**和numpy的相互转换**\n\n\n```python\nprint(x)\nnumpy_x = x.numpy()\nprint(numpy_x)\ntorch_x = torch.from_numpy(numpy_x)\nprint(torch_x)\n```\n\n**绝对值**\n\n\n```python\na=torch.randn(2,3)\nprint(a)\n\nb=torch.abs(a)\nprint(b)\n```\n\n**运算**，例如加法\n\n**形式一**\n\n\n```python\ny=torch.rand(5,3)\nprint(x+y)\n```\n\n**形式二**\n\n\n```python\nprint(torch.add(x,y))\n```\n\n**形式三**\n\n\n```python\nresult=torch.empty(5,3)\ntorch.add(x,y,out=result)\nprint(result)\n```\n\n**形式四**\n\n\n```python\ny.add_(x)\nprint(y)\n```\n\n>**注意：**\n任何一个in-place改变张量的操作后面都固定一个_。例如x.copy_(y)、x.t_()将更改x\n\n**剪裁**:如果在上下边界内则不变，否则大于上边界值，则改为上边界值，小于下边界值，则改为下边界值\n\n\n```python\na=torch.randn(2,3)\nprint(a)\n\nb=torch.clamp(a,-0.1,0.1)\nprint(b)\n```\n\n**除法**\n\n\n```python\na=torch.randn(2,3)\nb=torch.randn(2,3)\nc=torch.div(a,b)\nd=torch.div(c,10)\nprint(a)\nprint(b)\nprint(c)\nprint(d)\n```\n\n>**加法**add，**乘积**mul，**除法**div，**求幂**pow，**矩阵乘法**mm，**矩阵向量乘法**mv\n\n**改变张量形状**\n\n\n```python\nx=torch.randn(4,4)\ny=x.view(16)\nz=x.view(-1,8) # -1将会自动取值\nprint(x.size(),y.size(),z.size())\n```\n\n**对于只含一个元素的tensor，可以使用`.item()`来得到数值**\n\n\n```python\nx=torch.randn(1)\nprint(x)\nprint(x.item())\n```\n\n**使用GPU**\n\n\n```python\nif torch.cuda.is_available():\n    device = torch.device(\"cuda\")\n    y = torch.ones_like(x, device=device)\n    x = x.to(device)\n    z = x+y\n    print(z)\n    print(z.to(\"CPU\",torch.double))\n```\n\n#### 3.1.2 Variable（变量）\n\n**1. Autograd：自动求导**\n\n**创建一个张量并设置requires_grad=True用来追踪其计算历史**\n\n\n```python\nx=torch.ones(2,2,requires_grad=True)\nprint(x)\n```\n\n**对这个张量做一次运算**\n\n\n```python\ny=x+2\nprint(y)\n# y是计算结果，所以他有grad_fn属性\nprint(y.grad_fn)\n# 对y进行更多操作\nz=y*y*3\nout=z.mean()\nprint(z,out)\n```\n\n.requires_grad_(...) 改变了现有张量的 requires_grad 标志。如果没有指定的话，默认输入的这个标志是 False。\n\n\n```python\na = torch.randn(2, 2)\na = ((a * 3) / (a - 1))\nprint(a.requires_grad)\na.requires_grad_(True)\nprint(a.requires_grad)\nb = (a * a).sum()\nprint(b.grad_fn)\n```\n\n**2. 梯度**\n\n\n```python\nx=torch.ones(2,2,requires_grad=True)\ny=x+2\nz=y*y*3\nout=z.mean()\n# 现在开始反向传播，因为out是一个标量，则out.backward()和out.backward(torch.tensor(1.))等价\nout.backward()\n#输出导数d(out)/dx\nprint(x.grad)\n```\n\n即\n\n$$out=\\frac{1}{4}\\sum_iz_i$$\n\n$$z_i=3(x_i+2)^2$$\n\n并且$ z _ i| _ {x_i=1}=27$，因此，有\n\n$$\\frac{\\partial_{out}}{\\partial_{x_i}}=\\frac{3}{2}(x_i+2)$$\n因此\n$$\\frac{\\partial _ {out}}{\\partial_ {x_i}}|_ {x_i=1}=\\frac{9}{2}=4.5$$\n\n**雅可比矩阵**\n\n数学上，若有向量值函数y=f(x)，那么y相当于对x的梯度是一个雅可比矩阵（下面是一个latex数学公式）\n\n```latex\nJ=\\begin{bmatrix}\n\\frac{\\partial y_1}{\\partial x_1} &\\cdots& \\frac{\\partial y_1}{\\partial x_n} \\\\\n\\vdots & \\ddots & \\vdots \\\\\n\\frac{\\partial y_m}{\\partial x_1} &\\cdots& \\frac{\\partial y_m}{\\partial x_n}\n\\end{bmatrix}\n```\n\n![image-20211125183936512](https://unpkg.com/justlovesmile-img/image-20211125183936512.png)\n\n通常来说，torch.autograd是计算雅可比向量积的一个引擎。也就是说，给定任意向量v，计算乘积$v^TJ$.如果v恰好是一个标量函数l=g(y)的导数，即$v=(\\frac{\\partial l}{\\partial y_1} \\cdots \\frac{\\partial l}{\\partial y_m}^T)$，那么根据链式法则，雅可比向量积应该是l对x的导数\n\n```latex\nJ^T·v=\\begin{bmatrix}\n\\frac{\\partial y_1}{\\partial x_1} &\\cdots& \\frac{\\partial y_m}{\\partial x_1} \\\\\n\\vdots & \\ddots & \\vdots \\\\\n\\frac{\\partial y_1}{\\partial x_n} &\\cdots& \\frac{\\partial y_m}{\\partial x_n}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\frac{\\partial l}{\\partial y_1}\\\\\n\\cdots\\\\\n\\frac{\\partial l}{\\partial y_m}\n\\end{bmatrix}=\n\\begin{bmatrix}\n\\frac{\\partial l}{\\partial x_1}\\\\\n\\cdots\\\\\n\\frac{\\partial l}{\\partial x_n}\n\\end{bmatrix}\n```\n\n![image-20211125184143947](https://unpkg.com/justlovesmile-img/image-20211125184143947.png)\n\n(注意：行向量的$v^T⋅J$也可以被视作列向量的$J^T⋅v$)\n\n雅可比向量积的这一特性使得将外部梯度输入到具有非标量输出的模型中变得非常方便。\n\n\n```python\nx=torch.randn(3,requires_grad=True)\ny=x*2\nwhile y.data.norm() <1000:\n    y=y*2\n\nprint(y)\n```\n\n在这种情况下，y 不再是标量。torch.autograd 不能直接计算完整的雅可比矩阵，但是如果我们只想要雅可比向量积，只需将这个向量作为参数传给 backward\n\n\n```python\nv = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)\ny.backward(v)\n\nprint(x.grad)\n```\n\n也可以通过将代码块包装在 with torch.no_grad(): 中，来阻止autograd跟踪设置了 .requires_grad=True 的张量的历史记录。\n\n\n```python\nprint(x.requires_grad)\nprint((x ** 2).requires_grad)\n\nwith torch.no_grad():\n    print((x ** 2).requires_grad)\n```\n\n**3. Variable**\n\nVariable和Tensor的区别，Variable会被放入计算图中，然后进行前向传播，反向传播，自动求导\n\nVariable是在torch.autograd.Variable中\n\n\n```python\nfrom torch.autograd import Variable\n\nx=Variable(torch.Tensor([1]),requires_grad=True)\nw=Variable(torch.Tensor([2]),requires_grad=True)\nb=Variable(torch.Tensor([3]),requires_grad=True)\n\ny=w*x+b\n\ny.backward()\n\nprint(x.grad)\nprint(w.grad)\nprint(b.grad)\n```\n\n**搭建一个简单的神经网络**\n\n\n```python\nbatch_n = 100 # 一个批次中输入数据的数量\nhidden_layer = 100 # 经过隐藏层后保留的数据特征的个数\ninput_data = 1000 # 每个数据包含的数据量\noutput_data = 10 # 每个输出的数据包含的数据量\n\nx=torch.randn(batch_n,input_data) #100*1000\ny=torch.randn(batch_n,output_data) #100*10\n\nw1=torch.randn(input_data,hidden_layer) #1000*100\nw2=torch.randn(hidden_layer,output_data) # 100*10\n\nepoch_n = 20 #训练的次数\nlearning_rate = 1e-6 #学习率\n\nfor epoch in range(epoch_n):\n    h1=x.mm(w1)#100*100\n    h1=h1.clamp(min=0) # if x<0 ,x=0\n    y_pred=h1.mm(w2) #100*10，前向传播预测结果\n    \n    loss = (y_pred - y).pow(2).sum() #损失函数，即均方误差\n    print(\"Epoch:{}, Loss:{:.4f}\".format(epoch,loss))\n    grad_y_pred = 2*(y_pred-y) #dloss/dy\n    grad_w2 = h1.t().mm(grad_y_pred) #dloss/dy * dy/dw2\n    \n    grad_h = grad_y_pred.clone() #复制\n    grad_h = grad_h.mm(w2.t()) #dloss/dy * dy/dh1\n    grad_h.clamp_(min=0) # if x<0 ,x=0\n    grad_w1 = x.t().mm(grad_h) \n    \n    w1 -= learning_rate*grad_w1 #梯度下降\n    w2 -= learning_rate*grad_w2\n```\n\n**使用Variable搭建一个自动计算梯度的神经网络**\n\n\n```python\nfrom torch.autograd import Variable\n\nbatch_n = 100 # 一个批次中输入数据的数量\nhidden_layer = 100 # 经过隐藏层后保留的数据特征的个数\ninput_data = 1000 # 每个数据包含的数据量\noutput_data = 10 # 每个输出的数据包含的数据量\n\nx=Variable(torch.randn(batch_n,input_data),requires_grad = False) #requires_grad = False不保留梯度\ny=Variable(torch.randn(batch_n,output_data),requires_grad = False)\nw1=Variable(torch.randn(input_data,hidden_layer),requires_grad = True) #requires_grad = True自动保留梯度\nw2=Variable(torch.randn(hidden_layer,output_data),requires_grad = True)\n\nepoch_n = 20\nlearning_rate = 1e-6\n\nfor epoch in range(epoch_n):\n    y_pred = x.mm(w1).clamp(min = 0).mm(w2) #y_pred=w2*(w1*x)\n    loss = (y_pred-y).pow(2).sum() #损失函数\n    print(\"Epoch:{},Loss:{:.4f}\".format(epoch,loss))\n    \n    loss.backward() #后向传播计算\n    \n    w1.data -= learning_rate*w1.grad.data\n    w2.data -=learning_rate*w2.grad.data\n    \n    w1.grad.data.zero_() #置0\n    w2.grad.data.zero_()\n```\n\n**使用nn.Module自定义传播函数来搭建神经网络**\n\n\n```python\nfrom torch.autograd import Variable\n\nbatch_n = 100\nhidden_layer = 100\ninput_data = 1000\noutput_data = 10\n\nclass Model(torch.nn.Module):\n    def __init__(self):\n        super(Model,self).__init__()\n    \n    def forward(self,input_n,w1,w2):\n        x = torch.mm(input_n,w1)\n        x = torch.clamp(x,min=0)\n        x = torch.mm(x,w2)\n        return x\n    \n    def backward(self):\n        pass\n    \nmodel = Model()\n\nx=Variable(torch.randn(batch_n,input_data),requires_grad = False) #requires_grad = False不保留梯度\ny=Variable(torch.randn(batch_n,output_data),requires_grad = False)\nw1=Variable(torch.randn(input_data,hidden_layer),requires_grad = True) #requires_grad = True自动保留梯度\nw2=Variable(torch.randn(hidden_layer,output_data),requires_grad = True)\n\nepoch_n = 20\nlearning_rate = 1e-6\n\nfor epoch in range(epoch_n):\n    y_pred = model(x,w1,w2)\n    loss = (y_pred-y).pow(2).sum()\n    print(\"Epoch:{},Loss:{:.4f}\".format(epoch,loss))\n    loss.backward() #后向传播计算\n    \n    w1.data -= learning_rate*w1.grad.data\n    w2.data -=learning_rate*w2.grad.data\n    \n    w1.grad.data.zero_() #置0\n    w2.grad.data.zero_()\n```\n\n#### 3.1.3 Dataset(数据集)\n\ntorch.utils.data.Dataset是代表这一数据的抽象类，可以自己定义数据类继承和重写这个抽象类，只需要定义`__len__`和`__getitem__`函数即可\n\n\n```python\nfrom torch.utils.data import Dataset\nclass myDataset(Dataset):\n    def __init__(self, csv_file, txt_file, root_dir, other_file):\n        self.csv_data = pd.read_csv(csv_file)\n        with open(txt_file, 'r') as f:\n            data_list=f.readlines()\n        self.txt_data = data_list\n        self.root_dir = root_dir\n        \n    def __len__(self):\n        return len(self.csv_data)\n    \n    def __getitem__(self,idx):\n        data = (self.csv_data[idx],self.txt_data[idx])\n        return data\n```\n\n通过上面的方式，可以定义需要的数据类，可以通过迭代的方法取得每一个数据，但是这样很难实现取batch，shuffle或者多线程去读取数据，所以Pytorch中提供了torch.utils.data.DataLoader来定义一个新迭代器\n\n\n```python\nfrom torch.utils.data import DataLoader\ndataiter = DataLoader(myDataset,batch_size=32)\n```\n\n#### 3.1.4 nn.Module(模组)\n\n所有的层结构和损失函数来自torch.nn\n\n\n```python\nfrom torch import nn\n\nclass net_name(nn.Module):\n    def __init__(self,other_arguments):\n        super(net_name, self).__init__()\n        self.conv1 = nn.Conv2d(in_channels,out_channels, kernel_size)\n    \n    def forward(self,x):\n        x = self.conv1(x)\n        return x\n```\n\n一个神经网络的典型训练过程如下：\n\n- 定义包含一些可学习参数(或者叫权重）的神经网络\n- 在输入数据集上迭代\n- 通过网络处理输入\n- 计算loss(输出和正确答案的距离）\n- 将梯度反向传播给网络的参数\n- 更新网络的权重，一般使用一个简单的规则：weight = weight - learning_rate * gradient\n\n**使用torch.nn内的序列容器Sequential**\n\n\n```python\nbatch_n = 100\nhidden_layer = 100\ninput_data = 1000\noutput_data = 10\n\n# 第一种方式\nmodels_1 = torch.nn.Sequential(\n    torch.nn.Linear(input_data,hidden_layer),\n    torch.nn.ReLU(),\n    torch.nn.Linear(hidden_layer,output_data)\n)\n\n# 第二种方式\nfrom collections import OrderedDict\nmodels_2 = torch.nn.Sequential(OrderedDict([\n    (\"Line1\",torch.nn.Linear(input_data,hidden_layer)),\n    (\"ReLU1\",torch.nn.ReLU()),\n    (\"Line2\",torch.nn.Linear(hidden_layer,output_data))])    \n)\n\nprint(models_1)\nprint(models_2)\n```\n\n**使用nn.Module定义一个神经网络**\n\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\n\nclass Net(nn.Module):\n\n    def __init__(self):\n        super(Net, self).__init__()\n        # 输入图像channel：1；输出channel：6；5x5卷积核\n        self.conv1 = nn.Conv2d(1, 6, 5)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        # an affine operation: y = Wx + b\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        # 2x2 Max pooling\n        x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))\n        # 如果是方阵,则可以只使用一个数字进行定义\n        x = F.max_pool2d(F.relu(self.conv2(x)), 2)\n        x = x.view(-1, self.num_flat_features(x))\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x\n\n    def num_flat_features(self, x):\n        size = x.size()[1:]  # 除去批处理维度的其他所有维度\n        num_features = 1\n        for s in size:\n            num_features *= s\n        return num_features\n\n\nnet = Net()\nprint(net)\n```\n\n#### 3.1.5 torch.optim(优化)\n\n优化算法分为两大类：\n\n（1）一阶优化算法\n使用各个参数的梯度值来更新参数，最常用的是梯度下降。梯度下降的功能是通过寻找最小值，控制方差，更新模型参数，最终使模型收敛，网络的参数更新公式\n$$\\theta = \\theta - \\eta × \\frac{\\partial J(\\theta)}{\\partial \\theta}$$\n其中$\\eta$是学习率，$\\frac{\\partial J(\\theta)}{\\partial \\theta}$是函数的梯度\n\n（2）二阶优化算法\n二阶优化算法使用了二阶导数（Hessian方法）来最小化或最大化损失函数，主要是基于牛顿法\n\n```python\noptimizer=torch.optim.SGD(model.parameters(),lr=0.01,momentum=0.9)\n```\n\n#### 3.1.6 模型的保存和加载\n\n1.保存\n\n```python\n#保存模型\ntorch.save(model,path)\n#保存模型的状态\ntorch.save(model.state_dict(),path)\n```\n\n2.加载\n\n```python\n#加载完整的模型\nload_model = torch.load(path)\n#加载模型参数，需要先导入模型的结构\nmodel.load_state_dic(torch.load(path))\n```\n\n### 3.2 线性模型\n\n#### 3.2.1 介绍\n\nf(x)=wx+b\n\nf(x)=w1x1+w2x2+...+wdxd+b\n\nw和b都是需要学习的参数\n\n#### 3.2.2 一维线性回归\n\n给定数据集D={(x1,y1),(x2,y2),...,(xm,ym)}，线性回归希望得到一个f(x)=wx+b能够很好的拟合y\n\n方法是利用$Loss=\\sum_{i=1}^m(f(x_i)-y_i)^2$来衡量误差，即均方误差，那么\n$$(w^*,b^*)=arg\\min_{w,b}\\sum_{i=1}^m(f(x_i)-y_i)^2=arg\\min_{w,b}\\sum_{i=1}^m(y_i-wx_i-b)^2$$\n\n求解办法：求它的偏导数,并让其为0来估计参数\n$$\\frac{\\partial Loss_{(w,b)}}{\\partial w} = 2(w\\sum_{i=1}^{m}x_i^2-\\sum_{i=1}^{m}(y_i-b)x_i)=0$$\n$$\\frac{\\partial Loss_{(w,b)}}{\\partial b} = 2(mb-\\sum_{i=1}^{m}(y_i-wx_i))=0$$\n得到w和b的最优解\n$$w=\\frac{\\sum_{i=1}^{m}y_i(x_i- \\bar x)}{\\sum_{i=1}^{m}x_i^2-\\frac{1}{m}(\\sum_{i=1}^{m}x_i)^2}$$\n$$b=\\frac{1}{m}\\sum_{i=1}^{m}(y_i-wx_i)$$\n其中$\\bar x$是x的均值\n$$\\bar x = \\frac{1}{m}\\sum_{i=1}^{m}x_i$$\n\n#### 3.2.3 多维线性回归\n\n$$f(x_i)=w^Tx_i+b$$\n为使得$\\sum_{i=1}^{m}(f(x_i)-y_i)^2$最小，这也称为“多元线性回归”，使用最小二乘法对w和b进行估计，假设有d个属性，将w和d写入同一个矩`阵，将数据集D表示成一个m×(d+1)的矩阵X，即\n\n```latex\nX=\\begin{bmatrix}\nx_{11} & x_{12} & \\cdots & x_{1d} & 1 \\\\\nx_{21} & x_{22} & \\cdots & x_{2d} & 1 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\nx_{m1} & x_{m2} & \\cdots & x_{md} & 1\n\\end{bmatrix}=\n\\begin{bmatrix}\nx_1^T & 1\\\\\nx_2^T & 1\\\\\n\\vdots & \\vdots\\\\\nx_m^T & 1\n\\end{bmatrix}\n```\n\n![image-20211125184508266](https://unpkg.com/justlovesmile-img/image-20211125184508266.png)\n\n将目标y也写成乘向量的形式y=(y1,y2,...,ym),那么可得\n$$w^* = arg \\min_w(y-Xw)^T(y-Xw)$$\n对其求导，令它为0\n$$\\frac{\\partial Loss_w}{\\partial w}=2X^T(Xw-y)=0$$\n\n>上面涉及到矩阵的逆运算，所以需要$X^TX$是一个满秩矩阵或者正定矩阵\n\n可以得到:\n$$w ^ * =(X^TX)^{-1}X^Ty$$\n故回归模型可以写成：\n$$f(x _ i)=x _ i^T(X^TX)^{-1}X^Ty$$\n\n#### 3.2.4 一维线性回归的代码实现\n\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx_train = np.array([[3.3],[4.4],[5.5],[6.71],[6.93],[4.168],[9.779],[6.182],[7.59],[2.167],[7.042],[10.791],[5.313],[7.997],[3.1]],dtype=np.float32)\ny_train = np.array([[1.7],[2.76],[2.09],[3.19],[1.694],[1.573],[3.366],[2.596],[2.53],[1.221],[2.827],[3.465],[1.65],[2.904],[1.3]],dtype=np.float32)\n\nx_train = torch.from_numpy(x_train)\ny_train = torch.from_numpy(y_train)\n\nclass LinearRegression(nn.Module):\n    def __init__(self):\n        super(LinearRegression,self).__init__() #继承父类\n        self.linear = nn.Linear(1,1) # 1*1\n    \n    def forward(self,x):\n        out=self.linear(x)\n        return out\n\nif torch.cuda.is_available():\n    model = LinearRegression().cuda()\nelse:\n    model = LinearRegression()\n\ncriterion = torch.nn.MSELoss() # 均方误差\n#优化函数，model.parameters()为该实例中可优化的参数，lr为参数优化的选项（学习率等）\noptimizer = torch.optim.SGD(model.parameters(),lr=1e-3) #梯度下降\n\nnum_epochs = 1000\n\nfor epoch in range(num_epochs):\n    if torch.cuda.is_available():\n        inputs = Variable(x_train).cuda()\n        target = Variable(y_train).cuda()\n    else:\n        inputs = Variable(x_train)\n        target = Variable(y_train)\n    # forward\n    out = model(inputs)\n    loss = criterion(out,target) #均方误差\n    # backward\n    optimizer.zero_grad() #置0\n    loss.backward() #求梯度\n    optimizer.step() #更新所有的参数，梯度下降\n    \n    if(epoch+1)%50==0:\n        print('Epoch[{}/{}],Loss:{:.6f}'.format(epoch+1,num_epochs,loss))\n\nmodel.eval() #将模型变成测试模式\npredict = model(Variable(x_train))\npredict = predict.data.numpy()\n#画图\n#plt.plot(x_train.numpy(),y_train.numpy(),'ro',label='Original data')\n#plt.plot(x_train.numpy(),predict,label=\"Fitting Line\")\n#plt.show()\n```\n\n![](https://unpkg.com/justlovesmile-img/20201022195143.png)\n\n#### 3.2.5 多项式回归\n\n对于$y=b+w_1×x+w_2×x^2+w_3×x^3$，预处理数据，变成矩阵形式\n\n```latex\nX=\\begin{bmatrix}\nx_1 & x_1^2 & x_1^3 \\\\\nx_2 & x_2^2 & x_2^3 \\\\\n\\vdots & \\ddots & \\vdots \\\\\nx_n & x_n^2 & x_n^3\n\\end{bmatrix}\n```\n\n![image-20211125184611404](https://unpkg.com/justlovesmile-img/image-20211125184611404.png)\n\n\n```python\ndef make_features(x):\n    x=x.unsqueeze(1)  # 在第1维（从0开始）增加一维\n    return torch.cat([x ** i for i in range(1,4)],1) #1代表横着拼接x,x^2,x^3\n\nw_target = torch.FloatTensor([0.5,3,2.4]).unsqueeze(1) # 在第1维（从0开始）加一层\nb_target = torch.FloatTensor([0.9])\n\ndef f(x):\n    #定义∑wix^i+b\n    return x.mm(w_target) + b_target[0]\n\ndef get_batch(batch_size=32):\n    #产生数据\n    random = torch.randn(batch_size)\n    x = make_features(random)\n    y = f(x)\n    if torch.cuda.is_available():\n        return Variable(x).cuda(),Variable(y).cuda()\n    else:\n        return Variable(x),Variable(y)\n\nclass poly_model(nn.Module):\n    def __init__(self):\n        super(poly_model,self).__init__()\n        self.poly = nn.Linear(3,1)\n\n    def forward(self,x):\n        out = self.poly(x)\n        return out\n    \nif torch.cuda.is_available():\n    model = poly_model().cuda()\nelse:\n    model = poly_model()\n    \ncriterion = nn.MSELoss() # 均方误差\noptimizer = torch.optim.SGD(model.parameters(),lr=1e-3)#梯度下降\n\nepoch = 0\n\nwhile True:\n    batch_x,batch_y = get_batch()\n    #前向传播\n    output = model(batch_x)\n    loss = criterion(output,batch_y)\n    epoch+=1\n    if epoch%50 ==0:\n        print(\"Epoch:{},Loss:{:.6f}\".format(epoch,loss.data.item()))\n    optimizer.zero_grad() #置0\n    loss.backward() #后向传播\n    optimizer.step() #优化参数\n    \n    if loss <1e-2:\n        break\n    \n```\n\n>注意：\n`torch.nn`只支持小批量处理`(mini-batches）`。整个`torch.nn`包只支持小批量样本的输入，不支持单个样本的输入。\n比如，`nn.Conv2d` 接受一个4维的张量，即`nSamples x nChannels x Height x Width`.\n如果是一个单独的样本，只需要使用`input.unsqueeze(0)`来添加一个“假的”批大小维度。\n\n### 3.3 分类问题\n\n#### 3.3.1 问题介绍\n\n机器学习中的监督学习主要分为回归问题和分类问题，对于回归问题，希望预测的结果是连续的，对于分类问题所预测的结果是离散的。\n\n监督学习从数据中学习一个分类模型或者分类决策函数，被称为分类器\n\n#### 3.3.2 Logistic起源\n\n著名的二分类算法，Logistic回归。起源于对人口数量增长情况的研究\n\n#### 3.3.3 Logistic分布\n\n设x是连续的随机变量，服从Logistic分布是指X的分布函数和密度函数是如下\n$$F(x)=P(X≤x)=\\frac{1}{1+e^{-(x-\\mu)/\\gamma}}$$\n$$f(x)=\\frac{e^{-(x-\\mu)/\\gamma}}{\\gamma (1+e^{-(x-\\mu)/\\gamma})^2}$$\n其中μ影响中心对称点的位置，γ越小中心点附件的增长速度越快\nSigmoid函数是Logistic分布函数中γ=1，μ=0的特殊形式，表达式如下：$$p(x)=\\frac{1}{1+e^{-x}}$$\n\n#### 3.3.4 二分类的Logistic回归\n\n假设输入的数据的特征向量$x∈R^n$，那么决策边界可以表示为$\\sum_{i=1}^{n}w_ix_i+b=0$，建设存在一个样本点使得$h_w(x)=\\sum_{i=1}^{n}w_ix_i+b>0$，那么判定它的类别是1，如果<0，判定其类别是0.\nLogistic回归通过找到分类概率P(Y=1)与输入变量x的直接关系，然后通过比较概率值来判断类别，简单来说就是通过计算下面两个概率分布\n$$P(Y=0|x)=\\frac{1}{1+e^{wx+b}}$$\n$$P(Y=1|x)=\\frac{e^{wx+b}}{1+e^{wx+b}}$$\n其中w是权重，b是偏置\n\n>一个事件发生的几率（odds）是指该事件发生的概率（p）与不发生的概率的比值（1-p），该事件的对数几率或logit函数是：$logit(p)=log\\frac{p}{1-p}$\n\n对于Logistic回归而言，可以得到：\n$$log \\frac{P(Y=1|x)}{1-P(Y=1|x)}=wx+b$$\n\n#### 3.3.5 模型的参数估计\n\n对于给定的训练集数据T={(x1,y1),(x2,y2),...,(xn,yn)}，其中$x_i \\in R^n,y_i \\in ${0,1}，假设P(Y=1|x)=Π(x)，那么P(Y=0|x)=1-Π(x)，所以似然函数为：\n$$\\prod_{i=1}^{n}[\\pi (x_i)]^{y_1}[1-\\pi (x_i)]^{1-y_i}$$\n取对数后的对数似然函数：\n$$L(w)=\\sum_{i=1}^{n}[y_i(wx_i+b)-log(1+e^{wx_i+b})]$$\n用L(w)对w求导：\n$$\\frac{\\partial L(w)}{\\partial w}=\\sum_{i=1}^{n}y_ix_i-\\sum_{i=1}^{n}\\frac{e^{wx_i+b}}{1+e^{wx_i+b}}x_i=\\sum_{i=1}^{n}(y_i-logit(wx_i))x_i$$\n$$\\frac{\\partial L(w)}{\\partial b}=\\sum_{i=1}^{n}y_i-\\sum_{i=1}^{n}\\frac{e^{wx_i+b}}{1+e^{wx_i+b}}=\\sum_{i=1}^{n}(y_i-logit(wx_i))$$\n\n#### 3.3.6 Logistic回归的代码实现\n\n\n```python\nimport requests\n\n#获取数据\nurl=\"https://cdn.jsdelivr.net/gh/Justlovesmile/code-of-learn-deep-learning-with-pytorch/chapter3_NN/logistic-regression/data.txt\"\ndata = requests.get(url)\ndata_list=data.text.split('\\n')[:-1]\ndata_list=[i.split(',') for i in data_list]\ndata = [(float(i[0]),float(i[1]),float(i[2])) for i in data_list]\n\nnp_data = np.array(data, dtype='float32') # 转换成 numpy array\nx_data = torch.from_numpy(np_data[:, 0:2]) # 转换成 Tensor, 大小是 [100, 2]\ny_data = torch.from_numpy(np_data[:, -1]).unsqueeze(1) # 转换成 Tensor，大小是 [100, 1]\n\n#print(x_data,y_data)\n\n#画数据的散点图\nx0=list(filter(lambda x:x[-1]==0.0,data))\nx1=list(filter(lambda x:x[-1]==1.0,data))\nplot_x0_0 = [i[0] for i in x0]\nplot_x0_1 = [i[1] for i in x0]\nplot_x1_0 = [i[0] for i in x1]\nplot_x1_1 = [i[1] for i in x1]\n\nplt.plot(plot_x0_0,plot_x0_1,'ro',label=\"x_0\") #0类用红色\nplt.plot(plot_x1_0,plot_x1_1,'bo',label=\"x_1\") #1类用蓝色\nplt.legend(loc='best') #图例的位置\n\n#分类\nclass LogisticRegression(nn.Module):\n    def __init__(self):\n        super(LogisticRegression,self).__init__() #继承\n        self.lr = nn.Linear(2,1) #2*1\n        self.sm = nn.Sigmoid() #sigmoid函数\n        \n    def forward(self,x):\n        x=self.lr(x)\n        x=self.sm(x)\n        return x\n    \nlogistic_model = LogisticRegression()\nif torch.cuda.is_available():\n    logistic_model.cuda()\n\ncriterion = nn.BCELoss() #二分类的损失函数\n#随机梯度下降优化，parameters是可优化参数，lr是学习率，momentum是动量因子\noptimizer = torch.optim.SGD(logistic_model.parameters(),lr=1e-3,momentum=0.9)\n\nfor epoch in range(20000):\n    if torch.cuda.is_available():\n        x=Variable(x_data).cuda()\n        y=Variable(y_data).cuda()\n    else:\n        x=Variable(x_data)\n        y=Variable(y_data)\n    #forward\n    out = logistic_model(x)\n    loss = criterion(out,y)\n    mask = out.ge(0.5).float() #if out>0.5,out=1,else out=0\n    acc = float((mask == y_data).sum().item()) / y_data.shape[0]\n    #backward\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    if(epoch+1)%2000 ==0:\n        print('*'*10)\n        print('Epoch: {},Loss: {:.4f},Acc: {:.4f}'.format(epoch+1,loss,acc))\n\n# 画线w1x+w2y+b=0\nw0,w1 = logistic_model.lr.weight[0]\nb = logistic_model.lr.bias.data[0]\nplot_x = np.arange(30,100,0.1)\nw0=w0.data\nw1=w1.data\nplot_y = (-w0*plot_x-b) /w1\nplt.plot(plot_x,plot_y)\nplt.show()\n```\n\n![](https://unpkg.com/justlovesmile-img/20201023124844.png)\n\n### 3.4 简单多层全连接前向网络\n\n#### 3.4.1 模拟神经元\n\n神经网络就是受到了模拟脑神经元的启发\n\n#### 3.4.2 单层神经网络的分类器\n\n例如之前的Logistic回归，是使用了sigmoid函数作为激活函数的一层神经网络\n\n#### 3.4.3 激活函数\n\n1.Sigmoid函数\n\n$$\\sigma (x)=\\frac{1}{1+e^{-x}}$$\n\n缺点：\n（1）造成梯度消失。在靠近0，1两端，梯度几乎为0，导致没有信息来更新参数\n（2）输出不是以0为均值。\n\n2.Tanh\n\n$$tanh(x)=2\\sigma(2x)-1$$\n\nTanh激活函数是sigmoid函数的变形，将输入的数据转化到-1到1之间，解决了sigmoid函数第二个问题，但仍存在梯度消失的问题\n\n3.ReLU\n\nReLU的数学表达式为$f(x)=max(0,x)$\n\n优点：\n（1）相比较sigmoid和tanh，ReLU可以极大地加速随机梯度下降法的收敛速度，因为是线性的，不存在梯度消失\n（2）计算方法更简单\n\n缺点：\n训练的时候很脆弱，一个很大的梯度经过ReLU激活函数，更新参数之后，会使得这个神经元不会对任何数据有激活现象，之后再经过ReLU的梯度都是0，参数无法更新。可以通过设置较小的学习率来避免这个问题\n\n4.Leaky ReLU\n\nReLU的变式，为了修复ReLU脆弱的缺点，将x<0的部分变成一个很小的负的斜率，但是效果时好时不好\n\n5.Maxout\n\n$$f(x)=max(w_1x+b_1,w_2x+b_2)$$\nReLU只是Maxout中w1=0，b1=0的特殊形式\n\n优点：包含ReLU的优点，避免了ReLU的脆弱性\n缺点：参数存储变大\n\n#### 3.4.4 神经网络的结构\n\n神经网络是一个由神经元组成的无环图\n\nnn.Linear(in,out，bias=False)是全连接神经网络层的函数\n\n#### 3.4.5 模型的表示能力与容量\n\n在实际中，我们可能发现一个三层的全连接神经网络比一个两层的全连接神经网络表现更好，但是更深的网络结构对全连接神经网络效果提升表现不大。\n我们需要注意的是，增大网络的层数和每层的节点数，相当于在增大网络的容量，容量的增大意味着网络有着更大的潜在表现能力。\n\n但是当我们在做一个二分类问题时，更复杂的模型或许有着更复杂的形状，能将测试用例完美的分类，但是却忽略了潜在的数学关系，将噪声的干扰放大，这种效果被称为过拟合\n\n### 3.5 深度学习的基石：反向传播算法\n\n#### 3.5.1 链式法则\n\n求导的链式法则（高数知识）\n\n#### 3.5.2 反向传播算法\n\n是链式求导法则的应用\n\n局部求导，不断迭代传播\n\n### 3.6 各种优化算法的变式\n\n#### 3.6.1 梯度下降法\n\n梯度下降的更新公式\n$$x^i=x^{i-1}-\\eta \\nabla L(x^{i-1})$$\n\n#### 3.6.2 梯度下降法的变式\n\n1.SGD\n随机梯度下降法，每次使用一批（batch）数据进行梯度的计算，而不是全部数据的梯度\n\n2.Momentum\n在随机梯度下降的同时，增加动量（momentum），帮助跳出一些鞍点或局部极小值点\n\n3.Adagrad\n自适应学习率的方法，公式是\n$$w^{t+1}←w^{t}-\\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t}(g^i)^2}+\\varepsilon }$$\n\n学习率在不断变小，但是在某些情况下会导致学习过早停止\n\n4.RMSprop\n一种非常有效的自适应学习率的改进方法，公式是\n$$cache^t=\\alpha * cache^{t-1}+(1-\\alpha)(g^t)^2$$\n$$w^{t+1}←w^{t}-\\frac{\\eta}{\\sqrt{cache^t+\\varepsilon}}g^t$$\n其中α是衰减率，能有效避免Adagrad学习率一直递减太多的问题，能够更快地收敛\n\n5.Adam\n一种综合型学习方法，可以看成RMSprop加上momentum的学习方法\n\n### 3.7 处理数据和训练模型的技巧\n\n#### 3.7.1 数据预处理\n\n1.中心化\n变成0均值\n\n2.标准化\n使得每个特征维度的最大值和最小值按比例缩放到-1到1之间\n\n3.PCA（主成分分析）\n将数据去相关性，将其投影到一个特征空间，取一些较大的，主要的特征向量来降低数据的维度\n\n4.白噪声\n将数据投影到一个特征空间，然后每个维度除以特征值来标准化这些数据\n\n#### 3.7.2 权重初始化\n\n1.全0初始化\n不应该采用这种策略\n\n2.随机初始化\n包括了高斯随机化，均匀随机化\n\n3.稀疏初始化\n\n4.初始化偏置\n\n5.批标准化\n\n#### 3.7.3 防止过拟合\n\n1.正则化\n2.Dropout\n\n### 3.8 多层全连接神经网络实现MNIST手写数字分类\n\n\n```python\nimport torch\nfrom torch import nn,optim\nfrom torch.autograd import Variable\nfrom torch.utils.data import DataLoader\nfrom torchvision import datasets,transforms\n\n#带有批标准化和激活函数的三层全连接神经网络\nclass Batch_Net(nn.Module):\n    def __init__(self,in_dim,n_hidden_1,n_hidden_2,out_dim):\n        super(Batch_Net,self).__init__()\n        self.layer1 = nn.Sequential(nn.Linear(in_dim,n_hidden_1),nn.BatchNorm1d(n_hidden_1),nn.ReLU(True))\n        self.layer2 = nn.Sequential(nn.Linear(n_hidden_1,n_hidden_2),nn.BatchNorm1d(n_hidden_2),nn.ReLU(True))\n        self.layer3 = nn.Sequential(nn.Linear(n_hidden_2,out_dim))\n    \n    def forward(self,x):\n        x=self.layer1(x)\n        x=self.layer2(x)\n        x=self.layer3(x)\n        return x\n\nbatch_size = 64\nlearning_rate = 1e-2\nnum_epoch = 20\n\n#transforms.ToTensor()将图片转换成PyTorch中从处理的对象，并自动将图片标准化了，即范围0到1\n#transforms.Normalize(均值，方差)，处理：减均值，除以方差\n#图片为灰度图，只有一个通道，如果是三通道则为transforms.Normalize([a,b,c],[d,e,f])\ndata_tf = transforms.Compose(\n    [transforms.ToTensor(),transforms.Normalize([0.5],[0.5])]\n)\n\n# 获取数据集\ntrain_dataset = datasets.MNIST(root=\"./data\",train=True,transform=data_tf,download=True)\ntest_dataset = datasets.MNIST(root=\"./data\",train=False,transform=data_tf)\n# 数据迭代器，传入数据集和batch_size，通过shuffle=True来表示是否将数据打乱\ntrain_loader = DataLoader(train_dataset,batch_size=batch_size,shuffle=True)\ntest_loader = DataLoader(test_dataset,batch_size=batch_size,shuffle=False)\n\nmodel = Batch_Net(28*28,300,100,10)\nif torch.cuda.is_available():\n    model = model.cuda()\n\ncriterion = nn.CrossEntropyLoss() #交叉熵\n# 优化\noptimizer = optim.SGD(model.parameters(),lr=learning_rate)\n\n#训练\nfor epoch in range(num_epoch):\n    eval_loss = 0\n    eval_acc = 0\n    for data in train_loader:\n        img,label=data\n        img = img.view(img.size(0),-1)\n        if torch.cuda.is_available():\n            img = Variable(img).cuda()\n            label = Variable(label).cuda()\n        else:\n            img = Variable(img)\n            label = Variable(label)\n        out=model(img)\n        loss = criterion(out,label)\n        # backward\n        optimizer.zero_grad() #置0\n        loss.backward() #求梯度\n        optimizer.step() #更新所有的参数，梯度下降\n        #acc\n        eval_loss +=loss*label.size(0)\n        _,pred = torch.max(out,1)\n        num_correct = (pred == label).sum()\n        eval_acc +=num_correct\n        print('Epoch:{},Loss: {:.6f},Acc:{:.6f}'.format(epoch,eval_loss/(len(train_dataset)),float(eval_acc)/(len(train_dataset))))\n\n        \n#测试\nmodel.eval()\neval_loss = 0\neval_acc = 0\nfor data in test_loader:\n    img,label=data\n    img = img.view(img.size(0),-1)\n    if torch.cuda.is_available():\n        img = Variable(img).cuda()\n        label = Variable(label).cuda()\n    else:\n        img = Variable(img)\n        label = Variable(label)\n    out=model(img)\n    loss = criterion(out,label)\n    eval_loss +=loss.data*label.size(0)\n    _,pred = torch.max(out,1)\n    num_correct = (pred == label).sum()\n    eval_acc +=num_correct.data\n\nprint('Test Loss: {:.6f},Acc:{:.6f}'.format(eval_loss/(len(test_dataset)),float(eval_acc)/(len(test_dataset))))\n```\n\n## 第四章 卷积神经网络\n\n1998年由Yann Lecun提出，2012年Alex Krizhecsky凭借它赢得了ImageNet挑战赛\n\n### 4.1 主要任务及起源\n\n对于计算机视觉，主要用提取图像中的特征\n\n### 4.2 卷积神经网络的原理和结构\n\n一，卷积神经网络的三种思想\n\n1.局部性\n\n对于图片而言，需要检测图片中的特征来决定图片的类别，通常情况下这些特征都不是由整张图片决定的，而是由一些局部的区域决定的\n\n2.相同性\n\n对不同图片，如果具有同样的特征，这些特征会出现在不同位置，但特征检测所作的操作几乎一样\n\n3.不变性\n\n对于一张大图片，如果进行下采样，那么图片的性质基本保持不变\n\n二，卷积神经网络的层结构\n\n对于全连接神经网络，其由一系列隐藏层构成，每个隐藏层由若干个神经元构成，其中每个神经元都和前一层的所有神经元相关联，但是每一层中的神经元是相互独立的。全连接神经网络在处理图片时，比如在minist数据集上，图片大小是28×28，那么每层的单个神经元的权重数目就是28×28=784，但这知识一张小图片，且只有一个通道，如果是大图片，那么就会导致参数增长特别快，所以全连接神经网络在处理图像并不是好的选择\n\n而卷积神经网络是一个3D容量的神经元，每个神经元由三个维度排列：宽带，高度和深度。如果输入的图片是32×32×3，那么这张图片的宽度就是32，高度也是32，深度是3\n\n卷积神经网络的主要层结构有三个：卷积层，池化层，全连接层，通过堆叠这些层结构形成了一个完整的卷积神经网络结构，其中一些层包含参数（如：卷积层，全连接层），一些层不包含参数（如：激活层，池化层）。\n\n#### 4.2.1 卷积层\n\n卷积层是卷积神经网络的核心\n\n1.概述\n\n卷积神经网络的参数，是由一些可学习的滤波器集合构成，每个滤波器在空间上（宽度和高度）都比较小，但深度和输入数据的深度保持一致。在前向传播时，让每个滤波器都在输入数据的宽度和高度上滑动（卷积），然后计算整个滤波器和输入数据任意一处的内积。\n当滤波器沿着输入数据的宽度和高度滑动时，会生成一个二维的激活图。每个卷积层上，会有一整个集合的滤波器，这样会形成多个二维的不同的激活图，将这些激活图在深度方向堆叠起来形成卷积层的输出\n\n2.局部连接\n\n与神经元连接的空间大小叫做神经元的感受野，其大小是一个人为设置的超参数，其实是滤波器的宽和高\n\n3.空间排列\n\n卷积层的输出深度是一个超参数，与使用的滤波器数量一致，并且在滑动滤波器的时候必须指定步长\n\n4.边界填充\n\n可以将输入数据用0在边界进行填充，用来控制输出数据在空间上的尺寸，输出的尺寸可以用一个公式来计算，$\\frac{W-F+2P}{S}+1$，其中W是输入的数据大小，F表示卷积层中神经元的感受野尺寸，S表示步长，P表示边界填充0的数量\n\n5.步长的限制\n\n步长的选择是有所限制的。当输入尺寸W是10时，如果不使用0填充，即P=0，滤波器尺寸F=3，这样步长S=2就行不通，因为(10-3+0)/2+1=4.5，不是一个整数，说明神经元不能整齐对称地滑过输入数据体，这样的超参数是无效的\n\n6.参数共享\n\n输出体数据在深度切片上所有的权重都使用同一个权重向量，那么卷积层在向前传播的过程中每个深度切片都可以看成是神经元的权重对输入数据体做卷积，这也就是为什么把这些3D的权重集合称为滤波器或者卷积核\n\n7.总结\n\n卷积层的性质\n- （1）输入数据体尺寸是W1×H1×D1\n- （2）4个超参数：卷积核数量K，卷积核空间尺寸F，滑动步长S，零填充的数量P\n- （3）输出数据体的尺寸为W2×H2×D2，其中$W_2=\\frac{W_1-F+2P}{S}+1$,$H_2=\\frac{H_1-F+2P}{S}+1$,D2=K\n- （4）由于参数共享，每个卷积核包含的权重数目为F×F×D1，卷积层一共有F×F×D1×K个权重和K个偏置\n- （5）在输出体数据中，第d个深度切片（空间尺寸是W2×H2），用第d个卷积器和输入数据进行有效卷积运算的结果，再加上第d个偏置\n\n对于卷积神经网络的一些超参数，常见的设置是F=3，S=1，P=1\n\n#### 4.2.2 池化层\n\n通常或者卷积层之间周期性插入一个池化层，作用是逐渐减低数据体的空间尺寸，这样能减少网络中参数的数量，减少计算资源耗费，同时也能有效地控制过拟合\n\n步骤：设定一个空间窗口，不断滑动窗口，取这些窗口中的最大值作为输出结果\n\n池化层之所有有效，是因为之前介绍的图片特征具有不变性，也就是通过下采样不会丢失图片拥有的特征\n\n常用的池化层形式是尺寸为2×2的窗口，滑动步长是2，对图像进行下采样，将其中75%的激活信息都丢掉，选择其中最大的保留，池化层很少引入零填充\n\n除最大值池化外，还有平均池化，或者L2范数池化，实际证明，最大池化效果最好，平均池化一般放在卷积神经网络最后一层\n\n#### 4.2.3 全连接层\n\n全连接层的每个神经元与前一层所有的神经元全部连接，在这个过程中为了防止过拟合会引入`Dropout`。在进入全连接层之前，使用全局平均池化能够有效地降低过拟合\n\n#### 4.2.4 卷积神经网络的基本形式\n\n卷积神经网络最常见的形式就是将一些卷积层和`ReLU`层放在一起，有可能在`ReLU`层前面加上批标准化层，随后紧跟池化层，再不断重复，直到图像被缩小到一个足够小的尺寸，然后将特征图展开，连接几层全连接层，最后输出结果\n\n1.小滤波器的有效性\n\n2.网络的尺寸\n\n经验\n（1）输入层：一般而言，输入层的大小应该能够被2整除很多次，常用的数字包括32，44，96，224\n（2）卷积层：卷积层应该尽可能使用小尺寸，比如3×3或5×5，滑动步长取1。7×7通常用在第一个面对原始图像的卷积层上\n（3）池化层：池化层负责对输入的数据空间维度进行下采样，常用的设置使用2×2的感受野做最大值池化，步长取2\n（4）零填充：零填充的使用可以让卷积层的输入和输出在空间上的维度保持一致\n\n\n### 4.3 Pytorch卷积模块\n\n#### 4.3.1 卷积层\n\n`nn.Conv2d(in_channels,out_channels,kernel_size,stride,padding,dilation,groups,bias)`\n其中\n- `in_channels`对应输入数据体的深度\n- `out_channels`对应输出数据体的深度\n- `kernel_size`表示滤波器（卷积核）的大小，例如：`kernel_size=3`或`kernel_size=(3,2)`\n- `stride`表示滑动步长，默认`1`\n- `padding=0`表示四周不进行零填充，`padding=1`表示四周进行`1`个像素点的零填充，默认`0`\n- `bias`是一个布尔值，默认为`True`，表示使用偏置\n- `groups`表示输出数据体深度上的联系，默认`groups=1`，即所有的输出和输入都是相关联的，如果`groups=2`表示输入的深度被分割成两份，输出的深度也被分割成两份，他们之间分别对应起来，所以要求输出和输入都必须要能被`groups`整除\n- `dilation`表示卷积对于输入数据体的空间间隔，默认为`1`\n\n#### 4.3.2 池化层\n\n`nn.MaxPool2d(kernel_size,stride,padding,dilation,return_indices,ceil_model)`\n其中\n- `kernel_size`,`stride`,`padding`,`dilation`和卷积层相同\n- `return_indices`表示是否返回最大值所处的下标，默认为`False`\n- `ceil_mode`表示使用一些方格代替层结构，默认`False`\n\n`nn.AvgPool2d()`表示均值池化，里面的参数和MaxPool2d类似，但多一个参数`count_include_pad`表示计算均值的时候是否包含零填充，默认为`True`\n\n其他还有`nn.LPPool2d()`,`nn.AdaptiveMaxPool2d()`\n\n**下面是一个简单的多层卷积神经网络**\n\n\n```python\nfrom torch import nn\n\nclass SimpleCNN(nn.Module):\n    def __init__(self):\n        super(SimpleCNN,self).__init__()\n        layer1 = nn.Sequential()\n        layer1.add_module('conv1',nn.Conv2d(3,32,3,1,padding=1))\n        layer1.add_module('relu1',nn.ReLU(True))\n        layer1.add_module('pool1',nn.MaxPool2d(2,2))\n        self.layer1=layer1\n\n        layer2 = nn.Sequential()\n        layer2.add_module('conv2',nn.Conv2d(32,64,3,1,padding=1))\n        layer2.add_module('relu2',nn.ReLU(True))\n        layer2.add_module('pool2',nn.MaxPool2d(2,2))\n        self.layer2=layer2\n        \n        layer3 = nn.Sequential()\n        layer3.add_module('conv3',nn.Conv2d(64,128,3,1,padding=1))\n        layer3.add_module('relu3',nn.ReLU(True))\n        layer3.add_module('pool3',nn.MaxPool2d(2,2))\n        self.layer3=layer3\n\n        layer4 = nn.Sequential()\n        layer4.add_module('fc1',nn.Linear(2048,512))\n        layer4.add_module('fc_relu1',nn.ReLU(True))\n        layer4.add_module('fc2',nn.Linear(512,64))\n        layer4.add_module('fc_relu2',nn.ReLU(True))\n        layer4.add_module('fc3',nn.Linear(64,10))\n        self.layer4=layer4\n    \n    def forward(self,x):\n        conv1 = self.layer1(x)\n        conv2 = self.layer2(conv1)\n        conv3 = self.layer3(conv2)\n        fc_input = conv3.view(conv3.size(0),-1)\n        fc_out = slef.layer4(fc_input)\n        return fc_out\n\nmodel = SimpleCNN()\nprint(model)\n```\n\n#### 4.3.3 提取层结构\n\nnn.Module具有几个重要属性\n- `children()`，会返回下一级模块的迭代器，比如上面这个模型，直会返回在`self.layer1`,`slef.layer2`,`slef.layer3`以及`self.layer4`上的迭代器，不会返回他们内部的东西\n- `modules()`，会返回模型中所有模块的迭代器，这样就有了一个好处，即它能够访问到最内层，比如`self.layer1.conv1`这个模块\n- `named_children()`和`named_modules()`不仅会返回模块的迭代器，还会返回网络层的名字\n\n\n```python\n#提取前面两层\nprint(nn.Sequential(*list(model.children())[:2]))\n```\n\n**提取所有的卷积层**\n\n\n```python\nconv_model = nn.Sequential()\nfor layer in model.named_modules():\n    if isinstance(layer[1],nn.Conv2d):\n        conv_model.add_module(layer[0].split('.')[-1],layer[1])\n\nprint(conv_model)\n```\n\n#### 4.3.4 提取参数及自定义初始化\n\n`nn.Module`关于参数的属性\n- `named_parameters()`，给出网络层的名字和参数的迭代器\n- `parameters()`，给出一个网络的全部参数的迭代器\n\n\n```python\nfor param in model.named_parameters():\n    print(param[0])\n```\n\n**对权重初始化**，因为权重是Variable，只需要取出data属性就能处理\n\n```python\nfor m in model.modules():\n    if isinstance(m,nn.Conv2d):\n        nn.init.normal(m.weight.data)\n        nn.init.xavier_normal(m.weight.data)\n        nn.init.kaiming_normal(m.weight.data)#卷积层参数初始化\n        m.bias.data.fill_(0)\n    elif isinstance(m,nn.Linear):\n        m.weight.data.normal_()#全连接层参数初始化\n```\n\n### 4.4 卷积神经网络案例分析\n\n#### 4.4.1 LeNet\n\nLeNet是整个卷积神经网络的开山之作，共有7层，其中2层卷积和2层池化层交替出现，最后输出3层全连接层得到整体的效果\n\n\n```python\nclass Lenet(nn.Module):\n    def __init__(self):\n        super(Lenet,self).__init__()\n        layer1 = nn.Sequential()\n        layer1.add_module('conv1',nn.Conv2d(1,6,3,padding=1))\n        layer1.add_module('pool1',nn.MaxPool2d(2,2))\n        self.layer1 = layer1\n        \n        layer2 = nn.Sequential()\n        layer2.add_module('conv2',nn.Conv2d(6,16,5))\n        layer2.add_module('pool2',nn.MaxPool2d(2,2))\n        self.layer2 = layer2\n        \n        layer3 = nn.Sequential()\n        layer3.add_module('fc1',nn.Linear(400,120))\n        layer3.add_module('fc2',nn.Linear(120,84))\n        layer3.add_module('fc3',nn.Linear(84,10))\n        self.layer3 = layer3\n        \n    def forward(self,x):\n        x = self.layer1(x)\n        x = self.layer2(x)\n        x = x.view(x.size(0),-1) # 将第二次卷积的输出拉伸为一行\n        x = self.layer3(x)\n        return x\n```\n\n#### 4.4.2 AlexNet\n\n\n```python\nclass AlexNet(nn.Module):\n    def __init__(self,num_classes):\n        super(AlexNet,self).__init__()\n        self.features = nn.Sequential(\n            nn.Conv2d(3,64,kernel_size=11,stride=4,padding=2),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=3,stride=2),\n            nn.Conv2d(64,192,kernel_size=5,padding=2),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=3,stride=2),\n            nn.Conv2d(192,384,kernel_size=3,padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(384,256,kernel_size=3,padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(256,256,kernel_size=3,padding=1),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=3,stride=2),\n        )\n        self.classifier = nn.Sequential(\n            nn.Dropout(),\n            nn.Linear(256*6*6,4096),\n            nn.ReLU(inplace=True),\n            nn.Dropout(),\n            nn.Linear(4096,4096),\n            nn.ReLU(inplace=True),\n            nn.Linear(4096,num_classes),\n        )\n        \n    def forward(self,x):\n        x = self.features(x)\n        x = x.view(x.size(0),256*6*6)\n        x = self.classifier(x)\n        return x\n```\n\n#### 4.4.3 VGGNet\n\n使用了更小的滤波器，同时使用了更深的结构\n\n\n```python\nclass VGG(nn.Module):\n    def __init__(self,num_classes):\n        super(VGG,self).__init__()\n        self.features = nn.Sequential(\n            nn.Conv2d(3,64,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.Conv2d(64,64,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.MaxPool2d(kernel_size=2,stride=2),\n            nn.Conv2d(64,128,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.Conv2d(128,128,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.MaxPool2d(kernel_size=2,stride=2),\n            nn.Conv2d(128,256,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.Conv2d(256,256,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.Conv2d(256,256,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.MaxPool2d(kernel_size=2,stride=2),\n            nn.Conv2d(256,512,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.Conv2d(512,512,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.Conv2d(512,512,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.MaxPool2d(kernel_size=2,stride=2),\n            nn.Conv2d(512,512,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.Conv2d(512,512,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.Conv2d(512,512,kernel_size=3,padding=1),\n            nn.ReLU(True),\n            nn.MaxPool2d(kernel_size=2,stride=2),\n        )\n        self.classifier = nn.Sequential(\n            nn.Linear(512*7*7,4096),\n            nn.ReLU(True),\n            nn.Dropout(),\n            nn.Linear(4096,4096),\n            nn.ReLU(True),\n            nn.Dropout(),\n            nn.Linear(4096,num_classes),\n        )\n        self._initialize_weights()\n        \n    def forward(self,x):\n        x = self.features(x)\n        x = x.view(x.size(0),-1)\n        x = self.classifier(x)\n```\n\n#### 4.4.4 GoogleNet\n\n也叫InceptionNet，采用了比VGG更深的网络结构，一共22层，但是参数却比AlexNet少了12倍，同时有很高的计算效率，因为它采用了一种很有效的Inception模块，而且没有全连接层。\n\n**Inception模块**\n\n\n```python\nclass BasicConv2d(nn.Module):\n    def __init__(self,in_channels,out_channels,**kwargs):\n        super(BasicConv2d,self).__init__()\n        self.conv = nn.Conv2d(in_channels,out_channels,bias=False,**kwargs)\n        self.bn = nn.BatchNorm2d(out_channels,eps=0.001)\n    \n    def forward(self,x):\n        x = self.conv(x)\n        x = self.bn(x)\n        return F.relu(x,inplace=True)\n\nclass Inception(nn.Module):\n    def __init__(self,in_channels,pool_features):\n        super(Inception,self).__init__()\n        self.branch1x1 = BasicConv2d(in_channels,64,kernel_size=1)\n        self.branch5x5_1 = BasicConv2d(in_channels,48,kernel_size=1)\n        self.branch5x5_2 = BasicConv2d(48,64,kernel_size=5,padding=2)\n        \n        self.branch3x3db1_1 = BasicConv2d(in_channels,64,kernel_size=1)\n        self.branch3x3db1_2 = BasicConv2d(64,96,kernel_size=3,padding=1)\n        self.branch3x3db1_3 = BasicConv2d(96,96,kernel_size=3,padding=1)\n        \n        self.branch_pool = BasicConv2d(in_channels,pool_features,kernel_size=1)\n    \n    def forward(self,x):\n        branch1x1 = self.branch1x1(x)\n        \n        branch5x5 = self.branch5x5_1(x)\n        branch5x5 = self.branch5x5_2(branch5x5)\n        \n        branch3x3db1 = self.branch3x3db1_1(x)\n        branch3x3db1 = self.branch3x3db1_2(branch3x3db1)\n        branch3x3db1 = self.branch3x3db1_3(branch3x3db1)\n        \n        branch_pool = F.avg_pool2d(x,kernel_size=3,stride=1,padding=1)\n        branch_pool = self.branch_pool(branch_pool)\n        \n        outputs = [branch1x1,branch5x5,branch3x3db1,branch_pool]\n        return torch.cat(outputs,1) #按深度拼接\n```\n\n#### 4.4.5 ResNet\n\n由微软研究院提出，通过残差模块能够成功地训练高达152层深的神经网络\n\nResNet 最初的设计灵感来自这个问题:在不断加深神经网络的时候，会出现一个Degradation ，即准确率会先上升然后达到饱和，再持续增加深度则会导致模型准确率下降。\n\n这并不是过拟合的问题，因为不仅在验证集上误差增加，训练集本身误差也会增加，假设一个比较浅的网络达到了饱和的准确率，那么在后面加上几个恒等映射层，误差不会增加，也就说更深的模型起码不会使得模型效果下降。\n\n这里提到的使用恒等映射直接将前一层输出传到后面的思想，就是 ResNet 的灵感来源。假设某个神经网络的输入是x， 期望输出是 H(x)，如果直接把输入x传到输出作为初始结果，那么此时需要学习的目标就是 F(x) = H (x) - x\n![](https://unpkg.com/justlovesmile-img/20201027143439.png)\n左边是一个普通的网络，右边是一个 ResNet 的残差学习 单元， ResNet 相当于将学习目 标改变了.不再是学习一个完整的输出H ( x ) ， 而是学习输出和输入的差别H (x) - x，即残差。\n\n除了这些比较出名的以外还有很多。并且并不需要重复造轮子，PyTorch内为我们实现了以上网络，都在`torchvision.model`里面，并且大部分网络都有预训练好的参数\n\n### 4.5 再实现MNIST手写数字分类\n\n```python\nimport torch\nfrom torch import nn,optim\nfrom torch.autograd import Variable\nfrom torch.utils.data import DataLoader\nfrom torchvision import datasets,transforms\n\nclass CNN(nn.Module):\n    def __init__(self):\n        super(CNN,self).__init__()\n        self.layer1 = nn.Sequential(\n            nn.Conv2d(1,16,kernel_size=3),\n            nn.BatchNorm2d(16),# 归一化处理，使得数据分布一致，避免梯度消失或梯度爆炸\n            nn.ReLU(inplace=True)\n        )\n        self.layer2 = nn.Sequential(\n            nn.Conv2d(16,32,kernel_size=3),\n            nn.BatchNorm2d(32),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2,stride=2)\n        )\n        \n        self.layer3 = nn.Sequential(\n            nn.Conv2d(32,64,kernel_size=3),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True)\n        )\n        \n        self.layer4 = nn.Sequential(\n            nn.Conv2d(64,128,kernel_size=3),\n            nn.BatchNorm2d(128),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2,stride=2)\n        )\n        \n        self.fc = nn.Sequential(\n            nn.Linear(128*4*4,1024),\n            nn.ReLU(inplace=True),\n            nn.Linear(1024,128),\n            nn.ReLU(inplace=True),\n            nn.Linear(128,10)\n        )\n        \n    def forward(self,x):\n        x  = self.layer1(x)\n        x  = self.layer2(x)\n        x  = self.layer3(x)\n        x  = self.layer4(x)\n        x = x.view(x.size(0),-1)\n        x  = self.fc(x)\n        return x\n    \nbatch_size = 64\nlearning_rate = 1e-2\nnum_epoch = 5\n\ndata_tf = transforms.Compose(\n    [transforms.ToTensor(),transforms.Normalize([0.5],[0.5])]\n)\n\n# 获取数据集\ntrain_dataset = datasets.MNIST(root=\"./data\",train=True,transform=data_tf,download=True)\ntest_dataset = datasets.MNIST(root=\"./data\",train=False,transform=data_tf)\n# 数据迭代器，传入数据集和batch_size，通过shuffle=True来表示是否将数据打乱\ntrain_loader = DataLoader(train_dataset,batch_size=batch_size,shuffle=True)\ntest_loader = DataLoader(test_dataset,batch_size=batch_size,shuffle=False)\n\nmodel = CNN()\nif torch.cuda.is_available():\n    model = model.cuda()\n\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(),lr=learning_rate)\n\nfor epoch in range(num_epoch):\n    eval_loss = 0.0\n    eval_acc = 0.0\n    print(\"Epoch {}/{}\".format(epoch,num_epoch))\n    print(\"-\"*20)\n    for data in train_loader:\n        img,label=data\n        if torch.cuda.is_available():\n            img = Variable(img).cuda()\n            label = Variable(label).cuda()\n        else:\n            img = Variable(img)\n            label = Variable(label)\n        out=model(img)\n        loss = criterion(out,label)\n        # backward\n        optimizer.zero_grad() #置0\n        loss.backward() #求梯度\n        optimizer.step() #更新所有的参数，梯度下降\n        #acc\n        eval_loss += loss.data\n        _,pred = torch.max(out,1)\n        eval_acc += (pred == label).sum()\n        print('Epoch:{},Loss: {:.4f},Acc:{:.4f}%'.format(epoch,eval_loss/(len(train_dataset)),100*float(eval_acc)/(len(train_dataset))))\n\n        \nPATH='./minist_net.pth'\nprint(\"Train finished!\")\ntorch.save(model.state_dict(), PATH)\n```\n\n### 4.6 图像增强的方法\n\ntorchvision.transforms包括所有图像增强的方法\n- Scale，对图片的尺寸进行缩小和放大\n- CenterCrop，对图像正中心进行给定大小的随机裁剪\n- RandomCrop，对图片进行给定大小的随机裁剪\n- RandomHorizaontalFlip，对图像进行概率为0.5的随机水平翻转\n- RandomSizedCrop，首先对图片进行随机尺寸的裁剪，然后对裁剪图片进行一个随即比例的缩放，最后将图片变成给定的大小\n- Pad，对图片进行边界零填充\n\n除此之外，还可以使用OpenCV或者PIL等第三方图形库来实现\n\n### 4.7 实现cifar10分类\n\ncifar10数据集中有60000张图片，每张图片的大小都是32×32的三通道彩色图\n\n\n```python\nimport torch\nimport torchvision\nimport torchvision.transforms as transforms\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport os\nimport numpy as np\nfrom torch.autograd import Variable\n\n#数据处理\ntrain_transform = transforms.Compose([\n    transforms.Scale(40),\n    transforms.RandomHorizontalFlip(),\n    transforms.RandomCrop(32),\n    transforms.ToTensor(),\n    transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])\n])\n\ntest_transform = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])\n])\n\n#数据集获取\ntrain_set = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=train_transform)\ntrain_data = torch.utils.data.DataLoader(train_set, batch_size=32, shuffle=True)\n\ntest_set = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=test_transform)\ntest_data = torch.utils.data.DataLoader(test_set, batch_size=32, shuffle=False)\n\nclasses = ('plane', 'car', 'bird', 'cat',\n           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')\n#3×3卷积层\ndef conv3x3(in_channel, out_channel, stride=1):\n    return nn.Conv2d(in_channel, out_channel, 3, stride=stride, padding=1, bias=False)\n\nclass residual_block(nn.Module):\n    def __init__(self, in_channel, out_channel, same_shape=True):\n        super(residual_block, self).__init__()\n        self.same_shape = same_shape\n        stride = 1 if self.same_shape else 2\n          \n        self.conv1 = conv3x3(in_channel, out_channel, stride=stride)\n        self.bn1 = nn.BatchNorm2d(out_channel)\n          \n        self.conv2 = conv3x3(out_channel, out_channel)\n        self.bn2 = nn.BatchNorm2d(out_channel)\n        if not self.same_shape:\n            self.conv3 = nn.Conv2d(in_channel, out_channel, 1, stride=stride)\n        \n    def forward(self, x):\n        out = self.conv1(x)\n        out = F.relu(self.bn1(out), True)\n        out = self.conv2(out)\n        out = F.relu(self.bn2(out), True)\n          \n        if not self.same_shape:\n            x = self.conv3(x)\n        return F.relu(x+out, True)\n\n\nclass resnet(nn.Module):\n    def __init__(self, in_channel, num_classes):\n        super(resnet, self).__init__()\n        self.block1 = nn.Conv2d(in_channel, 64, 7, 2,3) # 32-7+2*3/2+1=16\n        self.block2 = nn.Sequential(\n            nn.MaxPool2d(3, 1),\n            residual_block(64, 64),\n            residual_block(64, 64)\n        )\n        self.block3 = nn.Sequential(\n            residual_block(64, 128, False),\n            residual_block(128, 128)\n        )\n        self.block4 = nn.Sequential(\n            residual_block(128, 256, False),\n            residual_block(256, 256)\n        )\n        self.block5 = nn.Sequential(\n            residual_block(256, 512, False),\n            residual_block(512, 512)\n        )\n        self.avg_pool = nn.AvgPool2d(2)\n        self.classifier = nn.Linear(512, num_classes)\n          \n    def forward(self, x):\n        x = self.block1(x)\n        #print(x.shape)\n        x = self.block2(x)\n        #print(x.shape)\n        x = self.block3(x)\n        #print(x.shape)\n        x = self.block4(x)\n        #print(x.shape)\n        x = self.block5(x)\n        #print(x.shape)\n        x = self.avg_pool(x)\n        x = x.view(x.size(0), -1)\n        x = self.classifier(x)\n        return x\n\nPATH = './cifar_net.pth'\nnet = resnet(3, 10)\n#if os.path.exists(PATH):\n#    net.load_state_dict(torch.load(PATH))\ncriterion = nn.CrossEntropyLoss() #交叉熵\noptimizer = optim.Adam(net.parameters(), lr=0.01) \n\nfrom datetime import datetime\n\n#计算正确率\ndef get_acc(output, label):\n    total = output.shape[0]\n    _, pred_label = output.max(1)\n    num_correct = (pred_label == label).sum().data\n    return float(num_correct) / total\n\ndef train(net, train_data, valid_data, num_epochs, optimizer, criterion):\n    if torch.cuda.is_available():\n        net = net.cuda()\n    #计时\n    prev_time = datetime.now()\n    for epoch in range(num_epochs):\n        print(\"*\"*10)\n        train_loss = 0.0\n        train_acc = 0.0\n        net = net.train() #训练模式\n        for data in train_data:\n            im,label = data\n            if torch.cuda.is_available():\n                im = Variable(im.cuda())\n                label = Variable(label.cuda())\n            else:\n                im = Variable(im)\n                label = Variable(label)\n            #forward\n            output = net(im)\n            loss = criterion(output, label)\n            #forward\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n               \n            train_loss += loss.data\n            train_acc += get_acc(output, label)\n        #计时\n        cur_time = datetime.now()\n        h, remainder = divmod((cur_time-prev_time).seconds, 3600)\n        m, s = divmod(remainder, 60)\n        time_str = \"Time %02d:%02d:%02d\" % (h, m, s)\n        #测试\n        if valid_data is not None:\n            valid_loss = 0.0\n            valid_acc = 0.0\n            net = net.eval() # 切换测试模式\n            for data in valid_data:\n                im, label = data\n                if torch.cuda.is_available():\n                    im = Variable(im.cuda())\n                    label = Variable(label.cuda())\n                else:\n                    im = Variable(im)\n                    label = Variable(label)\n                output = net(im)\n                loss = criterion(output, label)\n                valid_loss += loss.item()\n                valid_acc += get_acc(output, label)\n            epoch_str = (\n                \"Epoch %d. Train Loss: %f, Train Acc: %f, Valid Loss: %f, Valid Acc: %f, \"\n                % (epoch, train_loss / len(train_data),\n                   train_acc / len(train_data), valid_loss / len(valid_data),\n                   valid_acc / len(valid_data)))\n        else:\n            epoch_str = (\"Epoch %d. Train Loss: %f, Train Acc: %f, \" %\n                         (epoch, train_loss / len(train_data),\n                          train_acc / len(train_data)))\n               \n        prev_time = cur_time\n        print(epoch_str + time_str)\n\ntrain(net, train_data, test_data, 10, optimizer, criterion) \nprint('Finished Training')\n\ntorch.save(net.state_dict(), PATH)\n```\n\n**测试**\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ntest_set = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=test_transform)\ntest_data = torch.utils.data.DataLoader(test_set, batch_size=4, shuffle=False)\n\n# 输出图像的函数\ndef imshow(img):\n    img = img / 2 + 0.5     # unnormalize\n    npimg = img.numpy()\n    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n    plt.show()\n\ndataiter = iter(test_data)\nimages, labels = dataiter.next()\n\n#print(images.shape)\n# 输出图片\nimshow(torchvision.utils.make_grid(images))\nprint('GroundTruth: ', ' '.join('%5s' % classes[labels[j]] for j in range(4)))\n\nPATH = './cifar_net.pth'\nnet.load_state_dict(torch.load(PATH))\n\noutputs = net(images)\n\n_, predicted = torch.max(outputs, 1)\n\nprint('Predicted: ', ' '.join('%5s' % classes[predicted[j]] for j in range(4)))\n\nclass_correct = list(0. for i in range(10))\nclass_total = list(0. for i in range(10))\nwith torch.no_grad():\n    for data in test_data:\n        images, labels = data\n        outputs = net(images)\n        _, predicted = torch.max(outputs, 1)\n        c = (predicted == labels).squeeze()\n        for i in range(4):\n            label = labels[i]\n            class_correct[label] += c[i].item()\n            class_total[label] += 1\n\n\nfor i in range(10):\n    print('Accuracy of %5s : %2d %%' % (\n        classes[i], 100 * class_correct[i] / class_total[i]))\n```\n\n## 第五章 循环神经网络\n\nRNN，在序列问题和自然语言处理等领域取得很大的成功\n\n### 5.1 循环神经网络\n\n卷积神经网络相当于人类的视觉，但是它没有记忆能力，所以它只能处理一种特定的视觉任务，没办法根据以前的记忆来处理新的任务。\n\n循环神经网络的提出便是居于记忆模型的想法，期望网络能够记住前面出现的特征，并依据特征推断后面的结果，而且整体的网络结构不断循环，因而得名循环神经网络\n\n比如：某一个单词的意思会因为上文提到的内容不同而有不同的含义，RNN可以很好的解决这类问题\n\n#### 5.1.1 问题介绍\n\n对于下面两句话\n\n- arrive beijing on November 2nd\n- leave beijing on November 2nd\n\n第一句话表达到达，第二句话表示离开，如果网络能构记忆“beijing”前面的词，就会预测出不同的结果。\n\n#### 5.1.2 循环神经网络的基本结构\n\n将网络的输出保存在一个记忆单元中，这个记忆单元和下一次的输入一起进入神经网络中。因此，输入序列（sequences）的顺序改变，会改变网络的输出结果。\n\n![](https://unpkg.com/justlovesmile-img/v2-206db7ba9d32a80ff56b6cc988a62440_r.jpg)\n![](https://unpkg.com/justlovesmile-img/v2-b0175ebd3419f9a11a3d0d8b00e28675_r.jpg)\n\n这个网络在t时刻接收到输入$x_t$之后，隐藏层的值是$S_t$，输出值是$O_t$。关键一点是，$S_t$的值不仅仅取决于$x_t$，还取决于$S_{t-1}$。我们可以用下面的公式来表示循环神经网络的计算方法：\n\n$$O _ t = g(VS_t)$$\n$$S _ t = f(UX_t+WS_{t-1})$$\n\n#### 5.1.3 存在的问题\n\n循环神经网络具有很好的记忆特性，能够将记忆内容应用到当前情景下，但是记忆最大的问题在于遗忘性\n\n### 5.2 循环神经网络的变式：LSTM和GRU\n\n#### 5.2.1 LSTM\n\nLSTM是Long Short Term Memory Networks的缩写，是一种链式循环的网络结构，在网络内部有着更复杂的结构，主要为了解决长序列训练过程中的梯度下降和梯度爆炸问题。\n\nLSTM由三个门来控制，分别是输入门，遗忘门和输出门。顾名思义，输入门控制着网络的输入，遗忘门控制着记忆单元，输出门控制着网络的输出。这其中最重要的就是遗忘门，遗忘门的作用是决定之前的哪些记忆及那个被保留，那些记忆将被去掉，正是由于遗忘门的作用，使得LSTM具有了长时记忆的功能\n\n#### 5.2.2 GRU\n\nGRU是Gated Recurrent Unit的缩写，由Cho于2014年提出，GRU和LSTM最大的不同在于GRU将遗忘门和输入门合成了一个“更新门”，同时网络不再额外给出记忆状态Ct，而是将输出结果ht作为记忆状态不断向后循环传递，网络的输出和出入变得简单\n\n#### 5.2.3 收敛性问题\n\n如果写了一个简单的LSTM网络去训练数据，会发现loss并不会按照想象的方式下降，而是在乱跳，这是因为RNN的误差曲面粗糙不平导致的，而解决方法是梯度裁剪（gradient clipping）\n\n### 5.3 循环神经网络的PyTorch实现\n\n#### 5.3.1 PyTorch的循环网络模块\n\n**1.标准RNN**\n\n`nn.RNN()`\n**参数**\n- `input_size`表示输入$x_t$的维度\n- `hidden_size`表示输出$h_t$的维度\n- `num_layers`表示网络层数，默认为1层\n- `nonlinearity`表示非线性激活函数，默认为tanh，可选relu\n- `bias`表示是否使用偏置，默认为True\n- `batch_first`决定网络输入的维度顺序，默认输入顺序（seq,batch,feature），如果设置为True，则顺序为（batch，seq，feature）\n- `dropout`，接受一个0到1的数值，并在除最后一层的其他输出层加上dropout层\n- `bidirectional`默认是False，如果设置为True，就是双向循环神经网络的结构\n\n**网络接受的输入**\n\n- 序列输入$x_t$：$x_t$的维度是（seq，batch，feature），分别表示序列长度，批量和输入的特征维度\n- 记忆输入$h_0$：$h_0$也叫隐藏状态，它的维度是（layers×direction，batch，hidden），分别表示层数乘方向（单向1，双向2），批量和输出的维度\n\n**网络的输出**\n\n- output，表示网络实际的输出，维度是（seq，batch，hidden×direction），分别表示序列长度，批量和输出维度乘方向\n- $h_n$表示记忆单元，维度是（layer×direction，batch，hidden）分别表示层数乘方向，批量，输出维度\n\n```python\nbasic_rnn = nn.RNN(input_size=20,hidden_size=50,num_layers=2)\n\ntoy_input = Variable(torch.randn(100,32,20)) # seq,batch,input_size\nh_0 = Variable(torch.rand(2,32,50)) # layer * direction,batch,hidden_size\n\ntoy_output,h_n = basic_rnn(toy_input,h_0)\n```\n\n**2.LSTM**\n\n`nn.LSTM()`\n参数和标准RNN一样\n\nLSTM与RNN不同的地方：\n- LSTM的参数比标准RNN多，是标准RNN维度的4倍，但是访问的方式仍然是相同的\n- LSTM的输入还多了一个$C_0$，它们合在一起称为网络的隐藏状态，即（layer×direction，batch，hidden），当然输出也会有$h_0$,$C_0$\n\n```python\nlstm = nn.LSTM(input_size=20,hidden_size=50,num_layers=2)\n\nlstm_input = Variable(torch.randn(10, 3, 20))\nout, (h, c) = lstm(lstm_input)\n```\n\n**3.GRU**\n\nGRU本质上和LSTM一样\n\n```python\ngru_seq = nn.GRU(10, 20)\ngru_input = Variable(torch.randn(3, 32, 10))\n\nout, h = gru_seq(gru_input)\n```\n\n它和LSTM不同的地方：\n- 参数是标准RNN的三倍\n- 网络的隐藏状态只有h0\n\n#### 5.3.2 实例介绍\n\n序列预测\n\n\n```python\nimport torch\nimport torch.nn as nn\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom torch.autograd import Variable\n%matplotlib inline\n\n#希望通过前两个月的流量来预测当月的流量\n#将前两个月的流量当做输入，当月的流量当做输出\ndef create_dataset(dataset,look_back=2):\n    dataX,dataY = [],[]\n    for i in range(len(dataset)-look_back):\n        a = dataset[i:(i+look_back)]\n        dataX.append(a)\n        dataY.append(dataset[i+look_back])\n    return np.array(dataX),np.array(dataY)\n\n# 定义模型\nclass lstm_reg(nn.Module):\n    def __init__(self, input_size, hidden_size, output_size=1, num_layers=2):\n        super(lstm_reg, self).__init__()\n        \n        self.rnn = nn.LSTM(input_size, hidden_size, num_layers) # rnn\n        self.reg = nn.Linear(hidden_size, output_size) # 回归\n        \n    def forward(self, x):\n        x, _ = self.rnn(x) # (seq, batch, hidden)\n        s, b, h = x.shape\n        x = x.view(s*b, h) # 转换成线性层的输入格式\n        x = self.reg(x)\n        x = x.view(s, b, -1)\n        return x\n\n#读取数据\ndata_csv = pd.read_csv('./data.csv', usecols=[1])\n\n# 预处理，将数据中na的数据去掉，然后将数据标准化到0~1之间\ndata_csv = data_csv.dropna()\ndataset = data_csv.values\ndataset = dataset.astype('float32')\nmax_value = np.max(dataset)\nmin_value = np.min(dataset)\nscalar = max_value - min_value\ndataset = list(map(lambda x: x / scalar, dataset))\n\n# 创建好输入输出\ndata_X, data_Y = create_dataset(dataset)\n\n# 划分训练集和测试集，70% 作为训练集\ntrain_size = int(len(data_X) * 0.7)\ntest_size = len(data_X) - train_size\ntrain_X = data_X[:train_size]\ntrain_Y = data_Y[:train_size]\ntest_X = data_X[train_size:]\ntest_Y = data_Y[train_size:]\n\n#将数据改变一下形状 (seq, batch, feature)\n#只有一个序列，所以 batch 是 1\n#输入的feature是希望依据的几个月份，这里定的是两个月份，feature=2.\ntrain_X = train_X.reshape(-1, 1, 2)\ntrain_Y = train_Y.reshape(-1, 1, 1)\ntest_X = test_X.reshape(-1, 1, 2)\n\ntrain_x = torch.from_numpy(train_X)\ntrain_y = torch.from_numpy(train_Y)\ntest_x = torch.from_numpy(test_X)\n\n# 定义损失和优化\nnet = lstm_reg(2, 4)\ncriterion = nn.MSELoss()\noptimizer = torch.optim.Adam(net.parameters(), lr=1e-2)\n\n# 开始训练\nfor e in range(1000):\n    var_x = Variable(train_x)\n    var_y = Variable(train_y)\n    # 前向传播\n    out = net(var_x)\n    loss = criterion(out, var_y)\n    # 反向传播\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    if (e + 1) % 100 == 0: # 每 100 次输出结果\n        print('Epoch: {}, Loss: {:.5f}'.format(e + 1, loss.data))\n        \n#测试\nnet = net.eval() # 转换成测试模式\ndata_X = data_X.reshape(-1, 1, 2)\ndata_X = torch.from_numpy(data_X)\nvar_data = Variable(data_X)\npred_test = net(var_data) # 测试集的预测结果\n\n# 改变输出的格式\npred_test = pred_test.view(-1).data.numpy()\n\n# 画出实际结果和预测的结果\nplt.plot(pred_test, 'r', label='prediction')\nplt.plot(dataset, 'b', label='real')\nplt.legend(loc='best')\n```\n\n![](https://unpkg.com/justlovesmile-img/20201102181225.png)\n\n### 5.4 自然语言处理的应用\n\n#### 5.4.1 词嵌入\n\n词嵌入（word embedding），也称为词向量，即对于每个词，可以使用一个高维向量去表示它\n\n例如：\n- (1)The cat likes playing ball\n- (2)The kitty likes playing wool\n- (3)The dog likes playing ball\n- (4)The boy doesn't like playing ball\n\n对于这四句话里的四个词，cat，kitty，dog，boy，如果用one-hot编码，那么cat可以是（1，0，0，0），kitty可以是（0，1，0，0），但是cat和kitty都是小猫，所以这两个词实际语义是接近的，但是one-hot不能体现这个特点，于是可以用词嵌入的方式表示这四个词。\n\n假设使用一个二维向量（a，b）来表示一个词，其中a代表是否喜欢玩球，b代表是否喜欢玩毛线，且数值越大代表越喜欢，那么对于cat可以表示（-1，4），对于kitty可以表示为（-2，5），对于dog可以表示为（3，-2），对于boy可以表示为（-2，-3）\n\n![](https://unpkg.com/justlovesmile-img/20201102190952.png)\n\n可以发现kitty和cat的夹角更小，所以它们更加相似\n\n#### 5.4.2 词嵌入的PyTorch实现\n\nPyTorch中的词嵌入是通过函数`nn.Embedding(m,n)`来实现的，其中m表示所有的单词数目，n表示词嵌入的维度\n\n```python\nword_to_ix = {'hello':0,'world':1}\nembeds = nn.Embeding(2,5)\nhello_idx = torch.LongTensor([word_to_ix['hello']])\nhello_idx = Variable(hello_idx)\nhello_embed = embeds(hello_idx)\nprint(hello_embed)\n```\n\n#### 5.4.3 N Gram模型\n\n对于一句话，单词的排列顺序是非常重要的，所以我们能否由前面的几个词来预测后面的几个单词呢，比如 'I lived in France for 10 years, I can speak _ ' 这句话中，我们能够预测出最后一个词是 French。\n\n对于一句话T，它由w1，w2,...,wn这n个词构成，可以得到下面的公式\n$$\nP(T) = P(w_1)P(w_2 | w_1)P(w_3 |w_2 w_1) \\cdots P(w_n |w_{n-1} w_{n-2}\\cdots w_2w_1)\n$$\n但是该模型存在如参数空间过大等缺陷，因此引入了马尔科夫假设，也就是说这个单词只与前面的几个词有关系。\n\n对于这个条件概率，传统的方式是统计语料中每个单词出现的频率，据此来估计这个条件概率，这里使用词嵌入的办法，直接在语料中计算这个条件概率，然后最大化条件概率从而优化词向量，据此进行预测\n\n#### 5.4.4 单词预测的PyTorch实现\n\n\n```python\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nfrom torch.autograd import Variable\n\nCONTEXT_SIZE = 2 # 依据的单词数\nEMBEDDING_DIM = 10 # 词向量的维度\n\n# 定义模型\nclass n_gram(nn.Module):\n    def __init__(self, vocab_size, context_size=CONTEXT_SIZE, n_dim=EMBEDDING_DIM):\n        super(n_gram, self).__init__()\n        \n        self.embed = nn.Embedding(vocab_size, n_dim)\n        self.classify = nn.Sequential(\n            nn.Linear(context_size * n_dim, 128),\n            nn.ReLU(True),\n            nn.Linear(128, vocab_size)\n        )\n        \n    def forward(self, x):\n        voc_embed = self.embed(x) # 得到词嵌入\n        voc_embed = voc_embed.view(1, -1) # 将两个词向量拼在一起\n        out = self.classify(voc_embed)\n        return out\n\n# 我们使用莎士比亚的诗\ntest_sentence = \"\"\"When forty winters shall besiege thy brow,\nAnd dig deep trenches in thy beauty's field,\nThy youth's proud livery so gazed on now,\nWill be a totter'd weed of small worth held:\nThen being asked, where all thy beauty lies,\nWhere all the treasure of thy lusty days;\nTo say, within thine own deep sunken eyes,\nWere an all-eating shame, and thriftless praise.\nHow much more praise deserv'd thy beauty's use,\nIf thou couldst answer 'This fair child of mine\nShall sum my count, and make my old excuse,'\nProving his beauty by succession thine!\nThis were to be new made when thou art old,\nAnd see thy blood warm when thou feel'st it cold.\"\"\".split()\n\ntrigram = [((test_sentence[i], test_sentence[i+1]), test_sentence[i+2]) \n            for i in range(len(test_sentence)-2)]\n\n# 建立每个词与数字的编码，据此构建词嵌入\nvocb = set(test_sentence) # 使用 set 将重复的元素去掉\nword_to_idx = {word: i for i, word in enumerate(vocb)}\nidx_to_word = {word_to_idx[word]: word for word in word_to_idx}\n\nnet = n_gram(len(word_to_idx))\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.SGD(net.parameters(), lr=1e-2, weight_decay=1e-5)\n\n# 开始训练\nfor e in range(100):\n    train_loss = 0\n    for word, label in trigram: # 使用前 100 个作为训练集\n        word = Variable(torch.LongTensor([word_to_idx[i] for i in word])) # 将两个词作为输入\n        label = Variable(torch.LongTensor([word_to_idx[label]]))\n        # 前向传播\n        out = net(word)\n        loss = criterion(out, label)\n        train_loss += loss.data\n        # 反向传播\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n    if (e + 1) % 20 == 0:\n        print('epoch: {}, Loss: {:.6f}'.format(e + 1, train_loss / len(trigram)))\n        \n# 测试\nword, label = trigram[19]\nprint('input: {}'.format(word))\nprint('label: {}'.format(label))\n\nword = Variable(torch.LongTensor([word_to_idx[i] for i in word]))\nout = net(word)\npred_label_idx = out.max(1)[1].item()\npredict_word = idx_to_word[pred_label_idx]\nprint('real word is {}, predicted word is {}'.format(label, predict_word))\n```\n\n```txt\nepoch: 20, Loss: 0.873597\nepoch: 40, Loss: 0.153170\nepoch: 60, Loss: 0.090456\nepoch: 80, Loss: 0.071410\nepoch: 100, Loss: 0.061979\ninput: ('so', 'gazed')\nlabel: on\n\nreal word is on, predicted word is on\n```\n\n#### 5.4.5 词性判断\n\n**1.LSTM做词性判断的基本原理**\n\n同构LSTM，根据它记忆的特性，能够通过这个单词前面记忆的一些词语来对它做一个判断，比如前面的单词如果是my，那么紧跟的词很可能是一个名词，这样就能充分利用上文来处理这个问题\n\n**2.字符增强**\n\n通过引入字符来增强表达，比如有些单词存在前缀或者后缀，比如`-ly`这种后缀很有可能是副词，这样我们就能在字符水平对词性进一步判断，把两种方法集成起来，能够得到一个更好的结果\n\n#### 5.4.6 词性判断的PyTorch实现\n\n```python\nimport torch\nfrom torch import nn\nfrom torch.autograd import Variable\n\ntraining_data = [(\"The dog ate the apple\".split(),\n                  [\"DET\", \"NN\", \"V\", \"DET\", \"NN\"]),\n                 (\"Everybody read that book\".split(), \n                  [\"NN\", \"V\", \"DET\", \"NN\"])]\n\n#对单词和标签进行编码\nword_to_idx = {}\ntag_to_idx = {}\nfor context, tag in training_data:\n    for word in context:\n        if word.lower() not in word_to_idx:\n            word_to_idx[word.lower()] = len(word_to_idx)\n    for label in tag:\n        if label.lower() not in tag_to_idx:\n            tag_to_idx[label.lower()] = len(tag_to_idx)\n\n#对字母编码\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nchar_to_idx = {}\nfor i in range(len(alphabet)):\n    char_to_idx[alphabet[i]] = i\n    \ndef make_sequence(x, dic): # 字符编码\n    idx = [dic[i.lower()] for i in x]\n    idx = torch.LongTensor(idx)\n    return idx\n\n#构建单个字符的lstm模型\nclass char_lstm(nn.Module):\n    def __init__(self, n_char, char_dim, char_hidden):\n        super(char_lstm, self).__init__()\n        \n        self.char_embed = nn.Embedding(n_char, char_dim)\n        self.lstm = nn.LSTM(char_dim, char_hidden)\n        \n    def forward(self, x):\n        x = self.char_embed(x)\n        out, _ = self.lstm(x)\n        return out[-1] # (batch, hidden)\n\n#构建词性分类的lstm模型\nclass lstm_tagger(nn.Module):\n    def __init__(self, n_word, n_char, char_dim, word_dim, \n                 char_hidden, word_hidden, n_tag):\n        super(lstm_tagger, self).__init__()\n        self.word_embed = nn.Embedding(n_word, word_dim)\n        self.char_lstm = char_lstm(n_char, char_dim, char_hidden)\n        self.word_lstm = nn.LSTM(word_dim + char_hidden, word_hidden)\n        self.classify = nn.Linear(word_hidden, n_tag)\n        \n    def forward(self, x, word):\n        char = []\n        for w in word: # 对于每个单词做字符的 lstm\n            char_list = make_sequence(w, char_to_idx)\n            char_list = char_list.unsqueeze(1) # (seq, batch, feature) 满足 lstm 输入条件\n            char_infor = self.char_lstm(Variable(char_list)) # (batch, char_hidden)\n            char.append(char_infor)\n        char = torch.stack(char, dim=0) # (seq, batch, feature)\n        \n        x = self.word_embed(x) # (batch, seq, word_dim)\n        x = x.permute(1, 0, 2) # 改变顺序\n        x = torch.cat((x, char), dim=2) # 沿着特征通道将每个词的词嵌入和字符 lstm 输出的结果拼接在一起\n        x, _ = self.word_lstm(x)\n        \n        s, b, h = x.shape\n        x = x.view(-1, h) # 重新 reshape 进行分类线性层\n        out = self.classify(x)\n        return out\n\nnet = lstm_tagger(len(word_to_idx), len(char_to_idx), 10, 100, 50, 128, len(tag_to_idx))\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.SGD(net.parameters(), lr=1e-2)\n\n# 开始训练\nfor e in range(300):\n    train_loss = 0\n    for word, tag in training_data:\n        word_list = make_sequence(word, word_to_idx).unsqueeze(0) # 添加第一维 batch\n        tag = make_sequence(tag, tag_to_idx)\n        word_list = Variable(word_list)\n        tag = Variable(tag)\n        # 前向传播\n        out = net(word_list, word)\n        loss = criterion(out, tag)\n        train_loss += loss.data\n        # 反向传播\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n    if (e + 1) % 50 == 0:\n        print('Epoch: {}, Loss: {:.5f}'.format(e + 1, train_loss / len(training_data)))\n\n#测试\nnet = net.eval()\ntest_sent = 'Everybody ate the apple'\ntest = make_sequence(test_sent.split(), word_to_idx).unsqueeze(0)\nout = net(Variable(test), test_sent.split())\nprint(out)\nprint(tag_to_idx)\n```\n\n### 5.5 循环神经网络的更多应用\n\n#### 5.5.1 Many to one\n\n循环神经网络不仅能够输入序列，输出序列，还能后输入序列，输出单个向量。只需要再输出的序列里面取其中一个就可以，通常是取最后一个。这样的结构被称为Many to one。\n\nMany to one的结构可以用来执行什么任务：\n- 情感分析\n- 关键字提取\n\n#### 5.5.2 Many to Many (shorter)\n\n这种结构是输入和输出都是序列，但是输出的序列比输入的序列短。这种类型的结构通常在语音识别中遇到，因为一段话如果用语言表达往往会比这段话更长。这种情况需要使用CTC算法解决重复的问题，CTC就是将输出的所有可能列举出来，然后通过去重复，去空格的方式来选择最大的概率。\n\n#### 5.5.3 Seq2seq\n\n这种情况是输出的长度不确定，一般是在机器翻译的任务中出现。\n\n#### 5.5.4 CNN+RNN\n\nRNN和CNN可以联合在一起完成图像描述任务，简而言之，就是通过预训练的卷积神经网络提取图片特征，接着通过循环网络将特征变成文字描述\n\n## 第6章 生成对抗网络\n\n2014年，lan Goodfellow提出的生成对抗网络（Generative Adversarial Networks，GANs）推进了整个无监督学习的发展进程，让机器实现一些创造性工作，如画画，写诗，创作歌词等成为可能...\n\n### 6.1 生成模型\n\n生成模型(Generative Model)这一概念属于概率统计和机器学习,是指一系列用于随机生成可观测数据的模型.简而言之,就是\"生成\"的样本和\"真实\"的样本尽可能地相似.\n\n生成模型的两个主要功能就是学习一个概率分布$P_{model}(x)$和生成数据\n\n#### 6.1.1 自动编码器\n\n自动编码器(AutoEncoder)最开始作为一种数据的压缩方法,其特点有:\n- 和数据相关程度很高\n- 压缩后数据是有损的\n\n所以现在自动编码器主要应用在几个方面:\n- 数据去噪\n- 可视化降维\n- 生成数据\n\n自动编码器的一般结构\n- 编码器(Encoder)\n- 解码器(Decoder)\n\n编码器和解码器可以是任意的模型,通常使用神经网络模型作为编码器和解码器.输入的数据经过神经网络降维到一个编码(code),接着又通过另一个神经网络去解码得到一个与输入原数据一模一样的生成数据,然后通过比较这两个数据,最小化它们之间的差异来训练这个网络中编码器和解码器的参数.当这个过程训练完之后,拿出这个解码器,随机传入一个编码,通过解码器能够生成一个和原数据差不多的数据\n\n下面我们使用 mnist 数据集来说明一个如何构建一个简单的自动编码器\n\n\n```python\nimport os\nimport torch\nfrom torch.autograd import Variable\nfrom torch import nn\nfrom torch.utils.data import DataLoader\nfrom torchvision.datasets import MNIST\nfrom torchvision import transforms as tfs\nfrom torchvision.utils import save_image\n\n#进行数据预处理和迭代器的构建\nim_tfs = tfs.Compose([\n    tfs.ToTensor(),\n    tfs.Normalize([0.5], [0.5]) # 标准化\n])\n\ntrain_set = MNIST('./data', train=True,transform=im_tfs,download=True)\ntrain_data = DataLoader(train_set, batch_size=128, shuffle=True)\n\n#定义网络\nclass autoencoder(nn.Module):\n    def __init__(self):\n        super(autoencoder,self).__init__()\n        self.encoder = nn.Sequential(\n            nn.Linear(28*28,128),\n            nn.ReLU(True),\n            nn.Linear(128,64),\n            nn.ReLU(True),\n            nn.Linear(64,12),\n            nn.ReLU(True),\n            nn.Linear(12,3) # 输出的 code 是 3 维，便于可视化\n        )\n        self.decoder = nn.Sequential(\n            nn.Linear(3,12),\n            nn.ReLU(True),\n            nn.Linear(12,64),\n            nn.ReLU(True),\n            nn.Linear(64,128),\n            nn.ReLU(True),\n            nn.Linear(128,28*28),\n            nn.Tanh()\n        )\n    \n    def forward(self,x):\n        encode = self.encoder(x)\n        decode = self.decoder(encode)\n        return encode,decode\n\"\"\"\n这里定义的编码器和解码器都是 4 层神经网络作为模型，\n中间使用 relu 激活函数，最后输出的 code 是三维，\n注意解码器最后我们使用tanh作为激活函数，\n因为输入图片标准化在 -1 ~ 1 之间，\n所以输出也要在 -1 ~ 1 这个范围内\n\"\"\"\nnet = autoencoder()\ncriterion = nn.MSELoss(size_average=False)\noptimizer = torch.optim.Adam(net.parameters(), lr=1e-3)\n\ndef to_img(x):\n    # 定义一个函数将最后的结果转换回图片\n    x = 0.5 * (x + 1.)\n    x = x.clamp(0, 1)\n    x = x.view(x.shape[0], 1, 28, 28)\n    return x\n\n# 开始训练自动编码器\nfor e in range(100):\n    for im, _ in train_data:\n        im = im.view(im.shape[0], -1)\n        im = Variable(im)\n        # 前向传播\n        _, output = net(im)\n        loss = criterion(output, im) / im.shape[0] # 平均\n        # 反向传播\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n    \n    if (e+1) % 20 == 0: # 每 20 次，将生成的图片保存一下\n        print('epoch: {}, Loss: {:.4f}'.format(e + 1, loss.data))\n        pic = to_img(output.cpu().data)\n        if not os.path.exists('./simple_autoencoder'):\n            os.mkdir('./simple_autoencoder')\n        save_image(pic, './simple_autoencoder/image_{}.png'.format(e + 1))\n```\n\n训练完成之后看看效果\n\n\n```python\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import Axes3D\n%matplotlib inline\n\n# 可视化结果\nview_data = Variable((train_set.train_data[:200].type(torch.FloatTensor).view(-1, 28*28) / 255. - 0.5) / 0.5)\nencode, _ = net(view_data)    # 提取压缩的特征值\nfig = plt.figure(2)\nax = Axes3D(fig)    # 3D 图\n# x, y, z 的数据值\nX = encode.data[:, 0].numpy()\nY = encode.data[:, 1].numpy()\nZ = encode.data[:, 2].numpy()\nvalues = train_set.train_labels[:200].numpy()  # 标签值\nfor x, y, z, s in zip(X, Y, Z, values):\n    c = cm.rainbow(int(255*s/9))    # 上色\n    ax.text(x, y, z, s, backgroundcolor=c)  # 标位子\nax.set_xlim(X.min(), X.max())\nax.set_ylim(Y.min(), Y.max())\nax.set_zlim(Z.min(), Z.max())\nplt.show()\n```\n\n![](https://unpkg.com/justlovesmile-img/untitled.png)\n可以看到，不同种类的图片进入自动编码器之后会被编码得不同，而相同类型的图片经过自动编码之后的编码在几何示意图上距离较近，在训练好自动编码器之后，我们可以给一个随机的 code，通过 decoder 生成图片\n\n\n```python\ncode = Variable(torch.FloatTensor([[-20.19, 10.36, -0.06]])) # 给一个 code\ndecode = net.decoder(code)\ndecode_img = to_img(decode).squeeze()\ndecode_img = decode_img.data.numpy() * 255\nplt.imshow(decode_img.astype('uint8'), cmap='gray') \n```\n\n![](https://unpkg.com/justlovesmile-img/20201104180838.png)\n这里我们仅仅使用多层神经网络定义了一个自动编码器，当然你会想到，为什么不使用效果更好的卷积神经网络呢？我们当然可以使用卷积神经网络来定义，下面我们就重新定义一个卷积神经网络来进行 autoencoder\n\n\n```python\nclass conv_autoencoder(nn.Module):\n    def __init__(self):\n        super(conv_autoencoder, self).__init__()\n        \n        self.encoder = nn.Sequential(\n            nn.Conv2d(1, 16, 3, stride=3, padding=1),  # (b, 16, 10, 10)\n            nn.ReLU(True),\n            nn.MaxPool2d(2, stride=2),  # (b, 16, 5, 5)\n            nn.Conv2d(16, 8, 3, stride=2, padding=1),  # (b, 8, 3, 3)\n            nn.ReLU(True),\n            nn.MaxPool2d(2, stride=1)  # (b, 8, 2, 2)\n        )\n        \n        self.decoder = nn.Sequential(\n            nn.ConvTranspose2d(8, 16, 3, stride=2),  # (b, 16, 5, 5)\n            nn.ReLU(True),\n            nn.ConvTranspose2d(16, 8, 5, stride=3, padding=1),  # (b, 8, 15, 15)\n            nn.ReLU(True),\n            nn.ConvTranspose2d(8, 1, 2, stride=2, padding=1),  # (b, 1, 28, 28)\n            nn.Tanh()\n        )\n\n    def forward(self, x):\n        encode = self.encoder(x)\n        decode = self.decoder(encode)\n        return encode, decode\n\nconv_net = conv_autoencoder()\nif torch.cuda.is_available():\n    conv_net = conv_net.cuda()\noptimizer = torch.optim.Adam(conv_net.parameters(), lr=1e-3, weight_decay=1e-5)\n\n# 开始训练自动编码器\nfor e in range(40):\n    for im, _ in train_data:\n        if torch.cuda.is_available():\n            im = im.cuda()\n            print(torch.device(\"cuda\"))\n        im = Variable(im)\n        # 前向传播\n        _, output = conv_net(im)\n        loss = criterion(output, im) / im.shape[0] # 平均\n        # 反向传播\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n    \n    if (e+1) % 20 == 0: # 每 20 次，将生成的图片保存一下\n        print('epoch: {}, Loss: {:.4f}'.format(e+1, loss.data))\n        pic = to_img(output.cpu().data)\n        if not os.path.exists('./conv_autoencoder'):\n            os.mkdir('./conv_autoencoder')\n        save_image(pic, './conv_autoencoder/image_{}.png'.format(e+1))\n```\n\n为了时间更短，只跑 40 次，如果有条件可以再 gpu 上跑跑.这里我们展示了简单的自动编码器，也用了多层神经网络和卷积神经网络作为例子，但是自动编码器存在一个问题，我们并不能任意生成我们想要的数据，因为我们并不知道 encode 之后的编码到底是什么样的概率分布，所以有一个改进的版本变分自动编码器，其能够解决这个问题\n\n#### 6.1.2 变分自动编码器\n\n变分自动编码器（Variational Auto Encoder, VAE）是自动编码器的升级版本，它的结构和自动编码器相似，也是由编码器和解码器构成的。\n\n自动编码器不能任意生成数据，因为没办法自己去构造隐藏向量，需要通过数据输入编码才知道得到的隐含向量是什么，这个时候变分自动编码器就可以解决这个问题\n\n它的原理是，在编码过程给他增加一些限制，迫使他生成的隐含向量能够粗略地遵循一个标准正态分布。\n\n这样我们生成一张新图片就很简单了，我们只需要给它一个标准正态分布的随机隐含向量，这样通过解码器就能够生成我们想要的图片，而不需要给它一张原始图片先编码。\n\n一般来讲，我们通过 encoder 得到的隐含向量并不是一个标准的正态分布，为了衡量两种分布的相似程度，我们使用 KL divergence，利用其来表示隐含向量与标准正态分布之间差异的 loss，另外一个 loss 仍然使用生成图片与原图片的均方误差来表示。\n\nKL divergence 的公式如下\n$$\nD_{KL} (P || Q) =  \\sum_{i} p(i) \\log \\frac{P(i)}{Q(i)}\n$$\n\n$$\nD_{KL} (P || Q) =  \\int_{-\\infty}^{\\infty} p(x) \\log \\frac{p(x)}{q(x)} dx\n$$\n\n**重参数**\n\n为了避免计算 KL divergence 中的积分，我们使用重参数的技巧，不是每次产生一个隐含向量，而是生成两个向量，一个表示均值，一个表示标准差，这里我们默认编码之后的隐含向量服从一个正态分布的之后，就可以用一个标准正态分布先乘上标准差再加上均值来合成这个正态分布，最后 loss 就是希望这个生成的正态分布能够符合一个标准正态分布，也就是希望均值为 0，方差为 1\n\n[详细内容见https://arxiv.org/pdf/1606.05908.pdf](https://arxiv.org/pdf/1606.05908.pdf)\n\n所以最后我们可以将我们的 loss 定义为下面的函数，由均方误差和 KL divergence 求和得到一个总的 loss\n\n```python\nreconstruction_funtion = nn.BCELoss(size_average=False)\n\ndef loss_function(recon_x, x, mu, logvar):\n    \"\"\"\n    recon_x: generating images\n    x: origin images\n    mu: latent mean\n    logvar: latent log variance\n    \"\"\"\n    MSE = reconstruction_function(recon_x, x)\n    # loss = 0.5 * sum(1 + log(sigma^2) - mu^2 - sigma^2)\n    KLD_element = mu.pow(2).add_(logvar.exp()).mul_(-1).add_(1).add_(logvar)\n    KLD = torch.sum(KLD_element).mul_(-0.5)\n    # KL divergence\n    return MSE + KLD\n```\n\n下面我们用 mnist 数据集来简单说明一下变分自动编码器\n\n\n```python\nimport os\nimport torch\nfrom torch.autograd import Variable\nimport torch.nn.functional as F\nfrom torch import nn\nfrom torch.utils.data import DataLoader\nfrom torchvision.datasets import MNIST\nfrom torchvision import transforms as tfs\nfrom torchvision.utils import save_image\n\nim_tfs = tfs.Compose([\n    tfs.ToTensor(),\n    tfs.Normalize([0.5], [0.5]) # 标准化\n])\n\ntrain_set = MNIST('./data', transform=im_tfs)\ntrain_data = DataLoader(train_set, batch_size=128, shuffle=True)\n\nclass VAE(nn.Module):\n    def __init__(self):\n        super(VAE, self).__init__()\n        self.fc1 = nn.Linear(784, 400)\n        self.fc21 = nn.Linear(400, 20) # mean\n        self.fc22 = nn.Linear(400, 20) # var\n        self.fc3 = nn.Linear(20, 400)\n        self.fc4 = nn.Linear(400, 784)\n\n    def encode(self, x):\n        h1 = F.relu(self.fc1(x))\n        return self.fc21(h1), self.fc22(h1)\n\n    def reparametrize(self, mu, logvar):\n        std = logvar.mul(0.5).exp_()\n        eps = torch.FloatTensor(std.size()).normal_()\n        if torch.cuda.is_available():\n            eps = Variable(eps.cuda())\n        else:\n            eps = Variable(eps)\n        return eps.mul(std).add_(mu)\n\n    def decode(self, z):\n        h3 = F.relu(self.fc3(z))\n        return F.tanh(self.fc4(h3))\n\n    def forward(self, x):\n        mu, logvar = self.encode(x) # 编码\n        z = self.reparametrize(mu, logvar) # 重新参数化成正态分布\n        return self.decode(z), mu, logvar # 解码，同时输出均值方差\n\nnet = VAE() # 实例化网络\nif torch.cuda.is_available():\n    net = net.cuda()\n\nreconstruction_function = nn.MSELoss(size_average=False)\n\ndef loss_function(recon_x, x, mu, logvar):\n    \"\"\"\n    recon_x: generating images\n    x: origin images\n    mu: latent mean\n    logvar: latent log variance\n    \"\"\"\n    MSE = reconstruction_function(recon_x, x)\n    # loss = 0.5 * sum(1 + log(sigma^2) - mu^2 - sigma^2)\n    KLD_element = mu.pow(2).add_(logvar.exp()).mul_(-1).add_(1).add_(logvar)\n    KLD = torch.sum(KLD_element).mul_(-0.5)\n    # KL divergence\n    return MSE + KLD\n\noptimizer = torch.optim.Adam(net.parameters(), lr=1e-3)\n\ndef to_img(x):\n    #定义一个函数将最后的结果转换回图片\n    x = 0.5 * (x + 1.)\n    x = x.clamp(0, 1)\n    x = x.view(x.shape[0], 1, 28, 28)\n    return x\n\nfor e in range(100):\n    for im, _ in train_data:\n        im = im.view(im.shape[0], -1)\n        im = Variable(im)\n        if torch.cuda.is_available():\n            im = im.cuda()\n            print(torch.device(\"cuda\"))\n        recon_im, mu, logvar = net(im)\n        loss = loss_function(recon_im, im, mu, logvar) / im.shape[0] # 将 loss 平均\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n    if (e + 1) % 20 == 0:\n        print('epoch: {}, Loss: {:.4f}'.format(e + 1, loss.data[0]))\n        save = to_img(recon_im.cpu().data)\n        if not os.path.exists('./vae_img'):\n            os.mkdir('./vae_img')\n        save_image(save, './vae_img/image_{}.png'.format(e + 1))\n```\n\n可以看看使用变分自动编码器得到的结果，可以发现效果比一般的编码器要好很多\n\n### 6.2 生成对抗网络\n\n前面我们讲了自动编码器和变分自动编码器，不管是哪一个，都是通过计算生成图像和输入图像在每个像素点的误差来生成 loss，这一点是特别不好的，因为不同的像素点可能造成不同的视觉结果，但是可能他们的 loss 是相同的，所以通过单个像素点来得到 loss 是不准确的，这个时候我们需要一种全新的 loss 定义方式，就是通过对抗进行学习。\n\n#### 6.2.1 什么是生成对抗网络\n\n这种训练方式定义了一种全新的网络结构，就是生成对抗网络，也就是 GANs。\n\n根据这个名字就可以知道这个网络是由两部分组成的，第一部分是生成，第二部分是对抗。简单来说，就是有一个生成网络和一个判别网络，通过训练让两个网络相互竞争，生成网络来生成假的数据，对抗网络通过判别器去判别真伪，最后希望生成器生成的数据能够以假乱真。\n\n**对抗：Discriminator Network**\n\n首先我们来讲一下对抗过程，因为这个过程更加简单。\n\n对抗过程简单来说就是一个判断真假的判别器，相当于一个二分类问题，我们输入一张真的图片希望判别器输出的结果是1，输入一张假的图片希望判别器输出的结果是0。这其实已经和原图片的 label 没有关系了，不管原图片到底是一个多少类别的图片，他们都统一称为真的图片，label 是 1 表示真实的；而生成的假的图片的 label 是 0 表示假的。\n\n我们训练的过程就是希望这个判别器能够正确的判出真的图片和假的图片，这其实就是一个简单的二分类问题，对于这个问题可以用我们前面讲过的很多方法去处理，比如 logistic 回归，深层网络，卷积神经网络，循环神经网络都可以。\n\n**生成：Generator Network**\n\n接着我们看看生成网络如何生成一张假的图片。首先给出一个简单的高维的正态分布的噪声向量，这个时候我们可以通过仿射变换，也就是 xw+b 将其映射到一个更高的维度，然后将他重新排列成一个矩形，这样看着更像一张图片，接着进行一些卷积、转置卷积、池化、激活函数等进行处理，最后得到了一个与我们输入图片大小一模一样的噪音矩阵，这就是我们所说的假的图片。\n\n这个时候我们如何去训练这个生成器呢？这就需要通过对抗学习，增大判别器判别这个结果为真的概率，通过这个步骤不断调整生成器的参数，希望生成的图片越来越像真的，而在这一步中我们不会更新判别器的参数，因为如果判别器不断被优化，可能生成器无论生成什么样的图片都无法骗过判别器。\n\n关于生成对抗网络，出现了很多变形，比如 WGAN，LS-GAN 等等，这里我们只使用 mnist 举一些简单的例子来说明，更复杂的网络结构可以在 github 上找到相应的实现\n\n\n```python\nimport torch\nfrom torch import nn\nfrom torch.autograd import Variable\n\nimport torchvision.transforms as tfs\nfrom torch.utils.data import DataLoader, sampler\nfrom torchvision.datasets import MNIST\n\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n\n%matplotlib inline\nplt.rcParams['figure.figsize'] = (10.0, 8.0) # 设置画图的尺寸\nplt.rcParams['image.interpolation'] = 'nearest'\nplt.rcParams['image.cmap'] = 'gray'\n\ndef show_images(images): # 定义画图工具\n    images = np.reshape(images, [images.shape[0], -1])\n    sqrtn = int(np.ceil(np.sqrt(images.shape[0])))\n    sqrtimg = int(np.ceil(np.sqrt(images.shape[1])))\n\n    fig = plt.figure(figsize=(sqrtn, sqrtn))\n    gs = gridspec.GridSpec(sqrtn, sqrtn)\n    gs.update(wspace=0.05, hspace=0.05)\n\n    for i, img in enumerate(images):\n        ax = plt.subplot(gs[i])\n        plt.axis('off')\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.set_aspect('equal')\n        plt.imshow(img.reshape([sqrtimg,sqrtimg]))\n    return \n\ndef preprocess_img(x):\n    x = tfs.ToTensor()(x)\n    return (x - 0.5) / 0.5\n\ndef deprocess_img(x):\n    return (x + 1.0) / 2.0\n\nclass ChunkSampler(sampler.Sampler): # 定义一个取样的函数\n    \"\"\"Samples elements sequentially from some offset. \n    Arguments:\n        num_samples: # of desired datapoints\n        start: offset where we should start selecting from\n    \"\"\"\n    def __init__(self, num_samples, start=0):\n        self.num_samples = num_samples\n        self.start = start\n\n    def __iter__(self):\n        return iter(range(self.start, self.start + self.num_samples))\n\n    def __len__(self):\n        return self.num_samples\n\nNUM_TRAIN = 50000\nNUM_VAL = 5000\n\nNOISE_DIM = 96\nbatch_size = 128\n\ntrain_set = MNIST('./data', train=True, download=True, transform=preprocess_img)\n\ntrain_data = DataLoader(train_set, batch_size=batch_size, sampler=ChunkSampler(NUM_TRAIN, 0))\n\nval_set = MNIST('./data', train=True, download=True, transform=preprocess_img)\n\nval_data = DataLoader(val_set, batch_size=batch_size, sampler=ChunkSampler(NUM_VAL, NUM_TRAIN))\n\nimgs = deprocess_img(train_data.__iter__().next()[0].view(batch_size, 784)).numpy().squeeze() # 可视化图片效果\nshow_images(imgs)\n```\n\n![](https://unpkg.com/justlovesmile-img/20201105142821.png)\n\n**简单版本的生成对抗网络**\n\n通过前面我们知道生成对抗网络有两个部分构成，一个是生成网络，一个是对抗网络，我们首先写一个简单版本的网络结构，生成网络和对抗网络都是简单的多层神经网络\n\n**判别网络**\n\n判别网络的结构非常简单，就是一个二分类器，结构如下:\n* 全连接(784 -> 256)\n* leakyrelu,  $\\alpha$ 是 0.2\n* 全连接(256 -> 256)\n* leakyrelu, $\\alpha$ 是 0.2\n* 全连接(256 -> 1)\n\n其中 leakyrelu 是指 f(x) = max($\\alpha$ x, x)\n\n\n```python\ndef discriminator():\n    net = nn.Sequential(        \n            nn.Linear(784, 256),\n            nn.LeakyReLU(0.2),\n            nn.Linear(256, 256),\n            nn.LeakyReLU(0.2),\n            nn.Linear(256, 1)\n        )\n    return net\n```\n\n**生成网络**\n\n接下来我们看看生成网络，生成网络的结构也很简单，就是根据一个随机噪声生成一个和数据维度一样的张量，结构如下：\n* 全连接(噪音维度 -> 1024)\n* relu\n* 全连接(1024 -> 1024)\n* relu\n* 全连接(1024 -> 784)\n* tanh 将数据裁剪到 -1 ~ 1 之间\n\n\n```python\ndef generator(noise_dim=NOISE_DIM):   \n    net = nn.Sequential(\n        nn.Linear(noise_dim, 1024),\n        nn.ReLU(True),\n        nn.Linear(1024, 1024),\n        nn.ReLU(True),\n        nn.Linear(1024, 784),\n        nn.Tanh()\n    )\n    return net\n```\n\n接下来我们需要定义生成对抗网络的 loss，通过前面的讲解我们知道，对于对抗网络，相当于二分类问题，将真的判别为真的，假的判别为假的，作为辅助，可以参考一下论文中公式\n\n$$ \\ell_D = \\mathbb{E}_{x \\sim p_\\text{data}}\\left[\\log D(x)\\right] + \\mathbb{E} _ {z \\sim p(z)}\\left[\\log \\left(1-D(G(z))\\right)\\right]$$\n\n而对于生成网络，需要去骗过对抗网络，也就是将假的也判断为真的，作为辅助，可以参考一下论文中公式\n\n$$\\ell_G  =  \\mathbb{E} _ {z \\sim p(z)}\\left[\\log D(G(z))\\right]$$\n\n如果你还记得前面的二分类 loss，那么你就会发现上面这两个公式就是二分类 loss\n\n$$ bce(s, y) = y * \\log(s) + (1 - y) * \\log(1 - s) $$\n\n如果我们把 D(x) 看成真实数据的分类得分，那么 D(G(z)) 就是假数据的分类得分，所以上面判别器的 loss 就是将真实数据的得分判断为 1，假的数据的得分判断为 0，而生成器的 loss 就是将假的数据判断为 1\n\n下面我们来实现一下\n\n\n```python\nimport torch\nfrom torch import nn\nfrom torch.autograd import Variable\n\nimport torchvision.transforms as tfs\nfrom torch.utils.data import DataLoader, sampler\nfrom torchvision.datasets import MNIST\n\nimport numpy as np\n\nNUM_TRAIN = 50000\nNUM_VAL = 5000\n\nNOISE_DIM = 96\nbatch_size = 128\n\ndef discriminator():\n    net = nn.Sequential(        \n            nn.Linear(784, 256),\n            nn.LeakyReLU(0.2),\n            nn.Linear(256, 256),\n            nn.LeakyReLU(0.2),\n            nn.Linear(256, 1)\n        )\n    return net\n\ndef generator(noise_dim=NOISE_DIM):   \n    net = nn.Sequential(\n        nn.Linear(noise_dim, 1024),\n        nn.ReLU(True),\n        nn.Linear(1024, 1024),\n        nn.ReLU(True),\n        nn.Linear(1024, 784),\n        nn.Tanh()\n    )\n    return net\n\nbce_loss = nn.BCEWithLogitsLoss()\n\ndef discriminator_loss(logits_real, logits_fake): # 判别器的 loss\n    size = logits_real.shape[0]\n    true_labels = Variable(torch.ones(size, 1)).float().cuda()\n    false_labels = Variable(torch.zeros(size, 1)).float().cuda()\n    loss = bce_loss(logits_real, true_labels) + bce_loss(logits_fake, false_labels)\n    return loss\n\ndef generator_loss(logits_fake): # 生成器的 loss  \n    size = logits_fake.shape[0]\n    true_labels = Variable(torch.ones(size, 1)).float().cuda()\n    loss = bce_loss(logits_fake, true_labels)\n    return loss\n\n# 使用 adam 来进行训练，学习率是 3e-4, beta1 是 0.5, beta2 是 0.999\ndef get_optimizer(net):\n    optimizer = torch.optim.Adam(net.parameters(), lr=3e-4, betas=(0.5, 0.999))\n    return optimizer\n\ndef preprocess_img(x):\n    x = tfs.ToTensor()(x)\n    return (x - 0.5) / 0.5\n\ndef deprocess_img(x):\n    return (x + 1.0) / 2.0\n\nclass ChunkSampler(sampler.Sampler): # 定义一个取样的函数\n    \"\"\"Samples elements sequentially from some offset. \n    Arguments:\n        num_samples: # of desired datapoints\n        start: offset where we should start selecting from\n    \"\"\"\n    def __init__(self, num_samples, start=0):\n        self.num_samples = num_samples\n        self.start = start\n\n    def __iter__(self):\n        return iter(range(self.start, self.start + self.num_samples))\n\n    def __len__(self):\n        return self.num_samples\n\ntrain_set = MNIST('./data', train=True, download=True, transform=preprocess_img)\n\ntrain_data = DataLoader(train_set, batch_size=batch_size, sampler=ChunkSampler(NUM_TRAIN, 0))\n\nval_set = MNIST('./data', train=True, download=True, transform=preprocess_img)\n\nval_data = DataLoader(val_set, batch_size=batch_size, sampler=ChunkSampler(NUM_VAL, NUM_TRAIN))\n\n#下面我们开始训练一个这个简单的生成对抗网络\ndef train_a_gan(D_net, G_net, D_optimizer, G_optimizer, discriminator_loss, generator_loss, show_every=250, \n                noise_size=96, num_epochs=10):\n    iter_count = 0\n    for epoch in range(num_epochs):\n        for x, _ in train_data:\n            bs = x.shape[0]\n            # 判别网络\n            real_data = Variable(x).view(bs, -1).cuda() # 真实数据\n            logits_real = D_net(real_data) # 判别网络得分\n            \n            sample_noise = (torch.rand(bs, noise_size) - 0.5) / 0.5 # -1 ~ 1 的均匀分布\n            g_fake_seed = Variable(sample_noise).cuda()\n            fake_images = G_net(g_fake_seed) # 生成的假的数据\n            logits_fake = D_net(fake_images) # 判别网络得分\n\n            d_total_error = discriminator_loss(logits_real, logits_fake) # 判别器的 loss\n            D_optimizer.zero_grad()\n            d_total_error.backward()\n            D_optimizer.step() # 优化判别网络\n            \n            # 生成网络\n            g_fake_seed = Variable(sample_noise).cuda()\n            fake_images = G_net(g_fake_seed) # 生成的假的数据\n\n            gen_logits_fake = D_net(fake_images)\n            g_error = generator_loss(gen_logits_fake) # 生成网络的 loss\n            G_optimizer.zero_grad()\n            g_error.backward()\n            G_optimizer.step() # 优化生成网络\n\n            if (iter_count % show_every == 0):\n                print('Iter: {}, D: {:.4}, G:{:.4}'.format(iter_count, d_total_error.data, g_error.data))\n                imgs_numpy = deprocess_img(fake_images.data.cpu().numpy())\n                show_images(imgs_numpy[0:16])\n                plt.show()\n                print()\n            iter_count += 1\n```\n\n\n```python\nD = discriminator().cuda()\nG = generator().cuda()\n\nD_optim = get_optimizer(D)\nG_optim = get_optimizer(G)\n\ntrain_a_gan(D, G, D_optim, G_optim, discriminator_loss, generator_loss)\n```\n\n![](https://unpkg.com/justlovesmile-img/20201105174301-min.gif)\n\n我们已经完成了一个简单的生成对抗网络，是不是非常容易呢。但是可以看到效果并不是特别好，生成的数字也不是特别完整，因为我们仅仅使用了简单的多层全连接网络。\n\n除了这种最基本的生成对抗网络之外，还有很多生成对抗网络的变式，有结构上的变式，也有 loss 上的变式，我们先讲一讲其中一种在 loss 上的变式，Least Squares GAN\n\n**Least Squares GAN**\n\n[Least Squares GAN](https://arxiv.org/abs/1611.04076) 比最原始的 GANs 的 loss 更加稳定，通过名字我们也能够看出这种 GAN 是通过最小平方误差来进行估计，而不是通过二分类的损失函数，下面我们看看 loss 的计算公式\n\n$$\\ell_G  =  \\frac{1}{2}\\mathbb{E} _ {z \\sim p(z)}\\left[\\left(D(G(z))-1\\right)^2\\right]$$\n\n$$ \\ell_D = \\frac{1}{2}\\mathbb{E}_{x \\sim p_\\text{data}}\\left[\\left(D(x)-1\\right)^2\\right] + \\frac{1}{2}\\mathbb{E} _ {z \\sim p(z)}\\left[ \\left(D(G(z))\\right)^2\\right]$$\n\n可以看到 Least Squares GAN 通过最小二乘代替了二分类的 loss，下面我们定义一下 loss 函数\n\n\n```python\ndef ls_discriminator_loss(scores_real, scores_fake):\n    loss = 0.5 * ((scores_real - 1) ** 2).mean() + 0.5 * (scores_fake ** 2).mean()\n    return loss\n\ndef ls_generator_loss(scores_fake):\n    loss = 0.5 * ((scores_fake - 1) ** 2).mean()\n    return loss\n```\n\n\n```python\nD = discriminator().cuda()\nG = generator().cuda()\n\nD_optim = get_optimizer(D)\nG_optim = get_optimizer(G)\n\ntrain_a_gan(D, G, D_optim, G_optim, ls_discriminator_loss, ls_generator_loss)\n```\n\n![](https://unpkg.com/justlovesmile-img/20201105174302-min.gif)\n\n上面我们讲了 最基本的 GAN 和 least squares GAN，最后我们讲一讲使用卷积网络的 GAN，叫做深度卷积生成对抗网络\n\n**Deep Convolutional GANs**\n\n深度卷积生成对抗网络特别简单，就是将生成网络和对抗网络都改成了卷积网络的形式，下面我们来实现一下\n\n卷积判别网络就是一个一般的卷积网络，结构如下\n\n* 32 Filters, 5x5, Stride 1, Leaky ReLU(alpha=0.01)\n* Max Pool 2x2, Stride 2\n* 64 Filters, 5x5, Stride 1, Leaky ReLU(alpha=0.01)\n* Max Pool 2x2, Stride 2\n* Fully Connected size 4 x 4 x 64, Leaky ReLU(alpha=0.01)\n* Fully Connected size 1\n\n\n```python\nclass build_dc_classifier(nn.Module):\n    def __init__(self):\n        super(build_dc_classifier, self).__init__()\n        self.conv = nn.Sequential(\n            nn.Conv2d(1, 32, 5, 1),\n            nn.LeakyReLU(0.01),\n            nn.MaxPool2d(2, 2),\n            nn.Conv2d(32, 64, 5, 1),\n            nn.LeakyReLU(0.01),\n            nn.MaxPool2d(2, 2)\n        )\n        self.fc = nn.Sequential(\n            nn.Linear(1024, 1024),\n            nn.LeakyReLU(0.01),\n            nn.Linear(1024, 1)\n        )\n        \n    def forward(self, x):\n        x = self.conv(x)\n        x = x.view(x.shape[0], -1)\n        x = self.fc(x)\n        return x\n```\n\n卷积生成网络需要将一个低维的噪声向量变成一个图片数据，结构如下\n\n* Fully connected of size 1024, ReLU\n* BatchNorm\n* Fully connected of size 7 x 7 x 128, ReLU\n* BatchNorm\n* Reshape into Image Tensor\n* 64 conv2d^T filters of 4x4, stride 2, padding 1, ReLU\n* BatchNorm\n* 1 conv2d^T filter of 4x4, stride 2, padding 1, TanH\n\n\n```python\nclass build_dc_generator(nn.Module): \n    def __init__(self, noise_dim=NOISE_DIM):\n        super(build_dc_generator, self).__init__()\n        self.fc = nn.Sequential(\n            nn.Linear(noise_dim, 1024),\n            nn.ReLU(True),\n            nn.BatchNorm1d(1024),\n            nn.Linear(1024, 7 * 7 * 128),\n            nn.ReLU(True),\n            nn.BatchNorm1d(7 * 7 * 128)\n        )\n        \n        self.conv = nn.Sequential(\n            nn.ConvTranspose2d(128, 64, 4, 2, padding=1),\n            nn.ReLU(True),\n            nn.BatchNorm2d(64),\n            nn.ConvTranspose2d(64, 1, 4, 2, padding=1),\n            nn.Tanh()\n        )\n        \n    def forward(self, x):\n        x = self.fc(x)\n        x = x.view(x.shape[0], 128, 7, 7) # reshape 通道是 128，大小是 7x7\n        x = self.conv(x)\n        return x\n\ndef train_dc_gan(D_net, G_net, D_optimizer, G_optimizer, discriminator_loss, generator_loss, show_every=250, \n                noise_size=96, num_epochs=10):\n    iter_count = 0\n    for epoch in range(num_epochs):\n        for x, _ in train_data:\n            bs = x.shape[0]\n            # 判别网络\n            real_data = Variable(x).cuda() # 真实数据\n            logits_real = D_net(real_data) # 判别网络得分\n            \n            sample_noise = (torch.rand(bs, noise_size) - 0.5) / 0.5 # -1 ~ 1 的均匀分布\n            g_fake_seed = Variable(sample_noise).cuda()\n            fake_images = G_net(g_fake_seed) # 生成的假的数据\n            logits_fake = D_net(fake_images) # 判别网络得分\n\n            d_total_error = discriminator_loss(logits_real, logits_fake) # 判别器的 loss\n            D_optimizer.zero_grad()\n            d_total_error.backward()\n            D_optimizer.step() # 优化判别网络\n            \n            # 生成网络\n            g_fake_seed = Variable(sample_noise).cuda()\n            fake_images = G_net(g_fake_seed) # 生成的假的数据\n\n            gen_logits_fake = D_net(fake_images)\n            g_error = generator_loss(gen_logits_fake) # 生成网络的 loss\n            G_optimizer.zero_grad()\n            g_error.backward()\n            G_optimizer.step() # 优化生成网络\n\n            if (iter_count % show_every == 0):\n                print('Iter: {}, D: {:.4}, G:{:.4}'.format(iter_count, d_total_error.data, g_error.data))\n                imgs_numpy = deprocess_img(fake_images.data.cpu().numpy())\n                show_images(imgs_numpy[0:16])\n                plt.show()\n                print()\n            iter_count += 1\n\nD_DC = build_dc_classifier().cuda()\nG_DC = build_dc_generator().cuda()\n\nD_DC_optim = get_optimizer(D_DC)\nG_DC_optim = get_optimizer(G_DC)\n\ntrain_dc_gan(D_DC, G_DC, D_DC_optim, G_DC_optim, discriminator_loss, generator_loss, num_epochs=5)\n```\n\n![](https://unpkg.com/justlovesmile-img/20201105174303-min.gif)\n可以看到，通过 DCGANs 能够得到更加清楚的结果\n\n### 6.3 Improving GAN\n\n#### 6.3.1 Wasserstein GAN\n\nWasserstein GAN是GAN的一种变式，WGAN的出现解决了下面这些难点\n- 彻底解决了训练不稳定的问题\n- 基本解决了coolapse mode 的问题，确保了生成样本的多样性\n- 训练中有一个向交叉熵，准确率的数值指标来衡量训练的进程，数值越小代表GAN训练得越好，同时也代表着生成的图片质量越高\n- 不需要精心设计网络结构也能取得较好的效果\n\n### 6.4 应用介绍\n\n#### 6.4.1 Conditional GAN\n\nConditional GAN的一个应用是文字生成图片\n\n#### 6.4.2 Cycle GAN\n\n根据一个人的作品，想象他完成其他场景会是什么样\n\n\n## 第七章 深度学习实战\n\n### 7.1 实例一，猫狗大战：运用预训练卷积神经网络进行特征提取与预训\n\n#### 7.1.1 背景介绍\n\nAsirra是一个图像识别机制的验证码，其有很多不同猫狗的照片（三百万张），可以用他的子集当作训练集\n\n#### 7.1.2 原理分析\n\n对于这个问题，简单的网络模型可能效果并不好，这个时候，使用一些成熟的模型，比如VggNet，GoogleNet，ResNet等可以帮助我们解决问题，为了节省计算资源和时间，可以通过迁移学习实现。\n\n**迁移学习**\n\n对于一个特定任务，如果没有来自该任务足够的数据集，传统的监督学习无法支持，而迁移学习允许通过借用已经存在的一些相关任务的标签数据来处理这些场景，把解决相关任务时获得的知识存储下来，并将它应用到我们感兴趣的目标任务中。\n\n卷积神经网络可以理解为两个部分：前面的**卷积**部分和后面的**分类**部分，卷积部分主要用于提取图片特征，而预训练的网络对于特征提取效果已经非常好。我们可以直接用预训练的网络卷积部分来提取我们自己的图片特征，而对于自己的任务，比如猫狗二分类，就用自己的分类全连接层即可。\n\n当然，迁移学习并不是任何时候都能使用，需要它们**完成的任务是相关的**，所以迁移学习在相似数据集上的应用效果才是良好的。\n\n**实现方法**\n\n1. 第一种方法：导入预训练的卷积网络，将最后的全连接层改成我们自己设计的全连接层，然后更新整个网络，最后能特别快地达到收敛\n2. 第二种方法：锁定前面卷积层的参数，让网络训练只更新最后全连接层的参数，可以使训练时间大大减少\n3. 第三种方法：使用多个预训练好的网络，将它们并联在一起，图片经过每个网络都会得到特征图，我们将这些特征图拼接在一起进入最后的全连接层\n\n#### 7.1.3 代码实现\n\n1.数据预处理\n\n数据集可以去 [https://www.kaggle.com/c/dogs-vs-cats/data](https://www.kaggle.com/c/dogs-vs-cats/data) 下载\n\n\n```python\nimport os\nimport shutil\n\ntrain_root = './data/dogs-vs-cats/train/'\nval_root = './data/dogs-vs-cats/val/'\ndata_file=os.listdir(train_root)\n#print(data_file)\ndog_file = list(filter(lambda x:x.split(\".\")[0]=='dog'and x!=\"dog\",data_file))\ncat_file = list(filter(lambda x:x.split(\".\")[0]=='cat'and x!=\"cat\",data_file))\n\nroot = './data/dogs-vs-cats/'\nif not os.path.exists(train_root+'dog/'):\n    os.makedirs(train_root+'dog/')\nif not os.path.exists(train_root+'cat/'):\n    os.makedirs(train_root+'cat/')\nif not os.path.exists(val_root+'dog/'):\n    os.makedirs(val_root+'dog/')\nif not os.path.exists(val_root+'cat/'):\n    os.makedirs(val_root+'cat/')\n\nfor i in range(len(dog_file)):\n    pic_path = root+'train/'+dog_file[i]\n    if i < len(dog_file)*0.9:\n        obj_path = train_root+'dog/'+dog_file[i]\n    else:\n        obj_path = val_root+'dog/'+dog_file[i]\n    shutil.move(pic_path,obj_path)\n\nfor i in range(len(cat_file)):\n    pic_path = root+'train/'+cat_file[i]\n    if i < len(cat_file)*0.9:\n        obj_path = train_root+'cat/'+cat_file[i]\n    else:\n        obj_path = val_root+'cat/'+cat_file[i]\n    shutil.move(pic_path,obj_path)\n```\n\n上面的操作实现了，将猫狗照片分别移动到训练集和验证集，其中90%的数据作为训练集，10%的图片作为验证集，使用`shutil.move()`来移动图片\n\n2.迁移学习模型训练\n\n\n```python\nimport torch\nimport torch.nn as nn\nimport torchvision\nfrom torch.autograd import Variable\nfrom torchvision import models,transforms,datasets\nfrom torch.utils.data import DataLoader\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\n\nimg_classes=2\nepoch_num = 2\npath = \"./data/dogs-vs-cats/\"\n\n#数据\ndata_transform = transforms.Compose([\n    transforms.CenterCrop(224),\n    transforms.ToTensor(),\n    transforms.Normalize([0.5, 0.5, 0.5],[0.5, 0.5, 0.5])\n])\n\n# ImageFOLDER 返回的是一个list，这里的写法是字典的形式\ndata_image = {x: datasets.ImageFolder(root=os.path.join(path, x),transform=data_transform) for x in [\"train\", \"val\"]}\ndata_loader_image = {x: DataLoader(dataset=data_image[x],batch_size=4,shuffle=True) for x in [\"train\", \"val\"]}\n\n# 分类\nclasses = data_image[\"train\"].classes # 按文件夹名字分类\nclasses_index = data_image[\"train\"].class_to_idx # 文件夹类名所对应的链值\n# 打印类别\nprint(classes) \nprint(classes_index)\n# 打印训练集，验证集大小\nprint(\"train data set:\", len(data_image[\"train\"]))\nprint(\"val data set:\", len(data_image[\"val\"]))\n\n#导入预训练的网络，并修改全连接层\nmodel = models.resnet18(pretrained=True) # 18层的残差网络\n#print(model)\n\nfor parma in model.parameters():\n    parma.requires_grad = False  # 不进行梯度更新\n\n# 改变模型的全连接层，本项目只需要输出2类\nmodel.fc = nn.Sequential(nn.Linear(512, 256),\n                                       nn.ReLU(),\n                                       nn.Dropout(p=0.5),\n                                       nn.Linear(256, 256),\n                                       nn.ReLU(),\n                                       nn.Dropout(p=0.5),\n                                       nn.Linear(256, 2))\n\nfor index, parma in enumerate(model.fc.parameters()):\n    parma.requires_grad = True\n\n# 是否有GPU\nuse_gpu = torch.cuda.is_available()\nprint(\"Find GPU: \",use_gpu)\nif use_gpu:\n    model = model.cuda()\n#print(model)\n\n# 定义代价函数\ncost = torch.nn.CrossEntropyLoss()\n# 定义优化器\noptimizer = torch.optim.Adam(model.fc.parameters(),lr=1e-4)\n\ndef train():\n    for epoch in range(epoch_num):\n        since = time.time()\n        print(\"Epoch{}/{}\".format(epoch+1, epoch_num))\n        print(\"-\" * 10)\n        for param in [\"train\", \"val\"]:\n            if param == \"train\":\n                model.train = True\n            else:\n                model.train = False\n\n            running_loss = 0.0\n            running_correct = 0\n            batch = 0\n            for data in data_loader_image[param]:\n                batch += 1\n                X, y = data\n                if use_gpu:\n                    X, y = Variable(X.cuda()), Variable(y.cuda())\n                else:\n                    X, y = Variable(X), Variable(y)\n\n                optimizer.zero_grad()\n                y_pred = model(X)\n                _, pred = torch.max(y_pred.data, 1)\n                loss = cost(y_pred,y)\n                if param == \"train\":\n                    loss.backward()\n                    optimizer.step()\n                running_loss += loss.item()\n                # running_loss += loss.data\n                running_correct += torch.sum(pred == y.data)\n                if batch % 5 == 0 and param == \"train\":\n                    print(\"Batch {}, Train Loss:{:.4f}, Train ACC:{:.4f}\".format(\n                        batch, running_loss / (4 * batch), 100 * running_correct / (4 * batch)))\n\n            epoch_loss = running_loss / len(data_image[param])\n            epoch_correct = 100 * running_correct / len(data_image[param])\n\n            print(\"{} Loss:{:.4f}, Correct:{:.4f}\".format(param, epoch_loss, epoch_correct))\n        now_time = time.time() - since\n        print(\"Training time is:{:.0f}m {:.0f}s\".format(now_time // 60, now_time % 60))\n\ntrain()\ntorch.save(model, 'dogsvscats.pth')\n```\n\n测试\n\n\n```python\nimport os\nimport torch\nimport torchvision\nfrom torchvision import datasets, transforms, models\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom torch.autograd import Variable\nimport time\nmodel = torch.load('dogsvscats.pth')\npath = \"./data/dogs-vs-cats\"\n\ntransform = transforms.Compose([transforms.CenterCrop(224),\n                                transforms.ToTensor(),\n                                transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])])\n\ndata_test_img = datasets.ImageFolder(root=path+\"/val/\", transform = transform) \n\ndata_loader_test_img = torch.utils.data.DataLoader(dataset=data_test_img,\n                                                  batch_size = 16,shuffle=True) #载入测试数据集，并随机打乱\nclasses = data_test_img.classes   ##class\n\nimage, label = next(iter(data_loader_test_img))\nimages = Variable(image).cuda()\ny_pred = model(images)\n_,pred = torch.max(y_pred.data, 1)\nprint(pred)\nprint(label)\n\nimg = torchvision.utils.make_grid(image)\nimg = img.numpy().transpose(1,2,0)\nmean = [0.5, 0.5, 0.5]\nstd = [0.5, 0.5, 0.5]\nimg = img * std + mean\nprint(\"Pred Label:\", [classes[i] for i in pred])\nplt.imshow(img)\nplt.show()\n```\n\n### 7.2 实例二，Deep Dream：探索卷积神经网络眼中的世界\n\n2015年，Google发布了一个有意思的东西，叫做Deep Dream\n\n#### 7.2.1 原理介绍\n\n**1.反向神经网络**\n\n我们知道经过训练之后，每一层网络足部提取越来越高级的图像特征，知道最后一层将这些特征比较做出分类的结果。比如前面几层也许在寻找边缘和拐角的特征，中间几层分析整体的轮廓特征，这样不断的增加层数就可以发展出越来越多的复杂特征，最后几层将这些特征要素组合起来形成完整的解释，这样到最后网络就会对非常复杂的东西，比如小猫，树叶等图片有所反应\n\n**2.Deep Dream**\n\n如果我们将算法反复地应用到自身的输出上，不断迭代，并在每次迭代后应用一些缩放，就能不断地激活特征，得到无尽的新效果。\n\n#### 7.2.2 代码实现\n\n\n```python\nimport torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\nfrom torchvision import models\nfrom torchvision import transforms, utils\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\n# PIL.ImageFilter是Python中的图像滤波，主要对图像进行平滑、锐化、边界增强等滤波处理\n# PIL.ImageChops模块包含一些算术图形操作，叫做channel operations（“chops”）。这些操作可用于诸多目的，比如图像特效，图像组合，算法绘图等等\nfrom PIL import Image, ImageFilter, ImageChops\n\n\n# 加载图像并显示\ndef load_image(path):\n    image = Image.open(path)\n    plt.imshow(image)\n    plt.title(\"Image loaded successfully\")\n    return image\n\n# 对数据集的标准化设置——减去均值再除以标准差\nnormalise = transforms.Normalize(\n    mean=[0.485, 0.456, 0.406],\n    std=[0.229, 0.224, 0.225]\n    )\n\n# 数据集的预处理，包括缩放、转换成Tensor、标准化\npreprocess = transforms.Compose([\n    transforms.Resize((224,224)),\n    transforms.ToTensor(),\n    normalise\n    ])\n\n# 逆向处理过程，逆标准化，图像乘以标准差再加上均值\ndef deprocess(image):\n    return image * torch.Tensor([0.229, 0.224, 0.225]).cuda()  + torch.Tensor([0.485, 0.456, 0.406]).cuda()\n\n# 下载vgg16的预训练模型，传到GPU上，输出网络结构\nvgg = models.vgg16(pretrained=True)\nvgg = vgg.cuda()\nmodulelist = list(vgg.features.modules())\n\n# 这是deep dream的实际代码，特定层的梯度被设置为等于该层的响应，这导致了该层响应最大化。换句话说，我们正在增强一层检测到的特征，对输入图像（octaves）应用梯度上升算法。\ndef dd_helper(image, layer, iterations, lr):        \n    # 一开始的输入是图像经过预处理、在正数第一个维度上增加一个维度以匹配神经网络的输入、传到GPU上\n    input = Variable(preprocess(image).unsqueeze(0).cuda(), requires_grad=True)\n    # vgg梯度清零\n    vgg.zero_grad()\n    # 开始迭代\n    for i in range(iterations):\n        # 一层一层传递输入\n        out = input\n        for j in range(layer):\n            out = modulelist[j+1](out)\n        # 损失是输出的范数\n        loss = out.norm()\n        # 损失反向传播\n        loss.backward()\n        # 输入的数据是上次迭代时的输入数据+学习率×输入的梯度\n        input.data = input.data + lr * input.grad.data\n    # 将从网络结构中取出的输入数据的第一个维度去掉\n    input = input.data.squeeze()\n    # 矩阵转置\n    input.transpose_(0,1)\n    input.transpose_(1,2)\n    # 将输入逆标准化后强制截断在0到1的范围内\n    input = np.clip(deprocess(input), 0, 1)\n    # 得到像素值为0到255的图像\n    im = Image.fromarray(np.uint8(input*255))\n    return im\n\n\n# 这是一个递归函数，用于创建octaves，并且将由一次递归调用生成的图像与由上一级递归调用生成的图像相融合\ndef deep_dream_vgg(image, layer, iterations, lr, octave_scale, num_octaves):\n    # 若octave序号大于0，即还未到达最底层的octave时，一层一层递归\n    if num_octaves>0:\n        # 对图像进行高斯滤波（高斯模糊）\n        image1 = image.filter(ImageFilter.GaussianBlur(2))\n        # 判断是否缩放\n        if(image1.size[0]/octave_scale < 1 or image1.size[1]/octave_scale<1):\n            size = image1.size\n        else:\n            size = (int(image1.size[0]/octave_scale), int(image1.size[1]/octave_scale))\n        # 图像缩放    \n        image1 = image1.resize(size,Image.ANTIALIAS)\n        # 递归调用，直至num_octave==0\n        image1 = deep_dream_vgg(image1, layer, iterations, lr, octave_scale, num_octaves-1)\n        size = (image.size[0], image.size[1])\n        # 将图像缩放到最初输入图像的大小\n        image1 = image1.resize(size,Image.ANTIALIAS)\n        # 将最初输入的图像与合成的相同尺寸大小的图像融合\n        image = ImageChops.blend(image, image1, 0.6)\n#     print(\"-------------- Recursive level: \", num_octaves, '--------------')\n    # 按照dd_helper中的流程生成图像\n    img_result = dd_helper(image, layer, iterations, lr)\n    # 图像缩放并显示\n    img_result = img_result.resize(image.size)\n    plt.imshow(img_result)\n    return img_result\n    \n# 加载图像(原始图像)\nsky = load_image('1.jpg')\n\n# 对于vgg16最后一个卷积层conv5_3,迭代5次，学习率为0.2,octave缩放比例为2,octave从第20层开始\nsky_28 = deep_dream_vgg(sky, 28, 5, 0.2, 2, 20)\n```","tags":["深度学习","Python","PyTorch"],"categories":["人工智能"]},{"title":"深度学习 | “花书”，Deep Learning笔记","slug":"人工智能-深度学习-花书","url":"/posts/43678.html","content":"\n# 深度学习\n\n### 第一章 前言\n\n深度学习(Deep Learning) ∈ 表示学习(Representation Learning) ∈ 机器学习(Machine Learning) ∈ 人工智能(AI)\n\n![](https://unpkg.com/justlovesmile-img/20201015120220.png)\n\n分类，回归，聚类，降维\n\n![](https://unpkg.com/justlovesmile-img/20201015120404.png)\n\n神经网络\n\n![](https://unpkg.com/justlovesmile-img/149537710807280383.jpg)\n\n\n## 第一部分 应用数学与机器学习基础\n\n### 第二章 线性代数\n\n#### 2.1 标量，向量，矩阵和张量\n\n1.标量(scalar)是一个单独的数\n2.向量(vector)是一列数，这些数是有序排列的\n\n$$\nx = \\begin{bmatrix}\nx_1\\\\\nx_2\\\\\n\\vdots\\\\\nx_n\\\\\n\\end{bmatrix}\n$$\n\n3.矩阵(matrix)是一个二维数组\n\n$$\n\\begin{bmatrix}\nA_{1,1} & A_{1,2}\\\\\nB_{2,1} & B_{2,2}\\\\\n\\end{bmatrix}\n$$\n\n4.张量(tensor)：一般将超过二维的数组称为张量\n\n- 转置：以对角线为轴的镜像\n\n$$\n(A^T)_{i,j}=A_{j,i}\n$$\n\n- 广播：将一个向量隐式的复制到每一行生成矩阵（用于运算）的方式\n\n$$C=A+b$$\n$$C_{i,j}=A_{i,j}+b$$\n$$\n\\begin{bmatrix}\nC_{1,1} & C_{1,2} & C_{1,3}\\\\\nC_{2,1} & C_{2,2} & C_{2,3}\\\\\nC_{3,1} & C_{3,2} & C_{3,3}\\\\\n\\end{bmatrix}=\n\\begin{bmatrix}\nA_{1,1} & A_{1,2} & A_{1,3}\\\\\nA_{2,1} & A_{2,2} & A_{2,3}\\\\\nA_{3,1} & A_{3,2} & A_{3,3}\\\\\n\\end{bmatrix}+\n\\begin{bmatrix}\nb_{1} & b_{2} & b_{3}\\\\\n\\end{bmatrix}=\n\\begin{bmatrix}\nA_{1,1} & A_{1,2} & A_{1,3}\\\\\nA_{2,1} & A_{2,2} & A_{2,3}\\\\\nA_{3,1} & A_{3,2} & A_{3,3}\\\\\n\\end{bmatrix}+\n\\begin{bmatrix}\nb_{1} & b_{2} & b_{3}\\\\\nb_{1} & b_{2} & b_{3}\\\\\nb_{1} & b_{2} & b_{3}\\\\\n\\end{bmatrix}\n$$\n\n#### 2.2 矩阵和向量相乘\n\n如果A的形状是m×n，B的形状是n×p，`C=AB`，那么C的形状是m×p\n具体地，该乘法操作定义为：\n$$C_{i,j}=\\sum_kA_{i,k}B_{k,j}$$\n\n>注意区分：存在一种两个矩阵对应元素的乘积，叫`Hadamard乘积`，记为`A⊙B`\n\n\n性质：\n- 分配律\n$$A(B+C)=AB+AC$$\n- 结合律\n$$A(BC)=(AB)C$$\n- **矩阵乘积不具有交换律**，但是两个向量的点积满足交换律\n$$x^Ty=y^Tx$$\n$$(AB)^T=B^TA^T$$\n\n对于AX=b，可表示\n$$A_{1,1}x_1+A_{1,2}x_2+\\cdots+A_{1,n}x_n=b_1$$\n$$A_{2,1}x_1+A_{2,2}x_2+\\cdots+A_{2,n}x_n=b_2$$\n$$\\vdots$$\n$$A_{m,1}x_1+A_{m,2}x_2+\\cdots+A_{m,n}x_n=b_m$$\n即\n$$\n\\begin{bmatrix}\nA_{1,1} & A_{1,2} & \\cdots & A_{1,n}\\\\\nA_{2,1} & A_{2,2} & \\cdots & A_{2,n}\\\\\n\\vdots\\\\\nA_{m,1} & A_{m,2} & \\cdots & A_{m,n}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{1}\\\\\nx_{2}\\\\\n\\vdots\\\\\nx_{n}\\\\\n\\end{bmatrix}=\n\\begin{bmatrix}\nb_{1}\\\\\nb_{2}\\\\\n\\vdots\\\\\nb_{m}\\\\\n\\end{bmatrix}\n$$\n\n#### 2.3 单位矩阵和逆矩阵\n\n单位矩阵：任何向量和单位矩阵相乘，都不会改变\n$${\\forall}x{\\in}R^n,I_nx=x$$\n\n$$I_3=\n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\\\\\n\\end{bmatrix}\n$$\n矩阵逆，记作$$A^{-1}$$，定义\n$$A^{-1}A=I_n$$\n\n#### 2.4 线性相关和生成子空间\n\n对于矩阵逆的定义：\n$$A^{-1}A=I_n$$\n可以通过以下步骤求解：\n$$Ax=b$$\n$$A^{-1}Ax=A^{-1}b$$\n$$I_nx=A^{-1}b$$\n$$x=A^{-1}b$$\n如果能找到一个逆矩阵$A^{-1}$，那么若$s=w_1x_1+w_2x_2+{\\cdots}+w_kx_k$。s变量是对变量x的加权线性”混合”。因此，将s定义为变量的线性组合。\n\n- 生成子空间：原始向量的一切线性组合生成的子空间\n\n- 线性无关：一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量被称为线性无关\n\n>如果数组向量中的某一个或多个向量可以由数组内的其余向量通过加法或数乘表达，则该向量组线性相关，反之则线性无关。\n\n- 方阵：行列大小相同的矩阵\n\n#### 2.5 范数\n\n为了衡量一个向量的大小，在机器学习中，我们经常使用范数（norm）的函数衡量。形式上，$L^p$范数定义如下：\n$$\n\\left \\| x \\right \\| _ p=\\left ( \\sum_i\\left | x_i \\right |^p\\right )^\\frac{1}{p}\n$$\n其中$p \\in \\mathbb{R},p \\geqslant 1$\n- 范数，是将向量映射到非负值的函数。直观上来说，向量x的范数衡量从原点到点x的距离。更严格的说，范数是满足下列性质的任意函数：\n$$f\\left (x \\right )=0\\Rightarrow x=0$$\n$$\nf\\left (x + y \\right )\\leqslant f \\left ( x \\right ) + f\\left(y \\right)\n$$\n\n$$\n\\forall \\alpha \\in \\mathbb{R},f({\\alpha}x)=|\\alpha|f(x)\n$$\n- 当p=2时，$L^2$范数被称为**欧几里得范数**。平方$L^2$范数，也经常用来衡量向量的大小。\n- $L^1$范数的定义，$||x|| _ 1 = \\sum_i|x_i|$\n- 另一个常在机器学习中出现的范数是$L^∞$范数，也被称为**最大范数**。这个范数表示向量中具有最大幅值的元素的绝对值：\n$$||x|| _ ∞ =\\max_i|x_i|$$\n\n- Frobenius范数：$$\\left \\|A\\right \\| _ F = \\sqrt{\\sum _ {i,j}{A^2} _ {i,j}}$$\n\n两个向量的**点积**，可以用范数来表示：\n$$x^Ty=||x|| _ 2 ||y|| _ 2 \\cos \\theta $$\n其中$\\theta$，表示x和y之间的夹角\n\n#### 2.6 特殊类型的矩阵和向量\n\n**对角矩阵**:只在主对角线上含有非零元素，其他位置都是零的矩阵。单位矩阵是对角元素都为1的对角矩阵。\n- 如果用diag(v)表示一个对角元素由向量v中的元素给定的对角方阵,那么$diag(v)x=v\\odot x$，并且计算对角方阵的逆矩阵也很高效，如果对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，这种情况下有，$diag(v)^{-1}=diag([\\frac{1}{v_1},\\cdots,\\frac{1}{v_n}]^T)$\n- 不是所有的对角矩阵都是方阵，非方阵的对角矩阵没有逆矩阵\n\n**对称矩阵**是转置和自己相等的矩阵\n$$A=A^T$$\n\n**单位向量**是具有**单位范数**的向量\n$$||x|| _ 2 = 1$$\n\n**正交**：如果$x^Ty=0$，那么向量x和向量y互相正交，如果两个向量都有非零范数，那么他们之间的夹角为90度。\n**标准正交**：如果这些向量的不仅互相正交，并且范数都为1，那么我们称他们为标准正交\n**正交矩阵**：指行向量和列向量是分别标准正交的方针\n$$A^TA=AA^T=I$$\n$$A^{-1}=A^T$$\n\n>补充关于点乘和叉乘：\n点乘，也叫数量积，结果是一个向量在另一个向量方向上的投影的长度，是一个标量；\n$A·B=|A||B|\\cos\\theta$，点积为0，说明两个向量正交\n叉乘，也叫向量积，结果是一个和已有两个向量都垂直的向量，向量模长是向量A，B组成平行四边形的面积，即$\\left \\| A×B\\right\\|=\\left\\|A \\right\\|\\left\\|B \\right\\|\\sin\\theta$；向量方向垂直于向量A,B组成的平面；\n$$A×B=\\begin{vmatrix}\ni & j & k\\\\ \na_1 & a_2 & a_3\\\\ \nb_1 & b_2 & b_3\n\\end{vmatrix}=\n\\begin{vmatrix}\na_2 & a_3\\\\\nb_2 & b_3\n\\end{vmatrix}i-\n\\begin{vmatrix}\na_1 & a_3\\\\\nb_1 & b_3\n\\end{vmatrix}j+\n\\begin{vmatrix}\na_1 & a_2\\\\\nb_1 & b_2\n\\end{vmatrix}k$$\n![](https://unpkg.com/justlovesmile-img/v2-1bc29eef9c32d93b6b9d6604b0ce65ea_720w.png)\n\n#### 2.7 特征分解\n\n**特征分解**是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值\n- **方阵A**的特征向量是指与A相乘后相当于对该向量进行缩放的非零向量v：$Av=λv$\n\n$({\\lambda}E-A)v=0$，求特征值$\\lambda$，其中$|{\\lambda}E-A|$被称为特征多项式\n\n- 标量λ被称为这个特征向量对应的特征值。如果v是A的特征向量，那么任何缩放后的向量sv（s∈R，s≠0）也是A的特征向量。此外sv和v有相同的特征值。\n\n假设矩阵A有n个线性无关的特征向量\n\n$$v^{(1)},\\cdots,v^{(n)}$$\n\n对应着特征值\n\n$${\\lambda} _ 1,\\cdots,{\\lambda} _ n$$\n\n将特征向量连接成一个矩阵，使得每一列是一个特征向量：\n\n$$V=[v^{(1)},\\cdots,v^{(n)}]$$\n\n类似地，将特征值连接成一个向量\n\n$$\\lambda =[{\\lambda} _ 1,\\cdots,{\\lambda} _ n]^T$$\n\n因此A的特征分解可以记作：\n\n$$A=Vdiag(\\lambda)V^{-1}$$\n\n- 特征分解唯一当且仅当所有的特征值都是唯一的\n- 矩阵是奇异的当且仅当含有零特征值（奇异：非满秩）\n- 正定（所有特征值为正），半正定（所有特征值非负），负定（所有特征值为负），半负定（所有特征值非正）\n\n对于每个实对称矩阵，都可以分解成实特征向量和实特征值\n$$A=QΛQ^T$$\n其中Ｑ是Ａ的特征向量组成的正交矩阵，Λ是对角矩阵。特征值$Λ_{i,j}$对应的特征向量是矩阵Q的第i列，记作$Q_{:,j}$\n\n#### 2.8 奇异值分解\n\n[奇异值分解视频](https://www.bilibili.com/video/BV1N4411a78K?from=search&seid=2326855606635926731)\n\n奇异值分解：将矩阵分解为**奇异向量**和**奇异值**\n假设A是一个m×n的矩阵，那么U是一个m×m的矩阵，D是一个m×n的矩阵，V是一个n×n的矩阵，其中U和V是正交矩阵，D是对角矩阵（不一定是方阵）\n$$A=UDV^T$$\n对角矩阵D对角线上的元素被称为矩阵A的**奇异值**，矩阵U的列向量被称为**左奇异向量**(是$AA^T$的特征向量)，矩阵V的列向量被称为**右奇异向量**（是$A^TA$的特征向量）。A的非零奇异值是$A^TA$特征值的平方根，也是$AA^T$特征值的平方根\n\n正交-对角-正交：旋转-拉伸-旋转\n\n$$A^TA=(VD^TU^T)(UDV^T)=V(D^TD)V^T$$\n$$AA^T=(UDV^T)(VD^TU^T)=U(D^TD)U^T$$\n$$A=\n\\begin{bmatrix}\nu_1 & u_2\n\\end{bmatrix}\n\\begin{bmatrix}\n\\sigma_1 & \\\\\n & \\sigma_2\n\\end{bmatrix}\n\\begin{bmatrix}\nv_1^T\\\\\nv_2^T\n\\end{bmatrix}\n$$\n\n例子：\n\n$$A=\\begin{bmatrix}\n2 & 2\\\\\n1 & 1\n\\end{bmatrix}=\n\\begin{bmatrix}\n\\frac{2}{\\sqrt{5}} & \\frac{1}{\\sqrt{5}}\\\\\n\\frac{-1}{\\sqrt{5}} & \\frac{2}{\\sqrt{5}}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\sqrt{10} & \\\\\n & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}}\\\\\n\\frac{1}{\\sqrt{2}} & \\frac{-1}{\\sqrt{2}}\n\\end{bmatrix}\n$$\n\n#### 2.9 Moore-Penrose伪逆\n\n对于非方阵，将矩阵A 的伪逆定义为：\n$$A^+=\\lim_{a\\rightarrow0}(A^TA+{\\alpha}I)^{-1}A^T$$\n实际计算公式\n$$A^+=VD^+U^T$$\n其中，矩阵U，D和V是矩阵A奇异值分解后得到的矩阵，对角矩阵D的伪逆$D^+$是其非零元素取倒数之后再转置得到的\n\n#### 2.10 迹运算\n\n迹运算返回的是矩阵对角元素的和：\n$$Tr(A)=\\sum_iA_{i,i}$$\n\n迹运算提供了另一种描述矩阵Frobenius范数的方式$$\\left\\|A\\right\\|_F=\\sqrt{Tr(AA^T)}$$\n迹运算在转置条件下是不变的\n$$Tr(A)=Tr(A^T)$$\n如果多个矩阵相乘交换顺序后仍有定义，那么有\n$$Tr(ABC)=Tr(CAB)=Tr(BCA)$$\n$$Tr(\\prod_{i=1}^{n}F^{(i)})=Tr(F^{(n)}\\prod_{i=1}^{n-1}F^{(i)})$$\n标量的迹运算还是它自己\n\n#### 2.11 行列式\n\n记作det(A),是一个将方阵A映射到实数的函数。行列式等于矩阵特征值的乘积\n\n#### 2.12 实例：主成分分析\n\n主成分分析（PCA,Principle component analysis）是一个简单的机器学习算法，可以通过基础的线性代数知识推导。\n\n假设，在$\\mathbb{R}^n$空间中我们有m个点，为了对这些点进行有损压缩，可以采取低维表示（线性降维），对于每个点$x^{(i)}\\in \\mathbb{R}^n$,会有一个对应的编码向量$c^{(i)}\\in \\mathbb{R}^l$。如果l比n小，那么便实现了压缩。需要设置一个编码函数，根据输入返回编码$f(x)=c$，也希望设置一个解码函数，给定编码重构输入$x≈g(f(x))$，为了简化解码器，使用矩阵乘法将编码映射回$\\mathbb{R}^n$，即g(c)=Dc，其中D∈$\\mathbb{R}^{n×l}$是定义解码的矩阵\n\n首先，我们需要明确如何根据每一个输入x得到一个最优编码\n$$c ^ *$$\n一种方法是最小化原始输入向量x和重构向量\n$$g(c^*)$$\n之间的距离,在PCA中，我们使用L2范数：\n$$c ^ * =arg\\min _ c \\left\\|x-g(c)\\right\\| _ 2$$\n\n>arg min f(x) 是指使得函数 f(x) 取得其最小值的所有自变量 x 的集合。\n\n当然也可以用平方L2范数来替代L2范数：\n$$c^*=arg\\min_c\\left\\|x-g(c)\\right\\|_2^2$$\n该最小化函数可以简化成：\n$$(x-g(c))^T(x-g(c))$$\n$$=x^Tx-x^Tg(c)-g(c)^Tx+g(c)^Tg(c)$$\n$$=x^Tx-2x^Tg(c)+g(c)^Tg(c)$$\n因为第一项$x^Tx$不依赖于c所以我们可以忽略它，得到：\n$$c^*=arg\\min_c - 2x^Tg(c)+g(c)^Tg(c)$$\n代入g(c)的定义：\n$$c^*=arg\\min_c - 2x^TDc+c^TD^TDc=arg\\min_c - 2x^TDc+c^TI_lc=arg\\min_c - 2x^TDc+c^Tc$$\n$$\\nabla_c(-2x^TDc+c^Tc)=0$$\n$$-2D^Tx+2c=0$$\n$$c=D^Tx$$\n于是，最优编码x只需要一个矩阵-向量乘法操作\n$$f(x)=D^Tx$$\nPCA重构操作\n$$r(x)=g(f(x))=DD^Tx$$\n接下来需要挑选编码矩阵D，所以我们需要最小化所有维数和所有点上的误差矩阵的Frobenius范数：\n$$D^*=arg\\min_D\\sqrt{\\sum_{i,j}(x_j^{(i)}-r(x^{(i)})_j)^2}\\text{ subject to } D^TD=I_l$$\n先考虑l=1的情况，此时D是一个单一向量d\n$$d^*=arg\\min_d\\sum\\left\\|x^{(i)}-dd^Tx^{(i)}\\right\\|_2^2\\text{ subject to } \\left\\|d\\right\\|_2=1$$\n将表示个点的向量堆叠成一个矩阵，记为X∈$\\mathbb{R}^{m×n}$，其中$X_{i,:}=x^{(i)^T}$\n原问题可以重新表示为：\n$$d^*=arg\\min_d\\left\\|X-Xdd^T\\right\\|_F^2\\text{ subject to }d^Td=1$$\n暂不考虑约束，可以把Frobenius范数简化成\n$$arg\\min_d\\left\\|X-Xdd^T\\right\\|_F^2$$\n$$=arg\\min_dTr((X-Xdd^T)^T(X-Xdd^T))$$\n$$=arg\\min_d-2Tr(X^TXdd^T)+Tr(X^TXdd^Tdd^T)$$\n再考虑约束条件\n$$arg\\min_d-2Tr(X^TXdd^T)+Tr(X^TXdd^Tdd^T)\\text{ subject to } d^td=1$$\n$$=arg\\max_dTr(d^TX^TXd)\\text{ subject to }d^Td=1$$\n即，最优的d是X^TX最大特征值对应的特征向量\n\n>PCA算法两种实现方法：\n（1）基于特征值分解协方差矩阵实现\n输入数据集X={x1,x2,x3,...,xn}，需要降到k维。\n1）去平均值（去中心化），即每一位特征减去各自的平均值\n2）计算协方差矩阵$\\frac{1}{n}XX^T$\n3）用特征值分解方法求协方差矩阵的特征值和特征向量\n4）对特征值从大到小排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为行向量组成特征向量矩阵P\n5）将数据转换到k个特征向量构建的新空间中，即Y=PX\n(2) 基于SVD分解（奇异值分解）协方差矩阵实现PCA算法\n\n### 第三章 概率与信息论\n\n概率论是用于表示不确定性申明的数学框架\n\n#### 3.1 为什么要使用概率\n\n几乎所有的活动都需要能够再不确定性存在时进行推理\n不确定性的三种来源：被建模系统内在的随机性，不完全观测，不完全建模\n\n#### 3.2 随机变量\n\n随机变量时可以随机地取不同值的变量。\n\n#### 3.3 概率分布\n\n概率分布用来描述随机变量或一簇随机变量在每一个可能取到的状态的可能性大小\n\n##### 3.3.1 离散型变量和概率质量函数\n\n1. 离散型变量的概率分布可以用概率质量函数(PMF，probability mass function)来描述\n2. 联合概率分布是多个变量的概率分布\n3. 如果用P表示概率质量函数，则满足以下条件\n\n- P的定义域必须是随机变量x所有可能状态的集合\n- $\\forall x \\in X, 0 \\leq P(x) \\leq 1$，不可能发生的事件概率为0，并且不存在比这概率更低的状态。类似的，一定发生的事件概率为1，且不存在比这概率更高的事件。\n- $\\sum_i P(x)=1$\n\n##### 3.3.2 连续型变量和概率密度函数\n\n对于连续型随机变量，用概率密度函数（PDF，probability density function），如果用p表示概率密度函数，则满足以下条件\n\n- p的定义域必须是x所有可能状态的集合\n- $\\forall x \\in X,p(x) \\geq 0$.并不要求p(x)≤1\n- $\\int p(x) \\text{d}x = 1$\n\n#### 3.4 边缘概率\n\n边缘概率分布，定义在其中一个子集上的概率分布\n\n$\\forall x \\in X,P(X=x)=\\sum_yP(X=x,Y=y)$\n$p(x)=\\int p(x,y) \\text{d}y$\n\n#### 3.5 条件概率\n\n条件概率，在给定其他事件发生时出现的概率，我们将给定X=x，Y=y发生的条件概率记为P(Y=y|X=x)\n计算公式如下\n$$P(Y=y|X=x)=\\frac{P(Y=y,X=x)}{P(X=x)}$$\n\n条件概率只在P(X=x)＞0时有定义\n\n#### 3.6 条件概率的链式法则\n\n任何多维随机变量的联合概率分布，都可以分解成只有一个变量的条件概率相乘的形式\n$$P(x^{(1)},\\cdots,x^{(n)})=P(x^{(1)})\\prod_{i=2}^{n}P(x^{(i)}|x^{(1)},\\cdots,x^{(i-1)})$$\n\n例如：\nP(a,b,c)=P(a|b,c)P(b,c)\nP(b,c)=P(b|c)P(c)\nP(a,b,c)=P(a|b,c)P(b|c)P(c)\n\n#### 3.7 独立性和条件独立性\n\n**相互独立**：两个随机变量x，y的概率分布可以表示为两个因子的乘积形式，并且一个因子只包含x，另一个只包含y，那么这两个随机变量是相互独立的\n$$\\forall x \\in X,y\\in Y,p(X=x,Y=y)=p(X=x)p(Y=y)$$\n\n**条件独立**：如果关于x和y的条件概率分布对于z的每一个值都可以写成乘积的形式，那么这两个随机变量x和y在给定随机变量z时是条件独立的\n\n$$\\forall x \\in X,y\\in Y,z\\in Z,p(X=x,Y=y|Z=z)=p(X=x|Z=z)p(Y=y|Z=z)$$\n\n#### 3.8 期望，方差，协方差\n\n（1）期望(expected value)\n函数f(x)关于某分布P(x)的期望或者期望值是指，当x由P产生，f作用到x时，f(x)的平均值\n\n离散型随机变量的期望\n$$\\mathbb{E} _ {x\\sim P}[f(x)]=\\sum_x P(x)f(x)$$\n连续型随机变量的期望\n$$\\mathbb{E} _ {x\\sim P}[f(x)]=\\int p(x)f(x)\\text{d}x$$\n\n期望是线性的，假设α和β不依赖于x\n$$\\mathbb{E}_ x[\\alpha f(x)+ \\beta g(x) ]=\\alpha \\mathbb{E}_ x[f(x)] +\\beta \\mathbb{E}_ x[g(x)]$$\n\n（2）方差(variance)\n$$Var(f(x))=\\mathbb{E}[(f(x)-\\mathbb{E}[f(x)])^2]$$\n\n方差的平方根被称为标准差\n\n（3）协方差\n$$Cov(f(x),g(y))=\\mathbb{E}[(f(x)-\\mathbb{E}[f(x)])(g(y)-\\mathbb{E}[g(y)])]$$\n\n两个随机变量独立→协方差为0→没有线性关系\n但是协方差为0，两个变量不一定独立\n\n协方差矩阵：\n$$Cov(x)_ {i,j}=Cov(x_i,x_j)$$\n协方差矩阵的对角元是方差：\n$$Cov(x_i,x_i)=Var(x_i)$$\n\n#### 3.9 常用概率分布\n\n##### 3.9.1 Bernoulli分布（伯努利分布）\n\n单个二值随机变量的分布，又名两点分布，0-1分布\n\n- 对于单次随机试验，对于一个随机变量X而言：\n$$P(X=1)=p$$\n$$P(X=0)=1-p$$\n$$P(X=x)=p^x(1-p)^{1-x}$$\n$$E(X)=p$$\n$$Var(X)=p(1-p)$$\n\n- 进行一次伯努利试验，成功(X=1)概率为p(0≤p≤1)，失败(X=0)概率为1-p，则称随机变量X服从伯努利分布。伯努利分布是离散型概率分布，其概率质量函数为：\n\n$$f(x)=p^x(1-p)^{1-x}=\\left\\{\\begin{matrix}\np \\text{ ,if x=1}\\\\ \n1-p \\text{ ,if x=0}\\\\\n0 \\text{ ,otherwise}\n\\end{matrix}\\right.$$\n\n##### 3.9.2 Multinoulli分布\n\nMultinoulli分布，或称范畴分布，是指在具有k个不同状态的单个离散型随机变量上的分布，其中k是一个有限值\n\n>Multinoulli分布是多项式分布（Multinomial distribution）的一个特例。多项式分布是${0,...,n}^k$中的向量的分布，用于表示当对Multinoulli分布采样n次时k个类中的每一个被访问的次数。即n=1的多项式分布是Multinoulli分布。\n\nMultinoulli分布由向量$p∈[0,1]^{k−1}$参数化，其中每一个分量$ p_i $表示第 i 个状态的概率。最后的第k个状态的概率可以通过$1−1^Tp$给出。注意我们必须限制$1^⊤p≤1$。Multinoulli分布经常用来表示对象分类的分布，所以我们很少假设状态 1 具有数值 1 之类的。因此，我们通常不需要去计算 Multinoulli 分布的随机变量的期望和方差。\n\nBernoulli 分布和 Multinoulli 分布足够用来描述在它们领域内的任意分布。它们能够描述这些分布，不是因为它们特别强大，而是因为它们的领域很简单。它们可以对那些能够将所有的状态进行枚举的离散型随机变量进行建模。当处理的是连续型随机变量时，会有不可数无限多的状态，所以任何通过少量参数描述的概率分布都必须在分布上加以严格的限制。\n\n##### 3.9.3 高斯分布\n\n高斯分布，也叫正态分布\n\n$$N(x;\\mu ,\\sigma^2 )=\\sqrt{\\frac{1}{2\\pi \\sigma^2}}exp(-\\frac{1}{2\\sigma^2}(x-\\mu)^2)$$\n$$N(x;\\mu ,\\sigma^2 )=\\sqrt{\\frac{1}{2\\pi \\sigma^2}}e^{(-\\frac{1}{2\\sigma^2}(x-\\mu)^2)}$$\n\n正态分布的概率密度函数的图象的中心峰的x坐标由μ给出，峰的宽度受σ控制\n标准正态分布：μ=0，σ=1\n\n$$\\mathbb{E}(x)=\\mu$$\n$$Var(x)=\\sigma^2$$\n\n\n令β为方差的倒数，来控制分布的精度\n$$N(x;\\mu ,\\beta^{-1} )=\\sqrt{\\frac{\\beta}{2\\pi}}e^{(-\\frac{1}{2}\\beta(x-\\mu)^2)}$$\n\n正态分布可以推广到$\\mathbb{R}^n$空间，这种情况下被称为多维正态分布\n$$N(x;\\mu ,\\sum )=\\sqrt{\\frac{1}{(2\\pi)^ndet(\\sum)}}e^{(-\\frac{1}{2}(x-\\mu)^T\\sum^{-1}(x-\\mu))}$$\n\n参数μ仍然表示分布的均值，只不过现在是向量值。参数∑给出了分布的协方差矩阵，但并不是一个很高效的参数化分布的方式，因为要对∑求逆，因此可以使用一个精度矩阵**β**替换\n$$N(x;\\mu ,\\beta^{-1} )=\\sqrt{\\frac{det(\\beta)}{(2\\pi)^n}}e^{(-\\frac{1}{2}(x-\\mu)^T\\beta(x-\\mu))}$$\n\n##### 3.9.4 指数分布和Laplace分布\n\n指数分布，可以用来表示事件的时间间隔的概率，可以由泊松分布推导出来\n\n其概率密度函数\n$$f(x)=\\left\\{\\begin{matrix}\n\\lambda e^{-\\lambda x} , x >0 \\\\\n0 , otherwise\n\\end{matrix}\\right.$$\n分布函数\n$$F(x)=\\left\\{\\begin{matrix}\n1-\\lambda e^{-\\lambda x} , x \\geqslant 0 \\\\\n0 , x＜0\n\\end{matrix}\\right.（\\lambda>0）$$\n\nLaplace分布，允许我们在任意一点μ处设置概率质量的峰值\n$$Laplace(x;\\mu , \\gamma ) = \\frac{1}{2\\gamma}exp(-\\frac{|x-\\mu|}{\\gamma})$$\n\n##### 3.9.5 Dirac分布和经验分布\n\n概率密度函数\n$$p(x)=\\delta(x-\\mu)$$\n\nDirac分布经常作为经验分布的组成部分出现\n\n##### 3.9.6 分布的混合\n\n潜变量：不能直接观测到的随机变量\n\n高斯混合模型，概率密度的万能近似器\n\n先验概率：在观测到x之前计算的\n后验概率：在观测到x之后计算的\n\n#### 3.10 常用函数的有用性质\n\nlogistic sigmoid函数,在变量取绝对值很大的正值或负值时出现饱和现象\n\n$$\\sigma(x)=\\frac{1}{1+e^{-x}}$$\n\nsoftplus函数,范围（0,∞）\n\n$$\\zeta (x)=log(1+e^x)$$\n\nReLU函数，人工神经网络常用的激活函数\n\n$$f(x)=max(0,x)$$\n\n#### 3.11 贝叶斯规则\n\n$$P(x|y)=\\frac{P(x)P(y|x)}{P(y)}$$\n\n#### 3.12 连续型变量的技术细节\n\n测度论\n零测度\n几乎处处\nJacobin矩阵\n\n#### 3.13 信息论\n\n量化信息\n- 非常可能发生的事件信息量要比较少，并且极端情况下，确保能够发生的事件没有信息量\n- 较不可能发生的事件具有更高的信息量\n- 独立事件应具有增量的信息。例如，投掷的硬币两次正面朝上传递的信息量，应该是投掷一次硬币正面朝上信息量的两倍\n\n定义一个事件X=x的自信息为\n$$I(x)=-logP(x)$$\nlog为自然对数，底为e，I(x)单位是奈特，一奈特是以1/e概率观测到一个事件时获得的信息量\n若以2为底数，单位是比特或者香农\n\n香农熵，一个分布的香农熵时指遵循这个分布的事件所产生的期望信息总量\n$$H(x)=\\mathbb{E}_ {x\\sim P}[I(x)]=-\\mathbb{E} _ {x \\sim P}[logP(x)]$$\n\n当x连续，香农熵被称为微分熵\n\nKL散度，用域衡量两个分布的差异\n$$D_{KL}(P||Q)=\\mathbb{E} _ {x \\sim P}[log\\frac{P(x)}{Q(x)}]=\\mathbb{E} _ {x \\sim P}[logP(x)-logQ(x)]$$\n\n交叉熵\n$$H(P,Q)=-\\mathbb{E}_ {x \\sim P} logQ(x)$$\n\n#### 3.14 结构化概率模型\n\n结构化概率模型，又叫图模型\n\n有向\n无向\n\n\n### 第四章 数值计算\n\n#### 4.1 上溢和下溢\n\n通过有限数量的位表示无限多的实数，总会引入舍入误差，包括了上溢和下溢\n对上溢和下溢进行数值稳定的一个例子是softmax函数\n$$softmax(x) _ i=\\frac{exp(x_i)}{\\sum_{j=1}^nexp(x_j)}$$\n\n#### 4.2 病态条件\n\n条件数表征函数相对于输入的微小变化而变化的快慢程度\n考虑函数$f(x)=A^{-1}x$，当A∈$\\mathbb{R}^{n×n}$具有特征分解时，其条件数为\n$$\\max_{i,j}|\\frac{\\lambda_i}{\\lambda_j}|$$\n\n#### 4.3 基于梯度的优化方法\n\n（1）优化\n大多数深度学习算法涉及某种形式的优化，包括改变x以最小化或最大化某个函数f(x)。通常以最小化指代大多数最优化问题，最大化可以经由-f(x)来实现\n\n目标函数（准则）：要最小化或最大化的函数\n代价函数（损失函数/误差函数）：对其进行最小化时也称之为代价函数\n\n梯度下降：将x往导数反方向移动来减小f(x)\n\n$\\frac{df(x)}{x}=0$的点称为临界点，驻点\n有些临界点既不是最大点也不是最小点，被称为鞍点\n\n（2）偏导，梯度，方向导数\n对于多维输入函数，提出了**偏导数**。偏导数为函数在每个位置处沿着自变量坐标轴方向上的导数（切线斜率）\n\n**梯度**，写作$\\nabla_xf(x)$，当前位置的梯度方向，为函数在该位置处方向导数最大的方向，也是函数值上升最快的方向，反方向为下降最快的方向。当前位置的梯度长度（模），为最大方向导数的值\n\n**方向导数**，如果是方向不是沿着坐标轴方向，而是任意方向，则为方向导数\n\n##### 4.3.1 梯度之上：Jacobin和Hessian矩阵\n\n1.Jacobin\n在向量分析中, 雅可比矩阵是一阶偏导数以一定方式排列成的矩阵, 其行列式称为雅可比行列式. 还有, 在代数几何中, 代数曲线的雅可比量表示雅可比簇：伴随该曲线的一个代数群, 曲线可以嵌入其中. \n\n雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近. 因此, 雅可比矩阵类似于多元函数的导数.\n$$\\begin{bmatrix}\n\\frac{\\partial y_1}{\\partial x_1} &\\cdots& \\frac{\\partial y_1}{\\partial x_n} \\\\\n\\vdots & \\ddots & \\vdots \\\\\n\\frac{\\partial y_m}{\\partial x_1} &\\cdots& \\frac{\\partial y_m}{\\partial x_n}\n\\end{bmatrix}$$\n\n\n2.Hessian\n在数学中, 海森矩阵(Hessian matrix或Hessian)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 此函数如下：\n$f(x_1,x_2,\\cdots,x_n)$，如果f的所有二阶导数都存在，那么\n$$\\begin{bmatrix}\n\\frac{\\partial^2 f}{\\partial x_1^2} & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} &\\cdots& \\frac{\\partial^2 f}{\\partial x_1 \\partial x_n} \\\\\n\\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\frac{\\partial^2 f}{\\partial x_2^2} &\\cdots& \\frac{\\partial^2 f}{\\partial x_2 \\partial x_n} \\\\\n\\vdots & \\vdots & \\ddots &\\vdots\\\\\n\\frac{\\partial^2 f}{\\partial x_n \\partial x_1} & \\frac{\\partial^2 f}{\\partial x_n \\partial x_2} &\\cdots& \\frac{\\partial^2 f}{\\partial x_n^2} \n\\end{bmatrix}$$\n\nHessian矩阵等价于梯度的Jacobian矩阵\n海森矩阵在牛顿法中的应用，牛顿法时一个基于二阶泰勒展开来近似x附近的f(x)的方法\n\n例如：在x0处展开\n$$f(x)=f(x_0)+(x-x_0)^T\\nabla_xf(x_0)+\\frac{1}{2}(x-x_0)^TH(f)(x_0)(x-x_0)$$\n临界点为\n$$X'=X_0-H(f)(x_0)^{-1}\\nabla_xf(x_0)$$\n\n#### 4.4 约束优化\n\n在x的某些集合S中找f(x)的最大值或最小值，称为约束优化\n\nKarush-Kuhn-Tucker（KKT）方法\n\n广义Lagrangian（广义Lagrange函数）,通过m个函数g和n个函数h描述S，那么S可以表示为$\\mathbb{S}=\\{x|\\forall i,g^{(i)}(x)=0 and \\forall j ,h^{(j)}(x)≤0\\}$，其中涉及g的等式称为等式约束，涉及h的不等式称为不等式约束，定义如下：\n$$L(x,\\lambda , \\alpha)=f(x)+\\sum_i\\lambda_ig^{(i)}(x)+\\sum_j\\alpha_jh^{(j)}(x)$$\n\n#### 4.5 实例：线性最小二乘\n\n假设我们希望最小化下式中的x值：\n\n$$f(x)=\\frac{1}{2}\\left\\|Ax-b\\right\\| _ 2 ^ 2$$\n\n首先，计算梯度\n$$\\nabla_xf(x)=A^T(Ax-b)=A^TAx-A^Tb$$\n\n假设希望最小化同样的函数，但受$x^Tx≤1$的约束\n$$L(x,\\lambda)=f(x)+\\lambda(x^Tx-1)$$\n\n现在，我们解决以下问题\n$$\\min_x\\max_{\\lambda , \\lambda ≥ 0}L(x,\\lambda)$$\n\n我们可以用Moore-Penrose伪逆。\n关于x对Lagrangian微分，得到\n$$A^TAx-A^Tb+2\\lambda x=0$$\n\n解为：\n$$x=(A^TA+2\\lambda I)^{-1}A^Tb$$\n\n观察\n$$\\frac{\\partial}{\\partial \\lambda}L(x,\\lambda)=x^Tx-1$$\n\n当x的范数超过1时，该导数是正的，所以为了跟随导数上坡并相对λ增加Lagrangian，我们需要增加λ。因为$x^Tx$的惩罚系数增加，秋节关于x的线性方程现在将得到具有较小范数的解\n\n### 第五章 机器学习基础\n\n#### 5.1 学习算法\n\n能够从数据中学习的算法\n\n##### 5.1.1 任务T\n\n通常机器学习任务定义为机器学习系统应该如何处理样本。\n样本是我们从希望机器学习系统处理的对象或事件中收集到的已经量化的特征的集合\n\n常见任务：分类，输入缺失分类，回归，转录，机器翻译，结构化输出，异常检测，合成和采样，缺失值填补，去噪，密度估计或概率质量函数估计\n\n##### 5.1.2 性能度量P\n\n为了评估机器学习算法的能力，提出准确率，错误率\n\n使用测试集数据来评估系统性能，将其与训练机器学习系统的训练集数据分开\n\n##### 5.1.3 经验E\n\n机器学习算法分为无监督算法和监督算法\n\n##### 5.1.4 示例：线性回归\n\n#### 5.2 容量，过拟合和欠拟合\n\n##### 5.2.1 没有免费午餐定理\n\n##### 5.2.2 正则化\n\n#### 5.3 超参数和验证集\n\n##### 5.3.1 交叉验证\n\n#### 5.4 估计，偏差和方差\n\n##### 5.4.1 点估计\n\n##### 5.4.2 偏差\n\n##### 5.4.3 方差和标准差\n\n##### 5.4.4 权衡偏差和方差以最小化均方误差\n\n##### 5.4.5 一致性\n\n#### 5.5 最大似然估计\n","tags":["深度学习"],"categories":["人工智能"]},{"title":"大学课程 | 计算机系统结构精简知识点","slug":"学习笔记-计算机系统结构精简知识点","url":"/posts/651e6a0b.html","content":"\n[计算机系统结构笔记传送门](/posts/50754.html)\n\n# 计算机系统结构知识点\n\n1. 多级层次结构：\n（1）按功能划分成多层机器级组成的层次结构，从上到下依次为，应用语言机器级，高级语言机器级，汇编语言机器级，操作系统机器级，传统机器语言机器级，微程序机器级。\n（2）机器，被定义为能存储和执行相应语言程序的算法和数据结构的集合体\n（3）微程序机器级用硬件实现，传统机器语言机器级用固件实现\n（4）固件：具有软件功能的硬件\n（5）以软件为主实现的机器称为虚拟机器，由硬件或固件实现的称为实际机器\n2. 透明性：\n（1）客观存在的事物或属性从某个角度看不见\n3. 翻译与解释\n（1）翻译：先用转换程序将高一级机器级上的程序`整个`变换成低一级机器级上等效的程序，然后再在低一级机器级上实现的技术\n（2）解释：在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级的机器级语言程序中的每条语句或指令`逐条`解释来实现的技术\n4. 软硬件逻辑功能等效\n（1）概念：软硬件逻辑功能等效是指计算机系统的某功能可以由硬件实现也可以由软件实现，在逻辑功能上是等价的。由硬件实现功能的特点是速度快、增加硬件成本，灵活性低。由软件实现功能的特点是灵活性好、但速度较慢，增加软件设计费用等\n5. 计算机系统结构、组成与实现的定义及三者之间的关系，以乘法指令为例说明上述三者各自的研究内容\n（1）计算机系统结构的定义：对计算机系统中各级界面的定义及其上下的功能分配\n（2）计算机组成的定义：计算机系统结构的逻辑实现，包括机器级内部的数据流和控制流的组成以及逻辑设计等\n（3）计算机实现：是指计算机组成的物理实现（具体电路，器件的设计，装配技术等等）\n（4）三者的关系：三者互不相同，但又相互影响。组成向上决定于结构，向下受限于实现技术。\n（5）对于乘法指令，计算机系统结构主要考虑是否要设置乘法指令；而计算机组成主要考虑乘法指令是用专门的高速乘法器还是用加法器和移位器实现；计算机实现主要考虑乘法器，加法器的物理显示，如器件的类型，继承父，数量的确定和选择\n6. 计算机系统结构的设计思路\n（1）`“由上往下”设计`，由顶向底。先考虑应用要求，再逐级向下，下一级是对上一级的优化。是一种穿行设计方法，设计周期较长\n（2）`“由下往上”设计`，由底向顶。先设计底层，再加配操作系统和编译系统，以及设施的系统软件和算法等等。软硬件容易脱节，串行设计，周期长，很少采用\n（3）`“从中间开始”向两边设计`。一般方法。软硬件并行设计，较好的设计方法\n7. 软件移植及三种移植技术\n（1）软件的可移植性：软件不修改或只经少量修改就可以由一台机器移到另一台机器上允许，同一软件可应用于不同的环境\n（2）移植技术：`统一高级语言`；`采用系列机`；`模拟和仿真`\n8. 软件兼容及分类\n（1）软件兼容：机器语言程序以及编译程序能不加修改地通用于各档机器\n（2）分类：\na. 向上兼容/向下兼容：向上（下）兼容是指，按某党机器编制的软件，不加修改就能运行于比他高（低）档的机器上。\nb. 向前兼容/向后兼容：向前（后）兼容是指，按某个时期投入市场的该型号机器上编制的软件，不加修改就能运行于在它之前（后）的投入市场的机器上。\n（3）系列机软件必须保证向后兼容，力争向上兼容\n9. 系列机与兼容机，模拟与仿真\n（1）系列机：是具有相同体系结构，但组成和实现不同的一系列不同型号的计算机系统。\n兼容机：不同厂家生产的具有相同体系结构的计算机。\n（2）模拟：用机器语言程序（在主存）解释实现软件移植的方法；运行速度低，实时性差，模拟程序复杂\n仿真：用微程序（在控制寄存器）直接解释另一种机器指令系统的方法；两种系统结构差别较大时，难以仿真\n两者的主要区别在于解释用的语言，其次有解释程序的所存位置不同\n10. 应用与器件对系统结构的影响\n（1）应用的发展对结构设计提出范围广泛的要求\n（2）器件的发展改变了逻辑设计的传统方法；推动结构和组成前进的关键因素；加速了结构“下移”；促进了算法，语言和软件的发展\n11. 并行性概念及发展并行性的三种技术途径\n（1）并行性：把解题中具有可以同时进行运算或操作的特性称为并行性，并行性包括同时性和并发性\n（2）并行性等级：\n①按计算机系统执行程序的角度，从低到高：指令内部，指令之间，任务或进程之间，作业或程序之间\n②从计算机系统中处理数据的角度来看，从低到高：位串字串，位并字串，位片串字并，全并行\n（3）三种技术途径：时间重叠，资源重叠，资源共享\n时间重叠：多个处理过程在时间上错开\n资源重叠：重复设置硬件资源来提高可靠性和性能\n资源共享：多个用户按时间顺序轮流使用同一套资源\n12. 耦合度概念\n（1）耦合度概念：反映多机系统中各机器之间物理连接的紧密度和交叉作用能力\n（2）分类：\n最低耦合：除存储介质，无物理连接，脱机\n松散耦合：通过通道或通信线路互连，磁带，磁盘...\n紧密耦合：通过总线或高速开关互连，主存...\n13. 弗林分类法\n（1）单指令流单数据流（SISD），传统单处理器计算机\n（2）单指令流多数据流（SIMD），阵列处理机和相联处理机\n（3）多指令流单数据流（MISD），很少见\n（4）多指令流多数据流（MIMD），多级系统\n14. 数据表示与数据结构\n（1）数据表示：能由机器硬件识别和引用的数据类型（数据类型指一类值的集合和可作用于其上的操作集）\n（2）数据结构：结构数据类型的组织方式，反映了应用中要用到的各种数据元素或信息单元之间的结构关系\n（3）数据结构和数据表示是软硬件的交界面，数据结构是软，数据表示是硬\n15. 高级数据表示\n（1）自定义数据表示：\na). 标识符数据表示\n①每个数据带了类型标志位，标识符主要用于指明数据类型，但也可以用域指明所用信息类型。标识符由编译程序建立，对高级语言程序透明。\n②优点：简化了指令系统和程序设计；简化了编译程序；便于一致性校验；能由硬件自动变换数据类型；支持数据库系统的实现与数据类型无关的要求；为软件调试和应用软件开发提供了支持，便于程序的跟踪和调试\n③缺点：增加程序所占的主存空间；降低指令的执行速度\nb). 数据描述符\n①描述符和数据分开存放，用于描述所访问的数据是整块的还是单个的，访问该数据块或数据元素所要的地址以及其它信息\n②优点：进一步减少标识符所占存储空间\n（2）向量，数组数据表示\n①有向量数据表示的处理机是向量处理机\n②优点：加快形成元素地址，便于实现把向量各元素成块预取到中央处理机，用一条向量，数组指令流水或同事对整个向量，数组进行高速处理\n（3）堆栈数据表示\n①有堆栈数据表示的处理机是堆栈机器\n②通常用于保存子程序调用时的返回地址\n③堆栈机器特点：有丰富的堆栈操作指令且功能强大；有力地支持了高级语言程序的编译；有力的支持了子程序的嵌套和递归调用\n16. 引入数据表示的原则\n（1）原则1：看系统的效率是否显著提高，包括实现时间和存储空间是否显著减少。实现时间是否减少又主要看主存和处理机之间传送的信息量是否减少\n（2）原则2：看引入这种数据表示后，其通用性和利用率是否提高\n（3）原则3：基本的数据表示，也有可挖掘的细节问题\n（4）原则4：基本的数据类型必须设\n17. 浮点数尾数基值的选择与下溢处理方法\n（1）浮点数尾数基值的选择\n如果小数点的位置事先已有约定，不再改变，此类数称为“定点数”。\n如果小数点的位置可变，则称为“浮点数”。\n![](https://unpkg.com/justlovesmile-img/20200826171758.png)\nrm ：尾数的基\nre ：阶码的基（re =2）\nm： 尾数长度 (注意其含义)\np： 阶码长度\n【p表示数的范围大小；尾数的位数m主要影响表示值的精度】\n![](https://unpkg.com/justlovesmile-img/20200415135441.png)\n\n|条件：非负阶，规格化，正尾数|阶值：二进制p位，尾数：rm进制m'位|若p=2，m=4，当rm=2（即m'=4）时|若p=2，m=4，当rm=16（即m'=1）时|\n|:---:|:---:|:---:|:---:|\n|可表示最小尾数值|rm^(-1)|1/2|1/16|\n|可表示最大尾数值|1-1×rm^(-m')|15/16|15/16|\n|最大阶值|2^p-1|3|3|\n|可表示最小值|rm^(-1)|1/2|1/16|\n|可表示最大值|rm^(2^p-1)×(1-rm^(-m'))|7.5|3840|\n|可表示的尾数个数|rm^(m')×(rm-1)/rm|8|15|\n|可表示阶的个数|2^p|4|4|\n|可表示数的个数|2^p×rm^(m')×(rm-1)/rm|32|60|\n\n（2）下溢处理方法（对应用程序员，系统程序员透明）\n减少运算中的精度损失关键是要处理好运算中尾数超出字长的部分，使精度损失最小\na) **截断法**\n①方法：**将尾数超出机器字长的部分去掉**\n②以rm=2，m=2为例讨论最大误差：在整数时接近于1(“11:111…1”截断成“11:”)；在分数时接近于2^(-m) (“.01:111…1”截断成“.01:”)\n③对于正数，如有误差总是负误差\n![](https://unpkg.com/justlovesmile-img/20200415140626.png)\n④优点：实现简单，不增加硬件，不需要处理时间\n缺点：最大误差较大，且平均误差为负且较大，无法调节，因而已很少使用\nb) **舍入法**\n①方法：在机器运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加1，[整数加0.5，分数加2^(-(m+1))]\n②例如：整数：“10:10…0”舍入成“11:” 正误差；分数：“.10:01…0”舍入成“.10:” 负误差\n③优点：实现简单，增加的硬件开销少，最大误差小，平均误差接近于零，略偏正\n缺点：处理速度慢，需要花费在数的附加位加1以及因此产生进位的时间，最坏情况下，需要从尾数最低位进制\n![](https://unpkg.com/justlovesmile-img/20200415000000.png)\nc) **恒置“1”法**\n①方法：将机器运算的规定字长之最低位恒置“1”\n②最大误差：整数为1（如“10:00…0”处理成“11:”）；分数为2-m（如“.00:00…0”处理成“.01:”）\n③误差有正负：负误差（如“.11:10…1”处理成“.11:”）；正误差（如“.00:00…0”处理成“.01:”)\n![](https://unpkg.com/justlovesmile-img/20200415000001.png)\n④优点：实现简单，不需要增加硬件和处里时间，平均误差趋于0\n缺点：最大误差最大，比截断法还大（接近于1）\n⑤多用于中、高速机器中，由于尾数位数比微、小型机器长\nd) **查表舍入法**\n①方法：取尾数p位的最后k-1位和准备舍弃的最高1位，共k位。通过ROM或PLA查表得到k-1位，作为新的尾数p位的最后k-1位\n![](https://unpkg.com/justlovesmile-img/20200415000002.png)\n②下溢处理表的内容：当尾数最低k-1位为全”1“时以`截断法`设置处理结果；其余情况采用`舍入法`\n![](https://unpkg.com/justlovesmile-img/20200415142649.png)\n③优点：ROM法速度较快，平均误差可调到0；避免再次右规操作\n缺点：需要硬件配合，硬件量大\n（3）上述4种处理方法中：\n**最大误差最大**的是恒置“1”法，\n**最大误差最小**的是舍入法；\n**平均误差最大**的是截断法；\n**平均误差可人为调节**的是查表舍入法；\n**下溢处理不需要附加时间开销，即速度最快**的是截断法和恒置“1”法，\n**处理速度最慢**的是舍入法；\n**实现上最花费硬件**的是查表舍入法，\n**最省硬件**的是截断法和恒置“1”法。 \n\n18. 程序在主存中的定位技术\n（1）静态再定位：再目的程序装入主存时，由装入程序用软件方法把目的程序的逻辑地址变换成物理地址，程序执行时，物理地址不再改变\n（2）动态再定位：在执行每条指令时才形成访存物理地址的方法\n①基址寻址：设置基址寄存器和地址加法器硬件，实现逻辑地址到物理地址空间变换的支持\n②优越性：地址加法器形成物理地址的速度快于装入程序形成的物理地址速度；具有越界保护措施，如设置上、下界寄存器，判断是否出现地址越界错误\n（3）虚实地址映像表：用虚拟存储器增加映像表硬件后，程序空间可以超过实际主存空间，采用基地址寄存器加位移量的方法\n19. 基址寻址与变址寻址的区别\n（1）基址寻址：基址寄存器里的值加上指令格式内的逻辑地址形成物理地址；对逻辑地址空间到物理地址空间变换的支持；通常基址寄存器的内容不变，逻辑地址可变；\n（2）变址寻址：变址寄存器的值和指令地址码部分给出的地址之和作为操作数地址；对诸如向量，数组等数据块运算的支持；通常逻辑地址不变，变址寄存器里面的值由用户定义\n20. 信息按整数边界存储\n（1）为了使任何时候所需的信息都只用一个存储周期访问到，要求信息在主存中存放的地址必须是该信息宽度（字节数）的整数倍，防止信息跨主存边界存放\n（2）优点：访问周期短；缺点：存储空间浪费\n21. 哈夫曼压缩思想与指令格式的优化\n（1）指令包含操作码和地址码两部分，为了优化指令格式，要使指令的平均字长最短，减少程序总位数以及增加指令字能表示的操作信息和地址信息\n（2）哈夫曼压缩思想：当各种时间发生的概率不均等时，对发生概率最高的事件用最短的位数（时间）来表示（处理），而对出现概率较低的事件允许用较长的位数（时间）来表示（处理），就会使表示（处理）的平均位数（时间）缩短\n（3）扩展操作码编码\n22. CISC与RISC的常用技术\n（1）CISC（复杂指令系统计算机）：进一步增强原有指令的功能以及设置更为复杂的新指令，取代原先由软件子程序完成的功能，实现软件功能的硬化；\na)面向目标程序的优化实现改进\n①途径1：对大量已有机器的机器语言程序及其执行情况进行统计各种指令和指令串的使用频度来加以分析和改进。\n使用频度分为`静态使用频度`（程序中统计出的指令及指令串的使用频度称为静态使用频度。着眼于减少目标程序所占用的存储空间）和`动态使用频度`（目标程序执行过程中对指令和指令串统计出的频度称为动态使用频度。着眼于减少目标程序的执行时间）\n②途径2：增设强功能复合指令来取代原先由常用宏指令或子程序实现的功能，由微程序解释实现，不仅大大提高了运算速度，减少了程序调用的额外开销，也减少了子程序所占的主存空间。\nb)面向高级语言的优化实现改进\n①目的：缩短高级语言和机器语言的语义差距，支持高级语言编译，缩短编译程序长度和时间\n②途径1：通过对源程序中各种高级语言语句的使用频度进行统计来分析改进\n③途径2：如何面向编译，优化代码生成来改进\n④途径3：改进指令系统，使它与各种语言间的语义差距都有同等的缩小\n⑤途径4：让机器具有分别面向各种高级语言的多种指令系统，多种系统结构的面向问题动态自寻优的计算机系统\n⑥途径5：发展高级语言计算机（或称高级语言机器）\nc)面向操作系统的优化实现改进\n①目的：通过缩短操作系统与计算机系统结构之间的语义差距，来进一步减少运行操作系统的时间和节省操作系统软件所占用的存储空间\n②途径1：通过对操作系统中常用指令和指令串的使用频度进行统计分析来改进\n③途径2：考虑如何增设专用于操作系统的新指令\n④途径3：把操作系统中频繁使用的，对速度影响大的机构型软件子程序硬化或固化，直接用硬件或微程序解释实现\n⑤途径4：发展让操作系统由专门的处理机来执行的功能分布处理系统结构\nd) CISC的问题：指令系统庞大；许多质量操作繁杂，执行速度很低；编译程序太长，太复杂；部分指令利用率很低\n（2）RISC（精简指令系统计算机）：通过减少指令种数和简化指令功能来降低硬件设计的复杂度，提高指令的执行速度\na) RISC的基本技术\n①按照设计RISC一般原则来设计\n②逻辑实现采用硬联和微程序相结合\n③在CPU中设置大量工作寄存器并采用重叠寄存器窗口\n④指令用流水和延迟转移\n⑤采用高速缓冲寄存器cache，设置指令cache和数据cache分别存放指令和数据\n⑥优化设计编译系统\nb) RISC的问题\n①指令少，加重汇编语言程序设计的负担，增加了机器语言程序的长度，占用存储空间多，加大了指令的信息流量\n②对浮点运算和虚拟存储器支持不足\n③RISC机器的编译程序比CISC的难写\n23. 总线的分类\n（1）按在系统中的位置分为`芯片级`，`板级`，`系统级`\n（2）按允许信息传送方向分为`单向传输`，`双向传输（半双向和全双向）`\n（3）按用法分为`专用`和`非专用`\n24. 总线的控制技术及通讯技术\n（1）控制技术\na） 集中式控制\n①优先次序的确定方法：串行链接，定时查询，独立请求\n②串行链接获得使用总线权优先次序由“总线可用”线所接不见的物理位置决定，离总线控制器越近，优先级越高；三根总线，总线忙，总线可用，总线请求\n③定时查询：查询线上计数值与发出请求的部件号是否一致；总线忙+总线请求+「logn「个定时查询计数线=2+「logn「\n④独立请求：1根总线已被分配线+每个部件各有一对总线请求和总线准许线=2×N+1\nb） 分布式控制\n（2）通讯技术\na) 同步通信：定宽，定距的系统时标同步\nb) 异步通信：\n分为单向控制（分为单向源控和单向目控）和请求/回答双向控制（分为源控式（互锁和非互锁）和目控）\n25. 中断响应优先级与中断处理程序优先级及分析过程\n（1）基本概念:\n中断：CPU中止正在执行的程序，转去处理随机提出的请求，待处理完后，再回到预先被打断的程序继续恢复执行的过程\n中断系统：相应和处理各种中断的软硬件总体称为中断系统\n中断分为内部中断（CPU内的异常引起），外部中断（由中断信号引起）和软件中断（由自陷指令引起）；外部中断又分为可屏蔽中断和不可屏蔽中断\n中断源：引起中断的各种事件\n中断请求：中断源向中断系统发出请求中断的申请\n中断响应：允许中断CPU现行程序的运行，转去对该请求进行预处理，包括保存好断电及其现场，调出有关处理该中断的中断服务程序，准备运行（交换新旧程序状态字PSW）\n中断现行程序细分为中断（可屏蔽）和异常（不可屏蔽，如自陷，故障，失败）\n（2）中断分级\n机器校验（第1级），程序性中断和管理程序调用（第2级），外部中断（第3级），输入/输出（第4级），重新启动（最低级）\n（3）中断的响应次序与处理次序\n中断级屏蔽位寄存器\n本级对本级屏蔽\n中断响应次序，中断处理完成次序，中断处理次序\n![](https://unpkg.com/justlovesmile-img/20200909153438.png)\n![](https://unpkg.com/justlovesmile-img/20200909154306.png)\n![](https://unpkg.com/justlovesmile-img/20200909160431.png)\n![](https://unpkg.com/justlovesmile-img/20200909160611.png)\n（4）通道程序结束引起的中断属于I/O中断；\n访管中断属于第2级；\n26. 通道的工作原理及三类通道的流量计算\n（1）通道的工作原理：用户只能再目态程序中安排要求输入输出的广义指令，然后进入相应管理程序执行这些输入输出管态指令\na) 目态和管态：\n管态又叫特权态，系统态或核心态。CPU在管态下可以执行指令系统的全集。通常，操作系统在管态下运行。\n目态又叫常态或用户态。机器处于目态时，程序只能执行非特权指令。\n从目态转换为管态的唯一途径是中断。\n从管态到目态可以通过修改程序状态字来实现，这将伴随这由操作系统程序到用户程序的转换。\n启动I/O指令属于管态指令\n（2）三类通道：`字节多路`，`数组多路`和`选择通道`\n通道流量和通道工作方式，数据传送期内选择一次设备的时间Ts，传送一个字节的时间Td有关\n通道的极限流量：\nfmaxbyte=1/(Ts+Td)\nfmaxblock=K/(Ts+K×Td)\nfmaxselect=N/(Ts+N×Td)\n设备要求通道的实际最大流量只有小于等于通道所能达到的极限\n![](https://unpkg.com/justlovesmile-img/20200909165849.png)\n工作周期小的不能挂载\n![](https://unpkg.com/justlovesmile-img/20200909171038.png)\n![](https://unpkg.com/justlovesmile-img/20200909171326.png)\n![](https://unpkg.com/justlovesmile-img/20200909171903.png)\n27. 存储器的性能指标\n（1）容量Sm：存储器的位数或总字节数\nSm=W×L×m （W:存储体的字长，L每个存储体的字数，m并行工作存储体的个数）\n（2）速度\n访问时间Tn，存储周期Tm，频宽Bm\n（3）价格\n总价格C，每位价格c\n同等容量下，存储器的访问速度由高到低：双极型→MOS→电荷耦合型→磁泡→定位磁盘→动头磁盘→磁带\n28. 单体多字、多体单字与多体多字\n（1）并行主存系统的三种模式：单体多字，多体单字，多体多字\n29. 存储器系统、并行存储体系与存储层次\n（1）存储系统：存储系统是指计算机中由存放程序和数据的各种存储设备、控制部件及管理信息调度的设备（硬件）和算法（软件）所组成的系统。\n（2）存储体系（存储层次）：构成存储系统的几种不同的存储器之间，配上辅助软硬件或辅助硬件，使之从应用程序员来看，在逻辑上是一个整体\n基本的二级存储体系：虚拟存储器和Cache存储器（主存-辅存存储层次）\nCache存储器对于应用程序员和系统程序员都是透明的\n（3）并行主存系统：可以并行读出多个CPU字的单体多字，多体单字，，多体多字的交叉存储主存系统\n30. 虚拟存储器与高速缓冲存储器\n（1）在具有层次结构存储器的计算机系统中，增设地址映像表机构来实现程序在主存中的定位，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理贮存容量大得多，可寻址的“主存储器”。虚拟存储区的容量与物理主存大小无关，而受限于计算机的地址结构和可用磁盘容量。\n（2）存储管理方式：段式，页式，段页式\n31. 段式存储管理与页式存储管理技术\n（1）段式管理：将主存按段分配的存储管理方式\n![](https://unpkg.com/justlovesmile-img/20200909201223.png)\n首先分配算法\n最佳分配算法\n（2）页式管理：将主存空间和程序空间都机械等分成固定大小的页\n![](https://unpkg.com/justlovesmile-img/20200909201854.png)\n![](https://unpkg.com/justlovesmile-img/20200909202427.png)\n（3）段页式管理：将主存机械等分成固定大小的页，程序按模块分段，每个段又分为和主存页面大小相同的页\n32. 地址的映像与变换\n（1）地址的映像：将每个虚存单元按什么规则（算法）装入（定位于）主存，建立起多用户虚地址N和贮存地址n之间的对应关系\n（2）地址变换：是指程序按照映像关系装入实存后，在执行中，如何将多用户虚地址N变换成对应的实地址\n33. 全相联映像、直接相联映像与组相联映像\n（1）Cache的全相联映像：主存中任意一块都可映像装入到Cache中任意一块位置\n![](https://unpkg.com/justlovesmile-img/20200909212811.png)\n![](https://unpkg.com/justlovesmile-img/20200909212838.png)\n（2）Cache的直接相联映像：把主存空间按Cache大小等分成区，每区内的各块只能映像到Cache中唯一一个特定块位置\n![](https://unpkg.com/justlovesmile-img/20200909212844.png)\n![](https://unpkg.com/justlovesmile-img/20200909212845.png)\n（3）Cache的组相联映像：将Cache和贮存空间先分成若干个组，共有2^n个组。Cache中多有的组构成Cache的唯一一个区。而主存则分成与Cache同样大小的2^(nd)个区\n![](https://unpkg.com/justlovesmile-img/20200909212846.png)\n![](https://unpkg.com/justlovesmile-img/20200909212847.png)\n![](https://unpkg.com/justlovesmile-img/20200910083257.png)\n![](https://unpkg.com/justlovesmile-img/20200910212801.png)\n34. 常用替换算法\n（1）随机算法：RAND，随机产生页号，命中率低，不采用\n（2）先进先出算法：FIFO，选择最早装如主存的页作为被替换的页\n（3）近期最少使用算法：LRU，选择近期最少访问的页作为被替换的页\n（4）优化替换算法：OPT，将未来的近期内不用的页替换出去的算法，有较高的主存命中率，但是不太现实\n（5）页面失效频率法（动态算法）：PFF，根据各道程序运行中的主存页面失效率的高低，由操作系统来动态操控\n35. 堆栈型替换算法\n（1）堆栈型替换算法：任何时刻t，在n个实页中的虚页集合总是被包含在给其增加一个实页，即n+1个实页时，在实存中的虚页集合之内的\n（2）堆栈型替换算法，命中率H随着主存页数n的增减单调上升，至少不下降。\nLRU替换算法属于堆栈型替换算法，操作：将刚访问过的页号置于栈顶，最久未被访问过的页号置于栈底\n![](https://unpkg.com/justlovesmile-img/20200909212445.png)\n36. 重叠与流水的区别\n（1）重叠解释方式：在解释第K条指令的操作完成之前，就开始解释第K+1条指令\n（2）重叠和流水的区别：依次重叠时把一条指令的解释分为两个子程序，而流水是分为更多个子过程\n37. 流水线中的各种相关及解决方案\n（1）局部性相关：指的是在机器同时解释的多条指令之间出现了对同一主存单元或寄存器要求“先写后读”；包括`指令相关`，`访存操作数相关`和`通用寄存器组相关`等;\na）指令相关：包含寄存器相关（包括数据相关和名字相关）和控制相关\n![](https://unpkg.com/justlovesmile-img/20200910101227.png)\nb）主存空间数相关：相邻两条指令之间出现要求对同一主存单元先写入而后再读出的关联\n解决方法：推后读\n![](https://unpkg.com/justlovesmile-img/20200910101451.png)\n（2）全局性相关：已进入流水线的转移指令（尤其时条件转移指令）和后续指令之间的相关\n38. 流水线的分类及三个性能指标的计算方法\n（1）流水线分类：\n按处理级别：部件级，处理机级，系统级\n按具有的功能多少：单功能流水线，多功能流水线\n按多功能流水线的各段能否允许同时用于多种不同功能连接流水：静态流水线，动态流水线\n按机器所具有的数据表示：标量流水机和向量流水机\n按各功能段间是否有反馈电路分为：线性流水和非线性流水\n按信息流动控制方式：顺序流动流水线，异步流动流水线\n（2）三个性能指标\na) 吞吐率Tp ：流水线单位时间里能流出的任务数或结果数\nTpmax = 1/max{各个子过程的时间}\nTp = n/(m×▲t+(n-1)×▲t) ：m段流水线，各段时间为▲t，完成n个任务的解释共需要时间m×▲t+(n-1)×▲t\n![](https://unpkg.com/justlovesmile-img/20200910102823.png)\nb) 加速比Sp ：流水线方式相对于非流水线顺序方式速度提高的比值\n![](https://unpkg.com/justlovesmile-img/20200910103021.png)\nc) 效率η：流水线设备的时间利用率，设备实际使用时间占整个设备运行时间的比值\n![](https://unpkg.com/justlovesmile-img/20200910103134.png)\n![](https://unpkg.com/justlovesmile-img/20200910103907.png)\n![](https://unpkg.com/justlovesmile-img/20200910103939.png)\n（3）消除瓶颈：\n①瓶颈子过程再细分\n②重复设置多套瓶颈段并联\n39. 单功能非线性流水线的调度技术\n![](https://unpkg.com/justlovesmile-img/20200910105055.png)\n![](https://unpkg.com/justlovesmile-img/20200910104959.png)\n","tags":["系统结构","大学课程"],"categories":["学习笔记"]},{"title":"大学课程 | 《微机原理与接口技术》笔记","slug":"学习笔记-微机原理与接口技术","url":"/posts/43666.html","content":"\n大学课程《微机原理与接口技术》学习笔记整理\n<!-- more -->\n\n# 第一章 微型计算机基础概论\n\n## 第一讲 关于\n\n- 计算机的主要应用：数值计算，信息处理，过程控制\n- 微机原理与接口技术包括：数值信息表示，微型机基本原理，汇编程序设计，半导体存储器及其接口设计，输入输出技术\n\n## 第二讲 微型计算机系统组成\n\n- 计算机系统：\n  - 硬件系统\n    - 主机系统：CPU，存储器，输入输出接口，总线\n    - 外部设备\n  - 软件系统\n- 能够与CPU直接进行信息交换的部件属于主机系统，不能够与CPU直接进行信息交换的部件属于外部设备\n- CPU\n  - 微处理器简称CPU，是计算机的核心\n  - 主要包括：运算器，控制器，寄存器组\n- 存储器：\n  - 计算机中的记忆装置。用于存放计算机工作过程中需要操作的数据和程序\n  - 内存储器 ：\n    - 存取速度较快，容量相对较小\n    - 内存按单元组织，每单元都对应一个惟一的地址 \n    - 每个内存单元中存放1Byte数据【每8位0或1称 为1字节（Byte）】\n    - 内存单元个数称为内存容量\n    - 按工作方式分类：随机存取存储器（RAM），只读存储器（ROM） \n  - 外存储器 \n    - 联机外存：硬磁盘 \n    - 脱机外存：各种移动存储设备\n- 输入/输出接口 \n  - 接口是CPU与外部设备间的桥梁\n  - 主要功能：\n    - 数据缓冲寄存；\n    - 信号电平或类型的转换；\n    - 实现主机与外设间的运行匹配。 \n- 总线 \n  - 是一组导线和相关的控制、驱动电路的集合。\n  - 是计算机系统各部件之间传输地址、数据和控制信息的通道 \n  - 地址总线（AB） 数据总线（DB） 控制总线（CB） \n\n## 第三讲 微机工作过程\n\n- 计算机的工作就是按照一定的顺序，一条条地执行指令\n- 指令： 由人向计算机发出的、能够为计算机所识别的命令 \n- 过程：**取指令**->**分析指令**->读取操作数->**执行指令**->存放结果 \n- 顺序执行： 一条指令执行完了再执行下一条指令。 \n  - 执行时间=取指令+分析指令+执行指令 \n  - 设：三个部分的执行时间均为Δt，则：执行n条指令时间T0为：  \n  - T0=3nΔt \n- 并行执行： 同时执行两条或多条指令。 \n  - 仅第1条指令需要3 Δt时间，之后每经过1 Δt，就有一条指令执行结束\n  - 执行时间： T =3Δt +（ n-1）Δt \n- 并行： 更高的效率，更高的复杂度 \n- 相对于顺序执行方式，指令并行执行的优势用加速比S表示： \n  - S=顺序执行花费的时间/并行执行花费的时间 \n  - 例： 3n Δt /（3Δt +（ n-1）Δt) =3n/（2+n） \n- 冯 • 诺依曼计算机的工作原理: 存储程序工作原理,结构特点:运算器为核心 \n- 冯 • 诺依曼机的工作过程 \n  - 取一条指令的工作过程： \n    - ① 将指令所在地址赋给程序计数器PC； \n    - ② PC内容送到地址寄存器AR，PC自动加1； \n    - ③ 把AR的内容通过地址总线送至内存储器，经地址译码器译码，选中相应单元。 \n    - ④ CPU的控制器发出读命令。 \n    - ⑤ 在读命令控制下，把所选中单元的内容（即指令操作码）读到数据总线 DB。 \n    - ⑥ 把读出的内容经数据总线送到数据寄存器DR。 \n    - ⑦ 指令译码:数据寄存器DR将它送到指令寄存器IR，然后再送到指令译码器ID \n  - 特点： \n    - 程序存储，共享数据，顺序执行 \n    - 属于顺序处理机，适合于确定的算法和数值数据的处理。\n  - 不足： \n    - 与存储器间有大量数据交互，对总线要求很高；\n    - 执行顺序由程序决定，对大型复杂任务较困难；\n    - 以运算器为核心，处理效率较低；\n    - 由PC控制执行顺序，难以进行真正的并行处理。 \n- 哈佛结构 \n  - 指令和数据分别存放在两个独立的存储器模块中； \n  - CPU与存储器间指令和数据的传送分别采用两组独立的总线；\n  - 可以在一个机器周期内同时获得指令操作码和操作数。 \n\n## 第四讲 常用数制\n\n- 计算机中的常用计数制：十进制 ，二进制数 ，十六进制数 ，八进制数 \n\n## 第五讲 编码\n\n- 编码：\n  - 信息从一种形式或格式转换为另一种形式的过程\n  - 用代码来表示各种信息，以便于计算机处理。 \n- 需要编码的信息种类：数值，字符，声音，图形，图像 \n- 所有需要由计算机处理的信息，都需要编码，使所有信息都以二进制码形式表示\n- 计算机中的编码 \n  - 数值编码：\n    - 二进制码\n    - BCD码 \n  - 西文字符编码\n    - ASCII码 \n- BCD（Binary Coded Decimal）码 \n  - 用二进制表示的十进制数\n  - 特点： \n    - 保留十进制的权，数字用0和1表示。\n- 8421BCD编码： \n  - 用4位二进制码表示1位十进制数，每4位之间有一个空格 \n  - 1010—1111是非法BCD码\n  - （0001 0001 .0010 0101）BCD    =11 .25    =（1011 .01）B \n- BCD码在计算机中的存储方式 \n  - 以压缩BCD码形式存放：\n    - 用4位二进制码表示1位BCD码\n    - 一个存储单元中存放2位BCD数\n  - 以扩展BCD码形式存放 \n    - 用8位二进制码表示1位BCD码.即高4位为0，低4位为有效位 \n    - 每个存储单元存放1位BCD \n- ASCII码 \n  - 西文字符编码：将每个字母、数字、标点、控制符用1Byte二进制码表示 \n  - 标准ASCII的有效位：7bit，最高位默认为0 \n- ASCII码的奇偶校验 \n  - 奇校验：加上校验位后编码中“1”的个数为奇数。\n  - 偶校验：加上校验位后编码中“1”的个数为偶数。 \n\n## 第六讲 数及其运算\n\n- 定点数\n- 浮点数 \n  - 小数点的位置可以左右移动的数\n  - 规格化浮点数：尾数部分用纯小数表示，即小数点右边第1位不为0 \n- 无符号数\n- 有符号数：用最高位表示符号，其余是数值，0正，1负\n  - 原码：最高位为符号位，其余为真值部分\n    - [X]原=符号位+|绝对值| \n    - 有[+0]和[-0]之分\n  - 反码：\n    - 若X>0 ，则 [X]反 = [X]原 \n    - 若X<0， 则 [X]反 = 对应原码的符号位不变，数值部分按位求反。\n    - 有[+0]和[-0]之分\n  - 补码：\n    - 若X>0， 则 [X]补 = [X]反= [X]原\n    - 若X<0， 则 [X]补 = [X]反+1 \n    - 没有[+0]和[-0]之分\n- 无符号整数的表示范围(n表示字长)： 0 ≤ X ≤ 2^n - 1\n- 有符号整数的表示范围： \n  - 原码和反码： -（2^(n-1) -1） ≤ X ≤ 2^(n-1) -1 \n  - 补码： -2^(n-1) ≤ X ≤ 2^(n-1) -1 \n  - 对8位二进制数：\n    - 原码： -127 ～+127\n    - 反码： -127 ～+127\n    - 补码： -128 ～+127 \n\n## 第七讲 基本逻辑运算和逻辑门\n\n- 逻辑，命题，推理\n- 基本逻辑运算：与或非\n- 逻辑运算是按位进行的运算，低位运算结果对高位运算不产生影响 \n- 算术运算是两个数之间的运算，低位运算结果将对高位运算产生影响\n\n## 第八讲 基本逻辑运算及其门电路\n\n- 与非，或非，异或，同或\n\n# 第二章 微处理器与总线\n\n## 第九讲 8088/8086微处理器\n\n- 8088/8086 CPU的特点 \n  - 采用并行流水线工作方式\n    - 通过设置指令预取队列实现\n  - 对内存空间实行分段管理\n    - 将内存分为4个段并设置地址段寄存器，以实现对1MB空间的寻址\n  - 支持协处理器\n- 8088/8086可工作于两种模式下 \n  - 最小模式：单处理器模式，所有控制信号由微处理器产生\n    - ![](https://unpkg.com/justlovesmile-img/20200605180344.png)\n  - 最大模式：最大模式为多处理器模式，部分控制信号由外部总线控制器产生 \n    - ![](https://unpkg.com/justlovesmile-img/20200605180420.png)\n\n## 第十讲 8088的主要引线及其内部结构\n\n- 8088最小模式下的主要引脚信号\n  - 完成一次访问内存或接口所需要的主要信号\n  - 与外部同步控制信号\n  - 中断请求和响应信号\n  - 总线保持和响应信号 \n    ![](https://unpkg.com/justlovesmile-img/20200605180737.png)\n- 主要控制信号\n  - WR：  写信号；\n  - RD：  读信号；\n  - IO/M：为“0”表示访问内存，为“1”表示访问接口；\n  - DEN： 低电平有效时，允许进行读/写操作；\n  - DT/R：数据收发器的传送方向控制；\n  - ALE：  地址锁存信号；\n  - RESET：复位信号。 \n- 中断请求和响应信号\n  - INTR：可屏蔽中断请求输入端\n  - NMI： 非屏蔽中断请求输入端 \n  - INTA：中断响应输出端 \n- 总线保持信号\n  - HOLD：总线保持请求信号输入端。当CPU以外的其他设备要求占用总线时，通过该引脚向CPU发出请求。\n  - HLDA：总线保持响应信号输出端。CPU对HOLD信号的响应信号。 \n- 微处理器读取一条指令的控制过程\n  - 1.发出读取数据所在的目标地址\n    - 内存储器单元地址\n    - I/O接口地址 \n  - 2.发出读控制信号\n  - 3.送出传输的数据 \n- 地址线和数据线：\n  - 20位地址信号(20根地址线)--》可产生2^20=1M个编码 \n  - 8位数据信号(8位数据线)--》可同时传输8bit二进制码 \n- 8088内部结构：\n  - 执行单元EU\n    - 构成：运算器，8个通用寄存器，1个标志寄存器，EU部分控制电路\n    - 功能：指令译码，指令执行，暂存中间运算结果，保存运算结果特征 \n  - 总线接口单元BIU\n    - 功能：\n    - 从内存中取指令到指令预取队列，指令预取队列是并行流水线工作的基础\n    - 负责与内存或输入/输出接口之间的数据传送\n    - 在执行转移程序时，BIU使指令预取队列复位，从指定的新地址取指令，并立即传给执行单元执行。 \n- 指令预取队列的存在使EU和BIU两个部分可同时进行工作 \n- 8088和8086CPU引线功能比较 \n  - 数据总线宽度不同：8088的外部总线宽度是8位，8086为16位。 \n  - 访问存储器和输入输出控制信号含义不同：8088——IO/M=0表示访问内存；8086——IO/M=1表示访问内存。 \n  - 其他部分引线功能的区别 \n\n## 第十一讲 8088CPU内部寄存器\n\n- 含14个16位寄存器，按功能可分为三类： \n  - 8个通用寄存器\n    - 数据寄存器（AX，BX，CX，DX）\n    - 地址指针寄存器（SP，BP）\n    - 变址寄存器（SI，DI） \n  - 4个段寄存器\n  - 2个控制寄存器  \n- 通用寄存器：\n  - 数据寄存器：8088/8086含4个16位数据寄存器，它们又可分为8个8位寄存器，即： \n    - AX-------AH，AL：累加器，所有I/O指令都通过AX与接口传送信息，中间运算结果也多放于AX中； \n    - BX-------BH，BL：基址寄存器,在间接寻址中用于存放基地址\n    - CX-------CH，CL：计数寄存器,用于在循环或串操作指令中存放计数值\n    - DX-------DH，DL：数据寄存器,在间接寻址的I/O指令中存放I/O端口地址；在32位乘除法运算时，存放高16位数。 \n  - 地址指针寄存器:\n    - SP：堆栈指针寄存器，其内容为栈顶的偏移地址 \n    - BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址。 \n  - 变址寄存器 \n    - SI：源变址寄存器\n    - DI：目标变址寄存器\n    - 变址寄存器在指令中常用于存放数据在内存中的地址。 \n- BX与BP在应用上的区别 \n  - 作为通用寄存器，二者均可用于存放数据；\n  - 作为基址寄存器，用BX表示所寻找的数据在数据段；用BP 则表示数据在堆栈段。 \n- 段寄存器:\n  - 作用:用于存放相应逻辑段的段基地址\n  - 8086/8088内存中逻辑段的类型\n    - 代码段: 存放指令代码\n    - 数据段: 存放操作的数据\n    - 附加段: 存放附加的操作的数据\n    - 堆栈段: 存放暂时不用但需保存的数据。 \n  - CS:代码段寄存器，存放代码段的段基地址。\n  - DS:数据段寄存器，存放数据段的段基地址。\n  - ES:附加段寄存器，存放附加段的段基地址。\n  - SS:堆栈段寄存器，存放堆栈段的段基地址 \n  - 段寄存器的值表明相应逻辑段在内存中的位置 \n- 控制寄存器：\n  - 指令指针控制寄存器IP\n  - 状态标志寄存器FLAGS\n    - 状态标志位：\n      - CF:进位标志位。加(减)法运算时，若最高位有进(借)位则CF=1\n      - OF:溢出标志位。当算术运算的结果超出了有符号数的可表达范围时，OF=l\n      - ZF:零标志位。当运算结果为零时ZF=1\n      - SF:符号标志位。当运算结果的最高位为1时，SF=l\n      - PF:奇偶标志位。运算结果的低8位中“1”的个数为偶数时PF=l\n      - AF:辅助进位标志位。加(减)操作中，若Bit3(D3)向Bit4(D4)有进位(借位)， AF=1\n    - 控制标志位：\n      - TF:单步陷阱标志位，也叫跟踪标志位。TF=1时，使CPU处于单步执行指令的工作方式。\n      - IF:中断允许标志位。IF=1时，CPU可以响应中断请求。\n      - DF:方向标志位。在数据串操作时确定操作的方向。 \n\n## 第十二讲 实模式下的存储器寻址\n\n- 存储单位地址及其内容表示\n  - 若X表示某个单元地址，则[X]表示X单元的内容\n  - 例如：[0004H]=34H代表34存放在4号单元，而[0004H]=1234H，代表34存放在4号单元，12存放在5号单元\n- 字的存储\n  - 占连续两个字节（16位）\n  - 低对低，高对高\n  - 用低位地址来表示字的地址\n- 规则存放，非规则存放\n  - 8088：数据总线8位，每次传送1个字节\n  - 8086：数据总线16位\n  \t- 字：16位，规则字，以偶地址开始存放\n  \t- 字节： 高8位传送奇地址，低8位传送偶地址\n- 内存储器管理\n  - 8088CPU是16位体系结构的微处理器\n  - 可以同时处理16位二进制码\n  - 8088CPU需要管理1MB内存\n- 分段技术\n  - 分为若干个逻辑段，取内地址，用16位表示，每段最大64KB\n  - 对段首地址（物理地址）规定，段首地址低4位为0，例如：00000H,00010H,FFFF0H\n  - 段地址：段的起始地址的高16位\n  - 偏移地址：段内相对于段的起始地址的偏移量（字节数）\n- 实地址模式下的存储器地址变换\n  - 内存物理地址由段基地址和偏移地址组成\n  - 物理地址=段基地址×16+偏移地址\n- 内存地址变换\n  - 内存单元编址\n    - 段（基）地址\n    - 段内地址（相对地址/偏移地址）\n  - 存储器的编址\n    - 段（基）地址\n    - 相对地址（偏移地址）\n    - 逻辑段的起始地址称为段首，段首的偏移地址0000H\n- 段寄存器：\n  - 作用：用于存放相应逻辑段的段基地址\n  - 8086/8088内存中逻辑段的类型\n    - 代码段==>CS（代码段寄存器）\n      - CS×16+IP\n    - 数据段==>DS（数据段寄存器）\n      - DS×16+偏移地址\n    - 附加段==>ES（附加段寄存器）\n      - ES×16+偏移地址\n    - 堆栈段==>SS（堆栈段寄存器）\n      - SS×16+SP\n  - 8086/8088内存中每类逻辑段的数量最多64K个\n- 逻辑段与逻辑地址\n  - 内存的分段式逻辑分段，不是物理段\n  - 两个逻辑段可以完全重合或部分重合\n- 堆栈及堆栈段的使用\n  - 堆栈： \n    - 内存中一个特殊区域，用于存放暂时不用或需要保护的数据。\n    - 常用于响应中断或子程序调用\n\n![](https://unpkg.com/justlovesmile-img/20200626171551.png)\n\n## 第十三讲 8088 系统总线\n\n- 总线时序\n  - CPU工作时序\n    - CPU各引脚信号在时间上的关系\n  - 总线周期\n    - CPU完成一次访问内存（或接口）操作所需要的时间\n    - 8086的基本总线周期为4个时钟周期，每个时钟周期间隔称为一个T状态（8086/8088：5MHz时钟信号，时钟周期T=200ns）\n      ![](https://unpkg.com/justlovesmile-img/20200626181818.png)\n    - T1 状态：BIU将RAM或I/O地址放在地址/数据复用             总线（AD）上。\n\t- T2 状态：   \n\t  - 读总线周期： A/D总线为接收数据做准备。改变线路的方向。\n\t  - 写总线周期： A/D总线上形成待写的数据，且保持到总线周期的结束(T4)。\n\t- T3, T4:对于读或写总线周期，AD总线上均为数据。\n\t- Tw: 当RAM或I/O接口速度不够时，T3与 T4 之间可插入等待状态 Tw 。\n\t- Ti : 当BIU无访问操作数和取指令的任务时，8086不执行总线操作，总线周期处于空闲状态 Ti 。\n- 总线：\n  - 按层次结构分类：\n    - CPU总线\n    - 系统总线\n    - 外部总线\n  - 按传送信息的类别分类：\n  \t- 地址总线\n  \t- 数据总线\n  \t- 控制总线\n  - 按总线在微机系统的位置分类：\n  \t- 片内总线\n  \t- 片间总线\n  \t- 系统总线\n  \t- 通信总线\n  - 总线的基本功能\n    - 数据传送\n    - 仲裁控制\n    - 出错处理\n    - 总线驱动\n  - 总线的主要性能指标\n    - 总线带宽（B/S）\n      - 单位时间内总线上可传送的数据量\n      - 总线带宽=位宽×工作频率\n    - 总线位宽（bit）\n      - 能同时传送的数据位数\n    - 总线的工作频率（MHz）\n      - 总线带宽=（位宽/8）×（工作频率/每个存储周期的时钟数）\n- 引脚信号设计特点\n  - 分时复用，如引脚AD0-AD15\n  \t- 如何实现：增加地址锁存器\n  \t- 8282三位锁存器\n  \t- 8286八位数据收发器\n  - 两种工作模式复用\n  \t- 最大模式\n  \t- 最小模式\n\n# 第三章 指令系统概述\n\n## 第十四讲 8088/8086指令系统\n\n- 指令：控制计算机完成某种操作的命令\n- 指令系统：处理器所能识别的所有指令的集合\n- 指令的兼容性：同一系列机的指令都是兼容的\n- 一条指令应包含的信息：\n  - 运算数据的来源\n  - 运算结果的去向\n  - 执行的操作\n- 指令格式\n  ![](https://unpkg.com/justlovesmile-img/20200626182906.png)\n- 指令中的操作数\n  - 立即数：参加操作的数据本身，可以是8位或16位，只能作为源操作数，无法作为目标操作数\n    - `MOV AX, 1234H`\n  - 寄存器：数据存放地址\n    - `MOV AX, BX`\n  - 存储器：数据存放地址\n    - 参加运算的数存放在存储器的某一个或两个单元中\n    - 表现形式： [操作数在内存中的偏移地址]\n    - `MOV AL, [1200H]`\n\n## 第十五讲 指令的寻址方式\n\n- 操作数可能的来源或运算结果可能的去处：\n  - 由指令直接给出\n  - 寄存器\n  - 内存单元\n- 寻找操作数所在地址的方法可以有三种大类型：\n  - 指令直接给出的方式\n  - 存放于寄存器中的寻址方式\n  - 存放于存储器中的寻址方式\n\n- 1.直接寻址：\n  - 指令中直接给出操作数的偏移地址\n  - 直接寻址方式下，操作数默认为在数据段，但允许段重设，即由指令给出所在逻辑段。 \n  - `MOV AX，ES：[1200H]`  ES：段重设符\n- 2.寄存器间接寻址\n  - 操作数存放在内存中，数据在内存中的偏移地址为方括号中通用寄存器的内容\n  - 仅有4个通用寄存器可用于存放数据的偏移地址，`BX`，`BP`，`SI`，`DI`\n  \t- 若使用`BX`,`SI`,`DI`，则操作数在数据段`DS`中\n  \t\t- 物理地址=DS×16+{BX/SI/DI}\n  \t- 若使用`BP`，则操作数在堆栈段`SS`中\n  \t\t- 物理地址=SS×16+BP\n  - 间接寻址的一般格式：[ 间址寄存器 ] \n  - 例： `MOV AX，[BX]`\n  - 可以段重设\n- 3.寄存器相对寻址\n  - 操作数的偏移地址为寄存器的内容加上一个位移量\n  - 相对寻址主要用于一维数组的操作\n  - `MOV AX，[BX+DATA]`\n- 4.基址、变址寻址\n\t- 操作数的偏移地址为\n\t\t- 一个基址寄存器的内容 + 一个变址寄存器的内容；\n\t- 操作数的**段地址由选择的基址寄存器决定**\n\t\t- 基址寄存器为`BX`，默认在数据段`DS`\n\t\t- 基址寄存器为`BP`，默认在堆栈段`SS`\n\t- 基址变址寻址方式与相对寻址方式一样，主要用于一维数组操作。 \n- 5.基址、变址、相对寻址\n\t- 操作数的偏移地址为：\n\t\t- 基址寄存器内容+变址寄存器内容+位移量\n\t- 操作数的段地址由选择的基址寄存器决定。\n \t- 基址变址相对寻址方式主要用于二维表格操作。\n \t- 例如：`MOV AL, [BP][DI]5`==>也可以表示为`[BP+DI+5]`\n- 6.隐含寻址\n\t- 指令中隐含了一个或两个操作数的地址，即操作数在默认的地址中。\n\t- 例：\n\t\t- `MUL BL`\n\t- 指令执行：\n\t\t- `AL×BL-->AX`\n\n- I/O端口寻址方式\n\t- 直接端口寻址\n\t\t- 由指令提供一个8位端数（0-255）\n\t- 间接端口寻址\n\t\t- 由DX寄存器给出，寻址64KB\n\n![](https://unpkg.com/justlovesmile-img/20200626201755.png)\n\n## 第十六讲 数据传送指令\n\n- 8086指令系统从功能上包括六大类：\n\t- 数据传送\n\t- 算术运算\n\t- 逻辑运算和移位\n\t- 串操作\n\t- 程序控制\n\t- 处理器控制\n- 数据传送类指令\n\t- 1.通用数据传送指令\n\t\t- 一般数据传送指令\n\t\t\t- `MOV`\n\t\t\t- 格式：`MOV dest,src`\n\t\t\t- 操作：`src->dest`\n\t\t\t- 例子：`MOV AL, BL`\n\t\t\t- 注意点：两操作数字长必须相同；两操作数不允许同时为存储器操作数；两操作数不允许同时为段寄存器；在源操作数是立即数时，目标操作数不能是段寄存器；IP和CS不作为目标操作数，FLAGS一般也不作为操作数在指令中出现。 \n\t\t\t- ![](https://unpkg.com/justlovesmile-img/20200626203308.png)\n\t\t- 堆栈操作指令\n\t\t\t- 先进后出，以字为单位\n\t\t\t- 压栈：`PUSH OPRD` 16位寄存器或存储器两单元\n\t\t\t- ![](https://unpkg.com/justlovesmile-img/20200626204137.png)\n\t\t\t- 出栈：`POP OPRD`\n\t\t\t- ![](https://unpkg.com/justlovesmile-img/20200626204453.png)\n\t\t\t- 指令的操作数必须是16位；操作数可以是寄存器或存储器两单元，但不能是立即数；不能从栈顶弹出一个字给CS；PUSH和POP指令在程序中一般成对出现；PUSH指令的操作方向是从`高地址向低地址`，而POP指令的操作正好相反。 \n\t\t\t- 堆栈指针寄存器SP指向栈顶位置\n\t\t- 交换指令\n\t\t\t- 格式：`XCHG REG，MEM/REG`\n\t\t\t- 注：两操作数必须有一个是寄存器操作数;不允许使用段寄存器。\n\t\t\t- 例：`XCHG AX, BX`,`XCHG [2000], CL`\n\t\t- 查表转换指令\n\t\t\t- 格式：`XLAT`\n\t\t\t- 说明：用BX的内容代表表格首地址，AL内容为表内位移量，BX+AL得到要查找元素的偏移地址\n\t\t\t- 操作：将BX+AL所指单元的内容送AL（将BX为首地址的,偏移地址为AL的内容送给AL。）\n\t\t- 字位扩展指令 \n\t\t\t- 将符号数的符号位扩展到高位；\n\t\t\t- 指令为零操作数指令，采用隐含寻址，隐含的操作数为AX及AX，DX\n\t\t\t- 无符号数的扩展规则为在高位补0\n\t\t\t- 字节到字：`CBW`，将AL内容扩展到AX ，若AL最高位=1，则执行后AH=FFH，若AL最高位=0，则执行后AH=00H 。AL不变（即将AL的符号位移至AH）\n\t\t\t\t- CBW属符号扩展指令，它可以把8位扩展到16位，扩展前后两数的真值不变，主要用于数据类型不同时用符号扩展指令可以使得数据类型相同。\n\t\t\t- 字到双字：`CWD`，将AX内容扩展到DX AX ，若AX最高位=1，则执行后DX=FFFFH，若AX最高位=0，则执行后DX=0000H\n\t\t\t\t- CWD的作用是将带符号的16位整数（AX）转为32位的带符号位的整数(DX:AX),例如：AX=0xFFFE, 转为32位带符号位的整数时，DX=0xFFFF,AX=0XFFFE.又例如：AX=0x0002,转为带符号位的整数时DX=0x0000,AX=0x0002.\n\t- 2.输入输出指令\n\t\t- 从端口地址读入数据到累加器/将累加器的值输出到端口中 \n\t\t- 指令格式：\n\t\t\t- 输入指令： `IN acc，PORT`\n\t\t\t- 输出指令 ：`OUT PORT，acc`\n\t\t- 根据端口地址码的长度，指令具有两种不同的端口地址表现形式：直接寻址，间接寻址\n\t- 3.地址传送指令\n\t\t- `LEA`取偏移地址指令\n\t\t\t- 将变量的16位偏移地址写入到目标寄存器\n\t\t\t- `LEA REG,SRC`\n\t\t- `LDS`指令\n\t\t\t- `LDS`（Load pointer using DS）的一般格式：\n\t\t\t- `LDS 通用寄存器，存储器操作数(32位)`\n\t\t- `LES`指令\n\t\t\t- `LDS`和`LES`均用于将一个32位的远地址指针写入到目标寄存器。\n\t\t\t- `LES`（Load pointer using ES）的一般格式：\n\t\t\t- `LES 通用寄存器，存储器操作数(32位)`\n\t- 4.标志传送指令\n\t\t- 隐含操作数AH,将FLAGS的低8位装入AH \n\t\t\t- `LAHF`（Load AH from Flags）\n\t\t\t- `SAHF`（Store AH into Flags）\n\t\t- 隐含操作数FLAGS\n\t\t\t- `PUSHF`（Push flags onto stack）\n\t\t\t- `POPF`（Pop flags off stack）\n\t\t- 除标志传送指令外，其它指令的执行对标志位不产生影响\n\n# 第四章 算术运算，逻辑运算与移位操作指令\n\n## 第十七讲 算术运算类指令\n\n- 加法运算指令\n\t- 1.`ADD`加法指令\n\t\t- 格式：`ADD OPRD1，OPRD2`\n\t\t- 操作：`OPRD1+OPRD2-->OPRD1`\n\t\t- ADD指令的执行对全部6个状态标志位都产生影响\n\t- 2.`ADC`带进位的加法指令\n\t\t- ` OPRD1+OPRD2+CF-->OPRD1`\n\t- 3.`INC`加1指令\n\t\t- 格式：`INC OPRD`\n\t\t- 操作：`OPRD+1-->OPRD`\n\t\t- 常用于在程序中修改地址指针,OPRD不能是段寄存器,不能是立即数，除CF外，影响其他标志位\n- 减法运算指令\n\t- 1.普通减法指令`SUB`\n\t\t- 格式：`SUB OPRD1，OPRD2`\n\t\t- 操作：`OPRD1- OPRD2-->OPRD1`\n\t\t- 对标志位的影响与ADD指令同\n\t- 2.考虑借位的减法指令`SBB`\n\t\t- 操作：`OPRD1- OPRD2- CF-->OPRD1`\n\t- 3.减1指令`DEC`\n\t\t- 格式：`DEC OPRD`\n\t\t- 操作：`OPRD - 1-->OPRD`\n\t\t- 除了不影响CF外，影响其他标志位\n\t- 4.比较指令`CMP`\n\t\t- 格式：\t`CMP OPRD1，OPRD2`\n\t\t- 操作：`OPRD1- OPRD2`\n\t\t- 指令执行的结果不影响目标操作数，仅影响标志位！\n\t\t- ![](https://unpkg.com/justlovesmile-img/20200626210751.png)\n\t- 5.求补指令`NEG`\n\t\t- `NEG OPRD`\n\t\t- 操作：`0-OPRD-->OPRD`\n- 乘法指令\n\t- 乘法指令采用隐含寻址，隐含的是存放被乘数的累加器AL或AX及存放结果的AX，DX； \n\t- 1.无符号的乘法指令MUL\n\t\t- `MUL OPRD`不能是立即数和段寄存器\n\t\t- 操作：\n\t\t\t- OPRD为字节数`AL×OPRD-->AX`\n\t\t\t- OPRD为16位数`AX×OPRD-->DX,AX`\n\t- 2.带符号的乘法指令IMUL \n\t\t- 格式：`IMUL OPRD`\n\t\t- 指令格式及对操作数的要求与MUL指令相同。\n\t\t- 指令执行原理：\n\t\t\t- ① 将两个操作数取补码（对负数按位取反加1，正数不变）；\n\t\t\t- ② 做乘法运算；\n\t\t\t- ③ 将乘积按位取反加1。\n- 除法指令\n\t- 1.无符号除法指令\n\t\t- 格式： `DIV OPRD`\n\t\t- 操作：\n\t\t\t- 操作数是字节(8位)：`AX/OPRD`,商-->AL,余数-->AH\n\t\t\t- 操作数是字(16位)：`DX,AX/OPRD`,商-->AX,余数-->DX\n\t- 2.有符号除法指令\n\t\t- 格式： `IDIV OPRD`\n\t\t- 指令格式及对操作数的要求与DIV指令相同。\n\t- 注：\n\t\t- 余数符号与被除数相同\n\t\t- 范围\n\t\t\t- 双字/字：商范围 -32768到+32767\n\t\t\t- 字/字节：商范围 -128到+127\n\t\t\t- 超过范围按除数为0处理，产生0号中断\n算术运算指令的执行大多对状态标志位会产生影响\n\n## 第十八讲 逻辑运算指令\n\n- 逻辑运算指令\n\t- 对操作数的要求：\n\t\t- 大多与MOV指令相同。\n\t\t- “非”运算指令要求操作数不能是立即数；\n\t- 对标志位的影响\n\t\t- 除“非”运算指令，其余指令的执行都会影响除`AF`外的5个状态标志；\n\t\t- 无论执行结果如何，都会使标志位`OF=CF=0`。\n\t\t- “非”运算指令的执行不影响标志位。 \n- 1.\"与\"指令\n\t- 格式：`AND OPRD1，OPRD2`\n\t- 操作：两操作数相“与”，结果送目标地址。`(OPRD1)∧(OPRD2)-->(OPRD1)`\n\t- CF=0,OF=0,SF,ZF,PF有影响，对AF无影响\n- 2.\"或\"指令\n\t- 格式：`OR OPRD1，OPRD2`\n\t- 操作：两操作数相“或”，结果送目标地址 \n- 3.\"非\"指令\n\t- 格式：`NOT OPRD`\n\t- 操作：操作数按位取反再送回原地址\n- 4.\"异或\"指令\n\t- 格式：`XOR OPRD1，OPRD2`\n\t- 操作：两操作数相“异或”，结果送目标地址 \n- 5.\"测试\"指令\n\t- 格式：`TEST OPRD1，OPRD2`\n\t- 操作：执行“与”运算，但运算的结果不送回目标地址。\n\t- 应用：常用于测试某些位的状态 \n\n## 第十九讲 移位操作指令\n\n- 移位操作指令\n\t- 控制二进制位向左或向右移动的指令\n\t\t- 非循环移位指令\n\t\t- 循环移位指令\n\t- 移动移动1位时由指令直接给出；移动两位及以上时，移位次数必须由CL指定\n- 1.非循环移位指令\n\t- 逻辑左移`SHL`\n\t\t- 格式： `SHL OPR,CNT`\n\t\t- 注：\n\t\t\t- OPR不能是立即数和段寄存器操作数\n\t\t\t- CNT移位次数，若为1，直接写在指令中，若为几，必须先写入CL中\n\t\t\t- 对CF，OP，PF,ZF，SF有影响，对AF无意义\n\t- 算术左移`SAL`\n\t\t- 格式：`SAL OPR,CNT`\n\t\t- 操作同`SHL`\n\t- 逻辑右移`SHR`\n\t\t- 格式：`SHR OPR,CNT`\n\t- 算术右移`SAR`\n\t\t- 格式：`SAR OPR,CNT`\n\t\t- 操作：左边补上符号位，和之前的符号一样\n- 2.循环移位指令\n\t- 不带进位位的循环移位\n\t\t- 左移 `ROL`\n\t\t\t- 格式： `ROL OPR,CNT`\n\t\t- 右移 `ROR`\n\t\t\t- 格式： `ROR OPR,CNT`\n\t- 带进位位的循环移位\n\t\t- 左移 `RCL`\n\t\t\t- 格式： `RCL OPR,CNT`\n\t\t- 右移 `RCR`\n\t\t\t- 格式： `RCR OPR,CNT`\n\n# 第五章 串操作指令\n\n## 第二十讲 串操作指令\n\n- 针对数据块或字符串的操作 \n- 可实现存储器到存储器的数据传送； \n- 待操作的数据串称为源串，目标地址称为目标串。 \n- 串操作指令的操作对象是多个字节数（一串字符或数据），因此，指令的执行需要确定：\n  - 串所在的区域\n    - 源串一般存放在数据段，偏移地址由SI指定。允许段重设。\n    - 目标串必须在附加段，偏移地址由DI指定\n  - 串的首地址（原串、目标串起始地址）\n  - 串长度（大小）\n    - 串长度值由CX指定 \n  - 串的操作方向\n    - 由DF标志位决定。指令根据DF状态自动修改地址指针\n      - DF=0 增地址方向 \n      - DF=1 减地址方向 \n- 通过增加重复前缀， 可以实现对CX值的自动修改 \n  -  无条件重复\n    - REP\n      - 当CX≠0时，REP后的指令将继续重复执行\n      - 常用于传送类指令前--》未传完则继续传送 \n  - 条件重复\n    - 相等（为零）重复：REPE（REPZ）\n    - CX≠0  ∩  ZF=1，则前缀后的指令将继续重复执行\n    - 不相等（不为零）重复：REPNE（ REPNZ）\n    - CX≠0  ∩  ZF=0，则前缀后的指令将继续重复执行 \n    - 条件前缀常用于运算类指令前，当：\n      - 1）操作未结束  AND  结果=0\n      - 2）操作未结束  AND  结果≠0 使其后的指令继续重复执行。 \n- 串操作指令 \n  - 串传送 `MOVS` \n  - 串比较 `CMPS` \n  - 串扫描 `SCAS` \n  - 串装入 `LODS` \n  - 串送存 `STOS` \n\n![](https://unpkg.com/justlovesmile-img/20200627102608.png)\n\n![](https://unpkg.com/justlovesmile-img/20200627102624.png)\n\n## 第二十一讲 串传送与串比较指令\n\n1.串传送指令\n- 功能：将原数据串传送到目标地址\n- 格式：\n  - `MOVS OPRD1，OPRD2`\n  - `MOVSB`,按字节传送\n  - `MOVSW`，按字传送\n- 串传送指令常与无条件重复前缀连用\n2.串比较指令\n- 功能：用于实现两个数据串的比较\n- 操作：\n  - 目标串-源串，结果不写回目标地址\n  - 常与条件重复前缀连用\n- 格式：\n  - `CMPS OPRD1，OPRD2`\n  - `CMPSB`\n  - `CMPSW`\n- 前缀的操作对标志位不影响\n\n## 第二十二讲 串扫描指令\n\n- 格式：\n  - `SCAS OPRD`\n  - `SCASB`\n  - `SCASW`\n- 执行与CMPS指令相似的操作，区别是：这里的源操作数是AX或AL\n\n- 串扫描指令应用例：\n  - 在ES段中从2000H单元开始存放了10个字符，寻找其中有无字符“A”。若有则记下搜索次数，将搜索次数写入到DATA1单元，并将存放“A”的地址写入DATA2单元。\n  - ![](https://unpkg.com/justlovesmile-img/20200627103549.png)\n\n## 第二十三讲 串装入与串存储指令\n\n1.串装入指令\n- 格式：\n  - `LODS OPRD`\n  - `LODSB`\n  - `LODSW`\n- 操作：\n  - 对字节：AL  [DS:SI]\n  - 对  字：AX  [DS:SI]\n2.串存储指令\n- 格式：\n  - `STOS OPRD`\n  - `STOSB`\n  - `STOSW`\n- 操作：\n  - 对字节： AL  [ES:DI]\n  - 对  字： AX  [ES:DI]\n\n- 串操作指令应用注意事项:\n  - 需要定义附加段\n    - 目标操作数必须在附加段\n  - 需要设置数据的操作方向\n    - 确定DF的状态\n  - 源串和目标串指针分别为SI和DI\n  - 串长度值必须由CX给出\n  - 注意重复前缀的使用方法\n    - 传送类指令前加无条件重复前缀\n    - 串比较类指令前加条件重复前缀，但前缀不影响ZF状态 \n\n# 第六章 程序与处理器控制指令\n\n## 第二十四讲 程序控制指令\n\n![](https://unpkg.com/justlovesmile-img/20200627104125.png)\n\n- 程序控制类指令\n  - 转移指令\n    - 通过修改指令的偏移地址或段地址及偏移地址实现程序的转移\n    - 无条件转移指令-->无条件转移到目标地址\n      - `JMP OPRD`\n      - 段内直接转移\n      \t- 当偏移量为8位时，称为段内直接短跳转\n      \t  - 格式：`JMP (SHORT) 标号`\n      \t  - 操作：`(IP)<--disp8+(IP)`\n      \t- 当偏移量为8位时，称为段内直接近跳转\n      \t  - 格式：`JMP (NEAR PTR) 标号`\n      \t  - 操作：`(IP)<--disp16+(IP)`\n      - 段内间接转移\n      \t- `JMP BP`\n      \t  - 转向(SS):(BP)\n      \t- `JMP BX`\n      \t  - 转向(CS):(BX)\n      \t- `JMP (WORD PTR) [BX][DI]`\n      \t  - 转向(CS):(BX)+(DI)\n      - 段间直接转移\n      \t- `JMP (FAR PTR) 标号`\n      \t- 执行该指令时，将把标号所在的段的值送CS，将标号在所属段内的偏移量送IP，从而形成新的转移地址CS:IP\n      - 段间间接转移\n      \t- `JMP DWORD PTR [BX]`\n      \t- 中间的`DWORD PTR`不能省略，表示存储器双字操作数\n    - 条件转移指令-->当具备一定条件时转移到目标地址\n      - `JC/JNC`\n        - 判断CF的状态。常用于两个无符号数大小比较\n      - `JZ/JNZ`\n        - 判断ZF的状态。常用于循环体的结束判断\n      - `JO/JNO`\n        - 判断OF的状态。常用于有符号数溢出的判断\n      - `JP/JNP`\n        - 判断PF的状态。用于判断运算结果低8位中1的个数是否为偶数\n      - `JS /JNS`\n        - 判断SF的状态。常用于判断数的性质 \n      - `JA/JAE/JB/JBE`\n        - 判断CF或CF+ZF的状态。常用于无符号数大小的比较\n      - `JG/JGE/JL/JLE`\n        - 判断SF+OF或SF+OF+ZF的状态。常用于有符号数大小的比较\n      - `JCXZ`\n        - 可根据指令执行后CX的结果实现转移\n      ![](https://unpkg.com/justlovesmile-img/20200829201509.png)\n  - 循环控制\n    - `LOOP`\n      - 条件：CX≠0\n    - `LOOPZ`\n      - 条件：CX≠0，且ZF=1\n    - `LOOPNZ`\n      - 条件：CX≠0，且ZF=0\n  - 过程调用\n    - 用于调用一个子过程，必须保护返回地址 \n    - 调用指令的执行过程\n      - ① 保护断点：将调用指令的下一条指令的地址（断点）压入堆栈\n      - ② 获取子过程的入口地址：子过程第1条指令的偏移地址\n      - ③ 执行子过程：功能实现，参数的保存及恢复\n      - ④ 恢复断点，返回原程序：将断点偏移地址由堆栈弹出 \n    - 段内调用：被调用程序与调用程序在同一代码段\n      - `CALL NEAR PROCC`\n    - 段间调用:子过程与原调用程序不在同一代码段\n    - 返回指令:\n      - 功能：从堆栈中弹出断点地址，返回原程序\n      - 格式：`RET`\n      - 子程序的最后一条指令必须是RET\n  - 中断控制\n    - 中断的概念:某种异常或随机事件使处理器暂时停止正在运行的程序，转去执行一段特殊处理程序，并在处理结束后返回原程序被中断处继续执行的过程。\n    - 中断指令：引起CPU产生一次中断的指令 \n      - 格式：`INT n`\n      - 说明： nх4\n    - 中断指令的执行过程\n      - ① 将FLAGS压入堆栈；\n      - ② 将INT指令的下一条指令的CS、IP压栈；\n      - ③ 由n×4得到存放中断向量的地址；\n      - ④ 将中断向量（中断服务程序入口地址）送CS和IP寄存器；\n      - ⑤ 转入中断服务程序\n    - 中断返回指令:\n      - 格式：`IRET`\n      - 中断服务程序的最后一条指令，负责：恢复断点;恢复标志寄存器内容\n\n## 第二十五讲 处理器控制指令\n\n- 这类指令用来对CPU进行控制，如修改标志寄存器，使CPU暂停，使CPU与外部设备同步等。\n![](https://unpkg.com/justlovesmile-img/20200627113916.png)\n\n# 第七章 汇编语言\n\n## 第二十六讲 汇编语言程序设计\n\n1. 汇编语言源程序与汇编程序\n（1）汇编语言源程序：用助记符编写\n（2）汇编程序：源程序的编译程序\n2. 汇编语言程序设计与执行过程\n（1）输入汇编语言源程序：源文件.ASM\n（2）汇编MASM：目标文件.OBJ\n（3）链接LINK：可执行文件.EXE\n（4）调试TD：最终程序\n3. 汇编语言语句类型和格式\n（1）语句类型：指令性语句，指示性语句\n（2）语句格式：\n指令性语句：`[标号：] [前缀] 助记符 [操作数]，[操作数] [ ；注释] `\n指示性语句格式： `[名字] 伪指令助记符 操作数 [，操作数，…] [ ；注释] `\n4. 汇编语言语句中的操作数\n(1)寄存器\n(2)存储器单元\n(3)常量:（数字/字符串）\n(4)变量或标号\n(5)表达式 ：算术运算；逻辑运算；关系运算；取值运算（`OFFSET`,`SEG`）和属性运算(`PTR`)；其它运算 \n\n## 第二十七讲 数据定义伪代码\n\n1. 数据定义伪指令\n（1）用于定义数据区中变量的类型及其所占内存空间大小\n（2）DB（Define Byte）:定义的变量为字节型\n（3）DW （Define Word） :定义的变量为字类型\n（4）DD （Define Double Word） :定义的变量为双字型\n（5）DQ （Define Quadword） :定义的变量为4字型\n（6）DT （Define Tenbytes） :定义的变量为10字节型\n2. 重复操作符\n（1）当同样的操作数重复多次时，可以使用重复操作符\n（2）作用：为一个数据区的各单元设置相同的初值\n（3）格式：[变量名] 伪指令助记符 n DUP（初值 [,初值,… ] ）\n（4）例：`M1 DB 10 DUP（0）`\n3. “？”的作用\n（1）表示随机值，用于预留存储空间\n（2）例：`MEM1 DB 34H，’A’，？`，例：`DW 20 DUP（？）`\n4. 调整偏移量伪指令\n（1）规定程序或变量在逻辑段中的起始地址\n（2）格式：`ORG 表达式`\n（3）例：\n```x86asm\nDATA SEGMENT\nORG 1200H\nBUFF DB 1,2\nDATA ENDS \n```\n\n## 第二十八讲 符号与段定义相关伪指令\n\n1. 符号定义伪指令\n（1）将表达式的值赋给一个名字。当源程序中需多次引用某一表达式时，可以利用EQU伪指令，用一个符号代替表达式，以便于程序维护。\n（2）格式：`符号名 EQU 表达式`\n（3）操作：用符号名取代后边的表达式，不可重新定义\n（4）例：`CONSTANT EQU 100 `\n2. 段定义伪指令\n（1）在汇编语言源程序中定义逻辑段\n说明逻辑段的起始和结束\n说明不同程序模块中同类逻辑段之间的联系形态\n（2）格式：`段名 SEGMENT [定位类型] [组合类型] [’类别’] `\n3. 设定段寄存器伪指令\n（1）说明所定义逻辑段的性质\n（2）格式：`ASSUME 段寄存器名:段名[，段寄存器名:段名，…] `\n4. 结束伪指令\n（1）表示源程序结束\n（2）格式：`END [标号] `\n\n## 第二十九讲 其他伪指令\n\n1. 过程定义伪指令\n（1）用于定义一个过程体\n（2）格式：\n```\n 过程名 PROC [ NEAR / FAR ]\n ┇\n RET\n 过程名 ENDP\n```\n（3）![](https://unpkg.com/justlovesmile-img/20200627120345.png)\n2. 宏命令伪指令\n（1）宏：源程序中由汇编程序识别的具有独立功能的一段程序代码\n（2）当源程序中需要多次使用同一个程序段时，可以将该程序段定义为一个宏\n（3）格式：`宏命令名 MACRO <形式参数>`\n（4）![](https://unpkg.com/justlovesmile-img/20200627120517.png)\n\n## 第三十讲 系统功能调用\n\n1. BIOS、DOS功能调用\n（1）BIOS：驻留在ROM中的基本输入/输出系统\n加电自检，装入引导，主要I/O设备处理程序及接口控制\n（2）DOS：磁盘操作系统\nDOS功能/BIOS功能调用是调用系统内核子程序\n（3）BIOS、DOS功能调用：DOS功能与BIOS功能均通过中断方式调用，DOS和BIOS中断均可能影响AX\n2. DOS软中断\n（1）DOS中断包括：设备管理，目录管理，文件管理，其它用中断类型码区分\n（2）DOS软中断：类型码为21H \n3. 单字符输入\n（1）调用方法：\n```x86asm\nMOV AH，01\nINT 21H\n```\n（2）输入的字符在AL中 \n4. 字符串输入\n（1）接收由键盘输入一串字符\n（2）输入的字符串存储在内存指导区域中\n（3）用户自定义缓冲区格式：\n![](https://unpkg.com/justlovesmile-img/20200627121105.png)\n5. 单字符显示输出\n![](https://unpkg.com/justlovesmile-img/20200627121240.png)\n6. 字符串显示输出\nAH 功能号09H\nDS：DX 待输出字符串的偏移地址\nINT 21H\n7. 返回操作系统（DOS）功能\n（1）功能号：4CH\n（2）调用格式：\n```masm\nMOV AH，4CH\nINT 21H\n```\n（3）功能：程序执行完该2条语句后能正常返回OS;常位于程序结尾处\n\n# 第八章 半导体存储器\n\n## 第三十一讲 半导体存储器概述\n\n1. 半导体存储器\n（1）由能够表示二进制数“0”和“1”的，具有记忆功能的半导体器件组成\n（2）能存放一位二进制数的半导体器件称为一个存储元\n（3）若干存储元构成一个存储单元\n2. 半导体存储器的分类\n- 内存储器：\n  - 随机存取存储器（RAM）\n    - 静态存储器（SRAM）\n    - 动态存储器（DRAM）\n  - 只读存储器（ROM）\n    - 掩模ROM\n    - 一次性可写ROM\n    - 可读写ROM\n      - EPROM\n      - EEPROM\n      - PROM\n3. 半导体存储器的主要技术指标\n（1）存储容量：存储单元个数×每单元的二进制数位数\n存储容量=2^m×N\n（m：芯片地址线根数）\n（N：芯片数据线根数）\n（2）存取时间：实现一次读/写所需要的时间\n（3）存取周期：连续启动两次独立的存储器操作所需间隔的最小时间\n（4）可靠性，功耗\n\n## 第三十二讲 微机中的存储器\n\n1. 微机中的存储器\n（1）内存储器\n主内存\n高速缓冲存储器\n（2）外存储器\n联机外存\n脱机外存\n（3）虚拟存储器\n![](https://unpkg.com/justlovesmile-img/20200627143039.png)\n\n| |内存|外存|\n| :---: | :---: | :---: |\n|速度|快|慢|\n|容量|小|大|\n|单位容量价格|高|低|\n|制造材料|半导体|磁性材料|\n\n2. 微机中的存储系统主要有：\n（1）Cache存储器系统\n（2）虚拟存储器系统\n\n3. 随机存取存储器\n（1）特点：可以随机读或写操作；掉电后存储内容即丢失\n（2）类型：静态随机存取存储器（SRAM）；动态随机存取存储器（DRAM）\n\n## 第三十三讲 存储单元的编址\n\n![](https://unpkg.com/justlovesmile-img/20200627143427.png)\n![](https://unpkg.com/justlovesmile-img/20200627143454.png)\n\n1. 地址译码电路\n（1）单译码结构\n（2）双译码结构\n（3）3-8译码器（741S138）\n\n## 第三十四讲 存储器扩展技术\n\n1. 存储器扩展：用已有的存储器芯片构造一个需要的存储空间\n（1）用多片存储芯片构成一个需要的内存空间；\n（2）各存储器芯片在整个内存中占据不同的地址范围；\n（3）任一时刻仅有一片（或一组）被选中。\n（4）存储器芯片的存储容量等于：单元数×每单元的位数 \n2. 存储器扩展方法\n（1）位扩展--》扩展字长\n（2）字扩展--》扩展单元数\n（3）字位扩展--》既扩展字长也扩展单元数\n\n# 第九章 输入输出与中断技术\n\n## 第三十五讲 输入输出技术概述\n\n1. I/O接口\n（1）接口要解决的问题\n速度匹配👉数据的缓冲与暂存\n信号的驱动能力👉信号驱动\n信号形式和电平的匹配👉信号类型转换\n信息格式👉信号格式转换\n时序匹配（定时关系）\n总线隔离👉三态门 \n2. I/O端口及其编址\n（1）端口：接口电路中用于缓存数据及控制信息的部件\n（2）分类：数据端口，控制端口，状态端口\n![](https://unpkg.com/justlovesmile-img/20200627144642.png)\n（3）I/0端口编址：为确保CPU能够访问到每个不同的端口\n（4）寻址端口的方法：\n- 先找到端口所在的接口电路芯片\n- 再在该芯片上找具体访问的端口\n  - 若接口中仅有一个端口，则找到芯片即找到端口\n  - 若接口中有多个端口，则找到芯片后需再找端口\n（5）每个端口地址=片选地址（高位地址）+片内地址 \n3.  I/O地址译码\n（1）目的：确定端口的地址\n（2）参加译码的信号：\n`#IOR，#IOW，高位地址信号`\n（3）对端口读/写信号的产生条件\n- `IO/#M=1`\n- `#RD=0 #IOR=0`\n- `#WR=0 #IOW=0`\n（4）当接口只有一个端口时：无片内地址，全部地址信号均为高位地址（可全部参与译码），译码输出直接选择该端口；\n（5）当接口具有多个端口时：则16位地址线的高位参与译码（决定接口的基地址），而低位则用于确定要访问哪一个端口\n\n## 第三十六讲 简单接口芯片\n\n1.  接口的分类及特点\n（1）按传输信息的方向分类：\n输入接口\n输出接口\n（2）按传输信息的类型分类：\n数字接口\n模拟接口\n（3）按传输信息的方式分类：\n并行接口\n串行接口\n2. 接口特点\n（1）输入接口：\n要求对数据具有控制能力\n常用三态门实现\n（2）输出接口：\n要求对数据具有锁存能力\n常用锁存器实现\n\n## 第三十七讲 基本输入输出方法\n\n1. 基本输入/输出方法\n（1）无条件传送：要求外设总是处于准备好状态\n优点：软件及接口硬件简单\n缺点：只适用于简单外设，适应范围较窄\n（2）查询式传送：仅当条件满足时才能进行数据传送；每满足一次条件只能进行一次数据传送。\n适用场合：外设并不总是准备好；对传送速率和效率要求不高\n工作条件：外设应提供设备状态信息；接口应具备状态端口\n（3）中断方式传送\n特点：外设在需要时向CPU提出请求，CPU再去为它服务。服务结束后或在外设不需要时，CPU可执行自己的程序。\n优点：CPU效率高，实时性好，速度快。\n缺点：程序编制相对较为复杂。\n（4）直接存储器存取(DMA) ：\n特点：\n①外设直接与存储器进行数据交换 ，CPU不再担当数据传输的中介者；\n②总线由DMA控制器（DMAC）进行控制（CPU要放弃总线控制权），内存/外设的地址和读写控制信号均由DMAC提供。 \n③DMA传送方式有单元传送方式，快传送方式，请求传送方式\n![](https://unpkg.com/justlovesmile-img/20200627145513.png)\n![](https://unpkg.com/justlovesmile-img/20200627145541.png)\n![](https://unpkg.com/justlovesmile-img/20200627145557.png)\n\n### DMA控制器8237A\n\n![](https://unpkg.com/justlovesmile-img/20200907143459.png)\n\n## 第三十八讲 中断技术\n\n1. 中断的基本概念\n（1）CPU执行程序时，由于发生了某种随机的事件(外部或内部)，\n引起CPU暂时中断正在运行的程序，转去执行一段特殊的服务\n程序，以处理该事件，该事件处理完后又返回被中断的程序\n继续执行，这一过程称为中断。\n（2）引入中断的原因\n提高对外设请求的响应实时性。\n提高了CPU的利用率\n避免了CPU不断检测外设状态的过程 \n（3）中断类型\n![](https://unpkg.com/justlovesmile-img/20200627145857.png)\n\n# 第十章 可编程数字接口电路\n\n## 可编程定时计数器8253\n\n![](https://unpkg.com/justlovesmile-img/8253-1.PNG)\n![](https://unpkg.com/justlovesmile-img/8253-2.PNG)\n\n## 可编程并行接口8255\n\n![](https://unpkg.com/justlovesmile-img/8255-1.PNG)\n![](https://unpkg.com/justlovesmile-img/8255-2.PNG)\n![](https://unpkg.com/justlovesmile-img/8255-3.PNG)\n\n## 可编程中断控制器8259\n\n![](https://unpkg.com/justlovesmile-img/8259-1.PNG)\n![](https://unpkg.com/justlovesmile-img/8259-2.PNG)\n![](https://unpkg.com/justlovesmile-img/8259-3.PNG)\n![](https://unpkg.com/justlovesmile-img/8259-4.PNG)\n![](https://unpkg.com/justlovesmile-img/8259-5.PNG)\n\n# 第十一章 模拟接口电路\n\n## 模拟量的输入输出\n\nD： （Digital） 数字量\nA： （Analog） 模拟量\n采样和量化\n\n## D/A转换器和A/D转换器\n\n1. 主要参数\n（1）分辨率\n输入的二进制数每+1/-1个最低有效位LSB，使输出变化的程度 , 1LSB = 1/(2^n-1) \n[n：D/A转换器的字长]\n（2）转换时间\n（3）精度\n（4）线性度\n2. D/A转换器与微处理器的接口方法\n（1）接口任务:解决数据锁存，缓冲问题\n（2）特点：控制信号，无专门数据传送间隔时间，调节数据宽度\n（3）接口电路结构：通用并行接口或直连\n（4）D/A：数字量转换为模拟量\n\n## D/A转换器（DAC0832）NS\n\n1. 三种工作方式：直通方式，单缓冲方式，双缓冲方式\n2. 8位寄存器，T型电阻网络，电流型输出，不可编程\n3. 主要引脚功能：D7-D0，ILE，CS，WR1，WR2，XFER（低电平有效）\n4. 内部结构：\n（1）8位输入寄存器\n（2）8位DAC寄存器\n（3）8位D/A转换器\n![](https://unpkg.com/justlovesmile-img/20200907141224.png)\n\n## A/D转换器（ADC0809）\n\n1.特点\n- 8通道（8路）输入\n- 8位字长\n- 逐位逼近型\n- 转换时间100us\n- 内置三态输出缓冲器\n2.主要引脚功能\n- D7-D0：输出数据线，三态\n- IN0-IN7：8通道模拟输入\n- ADDC,ADDB,ADDA通道地址选择\n- Start：启动变换\n- ALE：通道地址锁存\n- EOC：转换结束状态输出\n- OE：输出允许\n- CLK：工作时钟\n\n\n# 补充\n\n1. 控制信号\n（1）M/IO=1,CPU对存储器操作，M/IO=0,CPU对I/O操作\n（2）DT/R=1,CPU→【内存/（I/O）】，DT/R=0，外部→CPU\n（3）8086，RD，WR低电平有效\n2. ADC0809\n（1）EOC发出中断请求\n（2）CPU查询EOC状态\n3. D/A和A/D\n（1）主要参数：分辨率，转换时间，精度\n4. 数据传输方式（输入输出控制方式）\n（1）程序控制方式\n\t(1.1)无条件传送\n\t(1.2)有条件传送（查询）\n（2）中断控制方式\n（3）DMA\n\t（3.1）DMA传送方式：单元传送，块传送，请求传送\n\t（3.2）DMAC，8237A\n\t（3.3）DMA方式写，外设到存储器\n\t（3.4）8237占用8个输入输出端口\n\t（3.5）DMA控制方式中需要用到的一对联络信号是HLDA/HRQ\n5. 串行接口\n（1）串行接口中，并行数据和串行数据的转换通过移位寄存器实现\n（2）RS-232是串行通信标准\n6. 片选控制方式，全译码，部分译码，线译码\n7. I/O接口有独立编址和统一编址方式\n8. 复位后段寄存器的初值为：CS=FFFFH，DS=0000H，SS=0000H，ES=0000H,其他寄存器的初值都是0，特别是CS=FFFFH，IP=0000H，因此复位后CPU从FFFF0H开始执行程序\n9. 奇地址存储体和系统数据总线高8位相连，用BHE=0作为选通信号；偶地址存储体和系统数据总线低8位相连，用A0=0作为连通信号\n10. 对准字，从偶地址开始存放字数据的存放方式（传一次，A0和BHE都有效），非对准字，从奇地址开始存放字数据的存放方式（传两次，先奇BHE后偶A0）\n11. 寻址隐含约定：\n（1）直接寻址，DS\n（2）寄存器寻址：DS←BX/SI/DI；SS←BP\n（3）基址变址寻址：DS←BX+SI/DI ； SS：BP+SI/DI\n（4）堆栈：SS←SP\n（5）取指令：CS←IP","tags":["大学课程","微机原理"],"categories":["学习笔记"]},{"title":"学习笔记 | CSP201912认证考试部分题解","slug":"学习笔记-CSP201912","url":"/posts/7c5e3f37.html","content":"\n# CSP练习\n\n## 201912-1 报数\n\n![](https://unpkg.com/justlovesmile-img/csp201912101.png)\n![](https://unpkg.com/justlovesmile-img/csp201912102.png)\n\n\n```python\nn=int(input())\na=[0 for i in range(4)]\ni,j=1,1\nwhile(j<=n):\n    if(i%7==0 or ('7' in str(i))):#7的倍数或者含有7则跳过\n        a[(i-1)%4]+=1#跳过次数加1\n        j-=1#不计被跳过的数\n    i+=1#下一个人\n    j+=1#下一个数\nfor i in a:\n    print(i)\n```\n\n    66\n    7\n    5\n    11\n    5\n    \n\n## 201912-2 回收站选址\n\n![](https://unpkg.com/justlovesmile-img/csp201912201.png)\n![](https://unpkg.com/justlovesmile-img/csp201912202.png)\n![](https://unpkg.com/justlovesmile-img/csp201912203.png)\n\n\n```python\nclass Point:\n    def __init__(self,x,y,w=0,a=0,s=0,d=0,score=0):\n        self.x,self.y,self.w,self.a,self.s,self.d,self.score=x,y,w,a,s,d,score\n    def newscore(self,p):#四对角得分\n        if(self.x+1==p.x and self.y+1==p.y):\n            self.score+=1\n            p.score+=1\n        elif(self.x+1==p.x and self.y-1==p.y):\n            self.score+=1\n            p.score+=1\n        elif(self.x-1==p.x and self.y+1==p.y):\n            self.score+=1\n            p.score+=1\n        elif(self.x-1==p.x and self.y-1==p.y):\n            self.score+=1\n            p.score+=1\n        else:\n            pass\n\n    def begood(self,p):#上下左右\n        if(self.x+1==p.x and self.y==p.y):\n            self.d+=1\n            p.a+=1\n        elif(self.x-1==p.x and self.y==p.y):\n            self.a+=1\n            p.d+=1\n        elif(self.x==p.x and self.y+1==p.y):\n            self.w+=1\n            p.s+=1\n        elif(self.x==p.x and self.y-1==p.y):\n            self.s+=1\n            p.w+=1\n        else:\n            pass\n    def good(self):#是否上下左右满足\n        if(self.w==1 and self.a==1 and self.s==1 and self.d==1):\n            return True\n        \n\ns=int(input())\np=[]\nfor i in range(s):\n    s=input().split()\n    tempP=Point(int(s[0]),int(s[1]))\n    for eachp in p:\n        dx=eachp.x-tempP.x\n        dy=eachp.y-tempP.y\n        if(not eachp.good() and dx*dx+dy*dy==1):\n            eachp.begood(tempP)\n        if(eachp.score!=4 and dx*dx+dy*dy==2):\n            eachp.newscore(tempP)\n\n    p.append(tempP)\n\nans=[0,0,0,0,0]\nfor i in p:\n    if(i.good()):\n        ans[i.score]+=1\n\nfor i in ans:\n    print(i)\n```\n\n    7\n    1 2\n    2 1\n    0 0\n    1 1\n    1 0\n    2 0\n    0 1\n    0\n    0\n    1\n    0\n    0\n    \n\n## 201912-3 化学方程式\n\n![](https://unpkg.com/justlovesmile-img/csp201912301.png)\n![](https://unpkg.com/justlovesmile-img/csp201912302.png)\n![](https://unpkg.com/justlovesmile-img/csp201912303.png)\n\n```txt\n//样例：\n11\nH2+O2=H2O\n2H2+O2=2H2O\nH2+Cl2=2NaCl\nH2+Cl2=2HCl\nCH4+2O2=CO2+2H2O\nCaCl2+2AgNO3=Ca(NO3)2+2AgCl\n3Ba(OH)2+2H3PO4=6H2O+Ba3(PO4)2\n3Ba(OH)2+2H3PO4=Ba3(PO4)2+6H2O\n4Zn+10HNO3=4Zn(NO3)2+NH4NO3+3H2O\n4Au+8NaCN+2H2O+O2=4Na(Au(CN)2)+4NaOH\nCu+As=Cs+Au\n//结果：\nN\nY\nN\nY\nY\nY\nY\nY\nY\nY\nN\n```\n\n```python\ndef chemistry(x):\n    each=x.split('+') #拆成每个化学式\n    res={}#化学元素字典\n    for item in each:\n        i=0\n        num=\"\"#存储每个化学式前面的数字\n        if(48<=ord(item[i])<=57):#如果开始是数字\n            num+=item[i]\n            i+=1\n            while(i<len(item)-1 and 48<=ord(item[i])<=57):\n                num+=item[i]\n                i+=1\n        n=1 if num==\"\" else int(num)\n        #化学式前面没有数字，代表为1\n        re=single(item[i:],n)\n        for key in re:\n            res[key]=res.get(key,0)+re[key]\n    return res\n    \ndef single(item,m):\n    res={}#化学元素字典\n    i=0\n    s=\"\"\n    num=\"\"\n    while(i<len(item)):\n        if(item[i]==\"(\"):\n            p=1\n            for j in range(i+1,len(item)):\n                if(item[j]==\"(\"):\n                    p+=1\n                elif (item[j]==\")\"):\n                    p-=1\n                    index=j\n                if(p==0):\n                    break\n            k=i+1#第一个左括号之后的位置\n            i=index#括号结束的位置\n            if(i<len(item)-1 and 48<=ord(item[i+1])<=57):#如果是数字\n                num+=item[i+1]\n                i+=1\n                while(i<len(item)-1 and 48<=ord(item[i+1])<=57):\n                    num+=item[i+1]\n                    i+=1\n            n=1 if num==\"\" else int(num)\n            re=single(item[k:index],n*m)\n            for key in re:\n                res[key]=res.get(key,0)+re[key]\n        elif(65<=ord(item[i])<=90):#如果是大写字母\n            s+=item[i]\n            if(i<len(item)-1 and 97<=ord(item[i+1])<=122):#如果是小写字母\n                s+=item[i+1]\n                i+=1\n            if(i<len(item)-1 and 48<=ord(item[i+1])<=57):#如果是数字\n                num+=item[i+1]\n                i+=1\n                while(i<len(item)-1 and 48<=ord(item[i+1])<=57):\n                    num+=item[i+1]\n                    i+=1\n            n=1 if num==\"\" else int(num)\n            res[s]=res.get(s,0)+m*n#这个化学元素个数，初始为0\n        num=\"\"\n        s=\"\"\n        i+=1\n    return res\n\ndef main():\n    n=int(input())\n    expressions=[]\n    for i in range(n):\n        expressions.append(input())\n    for item in expressions:\n        express=item.split(\"=\")#每个表达式从等号分开\n        left,right=express[0],express[1]\n        ans1=chemistry(left)\n        ans2=chemistry(right)\n        if(ans1==ans2):\n            print('Y')\n        else:\n            print('N')\n\nmain()\n```\n\n    11\n    H2+O2=H2O\n    2H2+O2=2H2O\n    H2+Cl2=2NaCl\n    H2+Cl2=2HCl\n    CH4+2O2=CO2+2H2O\n    CaCl2+2AgNO3=Ca(NO3)2+2AgCl\n    3Ba(OH)2+2H3PO4=6H2O+Ba3(PO4)2\n    3Ba(OH)2+2H3PO4=Ba3(PO4)2+6H2O\n    4Zn+10HNO3=4Zn(NO3)2+NH4NO3+3H2O\n    4Au+8NaCN+2H2O+O2=4Na(Au(CN)2)+4NaOH\n    Cu+As=Cs+Au\n    N\n    Y\n    N\n    Y\n    Y\n    Y\n    Y\n    Y\n    Y\n    Y\n    N\n    \n\n## 201912-4 区块链\n\n![](https://unpkg.com/justlovesmile-img/csp201912401.png)\n![](https://unpkg.com/justlovesmile-img/csp201912402.png)\n![](https://unpkg.com/justlovesmile-img/csp201912403.png)\n![](https://unpkg.com/justlovesmile-img/csp201912404.png)\n![](https://unpkg.com/justlovesmile-img/csp201912405.png)\n\n\n```python\n\n```\n\n## 201912-5 魔数\n\n![](https://unpkg.com/justlovesmile-img/201912501.png)\n![](https://unpkg.com/justlovesmile-img/201912502.png)\n![](https://unpkg.com/justlovesmile-img/201912503.png)\n![](https://unpkg.com/justlovesmile-img/201912504.png)\n![](https://unpkg.com/justlovesmile-img/201912505.png)\n![](https://unpkg.com/justlovesmile-img/201912506.png)\n![](https://unpkg.com/justlovesmile-img/201912507.png)\n![](https://unpkg.com/justlovesmile-img/201912508.png)\n\n\n```python\n\n```\n","tags":["Python","算法"],"categories":["学习笔记"]},{"title":"随笔记录 | 漫威DC观影指南","slug":"生活琐事-MarvelDC观影指南","url":"/posts/604a50ec.html","content":"\n## Marvel\n\n### MCU(漫威电影宇宙)\n\n十年漫威，一战终局，英雄已去，传奇依旧\n\n<big>对</big>于MCU（漫威电影宇宙）的<strong>电影</strong>观看顺序，上映顺序就是最好的指南\n\n|阶段|观影顺序（↓）|上映时间|\n| --- |---|---|\n|《无限传奇》第一阶段|钢铁侠|2008|\n| |无敌浩克|2008|\n| |钢铁侠2|2010|\n| |雷神|2011|\n| |美国队长：复仇者先锋|2011|\n| |复仇者联盟|2012|\n|《无限传奇》第二阶段|钢铁侠3|2013|\n| |雷神2：黑暗世界|2013|\n| |美国队长2：冬日战士|2014|\n| |银河护卫队|2014|\n| |复仇者联盟2：奥创纪元|2015|\n| |蚁人|2015|\n|《无限传奇》第三阶段|美国队长3：内战|2016|\n| |奇异博士|2016|\n| |银河护卫队2|2017|\n| |蜘蛛侠：英雄归来|2017|\n| |雷神3：诸神黄昏|2017|\n| |黑豹|2018|\n| |复仇者联盟3：无限战争|2018|\n| |蚁人2：黄蜂女现身|2018|\n| |惊奇队长|2019|\n| |复仇者联盟4：终局之战|2019|\n| |蜘蛛侠2：英雄远征（2019）|2019|\n\n\n- 下面是完整的电影，电视剧以及短片的观影顺序图：\n\n![](https://unpkg.com/justlovesmile-img/d01373f082025aafc11ca80500690662024f1a59.jpg)\n\n### X战警宇宙\n\n\n|系列名称|观影顺序（↓）|上映时间|\n| --- |---|---|\n|X战警系列作品|《金刚狼》X-Men Origins:Wolverine|2009|\n| |《X战警：第一战》X-Men:First Class|2011|\n| |《X战警》X-Men|2000|\n| |《X战警2》X2|2003|\n| |《X战警：背水一战》X-Men:The Last Stand|2006|\n| |《金刚狼2》The Wolverine|2013|\n| |《X战警：逆转未来》X-Men:Days of Future Past|2014|\n| |《死侍》Dead pool|2016|\n| |《X战警：天启》X-Men:Apocalypse|2016|\n| |《金刚狼3：殊死一战》Logan|2017|\n| |《死侍2：我爱我家》Deadpool2|2018|\n| |《X战警：黑凤凰》Dark Phoenix|2019|\n| |《新变种人》The New Mutants|2020|\n\n\n### 索尼电影宇宙\n\n\n|系列名称|观影顺序（↓）|上映时间|\n| --- |---|---|\n|索尼漫威宇宙|《蜘蛛侠》|2002|\n| |《蜘蛛侠2》|2004|\n| |《蜘蛛侠3》|2007|\n| |《超凡蜘蛛侠》|2012|\n| |《超凡蜘蛛侠2》|2014|\n| |《毒液：致命守护者》|2018|\n| |《蜘蛛侠：平行宇宙》（动画电影）|2018|\n\n\n### 其他漫威电影\n\n|电影名|上映时间|\n|---|---|\n|《新神奇四侠》|2015|\n|《超能陆战队》（动画电影）|2014|\n|《恶灵骑士2：复仇时刻》|2011|\n|《惩罚者2》|2008|\n|《神奇四侠2：银影侠来袭》|2007|\n|《恶灵骑士》|2007|\n|《神奇四侠》|2005|\n|《类人体》|2005|\n|《艾丽卡》|2005|\n|《惩罚者》|2004|\n|《刀锋战士3》|2004|\n|《夜魔侠》|2003|\n|《浩克》|2003|\n|《刀锋战士2》|2002|\n|《刀锋战士》|1998|\n|《神奇四侠》|1994|\n|《惩罚者》|1989|\n|《霍华德怪鸭》|1986|\n\n## DC\n\n### DCEU（DC扩展宇宙）\n\n|电影名|上映时间|\n|---|---|\n|《超人：钢铁之躯》|2013|\n|《DC电影出品：正义联盟黎明》|2016|\n|《蝙蝠侠大战超人：正义黎明》|2016|\n|《自杀小队》|2016|\n|《神奇女侠》|2017|\n|《正义联盟》|2017|\n|《海王》|2018|\n|《雷霆沙赞》|2019|\n\n### 其他DC电影\n\n- 太过久远的电影就不罗列了\n\n|电影名|上映时间|\n|---|---|\n|《猫女》|2004|\n|《康斯坦丁》|2005|\n|《V字仇杀队》|2005|\n|《蝙蝠侠：侠影之谜》|2005|\n|《超人归来》|2006|\n|《黑暗骑士》|2008|\n|《守望者》|2009|\n|《失败者》|2010|\n|《西部英雄约拿·哈克斯》|2010|\n|《绿灯侠》|2011|\n|《黑暗骑士崛起》|2012|\n|《乐高蝙蝠侠大电影》|2017|\n|《小丑》|2019|\n\n## 壁纸\n\n{% gallery %}\n![](https://unpkg.com/justlovesmile-img/444211.jpg)\n![](https://unpkg.com/justlovesmile-img/344e370b0a0d5fb463724cc556458d22.jpg)\n![](https://unpkg.com/justlovesmile-img/4c1svpbxcfh.jpg)\n![](https://unpkg.com/justlovesmile-img/4fcd5y13bws.jpg)\n![](https://unpkg.com/justlovesmile-img/bi3wrjelcd4.jpg)\n![](https://unpkg.com/justlovesmile-img/db2984b3a973e7e8cdc6834de4f69704.jpg)\n![](https://unpkg.com/justlovesmile-img/e7530dec43be8a8c7718752306bbbb54.jpg)\n![](https://unpkg.com/justlovesmile-img/ijelpz2bnxp.jpg)\n![](https://unpkg.com/justlovesmile-img/op3pktbhatl.jpg)\n![](https://unpkg.com/justlovesmile-img/qhoo4nupjp5.jpg)\n![](https://unpkg.com/justlovesmile-img/zfx1it4hq3i.jpg)\n![](https://unpkg.com/justlovesmile-img/zjykzjztrjg.jpg)\n{% endgallery %}","tags":["电影"],"categories":["生活琐事"]},{"title":"必看 | Hexo博客搭建超级指南","slug":"博客相关-Hexo博客搭建超级指南","url":"/posts/c8972b63.html","content":"\n\n# 1. 引言\n\n不知不觉，我的博客已经在风雨飘摇中运行超过一年时间了，回想这一年的博客维护以及魔改经历，我觉得有必要详细记录一下博客搭建的过程，以防我不小心搞崩了博客...\n\n![](https://unpkg.com/justlovesmile-img/20200715162057.png)\n\n# 2. 环境部署工作\n\n## 2.1 安装Node.js\n\n1.进入官网选择对应的系统下载：\n官网：[https://nodejs.org/en/download/](https://nodejs.org/en/download/)\n![](https://unpkg.com/justlovesmile-img/20200715163331.png)\n2.安装\n选好路径，完成安装\n3.检查\n打开`cmd`或者`powershell`,输入:\n\n```\nnode -v\nnpm -v\n```\n\n显示版本号，即安装无误\n\n>npm为Node.js的包管理工具\n\n## 2.2 安装Git\n\n1.进入官网下载\n官网：[https://git-scm.com/downloads](https://git-scm.com/downloads)\n2.安装\n选好路径，完成安装\n3.检查\n打开git bash，输入：\n\n```\ngit --version\n```\n\n![](https://unpkg.com/justlovesmile-img/20200715170132.png)\n\n## 2.3 注册Github账号\n\n1.Github官网[https://github.com](https://github.com),注册账号\n2.新建项目\n\n![](https://unpkg.com/justlovesmile-img/20200715171105.png)\n\n项目名字为`你的昵称.github.io`，例如：\n\n```\n//我的昵称是Justlovesmile\n所以我的项目名称为Justlovesmile.github.io\n```\n\n![](https://unpkg.com/justlovesmile-img/20200715170812.png)\n\n3.代码库设置\n\n创建好之后，保存`<>code`内的SSH，即：\n\n```\ngit@github.com:XXXXXXXXX/XXXXXXXXX.github.io.git\n```\n\n点击右侧的`Settings`\n\n![](https://unpkg.com/justlovesmile-img/20200715171759.png)\n\n向下找到`Gihub pages`,点击`Launch automatic page generator`，`Github`将会自动替你创建出一个`pages`的页面。 如果配置没有问题，大约几分钟之后，`yourname.github.io`这个网址就可以正常访问了\n\n5.推荐开启强制使用https\n\n## 2.4 安装Hexo\n\n1.在合适的位置，如`E:/hexo`，安装`hexo-cli`,输入：\n\n```\ncd /e/hexo/\nnpm install hexo-cli -g\n```\n\n![](https://unpkg.com/justlovesmile-img/20200715172419.png)\n\n再安装`hexo`\n\n```\nnpm install hexo --save\n```\n\n安装完成后，检查\n\n```\nhexo -v\n```\n\n![](https://unpkg.com/justlovesmile-img/20200715172614.png)\n\n2.初始化一个文件夹： \n\n```\ncd /e/hexo/\nhexo init\nnpm install\n```\n\n3.生成Hexo页面：\n\n```\nhexo g\n```\n\n4.启动服务：\n\n```\nhexo s\n```\n\n默认是`localhost:4000`，打开浏览器输入即可\n\n## 2.5 推送到Github\n\n1.配置个人信息\n\n```\ngit config --global user.name \"XXXX\"\ngit config --global user.email \"XXXXXXXXX@XXX.com\"\n```\n\n2.生成密钥\n\n```\nssh-keygen -t rsa -C \"XXXXXXXXX@XXX.com\"\n```\n\n3.查看`id_rsa.pub`文件，并整个复制\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n4.然后再在`Github`中添加`ssh key`\n\n![](https://unpkg.com/justlovesmile-img/20200715173551.png)\n\n5.修改hexo根目录下的文件`_config.yml`中的deploy，添加之前保存的ssh：\n\n```\ndeploy:\n  type: git\n  repository: \n\tgithub: git@github.com:Justlovesmile/Justlovesmile.github.io.git\n  branch: master\n```\n\n6.上传到github：\n\n```\nhexo d -g\n```\n\n如果没有hexo-deployer-git，安装\n\n```\nnpm install hexo-deployer-git --save\n```\n\n7.查看blog,`https://username.github.io`\n\n# 3. Hexo基础\n\n## 3.1 写博客\n\n1.新建文章\n\n```\nhexo new post '我的第一篇文章'\n```\n\n2.hexo自动生成一个md文件，修改md内容\n头部如：\n\n```\n---\ntitle: postName #文章页面上的显示名称\ndate: 2020-03-10 12:30:16 #文章生成时间，一般不改，当然也可以任意修改\ncategories: 默认分类 #分类\ntags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意冒号:后面有个空格\ndescription: 摘要\n---\n```\n\n3.在头部下面即可写文章内容\n\n>markdown，支持html和其自带的语法。Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n## 3.2 新建页面\n\n```\nhexo new page \"music\"\n```\n\n会在source文件夹中生成music文件夹，其内的index.md为页面内容\n\n## 3.3 常用基本命令\n\n```\nhexo new \"文章\"\nhexo new post \"文章\"\nhexo new page \"页面\"\n\nhexo clean #清除缓存，每次重新部署时最好执行\nhexo g #生成静态页面\nhexo s #本地端口，默认4000运行\nhexo s -p 5000 # 端口5000\nhexo d #部署\nhexo deploy #部署\n```\n\n```\n#为了方便，每次准备推送时,可以👇\nhexo cl && hexo g && hexo d\n```\n\n# 4. Hexo进阶\n\n## 4.1 推荐编辑器\n\n方便后续魔改内容\n\n1. VSCode [https://code.visualstudio.com/](https://code.visualstudio.com/)\n2. Sublime Text [http://www.sublimetext.com/](http://www.sublimetext.com/)\n\n## 4.2 更换主题\n\n1.因为自带的主题并不好看，所以可以更换主题，常见主题的很多，例如butterfly\n\n```\ncd /e/hexo/\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\n```\n\n2.修改hexo根目录下的`_config.yml`中的\t`theme: landscape`改成`theme： butterfly` ,(注意冒号：后面有一个空格)\n\n## 4.3 注册Coding账号\n\n1.由于国内访问github的速度较慢，因此可以通过双部署同时部署到Coding[https://coding.net/](https://coding.net/)，同样注册账号，新建项目，项目名随意\n![](https://unpkg.com/justlovesmile-img/20200715175443.png)\n2.创建好后，同样记住`SSH`\n3.修改hexo根目录下的文件`_config.yml`中的deploy，添加之前保存的ssh：\n例如我的：\n\n```\ndeploy:\n  type: git\n  repository: \n    github: git@github.com:Justlovesmile/Justlovesmile.github.io.git\n    coding: git@e.coding.net:justlovesmile/justlovesmile.top.git\n  branch: master\n```\n4.在Coding中保存你的密钥，方法同Github\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n5.下次`hexo d -g`部署后,开启`静态网站`，然后可以通过其提供的`//xxxxxxx.coding-pages.com`访问。（第一次记得点，`立即部署`）\n\n![](https://unpkg.com/justlovesmile-img/20200715180119.png)\n\n6.推荐开启强制使用https\n\n## 4.4 注册Gitee账号\n\n1.除了Coding外，网内访问速度较快的还有码云[https://gitee.com/](https://gitee.com/)，同样注册账号，新建项目`yourname`\n2.创建好后，同样记住`SSH`\n3.修改hexo根目录下的文件`_config.yml`中的deploy，添加之前保存的ssh：\n例如我的：\n\n```\ndeploy:\n  type: git\n  repository: \n    gitee: git@gitee.com:justlovesmile/justlovesmile.git\n    coding: git@e.coding.net:justlovesmile/justlovesmile.top.git\n    github: git@github.com:Justlovesmile/Justlovesmile.github.io.git\n  branch: master\n```\n\n4.在Gitee中保存你的密钥，方法同Github\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n5.开启GiteePages服务，Gitee只能免费使用gitee.io域名,其他的域名要收费，并且免费版每次部署后，需要手动点击更新来更新网站内容\n![](https://unpkg.com/justlovesmile-img/20200715181243.png)\n5.推荐开启强制使用https\n\n## 4.5 绑定域名\n\n1.在阿里云[https://wanwang.aliyun.com/](https://wanwang.aliyun.com/)购买自己喜欢的域名\n\n2.在阿里云控制台找到`云解析DNS`\n\n![](https://unpkg.com/justlovesmile-img/20200715185711.png)\n\n找到自己购买的域名,点击`解析设置`\n\n添加记录\n\n![](https://unpkg.com/justlovesmile-img/20200715185838.png)\n\n3.如果多部署了，可以设置多条\n\n![](https://unpkg.com/justlovesmile-img/20200715190408.png)\n\n一条给github.io，一条给coding-pages.com等等\n\n4.再返回到对应的部署页面，修改解析域名\n- Github的在仓库的`Settings--Github_Pages--Custon_domain`\n- Coding的`静态网站-设置-自定义域名`\n\n\n## 4.6 安装插件\n\n1.安装hexo插件\n\n```\nnpm install hexo-generator-sitemap --save\nnpm install hexo-generator-baidu-sitemap --save\nnpm install hexo-generator-feed --save\n```\n\n2.在hexo根目录下的文件`_config.yml`中添加\n\n```\nPlugins: # 在该区域添加两个插件名称\n  - hexo-generator-sitemap\n  - hexo-generator-baidu-sitemap\n  - hexo-generator-feed\n# 自动生成sitemap\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n3.更多插件见[Hexo插件推荐](/posts/86111745.html)\n\n## 4.7 添加robots.txt\n\n1.在hexo根目录下的source文件夹中，创建一个名为robots.txt的文件\n2.内容为\n\n```\nUser-agent: * \nAllow: /\nAllow: /categories/\nAllow: /tags/\nAllow: /archives/\n\nDisallow: /js/\nDisallow: /css/\nDisallow: /images/\nDisallow: /img/\nDisallow: /lib/\n\nSitemap: https://XXXXXXXXXXX.XXX/sitemap.xml\nSitemap: https://XXXXXXXXXXX.XXX/baidusitemap.xml\n```\n\n## 4.8 创建百度站长账号\n\n1.进入百度站长[https://ziyuan.baidu.com/](https://ziyuan.baidu.com/)，注册账号，登录\n2.点击用户中心-站点管理-添加网站\n\n![](https://unpkg.com/justlovesmile-img/image.png)\n\n3.验证\n（1）若选择文件验证，则下载文件到根目录下的source文件夹中，并在文件内容最上面添加三行\n\n```\n---\nlayout: false\n---\n```\n\n（2）若选择HTML标签验证，需要找到主题下的head文件位置，添加其给的html代码，（一般在`/themes/xxxxxx/layout/**/head.pug(ejs)`内)\n\n（3）若选择CNAME验证，操作和绑定域名操作一样，看其给的说明即可\n\n4.推送你的网址，使之更快收录\n点击左侧`资源提交-普通收录`可以选择三种方式提交网址\n\n## 4.9 创建百度/谷歌统计账号\n\n1.现在绝大部分国内主题集成了百度统计[https://tongji.baidu.com/](https://tongji.baidu.com/)和[谷歌统计](https://search.google.com/)功能，如果没有可以自行在head文件内添加，和上面的html标签验证相似\n\n![](https://unpkg.com/justlovesmile-img/20200715193338.png)\n\n```\n<script>\nvar _hmt = _hmt || [];\n(function() {\n  var hm = document.createElement(\"script\");\n  hm.src = \"https://hm.baidu.com/hm.js?a2ee893562999ebad688b0d82daa100a\";\n  var s = document.getElementsByTagName(\"script\")[0]; \n  s.parentNode.insertBefore(hm, s);\n})();\n</script>\n```\n\n其中问号`?`之后的一串数字为你的统计id\n\n```\nhm.src = \"https://hm.baidu.com/hm.js?a2ee893562999ebad688b0d82daa100a\";\n```\n\n2.谷歌同理，不过需要翻墙才能进去\n\n## 4.10 CDN图床\n\n1.博客中往往会使用到很多图片，如果全部都保存在博客中，那肯定是不行的，推荐使用`Github+Jsdelivr+PicGo`搭建免费图床\n2.在Github中创建一个新仓库`CDN`，名字随意\n3.生成Token\n在右上角个人设置处（不是仓库设置）依次选择`Settings`-`Developer settings`-`Personal access tokens`-`Generate new token`，勾选`repo`，然后点击`Generate token`生成一个`Token`\n\n**注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页**\n\n4.配置PicGo，使用jsDelivr的CDN\n(1)下载`PicGo` [https://github.com/Molunerfinn/picgo/releases](https://github.com/Molunerfinn/picgo/releases)\n(2)设置仓库名\n(3)设置分支名\n(4)设置Token\n(5)指定存储路径\n(6)设定自定义域名\n\n![](https://unpkg.com/justlovesmile-img/20200715200322.png)\n\n```\n#每次上传后,生成图片路径\n自定义域名+/+储存路径+上传的图片名\n```\n\n# 5. 主题配置总结\n\n## 5.1 Ayer主题修改--适用ejs类型的主题\n\n### 5.1.1 随机博客封面\n\n[Hexo博客美化之随机封面](/posts/27301.html)\n\n### 5.1.2 添加二级菜单\n\n[Hexo博客添加二级菜单](/posts/14357.html)\n\n### 5.1.3 添加公告板\n\n[Hexo博客美化之添加公告板](/posts/57206.html)\n\n## 5.2 Butterfly主题--适用pug类型的主题\n\n- 看Butterfly作者的教程[https://butterfly.js.org/](https://butterfly.js.org/)\n- 看小康博客[https://www.antmoe.com/posts/a811d614/index.html](https://www.antmoe.com/posts/a811d614/index.html)\n\n# 6. 主题魔改\n\n## 6.1 页脚养鱼🐟\n\n- 摘取自[木槿：Hexo大结局](https://xiabor.com/714f.html)\n\n1.在`\\themes\\butterfly\\layout\\includes\\footer.pug`最后添加这句话\n```pug\n#jsi-flying-fish-container.container\n\nstyle.\n  @media only screen and (max-width: 767px){\n    #sidebar_search_box input[type=text]{width:calc(100% - 24px)}\n  }\n```\n2.然后添加js文件，如果是butterfly在主题配置的inject处添加即可\n```html\n<script data-pjax src=\"https://cdn.jsdelivr.net/gh/Justlovesmile/CDN@latest/js/fish.js\"></script>\n```\n3.修改样式，butterfly在`themes\\butterfly\\source\\css\\_layout\\footer.styl`，这一部分对应修改\n```\n#footer\n  position: relative\n  background: $light-blue\n  background-attachment: local\n  background-position: bottom\n  background-size: cover\n\n  if hexo-config('footer_bg') != false\n    &:before\n      position: absolute\n      width: 100%\n      height: 100%\n      background-color: alpha($dark-black, .1)\n      content: ''\n\n#footer-wrap\n  position: absolute\n  padding: 1.2rem 1rem 1.4rem\n  color: $light-grey\n  text-align: center\n  left: 0\n  right: 0\n  top:0\n  bottom: 0\n```\n\n## 6.2 valine评论\n\n[博客美化之valine](/posts/27831.html)\n\n## 6.3 博客文章加密\n\n[添加博客加密](/posts/43010.html): `文章添加密码`功能\n\n## 6.4 打字机效果\n\n[花里胡哨的打字机js](/posts/7e7ef81c.html)\n\n[Type.js打字机效果](/posts/24067.html): 添加`打字机效果`\n\n## 6.5 图标，动态图标，网页运行时间，全站黑白，鼠标点击特效，网页动态标题，樱花，音效\n\n[博客中能用到的代码](/posts/56163.html): 关于`font awesome图标`字体库，使用`动态图标`，添加`网页运行时间`，`全站变黑白`，`鼠标点击特效`，`网页标题的动态效果`，`网页樱花特效`，`鼠标触动音乐特效`\n\n## 6.6 旋转小人，每日诗句\n\n[博客中能用到的代码（二）](/posts/15391.html): 添加`旋转小人`和`每日诗句`\n\n## 6.7 展示pdf\n\n[Hexo竟然可以展示PDF](/posts/7376.html)\n\n## 6.8 插件汇总\n\n[Hexo插件总结推荐](/posts/86111745.html)\n\n## 6.9 前端禁止右键，F12，F5\n\n- 在文件中添加以下代码\n\n```html\n<script>\nfunction unmouse(){\t\n\tdocument.oncontextmenu = new Function(\"return false;\");\n\tdocument.onkeydown = document.onkeyup = document.onkeypress = function(event) {\n\t\tvar e = event || window.event || arguments.callee.caller.arguments[0];\n\t\tif (e && (e.keyCode == 123 || (e.keyCode == 116 && e.type!='keypress'))) \n\t\t{\n\t\t\te.returnValue = false;\n\t\t\treturn (false);\n\t\t}\n\t}\n}\nunmouse()\n</script>\n```\n\n## 6.10 星空背景\n\n- [星空和流星特效](/posts/6a260bf6.html)\n![](https://unpkg.com/justlovesmile-img/202108121834269.gif)\n\n## 6.11 动态分类条、标签条\n\n- [动态分类标签条，自动获取全站分类与标签进行展示](/posts/2bfb1caa.html)\n\n## 6.12 提取图片主题色并修改字体颜色\n\n- [如何提取图片主题色并自动选择标题字体颜色](/posts/b16c0eda.html)\n\n# 7. 高级魔改\n\n## 7.1 Github Calendar\n\n![](https://unpkg.com/justlovesmile-img/20210208220529.png)\n\n[Gitcalendar](https://akilar.top/posts/1f9c68c9/)\n[教程：基于Butterfly主题（去jquery）的gitcalendar3.0](https://zfe.space/post/6948.html)\n\n## 7.2 首页磁贴\n\n![](https://unpkg.com/justlovesmile-img/20210208220855.png)\n[Akilar：Categories Magnet](https://akilar.top/posts/a9131002/)\n\n## 7.3 首页置顶轮播图\n\n![](https://unpkg.com/justlovesmile-img/20210208220928.png)\n\n[Akilar：Slider Bar](https://akilar.top/posts/8e1264d1/)\n\n## 7.4 友链朋友圈\n\n![](https://unpkg.com/justlovesmile-img/20220328133508.png)\n\n- [友链朋友圈新版本：Github](https://github.com/Rock-Candy-Tea/hexo-circle-of-friends)\n- [友链朋友圈新版本：文档](https://fcircle-doc.js.cool/#/)\n\n- [小冰大佬版：初代友链朋友圈](https://zfe.space/post/friend-link-circle.html)","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"随笔记录 | Loading竟然这样有趣","slug":"折腾记录-Loading竟然这样有趣","url":"/posts/e24ee5c3.html","content":"\n如今无论是在手机端还是PC端，浏览的页面的内容都会做的十分丰富，于是乎需要加载的东西就会很多。但是用户或许会网速慢或硬件卡，可能会遇到需要加载的情况，而没有耐心的人，就会因为不断的加载而放弃浏览直接关闭。\n\n于是添加一个有趣的Loading的画面，就可以大大地缓解等待过程的无趣感，让用户知道目前的加载状态，以及让用户多多关注在Loading画面的本身上，让他们把等待看成一件美好的事，那么我们来探寻一些有趣的Loading画面吧。\n\n{% gallery %}\n![](https://unpkg.com/justlovesmile-img/ambulanceloading.jpg)\n![](https://unpkg.com/justlovesmile-img/ballloading.gif)\n![](https://unpkg.com/justlovesmile-img/ballloading2.gif)\n![](https://unpkg.com/justlovesmile-img/ballonloading.gif)\n![](https://unpkg.com/justlovesmile-img/bigheadloading.gif)\n![](https://unpkg.com/justlovesmile-img/bikeloading2.gif)\n![](https://unpkg.com/justlovesmile-img/birdloading.gif)\n![](https://unpkg.com/justlovesmile-img/blockloading.gif)\n![](https://unpkg.com/justlovesmile-img/capsuleloading.gif)\n![](https://unpkg.com/justlovesmile-img/carloading.gif)\n![](https://unpkg.com/justlovesmile-img/catloading.gif)\n![](https://unpkg.com/justlovesmile-img/catloading2.gif)\n![](https://unpkg.com/justlovesmile-img/catloading3.gif)\n![](https://unpkg.com/justlovesmile-img/changeloading.gif)\n![](https://unpkg.com/justlovesmile-img/changeloading3.gif)\n![](https://unpkg.com/justlovesmile-img/changeloading3.jpg)\n![](https://unpkg.com/justlovesmile-img/changloading2.gif)\n![](https://unpkg.com/justlovesmile-img/christmasloading.gif)\n![](https://unpkg.com/justlovesmile-img/coffeeloading.gif)\n![](https://unpkg.com/justlovesmile-img/computerloading.gif)\n![](https://unpkg.com/justlovesmile-img/cutecatloading.gif)\n![](https://unpkg.com/justlovesmile-img/dinosaurloading.gif)\n![](https://unpkg.com/justlovesmile-img/earthloading.gif)\n![](https://unpkg.com/justlovesmile-img/fanloading.gif)\n![](https://unpkg.com/justlovesmile-img/fireloading.gif)\n![](https://unpkg.com/justlovesmile-img/fishloading.jpg)\n![](https://unpkg.com/justlovesmile-img/geoloading.gif)\n![](https://unpkg.com/justlovesmile-img/greenoctopusloading.gif)\n![](https://unpkg.com/justlovesmile-img/handloading.gif)\n![](https://unpkg.com/justlovesmile-img/labloading.gif)\n![](https://unpkg.com/justlovesmile-img/leafloading.gif)\n![](https://unpkg.com/justlovesmile-img/lineloading.gif)\n![](https://unpkg.com/justlovesmile-img/lionloading.gif)\n![](https://unpkg.com/justlovesmile-img/liquidloading.gif)\n![](https://unpkg.com/justlovesmile-img/loadingbike.jpg)\n![](https://unpkg.com/justlovesmile-img/magicloading.gif)\n![](https://unpkg.com/justlovesmile-img/manloading.gif)\n![](https://unpkg.com/justlovesmile-img/marvelloading.gif)\n![](https://unpkg.com/justlovesmile-img/milkloading.gif)\n![](https://unpkg.com/justlovesmile-img/mloading.gif)\n![](https://unpkg.com/justlovesmile-img/monkeyloading.gif)\n![](https://unpkg.com/justlovesmile-img/musicloading.gif)\n![](https://unpkg.com/justlovesmile-img/octopusloading.gif)\n![](https://unpkg.com/justlovesmile-img/paperloading.gif)\n![](https://unpkg.com/justlovesmile-img/pencilloading.gif)\n![](https://unpkg.com/justlovesmile-img/phoneloading.gif)\n![](https://unpkg.com/justlovesmile-img/pizzaloading.gif)\n![](https://unpkg.com/justlovesmile-img/planeloading.gif)\n![](https://unpkg.com/justlovesmile-img/planeloading2.gif)\n![](https://unpkg.com/justlovesmile-img/pointloading.gif)\n![](https://unpkg.com/justlovesmile-img/pointsloading.gif)\n![](https://unpkg.com/justlovesmile-img/rocketloading.gif)\n![](https://unpkg.com/justlovesmile-img/sandglassloading.gif)\n![](https://unpkg.com/justlovesmile-img/sandwichloading.gif)\n![](https://unpkg.com/justlovesmile-img/snowloading.gif)\n![](https://unpkg.com/justlovesmile-img/snowmanloading.gif)\n![](https://unpkg.com/justlovesmile-img/suntomoonloading.gif)\n![](https://unpkg.com/justlovesmile-img/tealoading.jpg)\n![](https://unpkg.com/justlovesmile-img/threeballloading.gif)\n![](https://unpkg.com/justlovesmile-img/threeloading.gif)\n![](https://unpkg.com/justlovesmile-img/timg.gif)\n![](https://unpkg.com/justlovesmile-img/trainloading.gif)\n![](https://unpkg.com/justlovesmile-img/triloading.gif)\n![](https://unpkg.com/justlovesmile-img/triloading2.gif)\n![](https://unpkg.com/justlovesmile-img/twoloading.gif)\n![](https://unpkg.com/justlovesmile-img/waterballloading.gif)\n![](https://unpkg.com/justlovesmile-img/waveloading.gif)\n![](https://unpkg.com/justlovesmile-img/waveloading2.gif)\n![](https://unpkg.com/justlovesmile-img/waveloading3.gif)\n![](https://unpkg.com/justlovesmile-img/whaleloading.gif)\n![](https://unpkg.com/justlovesmile-img/yellowloading.gif)\n{% endgallery %}\n\n<div class=\"note info\"><small>※图片搜集自百度图片</small></div>","tags":["前端"],"categories":["折腾记录"]},{"title":"打字机效果 | 又一款花里胡哨的打字机js","slug":"博客相关-花里胡哨的打字机js","url":"/posts/7e7ef81c.html","content":"\n又一款花里胡哨的打字机效果，之前在github上看到过一个不那么花的[打字机](/posts/24067.html)，它的效果大概是下面这样：\n\n![](https://unpkg.com/justlovesmile-img/typejs1.gif)\n\n源码如下：\n\n```html\n<script src=\"https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/typed.js\"></script>\n\n<strong id=\"typedjs1\"></strong>\n\n<script>\nvar typed = new Typed(\"#typedjs1\", {\n  strings: ['醒亦念卿，梦亦念卿','频繁记录，只因生活和你太值得❤'],\n  startDelay: 0,\n  typeSpeed: 200,\n  backSpeed: 100,\n  loop: true,\n  showCursor: true,\n  shuffle: false\n});\n</script>\n```\n\n最近又看到一款五彩斑斓的打字机，效果是👇下面这样的\n\n![](https://unpkg.com/justlovesmile-img/typejs2.gif)\n\n源码是这个样子的👇：\n\n```html\n<p><strong id=\"colortap1\"></strong></p>\n<script>\nvar colortap = function (r) {\n\tfunction t() {return b[Math.floor(Math.random() * b.length)]}  \n\tfunction e() {return String.fromCharCode(94 * Math.random() + 33)}\n\tfunction n(r) {\n\t\tfor(var n=document.createDocumentFragment(),i=0;r>i;i++){\n\t\t\tvar l=document.createElement(\"span\");\n\t\t\tl.textContent=e(),l.style.color=t(),n.appendChild(l)\n\t\t}\n\t\treturn n;\n\t}\n\tfunction i() {\n\t\tvar t = o[c.skillI];\n\t\tc.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), \n\t\tr.textContent = c.text,\n\t\tr.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))),\n\t\tsetTimeout(i, d)\n\t}\n\tvar l = \"\",\n\to = [\"醒亦念卿，梦亦念卿\",\"频繁记录，只因生活和你太值得\",\"孜孜不倦，认真且怂\"].map(function (r) {return r + \"\"}),\n\ta = 2,g = 1,s = 5,d = 75,\n\tb = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"],\n\tc = {text: \"\",prefixP: -s,skillI: 0,skillP: 0,direction: \"forward\",delay: a,step: g};i()\n};\ncolortap(document.getElementById('colortap1'));\n</script>\n```","tags":["前端","JS"],"categories":["博客相关"]},{"title":"Hexo博客 | 插件推荐","slug":"博客相关-Hexo插件推荐","url":"/posts/86111745.html","content":"\n## Hexo插件汇总\n\n|插件|功能|文档链接|\n| --- | --- | --- |\n|hexo-generator-index-pin-top|文章置顶|https://github.com/netcan/hexo-generator-index-pin-top |\n|hexo-wordcount|文章字数统计和阅读时长统计|https://github.com/willin/hexo-wordcount |\n|hexo-abbrlink|生成URL短链接|https://github.com/rozbo/hexo-abbrlink |\n|hexo-lazyload-image|图片懒加载|https://github.com/Troy-Yang/hexo-lazyload-image |\n|hexo-generator-baidu-sitemap|生成baidusitemap.xml|https://github.com/coneycode/hexo-generator-baidu-sitemap |\n|hexo-generator-sitemap|生成sitemap.xml|https://github.com/hexojs/hexo-generator-sitemap |\n|hexo-generator-feed|生成RSS文件|https://github.com/hexojs/hexo-generator-feed |\n|hexo-external-link|外链跳转|https://github.com/hvnobug/hexo-external-link |\n|hexo-autonofollow|自动对外部链接增加nofollow属性|https://github.com/liuzc/hexo-autonofollow |\n|hexo-filter-nofollow|为外链添加`rel=\"noopener external nofollow noreferrer\"`|https://github.com/hexojs/hexo-filter-nofollow |\n|hexo-prism-plugin|代码高亮|https://github.com/ele828/hexo-prism-plugin |\n|hexo-neat|博客压缩|https://github.com/rozbo/hexo-neat |\n|hexo-allminifier|博客压缩|https://developer.aliyun.com/mirror/npm/package/hexo-all-minifier |\n|hexo-tag-aplayer|aplayer音乐播放器|https://github.com/MoePlayer/hexo-tag-aplayer |\n|hexo-tag-dplayer|dplayer视频播放器|https://github.com/MoePlayer/hexo-tag-dplayer |\n|hexo-douban|添加豆瓣读书，电影，游戏页面|https://github.com/mythsman/hexo-douban |\n|hexo-generator-searchdb|本地搜索,生成search.xml|https://github.com/theme-next/hexo-generator-searchdb |\n|hexo-algoliasearch|搜索系统|https://github.com/LouisBarranqueiro/hexo-algoliasearch |\n|hexo-algolia|搜索系统|https://github.com/oncletom/hexo-algolia |\n|hexo-generator-search|本地搜索系统|https://github.com/wzpan/hexo-generator-search |\n|hexo-baidu-url-submit|百度站长主动推送|https://github.com/huiwang/hexo-baidu-url-submit |\n|hexo-offline|开启PWA|https://github.com/JLHwung/hexo-offline |\n|hexo-pwa|开启PWA|https://github.com/lavas-project/hexo-pwa |\n|hexo-helper-live2d|看板娘|https://github.com/EYHN/hexo-helper-live2d |\n|hexo-addlink|文末添加当前文章链接和版权声明|https://github.com/acwong00/hexo-addlink |\n|hexo-blog-encrypt|博客文章加密|https://github.com/MikeCoder/hexo-blog-encrypt |\n|hexo-simple-mindmap|博客添加脑图|https://github.com/HunterXuan/hexo-simple-mindmap |\n|hexo-pdf|博客展示pdf|https://github.com/superalsrk/hexo-pdf |\n|hexo-tag-echarts|博客添加图表|https://github.com/zhoulvjun/hexo-tag-echarts |\n|hexo-steam-games|添加Steam游戏界面|https://github.com/HCLonely/hexo-steam-games |\n|hexo-bilibili-bangumi|添加bilibili番剧页面|https://github.com/HCLonely/hexo-bilibili-bangumi |\n|hexo-generator-random|生成随机文章页面|https://github.com/Drew233/hexo-generator-random |\n|hexo-web-push-notification|web推送插件|https://github.com/glazec/hexo-web-push-notification |","tags":["Hexo","插件"],"categories":["博客相关"]},{"title":"Hexo博客 | Hexo竟然可以展示PDF","slug":"博客相关-Hexo竟然可以展示PDF","url":"/posts/7376.html","content":"\nhexo-pdf插件一键搞定，页面展示PDF\n<!-- more -->\n\n## 安装hexo-pdf\n\n```npm\nnpm install --save hexo-pdf\n```\n\n## 使用\n\n使用本地资源，可以在markdown文件路径下创建一个同名文件夹，其内放pdf文件\n例如：\n![](https://unpkg.com/justlovesmile-img/20200703172935.png)\n![](https://unpkg.com/justlovesmile-img/20200703173018.png)\n\n在需要的文章添加如下语句：\n```html\n{% pdf mydocument.pdf %}\n```\n\n使用外部资源同理，\n\n```npm\n{% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %}\n```\n\n## 效果\n![](https://unpkg.com/justlovesmile-img/20200703173123.png)\n\n\n","tags":["Hexo","插件"],"categories":["博客相关"]},{"title":"Hexo博客 | 如何在博客首页添加公告板模块","slug":"博客相关-Hexo博客美化之添加公告板","url":"/posts/57206.html","content":"\n在我的博客首页添加了`告示板模块`，有两种模式，一种是`自定义语句`，一种是`一言API`\n![](https://unpkg.com/justlovesmile-img/20200630163919.png)\n>**发现写了很多博客美化的文章了,罗列了一下**\n- [Type.js打字机效果](/posts/24067.html): 添加`打字机效果`\n- [博客中能用到的代码](/posts/56163.html): 关于`font awesome图标`字体库，使用`动态图标`，添加`网页运行时间`，`全站变黑白`，`鼠标点击特效`，`网页标题的动态效果`，`网页樱花特效`，`鼠标触动音乐特效`\n- [博客中能用到的代码（二）](/posts/15391.html): 添加`旋转小人`和`每日诗句`\n- [博客美化之Valine](/posts/27831.html): 关于valine添加`一言`，`每日诗句`，`自定义表情`，`自定义背景`\n- [添加二级菜单](/posts/14357.html): 添加`二级菜单`的简单方法\n- [添加博客加密](/posts/43010.html): `文章添加密码`功能\n- [Hexo博客美化之随机封面](/posts/27301.html): `封面图片随机更换`功能\n- [Hexo博客添加公告板](/posts/57206.html)\n- [花里胡哨的打字机效果](/posts/7e7ef81c.html)\n- [Hexo竟然可以展示PDF](/posts/7376.html)\n- [Hexo插件总结推荐](/posts/86111745.html)\n\n\n## 说明\n\n本文是以我现在使用的Ayer主题为例\n\n## 步骤\n\n### 第一步 找到对应的首页文章页的代码文章\n\n例如，ayer主题的位于`hexo\\themes\\ayer\\layout\\_partial\\archive.ejs`\n\n```html\n<section class=\"outer\">\n<!-- 找到这里，添加代码 -->\n  <% if (theme.broadcast.enable && pagination == 2){ %>\n  <%- partial('_partial/broadcast') %>\n  <% } %>\n<!-- 到这里结束 -->\n  <article class=\"articles\">\n    <%\n    var title = '';\n    if (page.category) title = page.category;\n    if (page.tag) title = \"#\" + \"&nbsp\" + page.tag;\n    if (page.archive) {\n      if (page.year) title = page.year + (page.month ? '/' + page.month : '');\n      else title = __('archive_a');\n    }\n    %>\n```\n\n### 第二步 创建`broadcast.ejs`文件\n\n在第一步里，`<%- partial('_partial/broadcast') %>`调用了`_partial`文件夹里面的`broadcast.ejs`文件，因此需要自己创建一个，内容为：\n\n```html\n<% if (theme.broadcast.type===1 && theme.broadcast.text){ %>\n<div class=\"notice\" style=\"margin-top:50px\">\n    <i class=\"fa <%- theme.broadcast.icon -%>\"></i>\n    <div class=\"notice-content\"><%= theme.broadcast.text %></div>\n</div>\n<% } %>\n<% if (theme.broadcast.type===2){ %>\n<div class=\"notice\" style=\"margin-top:50px\">\n    <i class=\"fa <%- theme.broadcast.icon -%>\"></i>\n    <div class=\"notice-content\" id=\"broad\"></div>\n</div>\n<script type=\"text/javascript\">\n   fetch('https://v1.hitokoto.cn')\n    .then(response => response.json())\n    .then(data => {\n      document.getElementById(\"broad\").innerHTML=data.hitokoto;\n    })\n    .catch(console.error)\n</script>\n<% } %>\n<style>\n.notice {\n    padding: 20px;\n    border: 1px dashed #e6e6e6;\n    color: #969696;\n    position: relative;\n    display: inline-block;\n    width: 100%;\n    background: #fbfbfb50;\n    border-radius: 10px;\n}\n.notice i{\n    float: left;\n    color: #999;\n    font-size: 18px;\n    padding-right: 10px;\n    vertical-align: middle;\n    margin-top:3px;\n}\n.notice-content{\n    display: initial;\n    vertical-align: middle;\n}\n</style>\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\">\n```\n\n当然，为了优化，也可以自己把css整合到css文件中，或者把cdn文件放到after-footer里，这里不再详述\n\n### 第三步 打开主题的配置文件\n\n注意是主题的配置文件！打开后添加配置项：\n\n```\n# 告示板模块\nbroadcast:\n  enable: true   #true开启，false关闭\n  icon: fa-bookmark  #fontawesome图标库，格式如示例\n  type: 2 #1：自定义输入，2：一言api\n  text: justlovesmile.top持续更新中...  #type为1时有效\n```\n\n### 第四步 效果\n\n![](https://unpkg.com/justlovesmile-img/20200630163919.png)","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"Hexo博客 | 采用随机图片作为博客封面背景，真香！","slug":"博客相关-Hexo博客美化之随机封面","url":"/posts/27301.html","content":"\n最近美化了一下我的博客[首页](/)，每次打开会随机选择一张图片作为封面\n![](https://unpkg.com/justlovesmile-img/display.gif)\n\n**发现写了很多博客美化的文章了,罗列了一下**\n- [Type.js打字机效果](/posts/24067.html): 添加`打字机效果`\n- [博客中能用到的代码](/posts/56163.html): 关于`font awesome图标`字体库，使用`动态图标`，添加`网页运行时间`，`全站变黑白`，`鼠标点击特效`，`网页标题的动态效果`，`网页樱花特效`，`鼠标触动音乐特效`\n- [博客中能用到的代码（二）](/posts/15391.html): 添加`旋转小人`和`每日诗句`\n- [博客美化之Valine](/posts/27831.html): 关于valine添加`一言`，`每日诗句`，`自定义表情`，`自定义背景`\n- [添加二级菜单](/posts/14357.html): 添加`二级菜单`的简单方法\n- [添加博客加密](/posts/43010.html): `文章添加密码`功能\n- [Hexo博客美化之随机封面](/posts/27301.html): `封面图片随机更换`功能\n- [Hexo博客添加公告板](/posts/57206.html)\n- [花里胡哨的打字机效果](/posts/7e7ef81c.html)\n- [Hexo竟然可以展示PDF](/posts/7376.html)\n- [Hexo插件总结推荐](/posts/86111745.html)\n\n\n## 说明\n\n本文是以我现在使用的Ayer主题为例\n\n## 步骤\n\n### 第一步 找到对应封面的代码位置\n\n例如，ayer主题的位于`hexo\\themes\\ayer\\layout\\_partial\\ayer.ejs`\n\n```html\n<div class=\"cover-frame\">\n\t<!-- 从这里开始，修改代码 -->\n    <div class=\"bg-box\">\n      <img src=\"\" alt=\"\" id=\"cover-pic\" />\n    </div>\n    <script>\n    $(document).ready(function(){\n    \tvar i=Math.floor((Math.random()*<%= theme.cover.num %>));\n    \timgs=[<% for (var i in theme.cover.path){ %> \"<%- url_for(theme.cover.path[i]) -%>\",<% } %>]\n    \tpic=document.getElementById(\"cover-pic\");\n    \tpic.src=imgs[i];\n    })\n    </script>\n    <!-- 到这里结束 -->\n    <div class=\"cover-inner text-center text-white\">\n      <h1 class=\"center-text glitch\" data-text=\"<%= config.title %>\"><a href=\"<%- url_for() %>\"><%= config.title %></a></h1>\n      <div id=\"subtitle-box\">\n        <% if (theme.subtitle.enable) { %>\n        <span id=\"subtitle\"></span>\n        <% }else{ %>\n          <span id=\"subtitle\"><%= theme.subtitle.text %></span>\n        <% } %>\n      </div>\n```\n\n### 第二步，修改配置文件\n\n找到`主题`下的配置文件`_config.yml`，修改cover项，例如我的是\n\n```\n# 封面配置\ncover:\n  enable: true\n  num: 8  #随机封面数量，前num张\n  path: #path可以任意修改\n    img1: https://unpkg.com/justlovesmile-img/cover1.JPG\n    img2: https://unpkg.com/justlovesmile-img/cover2.jpg\n    img3: https://unpkg.com/justlovesmile-img/cover3.jpg\n    img4: https://unpkg.com/justlovesmile-img/cover4.jpg\n    img5: https://unpkg.com/justlovesmile-img/cover5.JPG\n    img6: https://unpkg.com/justlovesmile-img/cover6.JPG\n    img7: https://unpkg.com/justlovesmile-img/cover7.JPG\n    img8: https://unpkg.com/justlovesmile-img/cover8.JPG\n  logo: false #如果不要直接设置成false\n```\n\n### 第三步，自定义\n\n第二步中的num和path均可以任意修改，例如，如果想要减少对应的图片数量为4张：\n\n```\ncover:\n  enable: true\n  num: 4  #随机封面数量，前num张\n  path: #path可以任意修改\n    img1: 换上自己的图片url1\n    img2: 换上自己的图片url2\n    img3: 换上自己的图片url3\n    img4: 换上自己的图片url4\n  logo: false #如果不要直接设置成false\n```\n\n如果你想要自定义其他的，步骤和我这篇文章的一样，只需要找到对应的代码位置，一般在layout和source里面，再修改就行了，注意ejs的用法\n>**下一篇文章想要介绍博客添加告示板😀**\n![](https://unpkg.com/justlovesmile-img/20200629110750.png)","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"Hexo博客 | 如何让你的valine更好看","slug":"博客相关-Hexo博客美化之valine","url":"/posts/27831.html","content":"\n之前写了一个[博客中能用到的代码（二）](/posts/15391.html),这是第三篇\n这篇文章介绍`valine的样式优化`\n\n\n## Valine介绍\n\n[Valine](https://valine.js.org/) 诞生于2017年8月7日，是一款基于[LeanCloud](https://www.leancloud.cn/)的快速、简洁且高效的无后端评论系统。\n理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo、Ghost 等博客程序在使用Valine。\n\n## Valine版本\n\n这篇文章基于 `Valine 1.4.14`介绍\n\n## Valine添加一言\n\n效果如图：\n![](https://unpkg.com/justlovesmile-img/20200628103932.png)\n\n修改方法：\n1. 找到博客对应添加valine的位置，例如Ayer主题的位于`hexo\\themes\\ayer\\layout\\_partial\\post\\valine.ejs`\n2. 在内部添加一段代码：\n\n```html\n<script type=\"text/javascript\">\n   fetch('https://v1.hitokoto.cn')\n    .then(response => response.json())\n    .then(data => {\n      document.getElementById(\"veditor\").setAttribute(\"placeholder\",data.hitokoto+\"__\"+data.from);\n    })\n    .catch(console.error)\n</script>\n```\n\n3. `Api`接口说明：\n（1）`https://v1.hitokoto.cn/` （从7种分类中随机抽取）\n（2）`https://v1.hitokoto.cn/?c=b` （请求获得一个分类是漫画的句子）\n\n|参数|说明|\n|---|---|\n|a|动画|\n|b|漫画|\n|c|游戏|\n|d|文学|\n|e|原创|\n|f|来自网络|\n|g|其他|\n|h|影视|\n|i|诗词|\n|j|网易云|\n|k|哲学|\n|l|抖机灵|\n|其他|作为动画类型处理|\n\n>可选择多个分类，例如： `?c=a&c=c`\n\n（3）`https://v1.hitokoto.cn/?c=f&encode=text` （请求获得一个来自网络的句子，并以纯文本格式输出）\n\n4. 返回的格式说明\n\n|返回参数名称\t|描述|\n|---|---|\n|id|一言标识|\n|hitokoto|一言正文。编码方式 unicode。使用 utf-8。|\n|type|类型|\n|from|一言的出处|\n|from_who|一言的作者|\n|creator|添加者|\n|creator_uid|添加者用户标识|\n|reviewer|审核员标识|\n|uuid|一言唯一标识；可以链接到 `https://hitokoto.cn?uuid=[uuid]` 查看这个一言的完整信息|\n|commit_from|提交方式|\n|created_at|添加时间|\n|length|句子长度|\n\n>例如：返回的data,通过data.hitokoto获取句子正文\n\n## valine添加每日诗句\n\n>参考[https://cungudafa.top/post/8202.html](https://cungudafa.top/post/8202.html)\n\n添加方法和效果上面差不多，加进去就行了\n\n```html\n<script src=\"https://sdk.jinrishici.com/v2/browser/jinrishici.js\" charset=\"utf-8\"></script>\n<script type=\"text/javascript\">\n jinrishici.load(function(result) {\n     var jrsc_plac =  result.data.content + \"\\n「\" + result.data.origin.title + \"」\" + result.data.origin.dynasty + \" · \" + result.data.origin.author;\n     document.getElementById(\"veditor\").setAttribute(\"placeholder\",jrsc_plac);\n })\n</script>\n```\n\n## valine自定义表情\n\n1. 首先，你需要很多表情包\n可以在GitHub上fork一些表情包仓库，然后使用Jsdelivr CDN调用\n例如：我Fork的[https://github.com/blogimg/emotion](https://github.com/blogimg/emotion)\n\n2. 在Valine配置里面,添加emojiCDN和emojiMaps参数\n\n```javascript\nnew Valine({\n    el:'#vcomment',\n    appId:'<Your_APP_ID>',\n    appKey:'<Your_APP_KEY>',\n\n    // 这里设置CDN, 默认微博表情CDN\n    emojiCDN: 'https://cdn.jsdelivr.net/gh/XXXXXX/emotion/', \n    // 表情title和图片映射\n    emojiMaps: {\n        \"黑人问号\":\"bilibili/tv_黑人问号.png\",\"鼓掌\":\"bilibili/tv_鼓掌.png\"\n        // ... 更多表情\n    } \n})\n```\n\n3. 效果如图：\n![](https://unpkg.com/justlovesmile-img/20200628110303.png)\n\n## valine背景\n\n1. 效果如图\n![](https://unpkg.com/justlovesmile-img/20200628111715.png)\n\n2. 添加方法,一样的添加代码即可\n\n```html\n<style>\n.v[data-class=v] .veditor {\n    background-image: url(https://cdn.jsdelivr.net/gh/xxxxxx/xxxx/xxxx.xxx);\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-position: right;\n}\n</style>\n```","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"大学课程 | 嵌入式智能大棚监测管理系统","slug":"学习笔记-嵌入式智能大棚监测管理系统","url":"/posts/14495.html","content":"\n我又肝完了一门课，**嵌入式课程设计**==>基于Proteus，Arduino，Flask搭建的**智能大棚管理系统**\n![](https://unpkg.com/justlovesmile-img/20200624120328.png)\n\n\n>源程序👇\n[Github🔗](https://github.com/Justlovesmile/Greenhouse-management-system)\n[Gitee🔗](https://gitee.com/justlovesmile/Greenhouse-management-system)\n\n\n# 智能大棚监测管理系统简介\n\n## 1.主要内容\n- 硬件嵌入式系统：采用FreeRTOS实时系统和Arduino UNO平台，以及ATMEGA328P微控制器，进行控制，结合DHT11,BMP180等多种传感器进行数据监测，具有自动控制和监测警报功能，能通过前端切换工作模式\n- 数据库：基于Python的pymsql库使用MYSQL数据库，能自动创建数据库，表以及存储和查找数据。\n- 服务器：基于Python的Flask框架搭建，能控制串口读写\n- 前端：具有登录检测，数据查询，远程控制功能\n\n## 2.采用的工具方法\n- Proteus 8.6\n- Visual Studio Code\n- Arduino\n- Python3.8\n- MySQL 8.0.15\n\n# 我的报告(爆肝)\n\n<div style=\"text-align: center;\"><h1>智能大棚设计与实现</h1></div>\n\n**摘要：**随着社会的不断发展，传统的农业生产活动方式，诸如农民亲自灌溉，施肥，搭棚保温的方式，这些落后的生产方式已经不能满足现代的经济发展需求，智能化，信息化的农业设计成为了农业发展的趋势。本文设计了一款简单易操作的智能大棚环境监测管理系统，能适用于温室大棚的数据监控和远程硬件操作功能，该系统基于嵌入式系统设计方法，使用了RTOS和Arduino UNO微处理器作为系统的主控芯片，使用了DHT11温湿度传感器，LDR光敏电阻，BMP180气压传感器作为外界环境监测模块，使用了COMPIM进行串口通信，结合Flask服务器框架和MySQL数据库，搭建了Web端和数据库，并优化了前端界面。实现了传感器对环境数据和设备数据进行收集分析处理后，通过串口存储于数据库中，用户通过前端网页实时监测环境数据，并可以控制硬件的状态。该智能大棚监测管理系统，简单易操作，智能化程度高，功能完备，十分适用于农业大棚的监测与管理。\n\n**关键词：**嵌入式；智能大棚；传感器；服务器；Arduino\n\n## **一，系统简介**\n\n  为了实现农业温室大棚的自动化，智能化管理，设计了智能大棚监测管理系统，该系统是基于嵌入式设计技术，利用了Arduino Uno平台，虚拟仿真实验环境Proteus软件，实时操作系统FreeRTOS，实现硬件及Arduino虚拟开发和仿真，根据传感器的检测值，进行判断处理，具有自动控制硬件调节功能和警报功能，再结合Python的Flask库搭建服务器端，serial库进行硬件和服务器端信息传输，以及MySQL进行数据存储，实现了对大棚内温度，湿度，光照，气压的监测和记录，以及对硬件设备，如风机，除湿器，照明，气泵的运行状态的监测和管理，能在Web端实时显示环境和设备运行数据和选择自动以及手动控制硬件的模式，能在前端控制硬件运行，能从数据库选择获取不同时间段的数据并以图表形式展示，并且具有登录登出功能。该系统操作简单，不需耗费大量人力物力学习掌握，能满足正常的数据监控和远程管理以及自动管理需要。\n\n## **二，需求分析和概要设计**\n\n### 1.需求分析\n  在当今智能化的背景下，传统的管理方式已经无法满足对温室大棚的实时监测和控制，尤其是因为当今的温室大棚种植面积普遍较大的，因此，从用户的角度出发，对于大棚的管理，最重要的就是实时监测处理大棚内的温度，湿度，光照和棚内气压等数据，这就需要智能大棚管理系统具有对环境的敏感性和监测的实时性，对于用户而言，他可能还需要了解最近一段时间棚内环境的变换以对未来可能发生的情况进行提前预测，以及了解设备的运行情况做出相应更换等措施，因此需要保存环境和设备运行状况的历史数据。并且系统还应该具有智能处理的功能，当环境变量发生改变，处于不适宜大棚内作物生长的环境时，系统还应该自动控制设备进行相应操作。除此以外，系统需要具有简单易操作，低成本的特点，这样才能减少人工看护和操作的费用，降低成本。对于远程在外的用户，还可以通过云平台进行实时监测和设备控制，从而实现对大棚的智能化，自动化监测管理。\n\n### 2.概要设计\n  通过上文对需求的分析，可以得出，智能大棚监测管理系统应该具有数据监控模块，数据传输模块，控制模块，警报模块，数据库模块，服务器模块以及前端模块，系统功能结构框图如图2.1所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624114845.png)\n\n图2.1 系统功能结构框图\n\n#### 2.1 数据监控模块\n  数据监控是本系统最为重要的一环，数据的获取主要通过三种器件，包括DHT11温湿度传感器，LDR光敏电阻以及BMP180气压传感器，它们在Proteus软件示意图如图2.2所示。数据监控模块的逻辑控制流程图如图2.3所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624114924.png)\n\n图2.2  DHT11(左上),LDR(左下),BMP180(右上)在Proteus中的示意图\n\n![](https://unpkg.com/justlovesmile-img/20200624114940.png)\n\n图2.3 数据监控控制流程图\n\n  由流程图可以看出，数据监控模块主要依靠不断读取三个传感器对温度，湿度，光照，气压的数据信息实现。\n\n#### 2.2 数据传输模块\n  数据传输模块包括了，硬件端传输数据到数据库以及服务器端传输数据到硬件两个部分。\n\n##### 2.2.1 硬件到数据库\n  硬件端到数据库之间的数据传输主要是为了进行数据存储，因此需要规定硬件写入到串口的格式，并传到服务器端接受，按照规定的格式解析并存储到数据库，硬件到数据库的数据传输流程图如图2.4所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624115022.png)\n\n图2.4 硬件到数据库的数据传输流程图\n\n##### 2.2.2 服务器到硬件\n  服务器端到硬件的数据传输主要是为了传输前端的控制信息，包括控制选择自动与手动模式，是否开启或关闭相应硬件等控制信息，服务器到硬件的数据传输流程图如图2.5所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624115155.png)\n\n图2.5 服务器到硬件的数据传输流程图\n\n#### 2.3 控制模块\n  控制模块包括了自动控制模块和手动控制模块。\n\n##### 2.3.1 自动控制模块\n  当硬件第一次运行时，默认为自动模式，此时，数据监控时会根据设定的危险范围进行相应的操作，例如当温度超过某个值时，打开风机，否则关闭风机，当湿度超过某个值时，打开除湿器，否则关闭除湿器，自动控制流程图如图2.6所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624115306.png)\n\n图2.6 自动控制流程图\n\n##### 2.3.2 手动控制模块\n  当服务器端传进来的数据为9时，关闭自动模式，此时硬件运行状态通过之后服务器端传来的数据控制，不同的数据对应不同的操作，手动控制流程图如图2.7所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624115328.png)\n\n图2.7 手动控制流程图\n\n#### 2.4 警示灯模块\n  为了更好的提醒用户温室大棚内的环境是否正常，设置了警示灯模块，通过不断获取环境数据并和危险区间的上下界进行比较，执行相应的警示灯亮起或熄灭操作，警示灯流程图如图2.8所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624115347.png)\n\n图2.8 警示灯流程图\n\n#### 2.5 数据库模块\n  数据库模块主要是编写成数据库相关的API，在前端点击，或者自动更新后将会向服务器端请求数据，然后服务器端调用数据库API执行相应的操作，包括：数据库和表的创建，初始用户数据导入，插入数据，按次数搜索最新数据，按时间搜索范围内的数据等等，数据库API结构图如图2.9所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624115503.png)\n\n图2.9 数据库模块API结构图\n\n#### 2.6 服务器模块\n  对于智能大棚管理系统，服务器的作用主要用于响应前端的请求，以及对串口和数据库的连接和处理，当前端发来不同的请求后，服务器进行相应的操作，包括，返回HTML页面，调用数据库API以及对串口的读取和写入，打开和关闭操作，其具体的功能结构图如图2.10所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624115452.png)\n\n图2.10 服务器功能结构图\n\n#### 2.7 前端模块\n  智能大棚系统的前端部分主要功能是展示环境数据和设备数据，通过向服务器端请求不同数据，实现对两种数据的最新一条数据和最近一小时数据，最近三小时数据，最近一天数据，最近两天数据的获取，并用折线图，柱状图和表格的形式展示，并且前端会像服务器请求登录状态，如果没有登陆则会自动跳转到登陆页面，保障了用户的信息安全，登录后用户可以通过前端监测数据，并且选择登出，打开或关闭自动模式，打开或关闭风机等硬件设备的功能，除此之外，前端还能每个一段时间自动更新，具体的功能结构图如图2.11所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624115534.png)\n\n图2.11 前端功能结构图\n\n## **三，系统设计与实现**\n\n### 1.硬件设计与实现\n\n#### 1.1 硬件总体电路原理图\n  硬件电路主要依靠Proteus软件，仿真实现，如图3.1所示。其中包括了DHTT11温湿度传感器用于获取大棚内的温度和湿度；LDR，其阻值随光照强度的增大而减小，将其与一个10K电阻组成分压电路，使得读取模拟IO的电压值可以用于监测大棚内的光照强度；BMP180，是一种高精度的气压传感器，用于监测大棚内气压。D2,D3,D4,D5为警示灯，D6,D7,D8,D9依次模拟风机，除湿器，照明，气泵设备。COMPIM用于串口通信。\n\n![](https://unpkg.com/justlovesmile-img/20200624115623.png)\n\n图3.1 硬件总体设计\n\n#### 1.2 硬件系统设计\n  硬件系统采用免费的实时系统FreeRTOS，其通过创建任务并调度实现系统的主要程序，在智能大棚系统中，硬件系统首先配置一系列IO口，定义了一些全局变量，如传感器的引脚，电压变量，所选择的智能模式，led端口等等，通过start_task()任务创建总任务zong_task()，在总任务内，不断读取串口传来的数据和传感器的数值，并写入串口，传递给服务器。\n\n##### 1.2.1 数据监控与传输\n  在zong_task()中，程序在延迟3秒后依次读取每个传感器的值，并通过串口传递固定格式的数据，最终传递的数据格式，如图3.2所示，依次分别代表温度，湿度，光强，气压，自动模式，风机状态，除湿器状态，照明状态，气泵状态。读取传感器的函数如下所示。\n\n```cpp\ndelay(3000); //每隔3s更新一次数据\nfloat h = dht.readHumidity();   //读取湿度\nfloat t = dht.readTemperature(); //读取温度\nvar = analogRead(LDR_PIN);   //读取光照强度\nSerial.print(bmp.readSealevelPressure());  //读取气压值\nSerial.print(digitalRead(led_pin[4])); //读取并传输硬件（其一）运行状态\n```\n\n![](https://unpkg.com/justlovesmile-img/20200624115737.png)\n\n图3.2 数据传输格式\n\n##### 1.2.2 自动控制和手动控制\n  程序定义了一个bool类型的全局变量MYBOOL，用于表示当前模式是自动还是手动，当模式是自动时，串口读入的数据将不能控制硬件状态改变，只能控制模式的改变，此时，硬件系统将根据传感器的值进行自动打开或关闭硬件设备，而当模式是手动时，则只能通过串口读入的值来控制硬件设备的开启与关闭。定义的读入手动控制操作的伪代码如下：\n\n```\nWhile(Serial.available()){\n    读取data\n    如果为自动模式{\n        当data=9时，关闭自动模式\n}\n如果为手动模式{\n    当data=1时，打开风机\n当data=2时，关闭风机\n当data=3时，打开除湿\n当data=4时，关闭除湿\n当data=5时，打开灯光\n当data=6时，关闭灯光\n当data=7时，打开气泵\n当data=8时，关闭气泵\n当data=0时，切换自动模式\n}\n}\n```\n\n定义的自动控制和警报操作伪代码如下：\n\n```\nIf(自动模式){\n    如果温度异常，警报灯亮，操作风机，否则关闭警报灯和风机\n    如果湿度异常，警报灯亮，操作除湿器，否则关闭警报灯和除湿\n    如果光强异常，警报灯亮，操作照明，否则关闭警报灯和照明\n    如果气压异常，警报灯亮，操作气泵，否则关闭警报灯和气泵\n}\n```\n\n### 2.数据库设计与实现\n  数据库的连接与操作，主要使用了Python的pymysql库，以及MYSQL数据库，主要实现当服务器连接时，自动查找大棚数据库，如果不存在则自动创建数据库BigPeng和三张数据表users,logs,e_logs,分别记录用户，环境数据，设备数据，并且提供了基于SQL语句的数据插入，数据查询功能，并有良好的异常处理机制。其中环境数据表的创建如下所示：\n\n```python\ncur.execute(\"\"\"\n        create table `logs`(\n            `log_id` int(11) unsigned unique NOT NULL AUTO_INCREMENT,\n            `time` char(20) not null,\n            `temperature` float(2),\n            `humidity` float(2),\n            `light` float(2),\n            `pressure` float(2),\n            PRIMARY KEY(`log_id`),\n            index id(log_id)\n        )DEFAULT CHARSET=utf8mb4 AUTO_INCREMENT=1;\"\"\")\n```\n\n  数据查找主要有两种模式，一种是select_logs(timestamp),其会根据传入的时间戳，查找大于这一个时间的数据，即可以实现查找最近一小时，最近一天等的数据，具体的实现代码如下：\n\n```python\ndef select_logs(timestamp):\n    conn=connect_BigPeng()\n    cur=conn.cursor()\n    sql=f\"select * from logs where time>={timestamp};\"\n    try:\n        ans=cur.fetchmany(cur.execute(sql))\n    except Exception as e:\n        conn.close()\n        print(\"数据查找失败！\")\n        print(e)\n        return False\n    else:\n        conn.close()\n        print(\"数据查找成功\")\n        return ans\n```\n\n  第二种是select_newlogs(index),其会根据传入的数量，按照时间倒序，查找最新的index条数据，具体的代码如下：\n\n```python\ndef select_newlogs(index):\n    conn=connect_BigPeng()\n    cur=conn.cursor()\n    sql=f\"select * from logs order by time desc limit 0,{index};\"\n    try:\n        ans=cur.fetchmany(cur.execute(sql))\n    except Exception as e:\n        conn.close()\n        print(\"数据查找失败！\")\n        print(e)\n        return False\n    else:\n        conn.close()\n        print(\"数据查找成功\")\n        return ans\n```\n\n### 3.服务器设计与实现\n\n#### 3.1 串口连接和数据插入\n  服务器端的串口操作，主要运用了python的serial库和threading库，serial用于串口通信交互。而threading用于使用多线程循环接受串口数据，并存储到数据库中。\n  串口的操作部分，主要功能有，打开串口DopenPort(portx,bps,timeout)，读取数据ReadData(ser)，关闭串口DclosePort(ser)，写入数据DWritePort(ser,text)四个部分。\n  当串口打开后，将会自动执行读取数据操作。具体代码如下：\n\n```python\n# 端口，Windows上的 COM2\n# 波特率，9600\n# 超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）\ndef DOpenPort(portx,bps,timeout):\n    ret=False\n    try:\n        # 打开串口，并得到串口对象\n        ser = serial.Serial(portx, bps, timeout=timeout)\n        #print(ser)\n        #判断是否打开成功\n        if(ser.is_open):\n           ret=True\n           threading.Thread(target=ReadData, args=(ser,)).start()\n           #ReadData(ser)\n    except Exception as e:\n        pass\n        print(\"---异常---：\", e)\n    else:\n        return ser,ret\n```\n\n#### 3.2 服务器框架设计与实现\n  该智能大棚系统的服务器端主要使用Python的Flask服务器框架，能够快速接受前端的响应，支持session保存如登录状态等数据，结合之前编写的数据库API以及串口操作函数，能够实现对前端请求数据的获取和传递。其中获取某一时间段的函数如下所示：\n\n```python\n@app.route('/getjson/',methods=['GET','POST'])\ndef getjson():\n    H=int(request.form.get('Hour'))\n    beforetime=time.strptime((datetime.now()-timedelta(hours=H)).strftime(\"%Y-%m-%d %H:%M:%S\"),\"%Y-%m-%d %H:%M:%S\")\n    timestamp=int(time.mktime(beforetime))\n    try:\n        ans=dealdata(sqlapi.select_logs(timestamp))\n        #数据处理\n    except Exception as e:\n        print(\"Get Json 失败！\")\n        #print(e)\n    else:\n        return json.dumps(ans)\n```\n\n  由于json不支持时间类型的数据解析，因此每次需要服务器端将获取时间并转换为字符串类型的数据进行传递.\n\n### 4.前端设计与实现\n  前端包含四个页面，即登录页，首页，详细数据页，设备数据页。前端需要导入两个js文件，一个是jQuery,一个是echarts.js，后者主要用于数据图表的显示。\n  前端页面具有登录检测功能，如果没有登录，则会自动跳转到登录页面，部分代码如下：\n\n```js\ncheck_session=function(){\n            $.get('/check_session/').done(function(ans){\n                data=$.parseJSON(ans);\n                console.log(data)\n                if(data[\"session\"]==\"false\"){\n                    window.location.replace(\"/login/\");\n                }\n                })\n}\n```\n\n前端具有数据图表以及按钮实时显示功能，每隔一定时间，将会请求服务器再次更新数据，设置定时更新的代码如下：\n\n```js\n        window.onload=function(){\n            check_session()\n            showdata()\n            drawcharts()\n            setInterval(\"showdata()\",5000);\n            setInterval(\"drawcharts()\",5000);\n            setInterval(\"check_session()\",5000);\n        }\n```\n\n## **四，系统测试**\n\n### 1.硬件运行\n  当硬件开启后，默认为自动模式，此时如果检测值超过设定的危险值后，警示灯将会点亮，并且运行响应的硬件设备，温度超过范围后自动控制的硬件运行图，如图4.1所示。一切正常时的运行图，如图4.2所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624120018.png)\n\n图4.1 温度超过范围后自动控制的硬件运行图\n\n![](https://unpkg.com/justlovesmile-img/20200624120203.png)\n\n图4.2 正常运行硬件图\n\n### 2.服务器运行\n  当服务器运行后，将会查找BigPeng数据库是否存在，如果不存在，将会自动创建数据库和表，如果存在，则自动连接数据库，如图4.3所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624120236.png)\n\n图4.3 服务器正常运行示意图\n\n### 3.前端运行\n  当服务器和硬件系统开启后，进入首页将会自动跳转登录页面，如图4.4所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624120259.png)\n\n图4.4 登陆页面\n\n  输入默认的用户名root和密码123456，即可自动跳转首页，首页上半部分如图4.5所示，下部分如图4.6所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624120328.png)\n\n图4.5 首页上部分示意图\n\n![](https://unpkg.com/justlovesmile-img/20200624120459.png)\n\n图4.6 首页下部分示意图\n\n  此时当服务器第一运行时，串口并没有打开，因此需要点击开始监测按钮才能进行数据记录，按下按钮后，可以看到数据表在实时更新，并且按钮状态已改变，这一将存储到服务器端，不会随刷新而改变，如图4.7所示。并且首页还能控制硬件端的模式和硬件设备的开启与停止，如果点击了关闭自动，并打开风机和气泵，等待几秒后将如图4.8所示，对应的硬件状态如图4.9所示\n\n![](https://unpkg.com/justlovesmile-img/20200624120512.png)\n\n图4.7 开启实时监测\n\n![](https://unpkg.com/justlovesmile-img/20200624120524.png)\n\n图4.8 关闭了自动模式打开风机气泵示意图\n\n![](https://unpkg.com/justlovesmile-img/20200624120538.png)\n\n图4.9 对应打开风机和气泵的硬件状态图\n\n  通过点击导航栏，可以跳转到详细数据页面，里面可以显示最近三小时，最近一天和最近两天的数据，如图4.10所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624120700.png)\n\n图4.10 详细数据页面\n\n  再点击导航栏上的设备详情，即可跳转设备数据页面，同样可以查看最近三小时，最近一天和最近两天的数据，如图4.11所示。\n\n![](https://unpkg.com/justlovesmile-img/20200624120715.png)\n\n图4.11 设备数据页\n\n## **五，总结**\n\n  通过对智能大棚监测管理系统的设计，我们团队实现了对系统的全部预期目标，不仅能实时监控环境数据，还能监控硬件运行状态数据，并存储到数据库，并且通过不懈努力，前端页面具有高效的实时性和动态效果，能定时获取数据实时更新数据，前端也会根据数据的不同发生相对应的改变，在实验过程中也遇到了很多问题，但是在查阅了很多文档后，问题都得到了解决，目前需要改进的地方是，硬件端的传感器数量较少，能够实现的功能可以继续增加，其次是前端的数据更新仍需要5到10秒中时间，当点击了打开硬件设备后需要等待较长时间才会更新。这次智能大棚监测管理系统的设计，让我受益匪浅，希望以后的我，能将它继续完善。\n","tags":["Python","大学课程","Arduino","嵌入式"],"categories":["学习笔记"]},{"title":"大学课程 | 计算机图形学，基于MFC和二维变换的画图软件","slug":"学习笔记-基于MFC和二维变换的画图软件","url":"/posts/16593.html","content":"\n我终于肝完了计算机图形学的作业，记录一下我的报告\n\n<img src=\"https://unpkg.com/justlovesmile-img/20200619203709.png\" style=\"max-width:75%;\">\n\n报告里面没有代码，不过上传到github了\n- [Github链接🔗](https://github.com/Justlovesmile/MFC-WORK)\n- [Gitee链接🔗](https://gitee.com/justlovesmile/MFC-WORK)\n\n# 基于MFC和二维变换的画图软件\n\n## 摘  要\n\n本文描述了二维复合变换的基本方法和思想，根据鼠标位置坐标获取起始点pStart和终止点pEnd的坐标，设计实现每个基本图形的画图方法，根据pStart和pEnd即可确定基本图形的控制点，进而绘制对应图形。规范化齐次坐标以后，图形几何变换可以表示为图形控制点点集合的规范化齐次坐标矩阵与二维变换矩阵相乘的形式，分别设置二维变换矩阵的参数信息，设计实现对应的方法，即可实现图形的二维变换功能。\n\n## 设 计\n\n“基于二维复合变换的动画制作软件”的设计中包括以下几个部分：(1) 程序结构设计，(2)鼠标消息映射，(3) 图形绘制实现，(4) 图形变换,（5）动画扩展实现,（6）信息保存,(7)程序交互设计。\n\n### 1 程序总体结构\n\n#### 1.1 总体结构设计\n\n##### 1.1.1 绘图设计\n\n基本图形包括点，直线，曲线，自由画笔，矩形，圆形，椭圆，三角形，左箭头，上箭头，五角星，四角形，五边形共12钟类型，每个基本图形都有自己的编号，用户在选择基本图形后，被选择图形的编号信息保存到dstyle变量中，绘图模块即可根据dstyle中的编号绘制相应的图形。图形大小，位置信息由全局变量pStart和pEnd控制，pStart和pEnd分别为用户在窗口内拖动鼠标时的起点坐标和终点坐标。根据两个坐标确定一个矩形，按照比例，设置相应的控制点，再根据控制点即可绘制相应图形。绘图流程图见图1.1。\n\n##### 1.1.2 变换设计\n\n图形变换包括图形移动，图形旋转，图形放缩。绘图模块绘制图形结束后，会将pStart，pEnd，style等基本信息存入图表中。例如，选择旋转类型后，执行对应函数，将图表中所有图形的位置信息修改，再执行重绘函数，按照点表内容依次重绘变换之后的图形，即可实现图形的旋转变换。变换流程图见图1.2。\n\n![](https://unpkg.com/justlovesmile-img/20200619203701.png)\n\n图1.1 绘图流程图\n\n![](https://unpkg.com/justlovesmile-img/20200619203702.png)\n\n图1.2 变换流程图\n\n### 2 程序实现\n\n#### 2.1 鼠标绘图的消息映射\n\n为了实现基本图形的绘制和组合，需要在项目的视图View类中定义鼠标左键按下OnLButtonDown，鼠标移动OnMouseMove，以及鼠标左键抬起OnLButtonUp的消息映射，以实现拖动鼠标绘图功能。当鼠标左键按下时，设置一个变量为true保存绘图状态并且记录按下时的点，记为pStart，只有当该变量为true时，鼠标移动时才会将绘图，当鼠标左键抬起时，该变量赋值为false,并保存此时的点，记为pEnd。\n其中，在鼠标左键按下并移动时，使用橡皮筋技术，即移动过程中选用画笔颜色取反模式（SetROP2(R2_NOT)），即可消除移动过程中不断绘制的图形，在鼠标左键抬起时，设置画笔为颜色覆盖模式（SETROP2(R2_COPYPEN)），绘制最终的图形，并保存pStart点和pEnd点，以及笔的粗细，形状，颜色等其他信息。\n\n#### 2.2 图形绘制实现\n\n##### 2.2.1 点\n\n由于单个点的像素太小，不利于在图形绘制中使用与观察。这里使用了画一个微型填充圆的方法代替原始像素点。\n\n##### 2.2.2 直线\n\n从直线起的以下图形的绘制均为根据外接矩形绘制内部图形。绘制图形时，当点击鼠标左键时获取矩形起点，按住不放拖动鼠标直至放开左键，放开鼠标左键的位置记录为矩形的终点。直线的绘制则根据矩形起始点使用MoveTo()和LineTo()函数绘制。\n\n##### 2.2.3 等腰和直角三角形\n\n在使用鼠标拉取的矩形中选取点位置并用画线函数连接点实现。三角形包括3个顶点。拉取矩形的起点坐标为(pStart.x,pStart.y),终点坐标为(pEnd.x,pEnd.y)。根据两种三角形在矩形中绘制时的对应比例，等腰三角形3个顶点坐标分别为：\nP1  (pStart.x+pEnd.x)/2,pStart.y);\nP2  (pStart.x,pEnd.y);\nP3  (pEnd.x,pEnd.y);\n直角三角形的三个顶点坐标为：\nP1  (pStart.x,pStart.y);\nP2  (pEnd.x,pEnd.y);\nP3  (pStart.x,pEnd.y);\n\n##### 2.2.4 矩形和填充矩形\n\n在使用鼠标拉取的矩形中获取了起始点和终止点后用矩形函数实现。拉取矩形的起点坐标为(pStart.x,pStart.y),终点坐标为(pEnd.x,pEnd.y)。要绘制矩形由绘制矩形的函数实现pdc->Rectangle(pStart.x , pStart.y , pEnd.x,  pEnd.y)。绘制填充矩形则在绘制前使用画刷以填充内部。\n\n##### 2.2.5 圆形和填充圆\n\n在使用鼠标拉取的矩形中获取了起始点后。将两点间的距离作为要画圆的半径r。使用绘制圆函数进行绘制pdc->Ellipse(pStart.x-r,pStart.y-r , pStart.x+r , pStart.y+r)。绘制填充矩形则在绘制前使用画刷以填充内部。\n\n##### 2.2.6 自由画笔\n\n在鼠标左键按下，并且移动的过程中，通过不断触发OnMouseMove消息映射，在移动中的点的位置和上一个位置间连线，即可实现自由画笔功能。\n\n##### 2.2.7 左箭头\n\n在使用鼠标拉取的矩形中选取点位置并用画线函数连接点实现。左箭头包括7个顶点。拉取矩形的起点坐标为(pStart.x,pStart.y),终点坐标为(pEnd.x,pEnd.y)。根据左箭头在矩形中绘制时的对应比例，7个顶点坐标为：\nP1  (pStart.x, pStart.y-dy/2);\nP2  (pStart.x+dx/2),pStart.y);\nP3  (pStart.x+dx/2), pStart.y-dy/4);\nP4  (pEnd.x, pStart.y-dy/4);\nP5  (pEnd.x, pStart.y-3\\*dy/4);\nP6  (pStart.x+dx/2), pStart.y-3\\*dy/4);\nP7  (pStart.x+dx/2),pEnd.y);\n其中dy=pStart.y-pEnd.y;dx= pEnd.x-pStart.x\n\n##### 2.2.8 上箭头\n\n在使用鼠标拉取的矩形中选取点位置并用画线函数连接点实现。上箭头包括7个顶点。拉取矩形的起点坐标为(pStart.x,pStart.y),终点坐标为(pEnd.x,pEnd.y)。根据上箭头在矩形中绘制时的对应比例，7个顶点坐标为：\nP1  (pStart.x, pStart.y-dy0/2);\nP2  ( (pStart.x+dx0/2,pStart.y);\nP3  (pEnd.x, pStart.y-dy0/2);\nP4  (pStart.x+3\\*dx0/4, pStart.y-dy0/2);\nP5  (pStart.x+3\\*dx0/4,pEnd.y);\nP6  (pStart.x+dx0/4,pEnd.y);\nP7  (pStart.x+dx0/4, pStart.y-dy0/2);\n其中dy0=pStart.y-pEnd.y;dx0=pEnd.x-pStart.x\n\n##### 2.2.9 五角星\n\n在使用鼠标拉取的矩形中选取点位置并用画线函数连接点实现。五角星绘制包括5个顶点。拉取矩形的起点坐标为(pStart.x,pStart.y),终点坐标为(pEnd.x,pEnd.y)。根据五角星在矩形中绘制时的对应比例，5个顶点坐标为：\nP1(pStart.x+pEnd.x)/2),pStart.y);\nP2(pStart.x+RX\\*(sin(72\\*pi/180)cos(54\\*pi/180))/2/sin(72\\*pi/180)),pEnd.y);\nP3(pEnd.x, pStart.y+RY\\*(1-cos(72\\*pi/180))/(1+sin(54\\*pi/180)));\nP4(pStart.x, pStart.y+RY\\*(1-cos(72\\*pi/180))/(1+sin(54\\*pi/180)));\nP5(pStart.x+RX\\*(sin(72\\*pi/180)+cos(54\\*pi/180))/2/sin(72\\*pi/180),pEnd.y);\n其中pi = 3.1415926;RX = -(pStart.x-pEnd.x);RY = -(pStart.y-pEnd.y);\n\n##### 2.2.10 五边形\n\n在使用鼠标拉取的矩形中选取点位置并用画线函数连接点实现。五边形包括5个顶点。拉取矩形的起点坐标为(pStart.x,pStart.y),终点坐标为(pEnd.x,pEnd.y)。根据五边形在矩形中绘制时的对应比例，5个顶点坐标为：\nP1  (pStart.x+pEnd.x)/2,pStart.y);\nP2  (pStart.x,(pEnd.y-pStart.y)\\*0.41+pStart.y);\nP3  (pStart.x+(pEnd.x - pStart.x)\\*0.19,pEnd.y);\nP4  (pStart.x+(pEnd.x - pStart.x)\\*0.81,pEnd.y);\nP5  (pEnd.x, (pEnd.y-pStart.y)\\*0.41+pStart.y);\n\n##### 2.2.11 四角星\n\n在使用鼠标拉取的矩形中选取点位置并用画线函数连接点实现。四角星包括8个顶点。拉取矩形的起点坐标为(pStart.x,pStart.y),终点坐标为(pEnd.x,pEnd.y)。根据四角星在矩形中绘制时的对应比例，8个顶点坐标为：\nP1  ((pStart.x+pEnd.x)/2,pStart.y)\nP2  (pStart.x+(pEnd.x-pStart.x)\\*3/8,(pEnd.y-pStart.y)\\* 3/8+pStart.y);\nP3  (pStart.x,(pStart.y+pEnd.y)/2);\nP4  (pStart.x+(pEnd.x-pStart.x)\\* 3/8,(pEnd.y-pStart.y)\\*6/8+pStart.y);\nP5  ((pStart.x + pEnd.x)/2),pEnd.y);\nP6  (pStart.x+(pEnd.x-pStart.x)\\* 6/8,(pEnd.y-pStart.y)\\*6/8+pStart.y);\nP7  (pEnd.x,(pStart.y+pEnd.y)/2);\nP8  (pStart.x+(pEnd.x-pStart.x)\\*6/8,(pEnd.y-pStart.y)\\*3/8+pStart.y);\n\n##### 2.2.12 弧线\n\n在使用鼠标拉取的矩形中获取了起始点后,使用绘制椭圆弧线函数进行绘制pdc->Arc(pStart.x,pStart.y,pEnd.x,pEnd.y,int((pStart.x+pEnd.x)/2),pStart.y,pEnd.x,int((pStart.y+pEnd.y)/2));\n\n#### 2.3 图形变换实现\n\n##### 2.3.1 图形移动\n\n图形移动包括包括左移，右移和上移，下移，点表中存有每个图形的pStart点，pEnd点和其他样式信息，绘图函数可根据这些信息重新绘制对应图形，所以只要调用transform.tranlate()函数将pStart，pEnd的x，y坐标同时增加减少相同数值即可完成图形的上下左右移动。\n\n##### 2.3.2 图形旋转\n\n图形旋转包括顺时针旋转和逆时针旋转。与其他的变换不同的是，旋转需要定义一个旋转中心，默认为坐标系原点。如果没有设置旋转中心，旋转变换可能会导致图形变换到窗口之外，所以设置坐标点(pStart+pEnd)/2为旋转中心，调用Transform.Rotate()函数，即可实现在原位置旋转变换。\n\n##### 2.3.3 图形放缩\n\n图形放大和缩小是由pStart和pEnd坐标的等比变换实现的。每次放大，将pStart和pEnd的x，y坐标放大两倍，每次缩小将pStart和pEnd的x，y坐标设置为原来的1/2。经过多次放缩后，可能导致图形太大或者太小而不能正常显示的问题，所以每次放缩判断pStart和pEnd之间的距离，如果距离大于窗口距离，或距离小于5个像素则终止放缩并给出相应提示。\n##### 2.4 图形变换扩展\n\n##### 2.4.1 动画设计\n\n通过自定义文本对话框类（Cchoosedig），实现通过输入框输入获取复合图形变换运动时间的功能，基于原有的图形变化函数，增加根据输入时间循环移动以及延时（Sleep()）的功能，即实现了自定义动画时间的动画制作。\n\n##### 2.4.2 自定义点表结构\n\n由于动画制作需要修改组合复杂图形的所有点的信息，因此需要遍历点集，再重绘所有图形，因此，自定义了一个结构体，用来存储每一个图形的信息，其中信息包括：起始点，终止点，图形类型，画笔类型，画笔粗细，画笔颜色，结构体如图2.1，然后为这个结构体创建链表，再修改文档类的串行化Serialize函数即可。\n\n![](https://unpkg.com/justlovesmile-img/20200619203703.png)\n\n图2.1 自定义结构体\n\n##### 2.4.3 运动时间设置\n\n为了自定义运动时间，采用了文本对话框，通过输入运动时间，从对话框获取信息，保存到变量，再传递到View类，实现动画制作功能。时间设置效果如图2.2所示。\n\n![](https://unpkg.com/justlovesmile-img/20200619203704.png)\n\n图2.2 运动时间设置\n\n##### 2.4.4 图形重绘\n\n对于图形重绘，先暂存当前所选择的图形类型，画笔，颜色等信息，再获取点表的长度，然后循环遍历点表，取出点表中的数据，赋值给CDC类的指针对象pdc，根据图形类型和其他信息画出所有对应的图形。最后恢复之前暂存的信息，即可实现图形重绘功能，且不影响当前选择的样式。\n\n##### 2.5 程序交互实现\n\n##### 2.5.1 绘图类型选择\n\n通过点击菜单栏的图标按钮，如图2.3所示，可以设置绘制图形的类型。具体实现是，当按钮被点击，调用相应的响应函数设置dstyle，并设置cclick为false即可。\n\n![](https://unpkg.com/justlovesmile-img/20200619203705.png)\n\n图2.3 菜单栏中选择绘图类型的按钮\n\n##### 2.5.2 画笔颜色选择\n\n颜色设置是调用系统自带的颜色对话框（CColorDialog）完成对画笔、画刷颜色的选择，同时选用该对话框能够实现自定义颜色。颜色选择对话框如图2.4所示。\n\n![](https://unpkg.com/justlovesmile-img/20200619203706.png)\n\n图2.4 颜色选择对话框\n\n##### 2.5.3 画笔类型选择\n\n在菜单栏中，有画笔形状和画笔粗细可以选择。其中，画笔形状包含包含直线（PS_SOLID），点线（PS_DOT），虚线（PS_DASH），画笔粗细包括粗线，标准线和细线。根据选择的画笔类型，设置type和thickness的值即可。其中，画笔形状中的虚线和点线只有在画笔粗细为细线的时候才能正常显示，当画笔粗细为标准或者粗线时，画出来的都是实线。\n\n##### 2.5.4 清屏\n\n在清屏时，首先会有弹窗提示是否确定清屏，点击“否”则取消操作，点击“是”则进行清屏。清屏功能的具体操作是先调用RedrawWindow()函数清屏，然后清空点表MyList并设置dstyle和cclick分别为初始值0和false即可。\n\n##### 2.5.5 回退\n\n由于本项目把每个图形外接矩形的一对顶点保存在了点表MyList中的一个自定义的节点结构体中，所以在回退时，我们只需要删除点表中的最后一个节点，然后根据点表重新绘图即可。\n\n### 3 程序运行效果\n\n#### 3.1 基本图形实现\n\n设计实现了包含点，直线段，椭圆弧线，矩形，填充矩形，等腰三角形，直角三角形，椭圆，圆，填充圆，五边形，五角星，四角星，箭头等多种基础图形，并且实现画图以及选择画笔类型功能，初始窗口如图3.1所示，基础图形效果如图3.2所示。\n\n![](https://unpkg.com/justlovesmile-img/20200619203707.png)\n\n图3.1 初始窗口\n\n![](https://unpkg.com/justlovesmile-img/20200619203708.png)\n\n图3.2 基础图形效果\n\n#### 3.2 组合复杂图形以及整体变换\n\n实现了基本图形组合成复杂图形的功能，并且具有回退，清空画布，颜色等功能，具有包含平移，旋转，放大缩小，输入动画时长的功能。组合复杂图形以及变换效果如图3.3所示。\n\n![](https://unpkg.com/justlovesmile-img/20200619203709.png)\n\n图3.3 组合复杂图形及变换\n\n### 4 结论\n\n通过这次的计算机图形学实践，我们熟悉了计算机是如何利用算法来生成，处理和显示图形的，学习了如何通过使用Visual C++ 6.0编程环境的MFC框架进行计算机图形学的编程。在程序编写的过程中，我们掌握了很多MFC库所提供的类及其功能函数的使用方法，也根据项目的需要编写了很多自定义的结构体和功能函数。在实验的过程中，我们逐渐了解了MFC框架中，不同类的功能和定义方法，明白了双缓冲机制的原理，熟悉了基本的消息映射功能和对话框的设计，以及如何在不同类间传递数据的方法。并且，在动画制作的过程中，我们又进一步加强了对于二维变化的理解，知道了图形变化的本质还是数学计算。在老师的帮助和我们小组的努力下，我们的收获是如此巨大，我们相信在今后的学习生活中，图形学的原理知识将会给我们很大的帮助。\n\n\n","tags":["大学课程","图形学","MFC"],"categories":["学习笔记"]},{"title":"Hexo博客 | 给博客导航栏添加二级菜单","slug":"博客相关-Hexo博客添加二级菜单","url":"/posts/14357.html","content":"\nHexo主题导航栏添加二级菜单的简单方法\n\n\n第一步，找到所使用主题的导航栏文件，例如：Ayer主题的位于`hexo\\themes\\ayer\\layout\\_partial\\sidebar.ejs`\n\n第二步，打开文件，找到文件对应生成菜单的位置,一般在`<li></li>`内，在里面添加代码\n\n```html\n  <ul class=\"nav nav-main\">\n    <% for (var i in theme.menu){ %>\n    <li class=\"nav-item\">\n      <!-- 找到这里，添加代码 -->\n      <a class=\"nav-item-link\" href=\"<%- url_for(theme.menu[i].path) %>\"><%= i %></a>\n      \t<% if (theme.menu[i].submenus) { %>\n          <ul class=\"sub-menu\">\n            <% for (var submenu in theme.menu[i].submenus){ %>\n              <li>\n                <small><a class=\"nav-item-link\" href=\"<%- url_for(theme.menu[i].submenus[submenu].path) %>\"><%= submenu %>\n                </a></small>\n              </li>\n            <% } %>\n          </ul>\n        <% } %>\n        <!-- 到这里结束 -->\n    </li>\n    <% } %>\n  </ul>\n```\n第三步，添加css,这是我的样式，当然可以自行修改\n\n```html\n<style>\n.nav-main li ul{\n\tdisplay: none;\n}\n.nav-main li:hover ul{\n\tdisplay:block;\n}\n.sub-menu{\n    position: absolute;\n    background: #fff;\n    padding: 5px;\n    width: 8rem;\n    z-index:1000;\n    text-align: center;\n    border-radius: 5px;\n    box-shadow: 0 1px 40px -8px rgba(0,0,0,.5);\n    -webkit-animation: fadeInUp .3s .1s ease both;\n    list-style:none;\n}\n.nav-main li ul::before {\n    content: \"\";\n    position: absolute;\n    top: -20px;\n    left: 50%;\n    margin-left: -10px;\n    border-width: 10px;\n    border-style: solid;\n    border-color: transparent transparent #fff transparent;\n}\n</style>\n```\n第四步，找到主题下的配置文件，如ayer的位于`hexo\\themes\\ayer\\_config.yml`，在需要的位置添加submenus，修改菜单menu信息，例如我的：\n\n```\n# 侧边栏菜单\nmenu:\n  主页: { path: / }\n  说说: { path: /talks }  \n  友链: { path: /friends }\n  随机: { path: /random.html }\n  留言: { path: /guestbook }\n  归档: { path: /archives ,submenus: {\n    分类: { path: /categories },\n    标签: { path: /tags },\n    相册: { path: /photos }\n        } }\n  关于: { path: /about ,submenus: {\n      统计: { path: /analytics },\n      监控: { path: https://monitor.justlovesmile.top }\n        } }\n```","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"大学课程 | 基于WINDLX的系统结构实验","slug":"学习笔记-基于WINDLX的系统结构实验","url":"/posts/47699.html","content":"基于WindLX的计算机系统结构实验，随机输入n个数，求数i的概率\n\n源码：\n[https://github.com/Justlovesmile/WindLX-Experiment](https://github.com/Justlovesmile/WindLX-Experiment)\n[https://gitee.com/justlovesmile/WindLX-Experiment](https://gitee.com/justlovesmile/WindLX-Experiment)\n\n# 《计算机系统结构》课程实验\n\n### 一、实验名称：\n\n随机输入n个数，求数i的概率\n\n### 二、实验原理：\n\n1. WinDLX平台与流水线\nWinDLX是一个基于Windows的、图形化、交互式的模拟器，能够演示DLX流水线是如何工作的，它采取伪汇编形式编码，模拟流水线的工作方式。流水线的指令执行分为5个阶段：取指、译码、执行、访存、写回。\nWinDLX模拟器还提供了对流水线操作的统计功能，便于对流水线进行性能分析。\n2. 流水线中的相关及解决办法\n（1）结构相关：当某一条机器指令需要访问物理器件时，该器件可能正在被占用，例如连续的两条加法指令都需要用到浮点加法器，就产生结构相关，可以通过增加加法器的方式解决结构相关；\n（2）数据相关：当某一条指令需要访问某个寄存器时，此时这个寄存器正被另一条指令所使用，从而产生数据相关，可以通过重定向技术解决数据相关；\n（3）控制相关：当程序执行到某个循环语句时，顺序执行的下一条语句将被跳继续执行循环体的内容，从而产生控制相关，可以通过循环展开解决控制相关。\n\n### 三、实验目的：\n\n1、加深对流水线理论知识的理解；\n2、掌握对流水线性能分析的方法，了解影响流水线效率的因素；\n3、熟悉在WinDLX体系结构下的汇编代码编写和优化；\n4、了解相关的类型及各类相关的解决办法；\n5、培养运用所学知识解决实际问题的能力。\n\n### 四、实验内容：\n\n1、根据WinDLX模拟器伪汇编指令规则编写：随机输入n个数后，求数i的概率的程序gailv.s以及input.s \n2、分别按照不同顺序将gailv.s和input.s装入主存，分析输入顺序不同对运行结果产生的影响；\n3、观察程序中出现的数据、控制、结构相关，指出程序中出现上述现象的指令组合，并提出解决相关的办法；\n4、分别考察各类解决的相关办法，分析解决相关后性能的变化。\n注意： \n除解决结构相关，其他情况下加、乘、除运算器都只有一个。\n本问题中所有浮点延迟部件设置为：加法：2个延迟周期；乘法：5个延迟周期；除法：19个延迟周期。\n\n### 五、实验器材（设备、元器件）：\n\n设备：笔记本电脑一台\n软件：VMware Workstation\n虚拟机：Windows7 32位操作系统\nWinDLX模拟器\n\n### 六、实验步骤及操作：\n1、初始化WinDLX模拟器\n（1）为WinDLX创建目录，C:\\WinDLX。将WinDLX和gailv.s、gailv2.s、input.s放在这个目录中。\n（2）初始化WinDLX模拟器：点击File 菜单中的 Reset all 菜单项，弹出一个“Reset DLX”对话框，点击窗口中的“确认”按钮即可。如图1所示。\n\n![](https://unpkg.com/justlovesmile-img/20200614105647.png)\n\n图1 初始化模拟器界面\n\n2、将程序装入WinDLX平台\n点击File 菜单中的 Load Code or Data 菜单项，依次双击gailv.s和input.s。点击load，将两个程序装入。如图2所示。\n\n![](https://unpkg.com/justlovesmile-img/20200614110049.png)\n\n图2 程序装入界面\n\n3、运行程序并观察\n\n进行单步调试，在WinDLX模拟器的6个子窗口观察程序的执行情况。观察程序运行的总时钟周期，产生的相关种类以及每种相关的数量。\n\n4、解决数据相关\n\n勾选Enable Forwading，采用重定向技术添加专用数据通路减少数据相关，观察数据相关的数量变化。\n\n5、解决结构相关\n\n将Addition Units的数目由1到2，观察结构相关的数量变化。\n\n6、解决控制相关\n\n将gaillv.s的循环体展开形成新文件gailv2.s，采用循环展开的方法减少控制相关，观察控制相关的数量变化。\n\n### 七、实验数据及结果分析：\n\n1、程序装入顺序对运行结果的影响\n先装入gailv.s再装入input.s时，程序能够正确执行；当先装入input.s再装入gailv.s时，因为input.s的地址高，而程序顺序执行到input.s时无法正确地输出，因此不会出现结果。\n\n2、主要代码及说明\n(1)gailv.s主要代码\n\n```assembly\n.data\nPrompt:         .asciiz     \"input An integer which is array's size value >=0 : \"\nPromptLast:    .asciiz     \"input an integer :\"\nPromptNum:     .asciiz     \"input an integer>=0 which you need:\"\nPrintfFormat:   .asciiz     \"Probability: %g \"\nPromptError:   .asciiz     \"Error!Need int>=0!Input:(Go:1,other to End)\"\n.align   2\nPrintfPar:      .word        PrintfFormat\nPrintf:        .space       8\nPrintfValue:    .space       1024\n.text\n.global main\nmain:\n                ;*** 输入数组大小和相关初始化\n                addi            r1,r0,Prompt     ;将Prompt字符串首地址放入r1寄存器中\n                jal         InputUnsigned    ;跳转子函数，输入数组大小n\n                bnez           r10,Error        ;输入异常处理\n                beqz           r1,InputNum      ;如果r1为0，跳转InputNum\n                add            r2,r0,r1         ;将数组大小n存于r2\n                add            r6,r0,r1         ;将数组大小n存于r6\n                addi           r3,r0,0          ;初始化r3\n                addi           r7,r0,1          ;r7等于1\n                movi2fp        f1,r7            ;f1等于1\n                addf           f2,f2,f0         ;初始化f2,f3,f4\n                addf           f3,f3,f0\n                addf           f4,f4,f0\n                movi2fp        f5,r1            ;将数组大小n存于f5\n\nInputArray:\n                ;*** 输入数组\n                beqz           r2, ProcessPart      ;如果r2等于0则跳转ProcessPart \n                addi           r1,r0,PromptLast     ;输入数字\n                jal            InputUnsigned\n                bnez           r10,Error\n                sw             PrintfValue(r3),r1   ;将r1寄存器中的数放入r3寄存区中所存数地址的存储器中\n                addi           r3,r3,4              ;r3后移\n                subi           r2,r2,1              ;r2减1\n                j              InputArray           ;循环输入\n\nProcessPart:\n                addi           r3,r0,0              ;初始化r3\n\nInputNum:\n                ;*** 输入求概率的数字 \n                addi           r1,r0,PromptNum\n                jal            InputUnsigned\n                 bnez           r10,Error\n                add            r2,r0,r1             ;保存i到r2\n                movi2fp        f2,r2                ;保存i到f2\n\nLoop:\n                ;*** 循环与计数       \n                beqz           r6,Output          ;如果r6等于0则结束Loop跳转Output\n                subi           r6,r6,1            ;r6减1\n                lf             f3,PrintfValue(r3) ;取出r3地址中的数到f3\n                addi           r3,r3,4            ;r3后移\n                movfp2i        r7,f2                \n                movfp2i        r8,f3\n                seq            r12,r7,r8          ;如果r7等于r8,r12为1，否则为0 \n                bnez           r12,Sum            ;r12为不等于0,则跳转到Sum计数，否则继续循环\n                j              Loop               ;循环\n\nSum:\n                addf           f4,f4,f1           ;计数\n                j              Loop\n\nOutput:\n                cvti2d         f0,f4              ;单精度转换为双精度\n                cvti2d         f6,f5\n                movfp2i        r5,f5\n                beqz           r5,OutputInner     ;分母为0\n                divd           f6,f0,f6           ;f6=f0/f6\n\nOutputInner:\n                sd              Printf,f6\n                addi            r14,r0,PrintfPar     \n                trap            5                    ;标准输出\n                trap            0                    ;程序结束\n\nError:\n                addi            r1,r0,PromptError\n                jal             InputUnsigned\n                bnez            r1,main\n                    trap                0\n```\n\n（2）input.s主要代码\n\n```assembly\nLoop:       ;*** reads digits to end of line\n        lbu         r3,0(r2)\n        seqi        r5,r3,10    ;LF -> Exit\n        bnez        r5,Finish\n        slti        r11,r3,58;***判断是否为非法字符\n        beqz        r11,Error\n        slti        r10,r3,48   \n        bnez        r10,Error\n        subi        r3,r3,48    ;转换ASCAII码\n        multu       r1,r1,r4    ;转换十进制\n        add         r1,r1,r3\n        addi        r2,r2,1     ;指针后移\n        j           Loop\n```\n\n3、程序分析及运行结果\n\n（1）根据提示输入一个正整数n代表接下来输入的数的总个数。\n测试用例：n=5。\n\n（2）再根据提示输入n个数字。\n测试用例：1，2，3，3，4\n\n（3）输入想要求概率的数i。\n测试用例：3\n\n![](https://unpkg.com/justlovesmile-img/20200614110236.png)\n\n图3 运行结果截图\n\n由图3可知运行结果为0.4，计算结果正确。\n\n（4）异常处理：输入任何不是自然数的字符，如：负数，小数，以及其他非法字符均会提示错误。异常处理结果如图4所示。\n\n![](https://unpkg.com/justlovesmile-img/20200614110251.png)\n\n图4 异常处理结果截图\n\n（5）点击Statistics窗口，查看程序执行的时钟周期以及数据相关、结构相关、控制相关的发生次数。\n程序执行共用621个时钟周期，数据相关发生172次，结构相关发生2次，控制相关发生42次，如图5所示。\n\n![](https://unpkg.com/justlovesmile-img/20200614110327.png)\n\n图5 时钟周期和相关数据截图\n\n4、数据相关及解决\n\n（1）数据相关产生的原因\n\n```assembly\nmovfp2i              r8,f3\nseq                  r12,r7,r8       ;如果r7等于r8,r12为1，否则为0 \nbnez                 r12,Sum         ;r12为不等于0,则跳转到Sum计数，否则继续循环\n```\n\nseq指令要使用r8寄存器的数据，但是上一条指令movfp2i刚刚执行完数据还没有更新，产生数据相关，并且之后的bnez指令也需要上一条seq指令的中还没更新的寄存器r12，产生数据相关，如图6所示。\n\n![](https://unpkg.com/justlovesmile-img/20200614110345.png) \n\n图6 数据相关截图\n\n（2）数据相关的解决\n\n采用重定向技术，勾选Configuration的Enable Forwading选项。在第一条指令结束后直接将寄存器r8的内容更新，在第二条指令结束后直接将寄存器r12数据更新，以此来消除数据相关，如图7所示。\n\n![](https://unpkg.com/justlovesmile-img/20200614110407.png)\n\n图7 解决数据相关截图\n\n查看运行结果，数据相关数量降低了64，处理后的数据相关个数为108，如图8所示。\n\n![](https://unpkg.com/justlovesmile-img/20200614110622.png)\n\n图8 解决数据相关的数据截图\n\n5、控制相关及解决\n\n（1）控制相关的产生原因\n\n```assembly\nLoop:       ;*** 循环与计数       \n            beqz          r6,Output          ;如果r6等于0则结束Loop跳转Output\n            subi          r6,r6,1            ;r6减1\n            lf            f3,PrintfValue(r3) ;取出r3地址中的数到f3\n            addi          r3,r3,4          ;r3后移\n                movfp2i       r7,f2                \n            movfp2i       r8,f3\n            seq           r12,r7,r8        ;如果r7等于r8,r12为1，否则为0 \n            bnez          r12,Sum   ;r12为不等于0,则跳转到Sum计数，否则继续循环\n            j             Loop      ;循环\n```\n\n在这段程序中，循环体的出现造成了控制相关。\n\n（2）控制相关的解决\n\n采用循环展开的方式将循环体的内容复制一次。可以降低控制相关的个数。如下：\n\n```assembly\nLoop:       ;*** 循环与计数      \n            beqz          r6,Output          ;如果r6等于0则结束Loop跳转Output\n            subi          r6,r6,1            ;r6减1\n            lf            f3,PrintfValue(r3) ;取出r3地址中的数到f3\n            addi          r3,r3,4            ;r3后移\n                movfp2i       r7,f2                \n            movfp2i       r8,f3\n            seq           r12,r7,r8    ;如果r7等于r8,r12为1，否则为0 \n            bnez          r12,Sum      ;r12为不等于0,则跳转到Sum计数，否则继续循环\n            beqz          r6,Output          ;如果r6等于0则结束Loop跳转Output\n            subi          r6,r6,1            ;r6减1\n            lf            f3,PrintfValue(r3) ;取出r3地址中的数到f3\n            addi          r3,r3,4            ;r3后移\n                movfp2i       r7,f2                \n            movfp2i       r8,f3\n            seq           r12,r7,r8    ;如果r7等于r8,r12为1，否则为0 \n            bnez          r12,Sum      ;r12为不等于0,则跳转到Sum计数，否则继续循环\n            j             Loop         ;循环\n```\n\n重新运行后控制相关数量减少为40，如图9所示。\n\n![](https://unpkg.com/justlovesmile-img/20200614120000.png)\n\n图9 解决控制相关的数据截图\n\n6、结构相关及解决\n\n（1）结构相关产生的原因\n\n```assembly\naddf          f2,f2,f0         ;初始化f2,f3,f4\naddf          f3,f3,f0\naddf          f4,f4,f0\n```\n\n在这段语句运行时需要连续进行加操作，由于加法器只有一个，产生结构相关。\n\n（2）结构相关的解决\n\n添加加法器Addition Units的个数，如图10所示。\n\n ![](https://unpkg.com/justlovesmile-img/20200614110830.png)\n\n图10 增加加法器Addition Units界面的截图\n\n再次运行程序可以发现结构相关数量降低，降低到0个，如图11所示。\n\n ![](https://unpkg.com/justlovesmile-img/20200614120002.png)\n\n图11 解决结构相关的数据截图\n\n7、程序流程图\n\n如图12所示。\n\n ![](https://unpkg.com/justlovesmile-img/20200614120003.png)\n\n图12 程序流程图\n\n### 八、实验结论：\n\n1. 通过采用重定向技术减少了数据相关；\n2. 通过循环展开的方式将循环体的内容展开来减少控制相关；\n3. 通过增加硬件的数目来减少结构相关；\n4. 执行程序的顺序会影响程序执行是否正确，必须先执行源程序gailv.s，再执行input.s；修改后的程序必须清空之前所有的操作（reset all）之后再重新运行。","tags":["系统结构","汇编","大学课程"],"categories":["学习笔记"]},{"title":"Python工具 | 用python把excel成绩单拼起来","slug":"代码编程-用python把excel成绩单拼起来","url":"/posts/18326.html","content":"\n接上一篇，昨天除了把pdf转word，还得把几次成绩单拼起来，又去百度了openpyxl的用法，😂\n<!-- more -->\n由于我是一个菜鸟，如果成绩单里有人少了一次成绩，那个人的信息就错位了。\n\n```python\nimport os\nfrom openpyxl import Workbook   #pip install openpyxl\nfrom openpyxl import load_workbook\n\nex={}#字典\n\ndef readexcel(file):\n\twb=load_workbook(file)#读取excel\n\tsheet=wb.get_sheet_by_name(wb.get_sheet_names()[0])#读第一个sheet表单\n\tprint(\"正在打开\"+file+\"的\"+sheet.title)\n\tws=wb.active#激活\n\t#找一找学号在第几列\n\tfor i in range(5):\n\t\tnav=[]\n\t\tfor cell in list(sheet.rows)[i]:\n\t\t\tnav.append(cell.value)\n\t\t\t#print(nav)\n\t\tif \"学号\" in nav:#！！！确保键值存在，且前后没有空格\n\t\t\tbreak\n\ttry:\n\t\tindex=nav.index(\"学号\")\n\texcept:\n\t\tprint(\"Not find key!\")\n\t\treturn;\n\t#读数据\n\tfor row in list(sheet.rows)[i:]:\n\t\trr=[]\n\t\tfor cell in row:\n\t\t\trr.append(cell.value)\n\t\tif rr[index] in ex.keys():\n\t\t\tex[rr[index]].extend(rr)\n\t\telse:\n\t\t\tex[rr[index]]=rr\n\ndef savefile(f):\n\tpath=os.getcwd()+'/'+f\n\tif(os.path.exists(path)):\n\t\tprint(\"Error!File exists.Please delete it!\")\n\t\treturn;\n\twb=Workbook()\n\tws = wb.active  # 默认第一个sheet\n\tfor i in ex:\n\t\tws.append(ex[i])\n\twb.save(f)\n\n\ndef main():\n\tcontents=[]\n\t#文件名，不要路径\n\tfiles=['1.xlsx','2.xlsx','3.xlsx']\n\tfor f in files:\n\t\treadexcel(f)\n\t#print(ex)\n\tendfile=\"总结.xlsx\"\n\tprint(\"正在保存到:\"+os.getcwd()+\"/\"+endfile)\n\tsavefile(endfile)\n\nif __name__ ==\"__main__\":\n\tmain()\n```","tags":["Python","Excel"],"categories":["代码编程"]},{"title":"Python工具 | pdf转excel的python方法","slug":"代码编程-pdf转excel的python方法","url":"/posts/10294.html","content":"\n最近不知道写什么了，正好昨天整理了几学期的年级排名，需要pdf转excel，所以百度学习了一下python的pdfplumber库\n<!-- more -->\n但是pdfplumber只能解析规整的完美的表格，那种乱七八糟的格式的表格，就不太行了，好在成绩单除了标题外，还算规整.\n\n```python\nimport pdfplumber  # pip install pdfplumber\nfrom openpyxl import Workbook #pip install openpyxl\nimport os\nwb = Workbook()  # 创建文件对象\nws = wb.active  # 获取第一个sheet\npath=os.getcwd()+\"/2.pdf\" #当前路径下的pdf文件\npdf = pdfplumber.open(path) #打开pdf文件\nprint('\\n')\nprint('开始读取数据')\nprint('\\n')\n#第一页第一行标题，解析只对规整的表格有用，凸(艹皿艹 )\n#ws.append(pdf.pages[0].extract_tables()[0][0])\nfor page in pdf.pages:\n    # 获取当前页面的全部文本信息，包括表格中的文字\n    #print(page.extract_text())\n    for table in page.extract_tables():\n        # print(table)\n        for row in table:\n            # print(row)\n            #把列表拆了\n            rowlist=str(row).replace(\"[\",\"\",).replace(\"]\",\"\").replace(\"'\",\"\").replace(\"\\\\n\",\"\").split(\",\")\n            #print(rowlist)\n            ws.append(rowlist)\n        print('---------- 分割线 ----------')\npdf.close()\n# 保存Excel表到22.xlsx,直接替换,注意保存\nendfile='22.xlsx'\nwb.save(endfile)\nprint('\\n')\nprint('写入excel成功')\nprint('保存位置：')\nprint(os.getcwd()+\"/\"+endfile)\nprint('\\n')\n```","tags":["Python","PDF","Excel"],"categories":["代码编程"]},{"title":"生活VLOG |  一个人说走就走的旅行","slug":"生活琐事-一个人说走就走的旅行","url":"/posts/5b7875dc.html","content":"\n今天看腾讯视频，翻出来了我2018年十一独自出去玩的vlog🦌\n[https://v.qq.com/txp/iframe/player.html?vid=e0728waf7bs](https://v.qq.com/txp/iframe/player.html?vid=e0728waf7bs)\n\n<ul><li>时间：2018年10月1日</li><li>地点：哈尔滨太阳岛</li><li>vlog-BGM：Nevada </li><li>剪辑：PR</li></ul>\n<div class=\"myvideo\"><iframe frameborder=\"0\" src=\"https://v.qq.com/txp/iframe/player.html?vid=e0728waf7bs\" allowFullScreen=\"true\"></iframe></div>\n<style>\n.myvideo{\n    position: relative;\n    width: 100%;\n    height: 0;\n    padding-bottom: 75%;\n}\n.myvideo iframe {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    left: 0;\n    top: 0;\n}\n</style>","tags":["旅拍","Vlog"],"categories":["生活琐事"]},{"title":"生活中的仪式感 | Happy Birthday","slug":"生活琐事-Happy-Birthday","url":"/posts/59673.html","content":"\n<div id=\"tab_1\">\n    <iframe src=\"/love/qmj/book.html\"\n            height=\"600\"\n            width=\"100%\"\n            frameborder=\"0\"\n            scrolling=\"0\"\n    ></iframe>\n</div>\n<div style=\"text-align:center;\">\n\t\t\t<p>宝贝,生日快乐鸭</p>\n\t\t\t<p>惟愿永远18岁的你,成为自己的骄傲与惊喜</p>\n\t\t\t<p>惟愿你心中有光,眼神清澈明亮</p>\n\t\t\t<p>惟愿你的眼角眉梢都是笑意</p>\n\t\t\t<p>惟愿你从此不必逞强不会伤心</p>\n\t\t\t<p>惟愿你想要的明天都会如约而至</p>\n\t\t\t<p>惟愿我就是那个对的人</p>\n\t\t\t<p>从此幸运，伴你一世温暖长情</p>\n\t\t\t<p>Happy Birthday, 蕉蕉!</p>\n\t\t\t<p>♥爱你的小明</p>\n</div>\n<div>\n<p>这幅画是我画的(๑•̀ㅂ•́)و✧</p>\n<img src=\"https://unpkg.com/justlovesmile-img/happybirthdat.png\"/>\n</div>","tags":["生日"],"categories":["生活琐事"]},{"title":"MySQL | 阿里云轻量应用服务器如何配置mysql","slug":"折腾记录-阿里云轻量应用服务器如何配置mysql","url":"/posts/355a5fb2.html","content":"在购买阿里云轻量应用服务器之后的环境是都帮你搭配好的，但是数据库就需要自己操作配置了，比如说**如何使用阿里云数据管理DMS远程操纵数据库**，其在部署的过程中还是有许多坑\n<!-- more -->\n\n>参考自[阿里云轻量应用服务器 配置mysql详解](https://blog.csdn.net/weixin_40862011/article/details/86260700)\n\n <p><span style=\"font-size:20px;\">在</span>购买了阿里云轻量应用服务器后，我结合自身的能力选择了建站相对简单的wordpress，毕竟对于阿里云学生机而言，每个月9.5元确实很便宜👍，最初的配置很简单，只需要参考阿里提供的步骤就能完成（除了升级php版本的时候踩了不少坑，详见<a href=\"/posts/10224.html\">阿里云轻量应用服务器Wordpress升级php步骤</a>），但是当我在服务器中输入`mysql -uroot -p`时，我发现没有找到命令。</p>\n\n<img src=\"https://unpkg.com/justlovesmile-img/1.png\"/>\n\n后来我才发现，我应该使用`sudo /usr/local/mysql/bin/mysql -uroot -p密码`命令😂,其实购买服务器之后的环境是都帮你搭配好的，但是数据库就需要自己操作配置了，比如说**如何使用阿里云数据管理DMS远程操纵数据库**，其在部署的过程中还是有许多坑。\n\n<img src=\"https://unpkg.com/justlovesmile-img/2.png\"/>\n\n<img src=\"https://unpkg.com/justlovesmile-img/3.png\"/>\n\n1.通过上述步骤，先在应用详情获取Mysql密码，方法即是点击MySQL的远程连接，然后复制命令输入获取密码\n2.点击轻量应用服务器左侧导航找到防火墙，在里面添加MYSQL规则，对应端口3306\n3.在顶部搜索框中搜索`数据管理DMS`\n\n<img src=\"https://unpkg.com/justlovesmile-img/4.png\"/>\n\n4.进入数据管理DMS，查看左侧导航，点击自建库（ESC、公网）,选择新增数据库，开始创建你的数据库\n\n<img src=\"https://unpkg.com/justlovesmile-img/5.png\"/>\n\n5.选择Mysql与公网自建，输入一系列信息，然后会出现一行报错`Host XX.XX.XX.XX is not allowed to connect Mysql server`,记录此时的IP值\n\n<img src=\"https://unpkg.com/justlovesmile-img/6.png\"/>\n<img src=\"https://unpkg.com/justlovesmile-img/7.png\"/>\n\n6.回到阿里云轻量应用服务器控制台，远程连接服务器\n（1）使用命令行方式通过MySQL的账号密码（密码即是之前步骤中获取到的数据库默认的账号和密码）连接到MySQL当中,输入 `sudo /usr/local/mysql/bin/mysql -uroot -p密码`\n (2)再输入`GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '远程连接的新密码' WITH GRANT OPTION;`,上面命令中`%`代表从任何主机都可以连接到mysql服务器的话，如果要指定ip即把%替换`ip地址`即可,例如第5步保存的ip地址\n（3）最后输入`FLUSH PRIVILEGES; `刷新先前的修改\n7.回到自建数据库界面输入公网ip，自己设置的数据库密码就可登录，登录后即可远程访问数据库，也可看到相关数据库的运行实例，也可以进行数据库相应的操作。\n\n<img src=\"https://unpkg.com/justlovesmile-img/8.png\"/>\n","tags":["数据库","服务器"],"categories":["折腾记录"]},{"title":"大学课程 | 计算机系统结构","slug":"学习笔记-计算机系统结构笔记","url":"/posts/50754.html","content":"大三计算机系统结构知识点总结笔记\n<!-- more -->\n\n# 计算机系统结构\n\n## 第一章 计算机系统结构基础及并行性的开发\n\n- 计算机性能的高速增长受益于\n\t- 电路技术的发展\n\t- 体系结构技术的发展\n\t- 其他因素(OS, Compiler 的发展)\n- 80年代后，RISC技术和微处理器技术使得体系结构技术对计算机性能发展的影响越来越大\n\n>CISC(复杂指令集)结构出现得较早。在这种结构中，新功能的增加主要靠增加新的指令，但为了保持向下兼容，就必须保持原有的指令；每条指令都有不同的操作指令码，对应不同的数据类型和位置，这样就造成了系统具有较大的指令系统和复杂的寻址技术，指令格式也很不规范。而RISC(精简指令集)结构则采用定长指令，使用流水线的方式执行指令。这种结构大量利用寄存器间的操作，大大简化了处理器的结构，优化了VLSI器件的使用效率，同时功耗较低。与CISC处理器相比，RISC处理器的突出特点是只用硬件实现最常用的指令，其他指令通过微代码软件来模拟实现，通过简短的定长指令提高并行度。这样虽然硬件设计较简单，但处理器指令的逻辑设计反而复杂了。RISC诞生之时恰逢386处理器取得了巨大的成功。在当时条件下，同样工艺水平的芯片，采用RISC架构的产品，其速度比CISC快3倍左右，这在Intel内部产生了很大的震动。最终诞生的 486处理器是第一个真正引入RISC技术的X86处理器。\n\n### 1.1 计算机系统的层次结构\n\n- 如何从整体上认识计算机系统？\n\t- 一种新的认识方法：从计算机语言的角度，将计算机系统看成按**功能**划分的**多级层次结构**\n\n![GmXU9f.jpg](https://unpkg.com/justlovesmile-img/GmXU9f.jpg)\n\n- M0用硬件实现，M1用微程序（固件）实现，M2到M5大多用软件实现\n- 固件：是一种具有软件功能的硬件\n- 虚拟机：由软件实现的机器。虚拟机的功能不一定全由软件实现，也可以是固件或硬件\n- **选择什么样的软硬件比例**，是系统结构研究的核心内容之一\n- 多层系统结构的意义和作用\n\t- 推动了计算机系统结构的发展\n\t\t- 有利于正确理解软件、硬件和固件在系统结构中的地位和作用\n\t- 发展了多处理机系统、分布处理系统、计算机网络系统等系统结构\n\t\t- 每级有各自的用户、实现方法和指令集，摆脱各级功能在一台机器实现\n\t- 推动自虚拟机、多种操作系统共行等技术\n- 对于使用某一级语言编程的程序员来说，只需要熟悉和遵守该级语言的使用规定。\n- 各机器级的实现采用翻译技术或解释技术，或者两者结合\n- **翻译**： 先用转换程序将高一级机器级上的程序**整个**地变换成低一级机器级上等效的程序，然后再在低一级机器级上实现的技术\n- **解释**： 在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级的机器级语言程序中的每条语句或指令**逐条**解释来实现的技术\n\n![Gn93xx.jpg](https://unpkg.com/justlovesmile-img/Gn93xx.jpg)\n\n### 1.2 计算机系统结构，计算机组成和计算机实现\n\n#### 1.2.1 计算机系统结构的定义和内涵\n\n从计算机系统的层次结构角度来看，系统结构是对计算机系统中各级界面的定义及其上下的功能分配。计算机系统的每一级都有自己的系统结构。\n\n![GKobNV.png](https://unpkg.com/justlovesmile-img/GKobNV.png)\n\n- 从不同级看到的计算机属性是不同的\n- 计算机系统的层次结构具有的特征：**透明性**\n- 透明：客观存在的事物或属性从某个角度**看不到**\n\t- 优点：可以不用管理它，简化设计\n\t- 缺点：看不到而无法加以控制，会带来不利\n\n![GKT6KJ.png](https://unpkg.com/justlovesmile-img/GKT6KJ.png)\n\n计算机系统结构也称为计算机系统的体系结构，它只是系统结构中的一部分，指的是传统机器级的系统结构。\n\n- 结论：计算机系统结构研究的是软，硬件之间的功能分配以及对传统机器级界面的确定\n- 计算机系统结构是程序员所看到的计算机的属性，即概念性结构与功能特性\n\n![GnAISJ.jpg](https://unpkg.com/justlovesmile-img/GnAISJ.jpg)\n\n>堆栈型机器、累加器型机器和通用寄存器型机器各自有什么优缺点\n1.堆栈型机器——CPU 中存储操作数的单元是堆栈的机器。\n2.累加型机器——CPU 中存储操作数的单元是累加器的机器。\n3.通用寄存器型机器——CPU 中存储操作数的单元是通用寄存器的机器。\nCPU状态分为管态和目态，CPU的状态属于程序状态字PSW的一位，管态又称特权状态、系统态或核心态。通常，操作系统在管态下运行，CPU在管态下可以执行指令系统的全集。\n目态又称常态或用户态，机器处于目态时，程序只能执行非特权指令。用户程序只能在目态下运行。\n\n#### 1.2.2 计算机组成和计算机实现的定义及内涵\n\n1.**计算机组成**：是指**计算机系统结构的逻辑实现**，包括机器级内部的数据流和控制流的组成以及逻辑设计等等\n（1）着眼点：机器内部各事件的排序方式与控制机构，各部件的功能及各部件间的联系。\n（2）预解决：在合理或满足要求的性能和价格的条件下，怎么最佳、最合理地把各种设备和部件组织成计算机，以实现所确定的计算机。\n\n- 计算机组成设计要确定的方面包括：\n\t- 数据通路宽度（数据总线上一次并行传送的信息位数）\n\t- 各种操作对功能部件的共享程度\n\t- 专用功能部件的设置\n\t- 功能部件的并行性\n\t- 缓冲和排队技术\n\t- 预测技术\n\t- 可靠性技术\n\t- 控制机构的组成，等等\n\n2.**计算机实现**：是计算机组成的**物理实现**\n（1）着眼点：器件技术（主导作用），微组装技术\n\n- 计算机实现:(是数字电路等课程主要研究的内容)\n\t- 处理器、主存的物理结构\n\t- 器件的集成度和速度\n\t- 信号传输\n\t- 器件、模块、插件、底板的划分与连接\n\t- 涉及的专用器件\n\t- 电源、冷却、微组装技术、整机装配技术，等等\n\n![GQGiSH.jpg](https://unpkg.com/justlovesmile-img/GQGiSH.jpg)\n![GQGwp4.png](https://unpkg.com/justlovesmile-img/GQGwp4.png)\n\n- 系列机：CPU的机器指令和汇编指令系统相同（或绝大部分相同）\n- **狭义的系统结构**是**组成**的抽象\n- **组成**是**实现**的抽象\n- 一种体系结构可以有多种组成，一种组成可以有多种物理实现\n- **计算机系统结构**研究的范畴：机器/汇编指令系统，数据表示，是否采用通道方式输入/输出的确定\n- **计算机组成研究**的范畴：指令采用顺序，重叠，流水还是其他方式解释，数据通路宽度的确定，通道采用结合型还是独立型\n- **广义**的计算机体系结构定义：包括**狭义的系统结构，计算机组成**\n\t- 任务：\n\t\t- 从程序设计者角度：软硬件的功能分配以及确定软硬件界面\n\t\t- 从计算机设计者角度：更合理地实现分配给硬件的功能\n\n#### 1.2.3 计算机系统结构，组成和实现的相互影响\n\n- 计算机系统结构，组成，实现三者互不相同，但又互相影响\n- 不同的系统结构会影响到组成技术\n- 组成技术也会影响系统结构，是一种推动作用\n\t- 专用部件的设置\n- **实现**永远是结构和组成的最坚实基础\n\n### 1.3 计算机系统的软硬件取舍，性能评测及定量设计原理\n\n#### 1.3.1 软，硬件取舍的基本原则\n\n- 计算机系统结构的任务：\n\t- 软、硬功能分配，确定软硬界面\n\n|提高硬件功能比例|提高软件功能比例|\n|---|---|\n|提高解题速度|降低解题速度|\n|减少程序所需存储空间|增加程序所需存储空间|\n|增加硬件成本|减少硬件成本|\n|降低软件费用|增加软件费用|\n|降低硬件利用率|增加系统灵活性|\n|降低系统灵活性||\n\n- 软硬件取舍的**三原则**：\n\t- 在现有的硬件和器件条件下，系统要有**高的性能价格比**；\n\t- 在软硬功能分配时，要考虑到准备采用的组成和实现技术，**使其不过多的限制或不合理限制各种组成、实现技术**；\n\t- 在软硬功能分配时，除了从“硬件”角度考虑，还要从“软”的角度考虑，把为**编译、OS以及高级语言的设计与实现提供更多、更好的硬件支持放在首位**。\n\n- 语义差距的大小实质上取决于软硬件功能的分配\n\n#### 1.3.2 计算机系统的性能评测与定量设计原理\n\n1.计算机系统的性能评测\n\n- 时钟频率：CPU的主频表示在CPU内数字脉冲信号震荡的速度，与CPU实际的运算能力并没有直接关系\n- 计算机系统的性能指标体现于**时间**和**空间**两个方面，在系统上程序实际运行的**时间**应该是衡量机器时间（速度）性能最可靠的标准\n- 机器的性能是通过采用好的硬件，系统结构以及高效的资源管理等技术来提高的\n- 计算机性能指：数据处理（数据运算（速度），数据传输（速度）），数据容量，数据质量的综合性能\n- 系统性能的测量依赖于人（计算机用户/系统管理者）的观点\n- 计算机的性能以及对系统评价的目标都指**系统速度的性能**，通常是用**响应时间**来衡量\n\n![GQT9Nq.png](https://unpkg.com/justlovesmile-img/GQT9Nq.png)\n![GQTuU1.png](https://unpkg.com/justlovesmile-img/GQTuU1.png)\n\n- 减少CPI是RISC思想的精华 \n- 反应程序的运行速度通常引入下面一些指标\n\t- MIPS：计算机单位时间执行的指令条数\n\t\t- 主频越高f，平均每条指令的时钟周期数CPI越少，其MIPS越高，在一定程度反映了机器的性能\n\t\t- MIPS很大程度的依赖指令集，它很难衡量指令系统不同机器之间的性能\n\t\t- 用于比较相同指令系统系统\n\t\t- 即使在同一台机器上，程序负荷不同，CPI也不同，MIPS也就受到影响——浮点运算、定点运算\n\t\t- MIPS还与机器的硬件实现有关\n\t\t\t- 浮点运算在硬件上实现，MIPS低，性能高\n\t\t\t- 浮点运算用软件实现，MIPS高，性能低\n\t- MFLOPS：每秒百万次浮点运算\n\t\t- Tflops:每秒一万亿次浮点运算\n\t\t- 1T=1024G ， 1G=1024M  \n- 计算机的性能通常用**峰值性能**和**持续性能**来评价\n\t- 峰值性能：理想情况下计算机系统可以获得的最高理论性能值\n\t- 持续性能：也称**实际性能**，其表示有**算术性能平均值**，**调和性能平均值**，**几何性能平均值**\n\n- 算术性能平均值\n\t- 设算术性能平均值Am是n道程序运算速度或运算时间的算术平均值\n\t- 以速率评价![GQHup6.png](https://unpkg.com/justlovesmile-img/GQHup6.png)\n\t- Ti是第i个程序的执行时间，Ri是第i个程序的执行速率\n\t- 以执行时间评价![GQHTE9.png](https://unpkg.com/justlovesmile-img/GQHTE9.png)\n- 调和性能平均值\n\t- 调和平均数又称倒数平均数，**给定数据的倒数之算术平均数的倒数**\n\t- **Hm的值与运行全部程序所需的时间成反比---比较准确**\n\t- ![GQbfPI.jpg](https://unpkg.com/justlovesmile-img/GQbfPI.jpg)\n- 几何性能平均值\n\t- 几何平均数是n个变量值连乘积的n次方根\n\t- ![GQqlod.png](https://unpkg.com/justlovesmile-img/GQqlod.png)\n\t- ![G1iX6g.png](https://unpkg.com/justlovesmile-img/G1iX6g.png)\n\t- 几何平均值无法给出系统性能的真实期望.\n\t- 几何平均值常常使用测试机和参考机之间归一化的比值\n\n- **调和平均数、几何平均数和算术平均数三者间，存在如下数量关系：  H≤G≤A**\n\n![GQOgZF.png](https://unpkg.com/justlovesmile-img/GQOgZF.png)\n\n2.计算机系统的定量设计原理\n（1）哈夫曼压缩原理\n\n- 也称关注经常性事件原则\n- 抓主要矛盾\n- 性能——功耗的折中\n\t- 处理器执行两个数的加法运算，溢出不溢出情况\n\t- Pentium M处理器为了降低系统功耗且同时提高计算机性能，在其译码单元引入“micro-op Fusion”概念，把原有的两个micro-op（microinstructions）合成为一个进行操作\n\n（2）Amdahl定律\n\n- 该定律将“关注经常性事件原则”进行了量化\n- 用于确定对系统中**性能瓶颈部件采取措施提高速度后**能得到系统性能改进的程度，即系统加速比Sp\n- **Sp定义为系统改进后的性能与未改进时的性能的比值，或者定义为系统未改进时的程序执行时间Told与改进后程序执行时间Tnew的比值**\n- Sp与两个因素有关，即性能可改进比fnew和部件加速比rnew\n- 性能可改进比fnew是系统性能可改进部件占用的时间与未改进时系统总执行时间的比值\n\t- 0≤fnew≤1\n- 部件加速比rnew是系统性能可改进部分在改进后性能提高的比值\n\t- Rnew>1\n\t- Rnew=TRold/TRnew\n- ![G1kiVA.png](https://unpkg.com/justlovesmile-img/G1kiVA.png)\n- 当fnew为0时，Sp=1；当Rnew趋于无穷大时，Sp=1/(1-fnew);\n- 通过使用某种较快的执行方式所获得的性能提高，受限于该部件占用系统执行时间的百分比,它是一个悲观定律\n- 通用多核系统在扩展到8个核以上时，往往会达到一个性能降低的拐点\n- 应用本身受到串行处理模式和技术的限制。无论拥有多少个核心，它们中的许多都因等待数据进行串行处理而被闲置起来\n- 阿姆达尔定律描述的一个关键事实是它**只适用于计算的一种场合**，即施行并行化后计算中的顺序部分将占据执行时间的主要部分\n- 阿姆达尔定律是在**固定应用规模的前提下**考虑并行性增长的影响。但大多数并行计算则是**固定并行性而扩展应用的规模**\n\n（3）程序访问的局部性规律\n\n- 时间局部性: 一个存储项被访问,可能很快再访问\n- 空间局部性: 存储项被访问,它的邻近项可能很快被访问\n\n![GQX3FJ.png](https://unpkg.com/justlovesmile-img/GQX3FJ.png)\n\n**某一计算机用于商业外贸的事务处理，有大量的字符串操作。由于这种事务处理很普遍，有较大的市场，故而设计人员决定在下一代此类计算机的CPU中加入字符串操作的功能。经测试应用软件调查发现，字符串操作的使用占整个程序运行时间的50%，而增加此功能如用软件（如微程序）实现，则快5倍，增加CPU成本1/5倍；如果用硬件实现，则快100倍，CPU成本增加到5倍。问设计人员提出增加此功能是否恰当？是否用软件还是硬件？（设CPU成本占整机成本的1/3）**\n![GQX0Te.png](https://unpkg.com/justlovesmile-img/GQX0Te.png)\n![GQXclt.png](https://unpkg.com/justlovesmile-img/GQXclt.png)\n\n#### 1.3.3 计算机系统设计的主要任务和方法\n\n1.计算机系统设计的主要任务\n\n- 包括系统结构，计算机组成和计算机实现的设计\n\n2.计算机系统的设计方法\n\n- 由上往下\n\t- 先考虑如何满足用户要求，定好面对使用者的虚拟机的基本功能和环境，如指令系统、语言结构、数据类型等，然后逐级向下设计，每一级都严格考虑优化上一级来实现\n\t- ![GQj7Ue.png](https://unpkg.com/justlovesmile-img/GQj7Ue.png)\n- 由下往上\n\t- 不考虑用户的具体需求，只根据当时拿到的器件，参照或吸收已有各种机器的特点，把微程序机器级和传统机器级分别研制出来，然后再配上适合不同应用环境的各种操作系统和各种编译程序，以满足不同方面的应用要求。\n\t- 优点:\n\t\t- 有利于缩短研制周期\n\t\t- 有利于软硬件人员之间的交流\n\t\t- 软硬分配更加合理\n\t\t- 系统的性能价格比更高\n- 从中间往两头\n\n### 1.4 软件，应用，器件的发展对系统结构的影响\n\n#### 1.4.1 软件的发展对系统结构的影响\n\n- 软件的可移植：软件不用修改或只需经少量加工就能由一台机器投到另一台机器上运行，即同一软件可以应用于不同的环境\n- 软件移植的三种技术\n\t- 统一高级语言：面向题目和算法，和具体结构关系不大\n\t\t- 指一种完全通用的高级语言，为所有程序员所使用，并能在完全不同的机器之间实现程序的软件移植。\n\t- 系列机、兼容机：具有相同结构的各种机器之间\n\t\t- 兼容机：不同厂家生产的具有相同指令集结构的计算机\n\t\t- 系列机：CPU的机器指令和汇编指令系统相同（或绝大部分相同）\n\t\t- 软件兼容：即同一个软件可以不加修改地运行于体系结构相同的各档机器，而且它们\t所获得的结果一样，差别只在于有不同的运行时间。\n\t\t- 向上(下)兼容指的是按某档机器编制的程序，不加修改的就能运行于比它高(低)档的机器。\n\t\t- 向前(后）兼容指的是按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之后(前)投入市场的机器。\n\t\t- 系列机软件兼容性必须保证做到向后兼容，力争向上兼容\n\t- 模拟与仿真：软件在不同体系结构之间的移植\n\t\t- 模拟\n\t\t\t- 用A机的机器语言程序解释B机器语言程序，从而实现软件移植方法 宿主机 A机  虚拟机 B机\n\t\t\t- 为实现模拟编制的各种解释程序\n\t\t- 仿真\n\t\t\t- 用A机的微程序解释B机的机器语言程序，从而实现软件移植方法 宿主机 A机  目标机 B机\n\t\t\t- 为实现仿真编制的各种解释微程序\n\t\t- ![GQzTET.png](https://unpkg.com/justlovesmile-img/GQzTET.png)\n\n![GlSiPe.png](https://unpkg.com/justlovesmile-img/GlSiPe.png)\n\n#### 1.4.2 应用对系统结构的影响\n\n- 应用需求是促使计算机系统结构发展的最根本的动力\n- 不同的应用对计算机系统结构的设计提出了不同的要求\n- 计算机应用可归纳为：数据处理，信息处理，知识处理，智能处理\n\n#### 1.4.3 器件的发展对系统结构的影响\n\n- 芯片制造的发展\n- 器件的发展对系统的影响\n\t- 功能和使用方法—非用户片、现场片及用户片\n\t- 改变了逻辑设计的传统方法—速度、规整\n\t- 推动了系统结构技术的发展\n\t- 体系结构\"下移\"速度加快—并行计算\n\t- 促进了算法、语言和软件的发展\n\n- 软件是促使计算机系统结构发展的最重要的因素\n- 应用需求是促使计算机系统结构发展的最根本的动力\n- 器件是促使计算机系统结构发展最活跃的因素\n\n- 非用户片：也称通用片，其功能是由器件厂家生产时已确定的，器件的用户（即机器设计者）只能使用，不能改变器件内部功能\n- 现场片：是用户根据需要可改变器件内部功能的芯片（FPGA）\n- 用户片：是专门按用户要求生产的高集成度VLSI器件（ASIC）\n\t- 全用户片：是完全按用户要求设计的用户片\n\t- 半用户片：是基本按通用片进行生产，最后按用户要求再制作的用户片，如门阵列、门-触发器阵列等\n\n\n### 1.5 系统结构钟的并发性开发及计算机系统的分类\n\n#### 1.5.1 并行性的概念和开发\n\n1.并行性的含义和级别\n\n- **并行性**：解题中具有可以同时进行运算或操作的特性\n- 并行性包含了同时性和并发性二重含义\n\t- **同时性**（Simultaneity）：两个或多个事件在**同一时刻**发生\n\t- **并发性**（Concurrency）：两个或多个事件在**同一时间间隔内**发生\n- **只要时间上有重叠就存在并行性！**\n\n- 并行性的等级：\n\t- 从计算机系统中执行程序的角度（由低到高）\n\t\t- 指令内部—一条指令内部各个微操作之间的并行\n\t\t- 指令之间—多条指令的并行执行\n\t\t- 任务或进程之间—多个任务或程序段的并行执行\n\t\t- 作业或程序之间—多个作业或多道程序的并行。\n\t- 从处理数据的角度（由低到高）\n\t\t- 位串字串——顺序\n\t\t- 位并字串——同时对一个字的全部位\n\t\t- 位片串字并——同时对许多字的同一位\n\t\t- 全并行——同时对许多字的全部或部分\n\t- 从计算机信息加工的各个步骤和阶段\n\t\t- 存储器操作并行\n\t\t- 处理器操作步骤并行\n\t\t- 处理器操作并行\n\t\t- 指令、任务、作业并行\n\n2.并行性开发的途径\n\n- **时间重叠**\n\t- 是在并行性概念中引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。\n\t\t- 举例：流水线\n\n- **资源重叠**\n\t- 是在并行性概念中引入空间因素，通过重复设置硬件资源来提高可靠性或性能\n\t\t- 例如：双工系统\n- **资源共享**\n\t- 是利用**软件的方法**让多个用户按一定时间顺序轮流地使用同一套资源，以提高其利用率，这样也可以提高整个系统的性能\n\t\t- 例如：网络打印机\n\t\t- 多道程序、分时OS →真正的处理机代替虚拟机→分布处理系统\n\n\n3.计算机系统的并行性发展\n\n- 不同时间阶段，并行性发展的主要表现不同\n\n4.多机系统的耦合度\n\n- 多机系统：包含多处理机系统和多计算机系统\n\t- 多处理机系统\n\t\t- 是由多台处理机组成的单一计算机系统，各处理机都可有自己的控制部件，可带自己的局部存储器，能执行各自的程序\n\t\t- **在逻辑上受统一的操作系统控制**，体系结构可以是共享存储器，也可以是分布式存储器\n\t- 多计算机系统\n\t\t- 是由多台独立的计算机组成的系统，**各计算机分别在逻辑上独立的操作系统控制下运行**，机间可以互不通信，即使通信也只是经通道或通信线路以文件或数据集形式进行，实现多个作业的并行\n\t\t- 一般指分布式存储结构\n\t\t- 集群系统和大规模并行处理机MPP都是多计算机系统\n- **耦合度**：一般用耦合度反映多机系统中各机器之间物理连接的紧密程度和交叉作用能力的强弱\n\t- **最低耦合系统**（Least Coupled System）：各种脱机系统 \n\t- **松散耦和系统**（Loosely Coupled System）：如果多台计算机通过通道或通信线路实现互连，共享某些磁带、磁盘等外围设备，以较低频带在文件或数据集一级相互作用。又称间接耦合系统\n\t- **紧密耦合系统**（Tightly Coupled System）：如果多台机器之间通过总线或高速开关互连，**共享主存**，并有较高的信息传输速度，可以实现数据集一级、任务级、作业级的并行。又称直接耦合系统 \n\n#### 1.5.2 计算机系统的分类\n\n1.弗林分类\n\n- 弗林分类法（Michael J,Flynn分类）：弗林提出按**指令流**和**数据流**的多倍性对计算机系统进行分类\n\t- **指令流**：是指机器执行的**指令序列**\n\t- **数据流**：是指指令流调用的**数据序列**，包括输入数据和中间结果\n\t- **多倍性**：是指在系统性能瓶颈部件上处于**同一执行阶段**的指令或数据的最大可能个数\n\n![G1KCqK.png](https://unpkg.com/justlovesmile-img/G1KCqK.png)\n![G1KQZ8.png](https://unpkg.com/justlovesmile-img/G1KQZ8.png)\n\n- 主要缺点：  \n\t- (1)分类太粗：例如，在SIMD中包括有多种处理机，对流水线处理机的划分不明确，标量流水线为SISD，向量流水线为SIMD \n\t- (2)根本问题是把两个不同等级的功能并列对待；通常，数据流受指令流控制，从而造成MISD不存在  \n\t- (3)非冯计算机的分类；其他新型计算机的分类  \n\n2.库克分类\n\n- 用**指令流**和**执行流**（Execution Stream）及其多倍性来描述计算机系统总控制器的结构特征\n\t- SISE：单处理机系统 \n\t- SIME：多操作部件的处理机\n\t- MISE：带指令级多道程序的单处理机\n\t- MIME：多处理机 \n- 缺点 \n\t- 有些系统，如分布处理机等，没有总控制器  \n\t- 分类太粗，如SIME中包含了多种类型的处理机  \n\n3.冯泽云分类\n- 提出用数据处理的并行度来定量地描述各种计算机系统特性\n\t- WSBS（字串位串） \n\t- WSBP（字串位并）\n\t- WPBS（字并位串）\n\t- WPBP（字并位并）\n- 缺点\n\t- 仅考虑了数据的并行性，没有考虑指令、任务、作业的并行 \n![G1MekF.png](https://unpkg.com/justlovesmile-img/G1MekF.png)\n\n### 1.6 本章小结\n\n1. 重点：（1）计算机系统结构，计算机组成，计算机实现三者的定义以及包含的内容（2）有关透明性问题的判断（3）软件和硬件的功能分配原则（4）软件可移植性的途径，方法，适用场合，存在问题和对策（5）并行性的概念（6）系统结构中开发并行性的途径\n2. 难点：透明性的判断与分析\n\n>下列哪些对**系统程序员**是透明的?\n**A、超大规模集成电路**\nB、虚拟存储器\n**C、Cache存储器**\nD、程序状态字\nE、“启动I/O”指令\nF、“执行”指令\n**G、指令缓冲寄存器**\n\n正确答案： ACG \n\n>下列哪些对**应用程序员**是透明的?\n**A、虚拟存储器**\n**B、Cache存储器**\n**C、程序状态字**\n**D、“启动I/O”指令**\nE、“执行”指令\n**F、指令缓冲寄存器**\n\n正确答案： ABCDF \n\n>1.系列机可将单总线改成双总线来减少公用总线的使用冲突。 【答案：√】\n2.系列机增加新机种时,为增加寻址灵活性和缩短平均指令字长,由原等长操作码改为多种码长的扩展操作码。【答案：×】\n3.系列机应用软件应做到向前兼容,力争向下兼容。【答案：×】\n4.可以说向后兼容是系列机的根本特征。 【答案：√】\n5.系列机不再是方向,因为它约束了计算机系统结构的发展。 【答案：×】\n6.由同一厂家生产的,系统结构相同的,但组成和实现不同的所有计算机,称为兼容机。 【答案：×】 \n\n## 第二章 数据表示，寻址方式与指令系统\n\n### 2.1 数据表示\n\n#### 2.1.1 数据表示与数据结构\n\n- 数据表示：能由机器硬件识别和引用的**数据类型**，表现在它有对这种类型的数据进行操作的指令和运算部件。\n- 数据类型：**不同于数据，数据类型除了指一组值的集合外，还定义了可作用于这个集合上的操作集** \n  - **基本数据**类型\n  - **结构数据**类型\n  \t- 一组由相互有关的数据元素复合而成的数据类型，这些数据元素可以是基本数据类型中的元素，也可以是结构数据类型本身中的元素。也就是说这些数据是有结构的，**包括向量和数组、字符串、堆栈、队列、记录**等，结构数据类型中的元素不一定都具有相同类型\n   - 访问指针\n   - 抽象数据等类型\n- 数据结构：通过软件映像，变换成机器中所具有的数据表示来实现的。\n\t- 是应用中相互之间存在一种或多种特定关系的数据元素的集合。如：线性表、栈、队列、串、数组、阵列、链表、树和图等。\n\t- 是结构数据类型的组织方式，它反映了结构数据类型中各种数据元素或信息单元之间的结构关系 \n\t- 不同数据表示可以为数据结构的实现提供不同的支持。**数据表示是数据结构的子集**\n\t- 数据结构和数据表示是软硬件的交界面。\n\n图为变址操作对向量，阵列数据结构的支持：\n![](https://unpkg.com/justlovesmile-img/1.png)\n\n#### 2.1.2 高级数据表示\n\n1.自定义数据表示\n（1）标志符数据表示\n\n- 为缩短高级语言与机器语言的语义差距，让机器中每个数据都带类型标志位\n- | 类型标志 | 数据值 |\n- 标志符数据表示的主要优点\n\t- 简化了指令系统和程序设计\n\t\t- 减少指令种类\n\t- 简化了编译程序\n\t\t- 不用做复杂的映射\n\t- 便于实现一致性校验\n\t- 能由硬件自动变换数据类型\n\t- 为软件调试和应用软件开发提供了支持\n- 使用标志符数据表示可能带来如下问题\n\t- 每个数据字因增设标志符，会增加程序所占的主存空间\n\t- 采用标志符会降低指令的执行速度\n\t\t- 增加按标志符确定数据属性及判断操作数之间是否相容等操作，单条指令的执行速度会下降。\n\t\t- 程序的编制和调试时间的缩短，是解题总时间缩短\n\t\t- 所以，引入标志符数据表示对微观性能（机器的运算速度）不利，但对宏观性能（解题总时间）是有利的。\n\n（2）数据描述符\n\n- 为了进一步减少标志符所占存储空间，对向量、数组、记录等数据，由于元素属性相同，因此就发展出数据描述符\n- 描述符和数据分开，表示访问的数据是整块还是单个，地址信息等其他信息\n![](https://unpkg.com/justlovesmile-img/20200415122950.png)\n\n- 描述符方法优点：\n\t- 描述符方法实现阵列数据的索引要比用变址方法实现更方便\n\t- 且便于检查出程序中的阵列越界错误\n\t- 数据描述符方法为向量、数组数据结构的实现提供了一定的支持，有利于并简化编译中的代码生成，可以比变址法更快地形成元素地址\n\n2.向量数组数据表示\n\n- 为向量、数组数据结构的**实现和快速运算提供更好的硬件支持的方法是增设向量、数组数据表示**\n- 向量在内存中是连续存放在一段空间里的，换句话说，这些向量元素的地址是连续的 \n- 在标量计算机上运行时，由于没有专门的向量数据表示，因此在计算一个向量(相当于一维数组的计算)时，每取用一个数据元素，都要用到计算该元素的地址。\n- 而在向量机中，由于有了向量数据表示，就**可以把一个向量用一个位串来表示出来**。向量指令就是能够用一条指令对向量的全部元素进行运算的指令。 \n\n![](https://unpkg.com/justlovesmile-img/20200415134043.png)\n\n- 引入向量、数组数据表示优点\n\t- 不只是能加快形成元素地址；\n\t- 便于实现把向量各元素成块预取到中央处理器；\n\t- 能对阵列中的每个元素又是一个子阵列的相关交叉型阵列进行处理；\n\t- 对稀疏矩阵能实现压缩存储、还原、运算等多种功能操作，不但节省了空间，也由于不必处理零元素而节省了时间。\n\n3.堆栈数据表示\n\n- 堆栈数据结构在编译和子程序调用中很有用\n- 通用寄存器型机器对堆栈数据结构支持**较差**\n\t- 堆栈操作用的机器指令数少，功能单一，没有专门的堆栈指令\n- 寄存器型机器的内存分配，有堆栈(Stack)空间\n\t- 堆栈置于存储器内，访问堆栈的速度低\n\t- 通常只用于保存子程序调用时的**返回地址**\n\t- 少量用堆栈来实现程序之前的**参数传递**\n\n- 堆栈机器\n\t- 有堆栈数据表示的机器称为堆栈机器\n\t- 堆栈寻址方式的地址是隐含的，在指令中不必给出操作数的地址，**零地址指令**\n\t- 从60年代开始，出现了一批以堆栈寻址方式为主的堆栈计算机\n\t- 堆栈对以下这些方面处理非常方便\n\t\t- 表达式求值\n\t\t- 子程序调用，递归，中断嵌套\n\t\t- 块结构语言中的变量访问\n\n堆栈计算机具有如下特点：\n（1）有高速寄存器组成的硬件堆栈，并附加控制电路，让它与主存中的堆栈区在逻辑上构成整体，使堆栈的访问速度是寄存器级，容量是主存级。\n（2）有丰富的堆栈指令且功能很强。\n（3）支持高级语言，有利于编译程序。因为一般的算术表达式可以很容易地转化成逆波兰表达式，而逆波兰表达式能够直接形成由堆栈指令组成的程序，这样就简化了编译程序。\n\n- **以主存寻址方式为主的计算机系统**，在编译一个算术表达式时，要**为每一个变量分配主存单元**，另外，还会人为地产生一些中间变量。**如何减少中间变量的个数**，合理地为变量分配存储单元，是编译器的一项许多相当困难的工作。\n- **以寄存器寻址方式为主的计算机系统**，编译器需要决定哪些变量放在通用寄存器中，哪些变量放在主存中，**以减少访问主存储器的次数**。另外，也同样存在**如何减少了中间变量**，节省了存储空间的问题\n\n（4）支持程序的嵌套和递归调用，支持中断处理\n\n#### 2.1.3 引入数据表示的原则\n\n**从根本上讲，存储器一维线性的存储结构与要求经常使用的多维离散数据结构有着很大的差距，不利于数据结构的实现。**\n\n一是基本数据表示不可少；\n二是看系统的效率是否显著提高；\n三是看引入这种数据表示后，其通用性和利用率是否提高。\n四是也需要挖掘基本数据表示的细节问题。\n\n#### 2.1.4 浮点数尾数基值大小和下溢处理方法的选择\n\n1.浮点数尾数基值的选择\n如果小数点的位置事先已有约定，不再改变，此类数称为“定点数”。\n如果小数点的位置可变，则称为“浮点数”。\n![](https://unpkg.com/justlovesmile-img/20200826171758.png)\n\nrm ：尾数的基\nre ：阶码的基（re =2）\nm： 尾数长度 (注意其含义)\np： 阶码长度\n【p表示数的范围大小；尾数的位数m主要影响表示值的精度】\n![](https://unpkg.com/justlovesmile-img/20200415135441.png)\n\n- 浮点数表数误差产生的原因：\n\t- 运算的结果\n\t- 十进制转化为二进制、四进制、八进制、十六进制\n- 浮点数尾数基值的选择\n\t- 可表示数的范围\n\t\t- 随着rm增大，可表示的范围增大\n\t\t- 随着rm增大，可表示数的最小值rm^-1将减少\n\t- 可表示数的个数\n\t\t- (2^p)×(rm^m')×(1-(rm^(-1)) ，其中rm的增大将因`(1-(rm^-1))`增大而使可表示数的个数增多\n\t- 可表示的精度\n\t\t- rm越大，数在数轴上的分布越稀，数的表示精度自然就下降\n\t- 运算中的精度损失\n\t\t- 尾数右移出机器字长，使有效数字丢失，但其不同于可表示数的精度，由于尾数基值rm取大后，对阶移位的机会和次数减少，又由于数的表示范围扩大，使尾数溢出需右规的机会也减少。因此，rm越大，尾数右移的机会越小，精度的损失就越小\n\t- 运算速度\n\t\t- Rm增大时，由于对阶或尾数溢出需右移及规格化需左移的次数减少，运算速度可以提高\n- 综上所述，尾数基值取大，会扩大浮点数的表示范围、增加可表示数的个数、减少移位次数、降低右移造成的精度损失和提高运算速度，但是会，降低数据的表示精度，数值的分布变稀\n- 规格化正尾数：**正尾数小数点后第一个rm进制数位不是0的数**\n\n|条件：非负阶，规格化，正尾数|阶值：二进制p位，尾数：rm进制m'位|若p=2，m=4，当rm=2（即m'=4）时|若p=2，m=4，当rm=16（即m'=1）时|\n|:---:|:---:|:---:|:---:|\n|可表示最小尾数值|rm^(-1)|1/2|1/16|\n|可表示最大尾数值|1-1×rm^(-m')|15/16|15/16|\n|最大阶值|2^p-1|3|3|\n|可表示最小值|rm^(-1)|1/2|1/16|\n|可表示最大值|rm^(2^p-1)×(1-rm^(-m'))|7.5|3840|\n|可表示的尾数个数|rm^(m')×(rm-1)/rm|8|15|\n|可表示阶的个数|2^p|4|4|\n|可表示数的个数|2^p×rm^(m')×(rm-1)/rm|32|60|\n\n2.浮点数位数的下溢处理方法\n减少运算中的精度损失关键是要处理好运算中尾数超出字长的部分，使精度损失最小\n（1）**截断法**\n方法：**将尾数超出机器字长的部分去掉**\n\n- 以rm=2，m=2为例讨论最大误差\n\t- 在整数时接近于1(“11:111…1”截断成“11:”)\n\t- 在分数时接近于2^(-m) (“.01:111…1”截断成“.01:”)\n总是产生负误差\n![](https://unpkg.com/justlovesmile-img/20200415140626.png)\n\n- 优点\n\t- 实现简单，不增加硬件，不需要处理时间\n- 缺点\n\t- 最大误差较大，且平均误差大且无法调节，因而已很少使用\n\n（2）**舍入法**\n在机器运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加1,(整数加0.5，分数加2-(m+1))\n\n- 例如：\n\t- 整数：“10:10…0”舍入成“11:” 正误差\n\t- 分数：“.10:01…0”舍入成“.10:” 负误差\n- 优点\n\t- 实现简单，增加的硬件开销少，最大误差小，平均误差接近于零\n- 缺点\n\t- 处理速度慢，需要花费在数的附加位加1以及因此产生进位的时间，最坏情况下，需要从尾数最低位进制\n![](https://unpkg.com/justlovesmile-img/20200415000000.png)\n（3）**恒置“1”法**\n\n- 将机器运算的规定字长之最低位恒置“1”\n- 最大误差\n\t- 整数为1（如“10:00…0”处理成“11:”）\n\t- 分数为2-m（如“.00:00…0”处理成“.01:”）\n- 误差有正负\n\t- 负误差（如“.11:10…1”处理成“.11:”）\n\t- 正误差（如“.00:00…0”处理成“.01:”)\n![](https://unpkg.com/justlovesmile-img/20200415000001.png)\n\n- 优点\n\t- 实现简单，不需要增加硬件和处里时间，平均误差趋于0\n- 缺点\n\t- 最大误差最大，比截断法还大（接近于1）\n多用于中、高速机器中，由于尾数位数比微、小型机器长\n\n（4）查表舍入法\n取尾数p位的最后k-1位和准备舍弃的最高1位，共k位。通过ROM或PLA查表得到k-1位，作为新的尾数p位的最后k-1位\n![](https://unpkg.com/justlovesmile-img/20200415000002.png)\n\n- 下溢处理表的内容\n\t- 当尾数最低k-1位为全”1“时以截断法设置处理结果\n\t- 其余情况采用舍入法\n![](https://unpkg.com/justlovesmile-img/20200415142649.png)\n\n- 优点\n\t- ROM法速度较快，平均误差可调到0\n\t- 避免再次右规操作\n- 缺点\n\t- 需要硬件配合\n\n- 上述4种处理方法中，\n\t- **最大误差最大**的是恒置“1”法，\n\t- **最大误差最小**的是舍人法；\n\t- **平均误差最大**的是截断法；\n\t- **平均误差可人为调节**的是查表舍入法；\n\t- **下溢处理不需要附加时间开销，即速度最快**的是截断法和恒置“1”法，\n\t- **处理速度最慢**的是舍人法；\n\t- **实现上最花费硬件**的是查表舍入法，\n\t- **最省硬件**的是截断法和恒置“1”法。 \n\n### 2.2 寻址方式\n\n寻址方式指的是按什么方式寻找（或访问）到所需的操作数或信息的。\n\n#### 2.2.1 寻址方式的三种面向\n\n**面向主存**，寻址主要访问主存，少量访问寄存器；\n**面向寄存器**，主要访问寄存器，少量访问主存和堆栈；\n**面向堆栈**，主要访问堆栈，少量访问主存或寄存器。\n\n#### 2.2.2 寻址方式在指令中的指明\n\n- 具体的寻址方式，组成原理已经讲过\n- 基本的指令格式：操作码 + 地址码\n- 寻址方式指明方法：\n\t- 占用操作码的某些位指明\n\t- 不占操作码，在地址码设置寻址方式字段\n\n#### 2.2.3 程序在主存中的定位技术\n\n- 逻辑地址与主存物理地址 \n\t- 逻辑地址：程序员编写程序时使用的地址；\n\t- 物理地址：程序在主存中的实际地址；\n- 早期——单道程序\n\t- 逻辑地址和物理地址是一致的，程序和数据存放在主存中的位置是由程序员编写程序时指明的；\n- 现在——多道程序\n\t- 程序员已不用主存的实际地址编程，改用符号、标号名编址；\n\t- 由源程序中的符号名空间→目标程序的逻辑地址空间→主存中的物理地址空间 \n\t- 程序员事先无法知道程序装在主存中什么位置；\n\t- 各道程序的逻辑地址都是从0开始编制，主存物理空间地址是从0开始编址的一堆线性空间；\n\n1. 静态再定位\n（1）在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的内存地址。重定位在程序装入时一次完成 \n（2）存在问题\n①一道程序地址改错而导致其他程序出错；\n②指令修改妨碍了程序的可重入。\n③指令修改了，不利于程序定位和调试。\n2. 动态再定位\n是在程序执行期间完成的，即程序的逻辑地址在装入内存时不作任何修改，程序执行中，每取出一条指令，CPU对其译码时，如果有逻辑地址，就借助于重定位机构将其转换成绝对地址，然后执行该指令。\n3. 基址寻址\n（1）指令中给出一个形式地址（作为修改量），并给出基址寄存器号，基址寄存器内容（作为基准量）与形式地址相加得到操作数有效地址\n（2）主要解决\n①程序重定位；\n②扩展有限字长指令的寻址空间\n![](https://unpkg.com/justlovesmile-img/8K2W9S17_VYSURM8WL~%25YOQ.png)\n4. 虚实地址映象表\n地址加界法要求程序员所用编址空间不能超出实际主存空间容量。\n\n#### 2.2.4 物理主存中信息的存储分布\n\n目前使用最普遍的编址单位是字节编址，这是为了适应非数值计算的需要\n\n### 2.3 指令系统的设计和优化\n\n#### 2.3.1 指令系统设计的基本原则\n\n- 指令系统是软、硬件的主要界面\n- 指令系统的设计主要包括**指令的功能**（操作类型、具体操作内容）和**指令格式**的设计.\n- 指令设计的步骤：\n\t- **根据应用**，初拟出指令的分类和具体的指令；\n\t- 试编出用该指令系统设计的各种**高级语言的编译程序**；\n\t- **大量测试**程序进行**模拟测试**，看指令系统的操作码和寻址方式效能是否都比较高；\n\t- **将程序中高频出现的指令串复合改成一条强功能新指令**，即改用硬件方式实现；而将频度很低的指令的操作改成基本的指令组成的指令串来完成，即用软件方式实现；\n- 系统设计人员希望：指令码密度适中，兼容性，适应性\n- 指令的组成：\n\t- 一般的指令主要由两部分组成：**操作码**和**地址码**\n\t- 操作码主要包括两部分内容：\n\t\t- 操作种类：加、减、乘、除、数据传送、移位、转移、输入输出\n\t\t- 操作数描述\n\t\t\t- 数据的类型：定点数、浮点数、复数、字符、字符串、逻辑数、向量\n\t\t\t- 进位制：2进制、10进制、16进制\n\t\t\t- 数据字长：字、半字、双字、字节\n\t- 地址码通常包括三部分内容：\n\t\t- 地址：直接地址、间接地址、立即数、寄存器编号、变址寄存器编号\n\t\t- 地址的附加信息：偏移量、块长度、跳距\n\t\t- 寻址方式：直接寻址、间接寻址、立即数寻址、变址寻址、相对寻址、寄存器寻址(可能)\n- 指令格式的优化\n\t- 指令=操作码+地址码\n\t- 指令格式的优化：如何用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短。\n\t- 主要目标：\n\t\t- 节省程序的存储空间\n\t\t- 指令格式尽量规整，便于译码\n- 操作码的优化表示：\n\t- 操作码的三种编码方法：\n\t\t- 固定长度：规整性好，解码简单，空间大\n\t\t- Huffman编码：空间小，规整性不好，解码复杂。\n\t\t- 扩展编码：折衷方案，由固定长操作码与Huffman编码法相结合形成\n\t- 改进操作码编码方式能够节省程序存储空间\n- 指令字格式的优化：\n\t- 只有操作码的优化，没有在地址码和寻址方式上采取措施，程序的总位数还是难以减少。\n\t- 如果主存按位编址，则部分指令的读取需要两个周期，是机器速度明显下降。\n","tags":["系统结构","大学课程"],"categories":["学习笔记"]},{"title":"Hexo博客 | 博客中能用到的代码（二）","slug":"博客相关-博客中能用到的代码（二）","url":"/posts/15391.html","content":"\n\n之前写了一个[博客中能用到的代码](/posts/56163.html),这是第二篇\n这篇文章介绍了如何添加`旋转小人`和`每日诗句`\n<!-- more -->\n\n# >旋转小人\n\n> 参考自[Codepen](https://codepen.io/)和[CodePen — 前端利器分享](/posts/11952.html)\n\n![](https://unpkg.com/justlovesmile-img/twopeople.gif)\n\n```HTML\n<div class=\"twopeople\">\n    <div class=\"container\" style=\"height:200px;\">\n        <canvas class=\"illo\" width=\"800\" height=\"800\" style=\"max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;\"></canvas>\n    </div>\n    <script src=\"https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js\"></script>\n    <script id=\"rendered-js\" src=\"https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js\"></script>\n    <style>\n        .twopeople{\n            margin: 0;\n            align-items: center;\n            justify-content: center;\n            text-align: center;\n        }\n        canvas {\n            display: block;\n            margin: 0 auto;\n            cursor: move;\n        }\n    </style>\n</div>\n```\n\n# >念两句诗\n\n>参考自[Sakura主题在留言页动态诗句 Sakura主题美化第三弹](https://m1314.cn/210.html)\n\n![](https://unpkg.com/justlovesmile-img/20200727182841.png)\n\n```html\n<script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"></script>\n<div class=\"poem-wrap\">\n    <div class=\"poem-border poem-left\"></div>\n    <div class=\"poem-border poem-right\"></div>\n    <h1>念两句诗</h1>\n    <p id=\"poem\">挑选中...</p>\n    <p id=\"info\">\n</div>\n```\n\n```css\n/*诗*/\n.poem-wrap {\n    position: relative;\n    width: 730px;\n    max-width: 80%;\n    border: 2px solid #797979;\n    border-top: none;\n    text-align: center;\n    margin: 80px auto;\n}\n \n.poem-wrap h1 {\n    position: relative;\n    margin-top: -20px;\n    display: inline-block;\n    letter-spacing: 4px;\n    color: #797979\n}\n \n.poem-wrap p {\n    width: 70%;\n    margin: auto;\n    line-height: 30px;\n    color: #797979;\n}\n \n.poem-wrap p#poem {\n    font-size: 25px;\n}\n \n.poem-wrap p#info {\n    font-size: 15px;\n    margin: 15px auto;\n}\n \n.poem-border {\n    position: absolute;\n    height: 2px;\n    width: 27%;\n    background-color: #797979;\n}\n \n.poem-right {\n    right: 0;\n}\n \n.poem-left {\n    left: 0;\n}\n \n@media (max-width: 685px) {\n    .poem-border {\n        width: 18%;\n    }\n}\n \n@media (max-width: 500px) {\n    .poem-wrap {\n        margin-top: 60px;\n        margin-bottom: 20px;\n        border-top: 2px solid #797979;\n    }\n \n    .poem-wrap h1 {\n        margin: 20px 6px;\n    }\n \n    .poem-border {\n        display: none;\n    }\n}\n```\n\n```javascript\n/*诗*/\nif ($(\"div\").hasClass(\"poem-wrap\")) {\n            get_poem('#poem', '#info')\n}\nfunction get_poem(poem_ele, info_ele) {\n    var poem = document.querySelector(poem_ele);\n    var info = document.querySelector(info_ele);\n    var xhr = new XMLHttpRequest();\n    xhr.open('get', 'https://v2.jinrishici.com/one.json');\n    xhr.withCredentials = true;\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n            var data = JSON.parse(xhr.responseText);\n            poem.innerHTML = data.data.content;\n            info.innerHTML = '【' + data.data.origin.dynasty + '】' + data.data.origin.author + '《' + data.data.origin.title + '》';\n        }\n    };\n    xhr.send();\n}\n```","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"Hexo博客 | 博客中能用到的代码（一）","slug":"博客相关-博客中能用到的代码","url":"/posts/56163.html","content":"\n这篇文章介绍了如何使用`font awesome图标`字体库，使用`动态图标`，添加`网页运行时间`，`全站变黑白`，`鼠标点击特效`，`网页标题的动态效果`，`网页樱花特效`，`鼠标触动音乐特效`，之前还介绍过`打字机效果`，可以看看[这篇文章](/posts/24067.html)\n<!-- more -->\n\n## >使用font awesome图标字体库\n\n[Font Awesome中文网](http://www.fontawesome.com.cn/)\n\n第一步，只需要导入css文件，就可以在全文使用其图标\n\n```HTML\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css\">\n```\n\n第二步，使用方法：\n1.在网站中找到自己看上的图标,保存它的名字`XXXX`\n![GBwWy8.png](https://unpkg.com/justlovesmile-img/GBwWy8.png)\n2.在需要的位置,插入`<i class=\"fa fa-XXXX\" aria-hidden=\"true\"></i>`\n\n```HTML\n<i class=\"fa fa-home\" aria-hidden=\"true\"></i>首页\n```\n\n效果如下：\n\n![](https://unpkg.com/justlovesmile-img/20201022105849.png)\n\n## >使用动态图标\n\n[Font Awesome Animation](https://l-lin.github.io/font-awesome-animation/)\n\n第一步，只需要导入css文件，就可以在全文使用其动态特效图标\n\n```HTML\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/font-awesome-animation@0.2.1/dist/font-awesome-animation.min.css\">\n```\n\n第二步，使用方法：\n1.在网站中找到自己看上的动态效果,保存它的名字`faa-YYYY`，结合font awesome图标\n![GBjP61.gif](https://unpkg.com/justlovesmile-img/GBjP61.gif)\n2.在需要的位置,插入`<span class=\"faa-parent animated-hover\"><i class=\"fa fa-XXXX faa-YYYY\" aria-hidden=\"true\"></i></span>`\n\n```HTML\n<span class=\"faa-parent animated-hover\"><i class=\"fa fa-home faa-wrench animated\" aria-hidden=\"true\"></i>首页</span>\n```\n\n效果如下：\n![](https://unpkg.com/justlovesmile-img/faa.gif)\n\n## >网页运行时间\n\n>参考自[网站底部添加网站运行时间代码](https://m1314.cn/140.html)\n\n```HTML\n<span id=\"webtime\"></span>\n<!-- js -->\n<script type=\"text/javascript\">function show_runtime() {\n        window.setTimeout(\"show_runtime()\", 1000);\n        X = new Date(\"12/31/2019 23:59:59\");\n        Y = new Date();\n        T = (Y.getTime() - X.getTime());\n        M = 24 * 60 * 60 * 1000;\n        a = T / M;\n        A = Math.floor(a);\n        b = (a - A) * 24;\n        B = Math.floor(b);\n        c = (b - B) * 60;\n        C = Math.floor((b - B) * 60);\n        D = Math.floor((c - C) * 60);\n        document.getElementById(\"webtime\").innerHTML = \"网站已运行了: \" + A + \"天\" + B + \"小时\" + C + \"分\" + D + \"秒\"\n    }\n    show_runtime();\n</script>\n```\n\n效果如下\n![](https://unpkg.com/justlovesmile-img/runtime.gif)\n\n## >全站变黑白\n\n>参考自[全站变黑白CSS代码](https://m1314.cn/375.html)\n\n适合在公祭日哀悼使用，兼容所有主流浏览器，直接添加到header或者博客自定义CSS里就可以生效了，开了缓存的记得清除下~\n\n```css\nhtml {\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n    filter: grayscale(100%);\n    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n}\n```\n\n## >鼠标点击特效\n\n[github](https://github.com/djzhao627/JSClickBubble)\n\n```HTML\n<script type=\"text/javascript\">\nonload = function() {\n    var click_cnt = 0;\n    var $html = document.getElementsByTagName(\"html\")[0];\n    var $body = document.getElementsByTagName(\"body\")[0];\n    $html.onclick = function(e) {\n        var $elem = document.createElement(\"b\");\n        $elem.style.color = \"#E94F06\";\n        $elem.style.zIndex = 9999;\n        $elem.style.position = \"absolute\";\n        $elem.style.select = \"none\";\n        var x = e.pageX;\n        var y = e.pageY;\n        $elem.style.left = (x - 10) + \"px\";\n        $elem.style.top = (y - 20) + \"px\";\n        clearInterval(anim);\n        switch (++click_cnt) {\n            case 10:\n                $elem.innerText = \"OωO\";\n                break;\n            case 20:\n                $elem.innerText = \"(๑•́ ∀ •̀๑)\";\n                break;\n            case 30:\n                $elem.innerText = \"(๑•́ ₃ •̀๑)\";\n                break;\n            case 40:\n                $elem.innerText = \"(๑•̀_•́๑)\";\n                break;\n            case 50:\n                $elem.innerText = \"（￣へ￣）\";\n                break;\n            case 60:\n                $elem.innerText = \"(╯°口°)╯(┴—┴\";\n                break;\n            case 70:\n                $elem.innerText = \"૮( ᵒ̌皿ᵒ̌ )ა\";\n                break;\n            case 80:\n                $elem.innerText = \"╮(｡>口<｡)╭\";\n                break;\n            case 90:\n                $elem.innerText = \"( ง ᵒ̌皿ᵒ̌)ง⁼³₌₃\";\n                break;\n            case 100:\n            case 101:\n            case 102:\n            case 103:\n            case 104:\n            case 105:\n                $elem.innerText = \"(ꐦ°᷄д°᷅)\";\n                break;\n            default:\n                $elem.innerText = \"❤\";\n                break;\n        }\n        $elem.style.fontSize = Math.random() * 10 + 8 + \"px\";\n        var increase = 0;\n        var anim;\n        setTimeout(function() {\n            anim = setInterval(function() {\n                if (++increase == 150) {\n                    clearInterval(anim);\n                    $body.removeChild($elem);\n                }\n                $elem.style.top = y - 20 - increase + \"px\";\n                $elem.style.opacity = (150 - increase) / 120;\n            }, 8);\n        }, 70);\n        $body.appendChild($elem);\n    };\n};\n</script>\n```\n\n## >网页标题的动态效果\n\n>参考自[JS代码实现浏览器网页标题的动态切换](https://zhangge.net/5032.html)\n\n```HTML\n<script>\njQuery(document).ready(function() {\n    function c() {\n        /* 排除首页（记得自行修改下首页地址） */\n\tif (location.href != \"https://justlovesmile.top/\") { document.title = document[a] ? \"(つェ⊂)誒呀→《\" + d + \"》\" : \"(*´∇｀*) 咦好了→《\" + d + \"》\" }\n    }\n    var a, b, d = document.title;\n    \"undefined\" != typeof document.hidden ? (a = \"hidden\", b = \"visibilitychange\") : \"undefined\" != typeof document.mozHidden ? (a = \"mozHidden\", b = \"mozvisibilitychange\") : \"undefined\" != typeof document.webkitHidden && (a = \"webkitHidden\", b = \"webkitvisibilitychange\");\n    \"undefined\" == typeof document.addEventListener && \"undefined\" == typeof document[a] || document.addEventListener(b, c, !1)\n});\n</script>\n```\n\n效果如下：\n\n![GDF12T.png](https://unpkg.com/justlovesmile-img/GDF12T.png)\n\n## >网页樱花特效\n\n>参考自[博客樱花飘落动效](https://hylpq.com/archives/sakuracss3/)\n\n```HTML\n<script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/sakura.js\"></script>\n```\n只需要导入js就可以了\n\n## >鼠标触动音乐特效\n\n>参考自[利用HTML5 Web Audio API给网页JS交互增加声音](https://www.zhangxinxu.com/wordpress/2017/06/html5-web-audio-api-js-ux-voice/)\n\n```HTML\n<button id=\"button\">经过我</button>\n<script>\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\n(function () {\n    if (!window.AudioContext) {\n        alert('当前浏览器不支持Web Audio API');\n        return;\n    }\n    // 按钮元素\n    var eleButton = document.getElementById('button');\n    // 创建新的音频上下文接口\n    var audioCtx = new AudioContext();\n    // 发出的声音频率数据，表现为音调的高低\n    var arrFrequency = \"880 987 1046 987 1046 1318 987 659 659 880 784 880 1046 784 659 659 698 659 698 1046 659 1046 1046 1046 987 698 698 987 987 880 987 1046 987 1046 1318 987 659 659 880 784 880 1046 784 659 698 1046 987 1046 1174 1174 1174 1046 1046 880 987 784 880 1046 1174 1318 1174 1318 1567 1046 987 1046 1318 1318 1174 784 784 880 1046 987 1174 1046 784 784 1396 1318 1174 659 1318 1046 1318 1760 1567 1567 1318 1174 1046 1046 1174 1046 1174 1567 1318 1318 1760 1567 1318 1174 1046 1046 1174 1046 1174 987 880 880 987 880\".split(\" \");\n    // 音调依次递增或者递减处理需要的参数\n    var start = 0, direction = 1;\n    // 鼠标hover我们的按钮的时候\n    eleButton.addEventListener('mouseenter', function () {\n        // 当前频率\n        var frequency = arrFrequency[start];\n        // 如果到头，改变音调的变化规则（增减切换）\n        if (!frequency) {\n            direction = -1 * direction;\n            start = start + 2 * direction;\n            frequency = arrFrequency[start];\n        }\n        // 改变索引，下一次hover时候使用\n        start = start + direction;\n        // 创建一个OscillatorNode, 它表示一个周期性波形（振荡），基本上来说创造了一个音调\n        var oscillator = audioCtx.createOscillator();\n        // 创建一个GainNode,它可以控制音频的总音量\n        var gainNode = audioCtx.createGain();\n        // 把音量，音调和终节点进行关联\n        oscillator.connect(gainNode);\n        // audioCtx.destination返回AudioDestinationNode对象，表示当前audio context中所有节点的最终节点，一般表示音频渲染设备\n        gainNode.connect(audioCtx.destination);\n        // 指定音调的类型，其他还有square|triangle|sawtooth\n        oscillator.type = 'sine';\n        // 设置当前播放声音的频率，也就是最终播放声音的调调\n        oscillator.frequency.value = frequency;\n        // 当前时间设置音量为0\n        gainNode.gain.setValueAtTime(0, audioCtx.currentTime);\n        // 0.01秒后音量为1\n        gainNode.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.01);\n        // 音调从当前时间开始播放\n        oscillator.start(audioCtx.currentTime);\n        // 1秒内声音慢慢降低，是个不错的停止声音的方法\n        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1);\n        // 1秒后完全停止声音\n        oscillator.stop(audioCtx.currentTime + 1);\n    });\n})();\n</script>\n```","tags":["Hexo","前端"],"categories":["博客相关"]},{"title":"打字机效果 | 使用type.js模拟打字输入回退效果","slug":"博客相关-打字机效果-type-js","url":"/posts/24067.html","content":"\n今天在Github上发现了一个有趣的开源项目\n\n![](https://unpkg.com/justlovesmile-img/typejs3.gif)\n\n<!-- more -->\n\n- github地址：[https://github.com/mattboldt/typed.js/](https://github.com/mattboldt/typed.js/)\n- 文档：[https://mattboldt.github.io/typed.js/docs/](https://mattboldt.github.io/typed.js/docs/)\n\n#### 导入js\n\n```HTML\n<script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.11\"></script>\n```\n\n#### 实现效果\n\n![](https://unpkg.com/justlovesmile-img/typejs4.gif)\n\n```javascript\n  try {\n    var typed = new Typed(\"#typed\", {\n    strings: ['醒亦念卿，梦亦念卿','频繁记录，只因生活和你太值得❤'],//字符串\n    startDelay: 0,//开始的延迟\n    typeSpeed: 200,//打字速度\n    backSpeed: 100,//回退速度\n    loop: true,//是否循环\n    showCursor: true,//显示游标\n    shuffle: false//是否随机\n    });\n  } catch (err) {\n  }\n```\n\n#### 游标样式\n\n![](https://unpkg.com/justlovesmile-img/typejs5.gif)\n\n```javascript\n  try {\n    var typed1 = new Typed(\"#typed1\", {\n    //一大堆同上\n    cursorChar: '_',//游标样式\n    });\n  } catch (err) {\n  }\n```\n\n#### 批量输入\n\n![](https://unpkg.com/justlovesmile-img/typejs6.gif)\n\n```javascript\n  try {\n    var typed2 = new Typed(\"#typed2\", {\n    strings: ['醒亦念卿，梦亦念卿\\n `频繁记录，只因生活和你太值得❤`'],//字符串\n    //一大堆同上\n    });\n  } catch (err) {\n  }\n```\n\n#### 智能退格\n\n![](https://unpkg.com/justlovesmile-img/typejs7.gif)\n\n```html\n<div style=\"text-align:center;font-size:2rem;\">\n<strong id=\"typed3\"></strong>\n\n</div>\n<script data-pjax>\n  try {\n    var typed3 = new Typed(\"#typed3\", {\n    strings: ['我想说：我','我想说：爱','我想说：你'],//字符串\n    startDelay: 0,//开始的延迟\n    typeSpeed: 200,//打字速度\n    backSpeed: 100,//回退速度\n    loop: true,//是否循环\n    showCursor: true,//显示游标\n    smartBackspace: true, //默认true\n    });\n  } catch (err) {\n  }\n</script>\n```\n","tags":["前端","JS"],"categories":["博客相关"]},{"title":"生活VLOG | 滑雪旅拍，北境踏雪","slug":"生活琐事-滑雪旅拍-北境踏雪","url":"/posts/14353.html","content":"\n[https://v.qq.com/txp/iframe/player.html?vid=k0821tyiv85](https://v.qq.com/txp/iframe/player.html?vid=k0821tyiv85)\n\n<img src=\"https://unpkg.com/justlovesmile-img/snow1.jpg\" alt=\"\" class=\"wp-image-94\"/>\n<!-- more -->\n<ul><li>时间：2018年12月</li><li>地点：哈尔滨</li><li>vlog-BGM：Your Radio</li><li>剪辑：PR</li></ul>\n<div class=\"myvideo\"><iframe frameborder=\"0\" src=\"https://v.qq.com/txp/iframe/player.html?vid=k0821tyiv85\" allowFullScreen=\"true\"></iframe></div>\n<style>\n.myvideo{\n    position: relative;\n    width: 100%;\n    height: 0;              /*高度设置这里无效，设置为0，用padding撑开div*/\n    padding-bottom: 75%;    /*68%到80%都可以*/\n}\n.myvideo iframe {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    left: 0;\n    top: 0;\n}\n</style>\n\n<p>上面是第一次去滑雪时拍摄的vlog🏂，不得不说，银装素裹的哈尔滨真的超美</p>","tags":["旅拍","Vlog"],"categories":["生活琐事"]},{"title":"Python爬虫 | 如何获取网易云音乐评论","slug":"代码编程-如何获取网易云音乐评论","url":"/posts/52305.html","content":"今天看了知乎上的一个问答，关于如何爬取网易云音乐的评论\n<!-- more -->\n[关于如何爬网易云音乐的评论](https://www.zhihu.com/question/36081767)\n我发现，第一位大佬写的方法，嗯，确实看不懂（虽然不妨碍白嫖），然后我自己试了试，params和encSecKey直接F12+ctrlC/V复制的😂\n\n```python\n\"\"\"\n不按照大佬写的加密方法，只能获取第一页的评论/(ㄒoㄒ)/~~\n\"\"\"\n\nimport requests\nfrom bs4 import BeautifulSoup\nimport json\nimport time\n\ndef get_song_html(url):\n        \"\"\"获取网页HTML\"\"\"\n        headers={\n                \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\",\n                \"Host\":\"music.163.com\",\n                \"Upgrade-Insecure-Requests\":'1'\n        }\n        data={\n                \"params\": \"wFDYU3SUWyoCUekCRy6S6oPwnDHv/2Cvd8zMLZ1TCZexhtvcOGdiZdCw+UC7Y5QKC+7KdMMOZqc2eHjTDFfqVEPwuajKbFwywKKBuxe2gfkYBTNiC02rbZM5OxMM22qhVrZRPZMzAxWZz3t213Ts8A==\",\n                \"encSecKey\": \"b6c67b2c848ef79a5cc0bc0261b6b88b75209276f9f1050091d64731398809b2e0d03081618d9c1a3d442ae1367e7e1a1f54224a6e94fed8eddc3bb337017d0b9f3bb8a274fbf58e8142020b7cbd909f9addf68c674f0232811fa18bf7a1dd90030a5f607ff2c488f20e2aab37dbab1bedff5cfa6684f6e49b69bfc727e943c1\"\n        }\n        song_id=url.split(\"=\")[1]\n        \"\"\"已知的网易云音乐网页链接\"\"\"\n        #歌曲\n        url_so=\"http://music.163.com/weapi/v1/resource/comments/R_SO_4_{}?csrf_token=\".format(song_id)\n        #专辑\n        url_al=\"https://music.163.com/weapi/v1/resource/comments/R_AL_3_{}?csrf_token=\".format(song_id)\n        #电台\n        url_dj=\"https://music.163.com/weapi/v1/resource/comments/A_DJ_1_{}?csrf_token=\".format(song_id)\n        urls=[url_so,url_al,url_dj]#常用三个url\n        answer=input(\"获取热门评论：1\\n获取全部评论：2\\n请输入： \")\n        if answer=='1':\n                for url in urls:\n                        try:\n                                html=requests.post(url,headers=headers,data=data)\n                                html.raise_for_status()\n                        except:\n                                return \"爬取失败！\"\n                        else:\n                                get_song_hot_comments(html)\n        elif answer=='2':\n                for url in urls:\n                        try:\n                                html=requests.post(url,headers=headers,data=data)\n                                html.raise_for_status()\n                        except:\n                                return \"爬取失败！\"\n                        else:\n                                get_song_comments(html)\n        else:\n                print(\"输入错误！\")\n\ndef get_song_hot_comments(html):\n        comments = json.loads(html.text)\n        hot_comments = comments['hotComments']\n        if hot_comments:\n                try:\n                        with open('网易云音乐热门评论.txt','w',encoding='utf-8') as f:\n                                for C_list in hot_comments:\n                                        f.write(\"User: \"+C_list['user']['nickname']+'\\n')\n                                        f.write(\"Comment: \\n\"+C_list['content']+'\\n')\n                                        f.write(\"\\n\"+\"-\"*30+\"\\n\\n\")\n                except:\n                        print(\"保存热门评论失败！\")\n                else:\n                        print(\"保存热门评论成功！\")\n\ndef get_song_comments(html):\n        comments = json.loads(html.text)\n        comments = comments['comments']\n        if comments:\n                try:\n                        with open('网易云音乐评论.txt','w',encoding='utf-8') as f:\n                                for C_list in comments:\n                                        f.write(\"User: \"+C_list['user']['nickname']+'\\n')\n                                        f.write(\"Comment: \\n\"+C_list['content']+'\\n')\n                                        f.write(\"\\n\"+\"-\"*30+\"\\n\\n\")\n                except:\n                        print(\"保存全部评论失败！\")\n                else:\n                        print(\"保存全部评论成功！\")\n\ndef main():\n        url=input(\"请输入需要获取的音乐网址（仅网易云音乐）: \")\n        get_song_html(url)\n\nif __name__ == \"__main__\":\n        main()\n```\n\n这样好像也可以获取评论，但是只有第一页的评论\n![88uadI.png](https://s1.ax1x.com/2020/03/15/88uadI.png)\n\n之后又看了第二个的评论，发现有没有加密的api\n，于是在尝试了多个各种评论后发现👇：\n\n# API\n\n```python\n        #单曲{id}{limit}{offset}\n        url_so=\"http://music.163.com/api/v1/resource/comments/R_SO_4_{}?limit={}&offset={}\"\n        #专辑\n        url_al=\"http://music.163.com/api/v1/resource/comments/R_AL_3_{}?limit={}&offset={}\"\n        #电台\n        url_dj=\"http://music.163.com/api/v1/resource/comments/A_DJ_1_{}?limit={}&offset={}\"\n        #视频\n        url_vi=\"http://music.163.com/api/v1/resource/comments/R_VI_62_{}?limit={}&offset={}\"\n        #MV\n        url_mv=\"http://music.163.com/api/v1/resource/comments/R_MV_5_{}?limit={}&offset={}\"\n        #歌单\n        url_pl\"http://music.163.com/api/v1/resource/comments/A_PL_0_{}?limit={}&offset={}\"\n        #事件（这个好像比较特殊，有id和uid）\n        url_ev=\"http://music.163.com/api/v1/resource/comments/A_EV_2_{}_{}?limit={}&offset={}\"\n```\n这些url对应都是评论，limit是一页的数量，offset就是偏移量=（评论页数-1） * limit\n![88l2cT.png](https://s1.ax1x.com/2020/03/15/88l2cT.png)\n\n\n如何爬网易云音乐的评论数？ - 知乎\nhttps://www.zhihu.com/question/36081767","tags":["Python","爬虫"],"categories":["代码编程"]},{"title":"生活琐事 | 爱与考研数学中的极限","slug":"生活琐事-极限的定义","url":"/posts/36558.html","content":"<img src=\"https://unpkg.com/justlovesmile-img/1.gif\">\n<!-- more -->\n<div style=\"text-align:center;\"><p style=\"color:red;\">♥</p></div>\n<img src=\"https://unpkg.com/justlovesmile-img/2.gif\">\n\n今天在看张宇考研数学的视频时发现了👇这个有趣的片段，极限是什么？\n\n<video controls poster=\"\" src=\"https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/video/limit.mp4\" style=\"width: 100%;\"></video>\n\n- lim我=你↔♥即使给我整个世界，我也只在你的身边♥\n\n\n\n<div style=\"text-align:center;\">\n<p>😘</p>\n</div>","tags":["考研"],"categories":["生活琐事"]},{"title":"生活VLOG | 哈尔滨的春雪","slug":"生活琐事-哈尔滨的春雪vlog","url":"/posts/1f068f9e.html","content":"\n北国风光VLOG❄\n[https://v.qq.com/txp/iframe/player.html?vid=f30744qsih5](https://v.qq.com/txp/iframe/player.html?vid=f30744qsih5)\n\n<ul><li>时间：2019年3月12日</li><li>地点：哈尔滨工程大学</li><li>vlog-BGM：Heaven Sent </li><li>剪辑：PR</li></ul>\n<div class=\"myvideo\"><iframe frameborder=\"0\" src=\"https://v.qq.com/txp/iframe/player.html?vid=f30744qsih5\" allowFullScreen=\"true\"></iframe></div>\n<style>\n.myvideo{position: relative;width: 100%;height: 0;padding-bottom: 75%;}\n.myvideo iframe {position: absolute;width: 100%;height: 100%;left: 0;top: 0;}\n</style>","tags":["旅拍","Vlog"],"categories":["生活琐事"]},{"title":"iOS快捷指令 | 早安，让Siri唤醒你的美好一天","slug":"折腾记录-iOS13捷径之早安","url":"/posts/62966.html","content":"\n<img src=\"https://unpkg.com/justlovesmile-img/7f907f6c-ba49-78e4-24e4-b3594dc3a1f2.jpg\"/>\n<blockquote class=\"wp-block-quote is-style-default\"><p>捷径 （英文名：Shortcuts）是苹果收购的 Workflow 在 iOS 中整合后的成果。用户可以通过该APP创建各种模块化操作，以提高iPhone的处理相关任务的效率 </p></blockquote>\n\n<p>根据捷径便捷操作iOS的特性，可以使用它编写强大的便捷功能，如“早安”捷径，只需要使用Siri说“早安”，便能够实现以下等功能： </p>\n<p>1、开启蓝牙;</p>\n<p>2、开启蜂窝移动数据;</p>\n<p>3、开启WIFI；</p>\n<p>4、关闭勿扰模式;</p>\n<p>5、关闭低电量模式;</p>\n<p>6、播报天气;</p>\n<p>7、播放音乐 （网易云/QQ音乐）</p>\n<p>获取链接为：（捷径名称保存后修改为早安即可）</p>\n<p>（1）打开网易云音乐<a href=\"https://www.icloud.com/shortcuts/e058bafd928f4f72ad7862ec2058d019\">https://www.icloud.com/shortcuts/e058bafd928f4f72ad7862ec2058d019</a></p>\n<p>（2）打开QQ音乐<a href=\"https://www.icloud.com/shortcuts/24c1ecfc35da419d9780c4a6fa9adf6a\">https://www.icloud.com/shortcuts/24c1ecfc35da419d9780c4a6fa9adf6a</a></p>\n<p class=\"has-text-align-center\"><strong>一些Tips：</strong></p>\n<p>URL中设置<strong>orpheus://download</strong>即为打开网易云音乐下载音乐页面，并自动播放。</p>\n<p>当然还有其他链接：</p>\n<p>（1）打开网易云热歌榜单并自动播放：</p>\n<p><strong>orpheus://playlist/3778678/?autoplay=1</strong></p>\n<p>（2）打开网易云飙升榜并自动播放：</p>\n<p><strong>orpheus://playlist/19723756/?autoplay=1</strong></p>\n<p>当然打开QQ音乐为：</p>\n<p>（1）QQ音乐“本地播放”：</p>\n<p><strong>qqmusic://today?mid=31&k1=3&k4=0</strong><br></p>\n<p>（2）QQ音乐“最近播放”：</p>\n<p><strong>qqmusic://today?mid=31&k1=2&k4=0</strong><br></p>\n<p>（3）QQ音乐“个性电台”：</p>\n<p><strong>qqmusic://qq.com/media/playRadio?p=%7B%22radioId%22%3A%2299%22%7D</strong></p>","tags":["iOS","捷径"],"categories":["折腾记录"]},{"title":"WordPress | 阿里云轻量应用服务器wordpress升级php步骤","slug":"折腾记录-阿里云轻量应用服务器wordpress升级php步骤","url":"/posts/10224.html","content":"当我买了阿里云轻量应用服务器wordpress镜像后，发现很多主题需要升级php...\n<!-- more -->\n\n\n## 1.首先更新依赖包。\n\n```\nyum -y update\n```\n\n## 2.安装依赖包\n\n```\nyum -y install libxml2 libxml2-devel openssl openssl-devel bzip2 bzip2-devel libcurl libcurl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel gmp gmp-devel libmcrypt libmcrypt-devel readline readline-devel libxslt libxslt-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel ncurses curl gdbm-devel db4-devel libXpm-devel libX11-devel gd-devel gmp-devel expat-devel xmlrpc-c xmlrpc-c-devel libicu-devel libmcrypt-devel libmemcached-devel libzip gcc-c++\n```\n\n## 3.转到 /usr/local/src 目录，下载php7.3.5\n\n`cd /usr/local/src`\n`wget https://www.php.net/distributions/php-7.3.5.tar.gz`\n\n## 4.解压安装包,并进入目录\n\n```\ntar -zxvf php-7.3.5.tar.gz\ncd php-7.3.5\n```\n\n## 5.添加用户和组\n\n```\ngroupadd www\nuseradd -g www www\n```\n\n## 6.开始编译\n\n```\n./configure --prefix=/usr/local/php --with-fpm-user=www --with-fpm-group=www --with-curl --with-freetype-dir --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-libdir=lib64 --with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql --with-pdo-sqlite --with-pear --with-png-dir --with-jpeg-dir --with-xmlrpc --with-xsl --with-zlib --with-bz2 --with-mhash --enable-fpm --enable-bcmath --enable-libxml --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-sysvshm --enable-xml --enable-zip --enable-fpm\n```\n\n这里会提示 `configure: error: Please reinstall the libzip distribution`，我们需要移除libzip,手动安装最新版本\n\n## 7.安装libzip\n\n（1）先安装cmake\n\n```\ncd /usr/local/src\nwget https://github.com/Kitware/CMake/releases/download/v3.14.3/cmake-3.14.3.tar.gz\ntar -zxvf cmake-3.14.3.tar.gz\ncd cmake-3.14.3\n./bootstrap\nmake && make install\n```\n\n（2）再编译安装libzip\n\n```\nyum remove libzip -y\ncd /usr/local/src\nwget https://libzip.org/download/libzip-1.5.2.tar.gz\ntar -zxvf libzip-1.5.2.tar.gz\ncd libzip-1.5.2\nmkdir build\ncd build\ncmake ..\nmake && make install\n```\n\n（3）执行以下命令\n\n```\nvi /etc/ld.so.conf\n#添加如下几行\n/usr/local/lib64\n/usr/local/lib\n/usr/lib\n/usr/lib64\n#保存退出\nldconfig -v \n# 使之生效 \n```\n\n## 8.再次编译PHP7.3\n\n`make && make install`\n\n## 9.编译完成后，添加环境变量\n\n```\nvi /etc/profile\n#添加以下内容到最后\nPATH=$PATH:/usr/local/php/bin<br>export PATH\n#刷新环境变量\nsource /etc/profile\n```\n\n## 10.配置文件\n\n```\n# 将启动脚本复制到init.d中。\ncp /usr/local/src/php-7.3.5/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm73\n# 给启动脚本加上执行权限\nchmod +x /etc/init.d/php-fpm73\n# 将默认配置文件复制为.conf文件\ncp /usr/local/php/etc/php-fpm.conf.default ${PHP73_DIR}/etc/php-fpm.conf\n# 添加pool的配置\ncat << EOF > /usr/local/php/etc/php-fpm.d/www.conf\n[www]\nlisten = /home/www/logs/php73-fpm.sock\nlisten.mode = 0666\nuser = www\ngroup = www\npm = dynamic\npm.max_children = 128\npm.start_servers = 5\npm.min_spare_servers = 5\npm.max_spare_servers = 15\npm.max_requests = 300\nrlimit_files = 1024\nslowlog = /home/www/logs/php73-fpm-slow.log\nEOF\n```\n\n## 11.修改apache\n\n镜像中默认是用的php-fpm，使用的是socket方式的监听，Apache对应配置文件`/usr/local/apache/conf/httpd.conf`，其中配置如下:\n\n![](https://unpkg.com/justlovesmile-img/20210304220934.png)\n\n需要修改其中socket的文件路径指向到新版本的PHP就可以了，在`/usr/local/php73/etc/php-fpm.d/www.conf`有指定，新的配置到`/home/www/logs/php73-fpm.sock`即可，如图:\n\n![](https://unpkg.com/justlovesmile-img/20210304221206.png)\n\n## 12.重启服务\n\n```\n# 停止旧版本的PHP(实际不停止也不影响，停止可以减少一些系统资源占用)\n/etc/init.d/php-fpm stop\n# 启动新版PHP-FPM\n/etc/init.d/php-fpm73 start\n#启动报错请修改文件名\n修改/usr/local/php/etc/php-fpm.conf.default为php-fpm.conf\n# 重启apache\n/etc/init.d/apachectl restart\n```","tags":["服务器","PHP"],"categories":["折腾记录"]},{"title":"Github | 解决github头像加载不出来","slug":"折腾记录-解决github头像加载不出来","url":"/posts/60270.html","content":"\n## 1. 查看失效头像链接\n\n![](https://unpkg.com/justlovesmile-img/20210209142745.png)\n\n例如，域名可能为`avatars.githubusercontent.com`\n\n## 2. 查找域名对应IP\n\n[https://www.ipaddress.com/](https://www.ipaddress.com/)\n\n![](https://unpkg.com/justlovesmile-img/20210209142320.png)\n\n\n## 3. 解决问题：修改hosts\n\n解决方法，打开路径C:\\Windows\\System32\\drivers\\etc下的hosts文件，并在后面添加下列信息，将IP与域名对应即可\n\n<!-- more -->\n\n```\n# GitHub Start \n140.82.113.3      github.com\n140.82.113.4     gist.github.com\n\n151.101.184.133    assets-cdn.github.com\n151.101.184.133    raw.githubusercontent.com\n151.101.184.133    gist.githubusercontent.com\n151.101.184.133    cloud.githubusercontent.com\n151.101.184.133    camo.githubusercontent.com\n199.232.96.133     avatars.githubusercontent.com\n151.101.184.133    avatars0.githubusercontent.com\n199.232.96.133     avatars0.githubusercontent.com\n151.101.184.133    avatars1.githubusercontent.com\n199.232.96.133     avatars1.githubusercontent.com\n151.101.184.133    avatars2.githubusercontent.com\n199.232.96.133     avatars2.githubusercontent.com\n151.101.184.133    avatars3.githubusercontent.com\n199.232.96.133     avatars3.githubusercontent.com\n151.101.184.133    avatars4.githubusercontent.com\n199.232.96.133     avatars4.githubusercontent.com\n151.101.184.133    avatars5.githubusercontent.com\n199.232.96.133     avatars5.githubusercontent.com\n151.101.184.133    avatars6.githubusercontent.com\n199.232.96.133     avatars6.githubusercontent.com\n151.101.184.133    avatars7.githubusercontent.com\n199.232.96.133     avatars7.githubusercontent.com\n151.101.184.133    avatars8.githubusercontent.com\n199.232.96.133     avatars8.githubusercontent.com\n\n# GitHub End\n```\n\n如果受管理权限限制，则新建并复制。","tags":["Github"],"categories":["折腾记录"]},{"title":"大学课程 | 计算机组成原理","slug":"学习笔记-计算机组成原理","url":"/posts/51917.html","content":"计算机组成原理笔记整理\n<!-- more -->\n\n# 计算机组成原理\n\n## 第一章 计算机系统概述\n\n### 1.1 计算机的基本概念\n\n**电子计算机**是一种可以**存储程序**，并且通过**执行程序指令**，可以自动，高速，精确地对数字信息进行各种**复杂处理**，然后**输出运算结果**的高科技**智能**电子设备。\n\n5个逻辑模块：\n输入设备 存储器 输出设备 运算器 控制器\n![lt99DP.png](https://s2.ax1x.com/2020/01/02/lt99DP.png)\n（如今运算器和控制器已集成在CPU中）\n\n#### 1.1.1 信息的数字化表示\n\n1. 在计算机中用数字代码（二进制代码）表示各种信息\n2. 在物理机制上用数字信号（数字型电信号）表示数字代码\n3. 信息数字化表示的优点：（1）物理上易实现信息的表示与存储（2）抗干扰能力强，可靠性高（3）数值表示范围大，精度高（4）可表示的信息类型广泛（5）能用数字逻辑技术进行处理\n\n#### 1.1.2 存储程序工作方式\n\n1. 编制程序\n2. 存储程序\n3. 自动，连续执行程序\n4. 输出结果\n\n计算机的工作流程：\n编写程序→输入程序→存储程序→转换为指令序列→执行指令→输出结果\n\n#### 1.1.3 计算机的分类\n\n计算机从总体上来说分为两大类：**模拟计算机**和**数字计算机**\n\n特点：\n模拟计算机：由模拟运算器件构成，处理在实践和数值上连续的模拟量（如：电压，电流等）\n数字计算机：由数字逻辑器件构成，处理离散的数字量\n\n其中数字计算机又可分为**专用计算机**和**通用计算机**\n\n按照系统规模和计算能力，也可以分为：巨型机（超算），大型机，小型机，微型机等，随着超大规模集成电路技术的不断发展，类型的划分会动态变化。\n\n### 1.2 计算机的诞生和发展\n\n计算机之父--冯·诺依曼\nEDVAC（冯·诺依曼思想）\n第一台严格意义上的电子计算机（ENIAC，宾夕法尼亚大学，1946.2）\n\n#### 1.2.1 冯·诺依曼体系\n\n（1）用二进制代码表示程序和数据；\n任何复杂运算和操作都转换成二进制代码表示的指令，数据也用二进制代码来表示\n（2）采用存储程序的工作方式；\n将程序和数据存储起来（存储程序），让计算机自动地执行指令，完成各种复杂的运算操作（核心思想）。\n（3）新型的现代计算机硬件组成；\n存储器，运算器，控制器，输入设备和输出设备\n\n奠定了现代电子计算机的理论基础\n\n#### 1.2.2 计算机的发展历程\n![ltA8PK.png](https://s2.ax1x.com/2020/01/02/ltA8PK.png)\n\n#### 1.2.3 未来的发展趋势\n\n1. 向巨型化方向\n2. 向微型化方向\n3. 向多媒体化方向\n4. 向网络化方向\n5. 向智能化方向\n\n### 1.3 计算机系统的层次结构\n\n硬件：是指构成计算机系统的实体和装置之类的有形设备，是组成计算机系统的物质基础。\n\n软件：是指硬件所表达的各种内在信息，包括数据与控制程序。因为它们是无形的东西，所以称为软件或软设备。\n\n#### 1.3.1 计算机的硬件系统组成\n\n1.硬件系统的基本组成模型\n\n![laAwtI.png](https://s2.ax1x.com/2020/01/03/laAwtI.png)\n\n主要功能部件：\n（1）CPU，主要由运算器，控制器等部件组成\n- 运算器\n\t- 功能：完成两类（算术和逻辑）运算\n\t- 组成特点：\n\t\t- 主要有ALU(算术逻辑单元)构成，执行算术，逻辑运算以及移位循环等操作，是CPU功能的主要执行部件\n\t\t- ALU以全加器为核心，具有多种运算功能\n\t\t- 运算的位数越多，计算精度就越高，但期间也更复杂\n\t\t- 运算器的数据宽度一般是：8/16/32/64位\n- 控制器\n\t- 功能：产生控制命令（微命令），控制全机操作\n\t- 基本组成：![laEWrD.png](https://s2.ax1x.com/2020/01/03/laEWrD.png)\n（2）存储器，存储数据和数字化后的程序\n- 存储单元\n- 地址\n- 存储容量\n- 内存储器（主存）\n- 外存储器（辅存）\n（3）输入输出设备\n（4）总线：能为多个部件分时共享的一组信息传送通路\n- 数据总线\n- 地址总线\n- 控制总线\n（5）接口，具有缓冲，转换，连接的功能的部件\n\n2.计算机硬件的典型架构 \n（1）微型计算机：南-北桥架构\n![3ixYod.png](https://s2.ax1x.com/2020/02/18/3ixYod.png)\n（2）小型计算机：多处理器架构\n![3ixDOS.png](https://s2.ax1x.com/2020/02/18/3ixDOS.png)\n（3）超级计算机（超算）：集群式架构\n[![3izitA.png](https://s2.ax1x.com/2020/02/18/3izitA.png)](https://imgchr.com/i/3izitA)\n（4）多处理机系统结构：用多处理器CPU构成\n根据处理器之间连接的紧密程度，又分为：①紧密耦合型多机系统②松散耦合型多机系统\n\n#### 1.3.2 软件系统\n\n1. 软件类别：**系统程序**和**应用程序**\n（1）系统程序：负责系统调度管理，提供运行和开发环境，各种服务，确保系统运行良好\n（2）应用程序：利用计算机来解决应用问题所编制的程序，如工程设计程序，数据处理程序，自动控制程序，企业管理程序，情报检索程序，科学计算程序等等\n\n#### 1.3.3 硬，软件系统层次结构\n计算机系统是一个由多层次的软件和硬件组成的系统，基本结构如下图所示：\n![3FIup4.png](https://s2.ax1x.com/2020/02/18/3FIup4.png)\n\n#### 1.3.4 软件和硬件的逻辑等价性\n1. 软件的特点：易于实现各种逻辑与运算功能，但是常受到速度指标和软件容量的制约\n\n2. 硬件的特点：可以高速实现逻辑和运算的功能，但是难以实现复杂功能或计算，受到控制复杂性指标的制约\n\n**计算机中的软件，理论上都可以“固化”或“硬化”成硬件，以提高执行速度**\n\n### 1.4 计算机系统的性能指标\n\n1.基本字长\n（1）指一次数据操作的基本位数\n（2）会影响计算的精度，指令的功能\n2.外频\n外频：外部频率或基频，也叫系统时钟频率\n[![3Fz9aQ.png](https://s2.ax1x.com/2020/02/18/3Fz9aQ.png)](https://imgchr.com/i/3Fz9aQ)\n3.常用的CPU性能指标\n（1）CPU的主频=外频✖倍频系数\n（2）IPS，每秒执行指令数\n（3）CPI，每一个指令执行过程中所需的时钟周期数量；\n（4）FLOPS，每秒执行浮点运算的次数\n（5）CPU的功耗\n![3kSmlt.png](https://s2.ax1x.com/2020/02/18/3kSmlt.png)\n静态功耗是由于半导体电路自身的损耗造成的功耗\n\n4.数据传输率\n带宽=（位宽✖工作频率）/8（B/S）\n物理含义：单位时间内数据的传输量。\n注意：计算PCI-E总线的带宽时，一般还要考虑编码方式，单双工模式和通道路数等。\n![3kpqPJ.png](https://s2.ax1x.com/2020/02/18/3kpqPJ.png)\n\n5.存储器的容量\n![3k99aD.png](https://s2.ax1x.com/2020/02/18/3k99aD.png)\n\n## 第二章 数据的表示，运算与校验\n\n### 2.1 数值及其相互转换\n\n#### 2.1.1 进位计数制\n1.数值的基与权\n在任一数制中，每一数位上允许使用的计数符号的个数被称为该数制的**基数**。\n每1位都对应1个表示该位在数码中的位置的值，这个值就称为数位的**权值**w。\n![3kCGfH.png](https://s2.ax1x.com/2020/02/18/3kCGfH.png)\n2.常用进位制：2进制，8进制，16进制\n3.进制之间的转换","tags":["大学课程","组成原理"],"categories":["学习笔记"]},{"title":"学习笔记 | 四六级复习卡片","slug":"学习笔记-四六级复习卡片","url":"/posts/10024.html","content":"<div style=\"text-align: center;background-color: #fbdff0;\">\n<div class=\"card\">\n\t<div class=\"headpic\">\n\t\t<img src=\"https://s2.ax1x.com/2019/12/09/Q0YD61.jpg\" alt=\"Q0YD61.jpg\" border=\"0\" />\n\t</div>\n\t<hr class=\"cardhr\">\n\t<div class=\"content\">\n\t\t<strong>高频词汇</strong>\n\t\t<p>candidate n.候选人</p>\n\t\t<p>absence n.缺席，缺乏（absent a.不在场的；缺乏的）</p>\n\t\t<p>abundant a.丰富的；大量的</p>\n\t\t<p>accidental a.偶然的（accident n.事故）</p>\n\t\t<p>agriculture n.农业，农学</p>\n\t\t<p>appropriate a.适当的，恰当的</p>\n\t\t<p>barrier n.障碍，栅栏</p>\n\t\t<p>sibling n.兄，弟，姐，妹</p>\n\t\t<p>demonstrate v.证明</p>\n\t\t<p>facilitate v.促进</p>\n\t\t<p>plunge v.暴跌,骤降n.骤降</p>\n\t\t<p>recruit v.吸收，招募</p>\n\t\t<p>commit v.自杀，犯罪，承诺</p>\n\t\t<p>advocate v.拥护</p>\n\t\t<p>asset n.资产</p>\n\t\t<p>diversity n.多样性</p>\n\t\t<p>institute n.学院；学会</p>\n\t\t<p>empire n.帝国；大企业</p>\n\t\t<p>economic 与财政相关<-->economical 与节约相关</p>\n\t\t<p>insure 保险<-->ensure  确保</p>\n\t\t<p>considerable 相当多（大）的<-->considerate 体谅的</p>\n\t\t<p>invalueable 非常贵重的<-->valueless 毫无价值的</p>\n\t\t<p>sensitive 敏感的<-->sensibl 明智的</p>\n\t\t<p>complement 补全<-->compliment 赞辞</p>\n\t\t<P>resist 抵制<-->persist 坚持</P>\n\t\t<p>principal 最重要的<-->principle 原则，定律</p>\n\t\t<p>intense 强烈的<-->intensive 精深的</p>\n\t</div>\n</div>\n<div class=\"card\">\n\t<div class=\"headpic\"><img src=\"https://s2.ax1x.com/2019/12/22/QzAz8O.jpg\" alt=\"QzAz8O.jpg\" border=\"0\" /></div>\n\t<div class=\"hr\"></div>\n\t<div class=\"content\">\n\t\t<strong>英语六级翻译预测</strong>\n<p>\n一，垃圾分类<br>\n【题干:】<br>\n       随着人民生活水平和消费水平的提高，中国的垃圾问题日益严峻。很多城市被垃圾包围。<br>\n       面对日益增长的垃圾产量和环境状况的恶化，中国政府正在努力推行垃极分类(garbage classification)的政策。<br>\n　　垃圾分类是指将垃圾分为可回收利用和不可回收利用两类，要求人们将垃圾投放至不同的垃圾桶(trash can)，通过不同的清理、运输和回收方式，使之变成新的资源。<br>\n　　它可以减少垃圾处理量，降低处理成本，减少土地资源的消耗，对社会、经济、生态三方面都有益。<br>\n</p>\n<p>\n【参考译文:】<br>\n　　With the improvement of people's living standards and the increase in consumption level, the garbage problem in China becomes increasingly urgent. Many cities are surrounded by garbage.<br>\n　　Confronted with the growing garbage output and deteriorating environment, the Chinese government is implementing the policy of garbage classification with great effort.<br>\n　　Garbage classification means dividing garbage into recyclable and unrecyclable, and requires people to put garbage into different trash cans so that it can become new resources through different ways of cleaning, transporting and recycling.<br>\n　　It can reduce not only the amount of garbage that needs to be disposed of, but also the deposing cost and the usage of the land, benefiting our society, economy, and environment.<br>\n　　【难点点拨：】<br>\n　　1. 第二句中的“面对日益增长的垃圾产量和环境状况的恶化”，其逻辑主语是后面的“中国政府”，故此处可采用过去分词短语作状语，置于句首，译成confronted with the growing garbage output and deteriorating environment。<br>\n　　2.“垃圾分类是指将垃圾分为…使之变成新的资源”句子较长，由三个短句组成，第一、第二个短句主语均是“垃圾分类”，因此可用and连接两个谓语“是指”和“要求”。<br>\n　　“要求人们…”用require sb.to do结构。“通过……方式使之变成新的资源”可看作是“人们将垃圾投放至不同的垃圾桶”的结果，可用so that连接，加强句子逻辑。<br>\n　　3.最后一句的主干可理解为“它可以减少…，降低…，减少…”，三个谓语动词都可用reduce来翻译，因此可共一个动词，后接不同的宾语，用not only...but also...连接。“对社会、经济、生态三方面都有益”则可处理成现在分词短语benefiting...,表结果。<br>\n二，一带一路<br>\n【题干：】<br>\n“一带一路”(The Belt and Road)是“丝绸之路经济带”和“21世纪海上丝绸之路”的简称。它将充分依靠中国与有关国家既有的双多边机制，借助既有的、行之有效的区域合作平台。一带一路旨在借用古代丝绸之路的历史符号，高举和平发展的旗帜，积极发展与沿线国家的经济合作伙伴关系，共同打造政治互信、经济融合、文化包容的利益共同体、命运共同体和责任共同体。<br>\n【参考译文：】<br>\n　　“The Belt and Road” is short for the Silk Road Economic Belt and the 21st-Century Maritime Silk Road. It will fully depend on the bi-lateral and multi-lateral mechanism between China and its related nations with the help of existing and effective regional cooperation platforms. It aims to use the historic symbol of the ancient Silk Road, raise the flag of peace and development, and develop the economic partnership with nations along the line positively, in order to build a community of interests with trustful politics, integrated economy and inclusive culture, a community with a shared future, a community with common responsibilities.<br>\n三，郑和下西洋<br>\n【题干：】<br>\n    明朝(the Ming Dynasty)初期,中国是世界上最发达的国家之一。为了弘扬国力、加强与其他各国的联系,明成祖多次派遣郑和出使西洋。1405年,郑和开始了第一次航行。他的舰队由200多艘船构成,所载人数超过2万人,包括水手、军人、技术人员、译员等,还有大量黄金和丝绸,用于交易和作为礼品。往返用了两年时间。郑和出使的一些国家随船派遣使者(envoy),并带来向明朝进贡的贡品(tribute)。郑和下西洋是世界航海史上的一大壮举(feat)。今天,东南亚仍有很多纪念郑和的建筑。<br>\n【参考译文：】    <br>\n    In the early Ming Dynasty, China was one of the most developed countries in the world.In order to transmit its national power and strengthen contacts with other countries,Emperor Chengzu sent Zheng He to the Western Ocean many times.In 1405,Zheng He embarked on his first voyage.His fleet was composed of more than 200 ships and carried over 20,000 men,including sailors,soldiers,technical personnel,interpreters etc.,and large amounts of gold and silk to be used for trade and as gifts.The round trip took two years.Some of the countries Zheng He visited dispatched envoys bearing tributes to the Ming court on his ships.Zheng He's voyages were a great feat in the world's navigation history.Today,there are still many buildings in Southeast Asia dedicated to his memory.<br>\n四，故宫<br>\n【题干：】<br>\n　　故宫，又名紫禁城，为明清共二十四位皇帝统治中国近500年的皇宫。它位于北京市中心，在天安门广场的北侧，形状为长方形。南北长960米，东西宽 750米，占地72公顷，总建筑面积达15万平方米。故宫是世界上现存规模最大、最完整的古代木构宫殿。它分为外朝和内廷两部分，外朝是皇帝上朝处理国家大事的地方，内廷是皇帝和皇室的居住地。1987年，故宫被联合国教科文组织列入世界文化遗产。<br>\n【翻译词汇：】<br>\n　　故宫 the Imperial Palace<br>\n　　紫禁城 the Forbidden City<br>\n　　天安门广场 Tian’anmen Square<br>\n　　长方形 rectangular<br>\n　　建筑面积 floor space<br>\n　　现存 in existence<br>\n　　上朝 give audience<br>\n　　处理 handle<br>\n　　世界文化遗产 World Cultural Heritage<br>\n【参考译文：】<br>\n　　The Imperial Palace, also called the Forbidden City was the palace where the 24 emperors of the Ming and Qing Dynasties ruled China for roughly 500 years. The Imperial Palace is located in the center of Beijing, on the northern side of Tian’anmen Square, rectangular in shape, 960 meters from north to south and 750 meters wide from east to west, with an area of 72 hectares and a total floor space of 150 000 square meters. It’s the world’s largest and most integral palace made of wood in existence. The Forbidden City is divided into two parts: the outer court and the inner court. The outer court was the place where the emperors gave audience and handled state affairs, while the inner court was the living quarters for the emperors and their families. In 1987 the Imperial Palace was listed by the UNESCO as one of the World Cultural Heritage sites.<br>\n五，孔子<br>\n【题干：】<br>\n孔子(Confucius)是我国古代著名的思想家、教育家，儒家学派(Confucian School)的创始人。相传孔子有弟子三千，贤弟子72人，孔子曾带领部分弟子周游列国14年。在中国五千年的历史上，对华夏民族的性格、气质 (temperament)产生最大影响的人就算是孔子了。他正直（upright）、乐观向上、积极进取。他一生都在追求真、善、美，一生都在追求理想的社会。他品格中的优点，几千年来影响着中国人，特别是影响着中国的知识分子。<br>\n【参考译文：】<br>\nConfucius is a famous ideologist, educator, and the founder of Confucian School in ancient China. It's said he has 3,000 disciples, 72 out of whom are excellent ones, and he has led some disciples to visit various states for 14 years. During 5,000 years' history of China, it's Confucius who has exerted the greatest impact on Chinese nation's characteristic and temperament. He is upright,optimistic, active and enterprising, striving for truthfulness, kindness and beauty, and seeking for an ideal society all his life. The shining points in his characteristics have been influencing the Chinese people, especially the Chinese intellectuals for thousands of years.<br>\n六，皇帝<br>\n【题干：】<br>\n皇帝是中国封建社会(feudal society)最高统治者。秦王赢政统一中国之后，称自己为皇帝。自此，中国开始了长达2132年的皇帝统治时期。到1912年中国最后一个皇帝溥仪退位，中国历史上共有495位皇帝。皇帝一人掌握国家政策制定、军事决策等全部大权，决定着国家和人民的命运。中国历史上有许多英明的皇帝，他们勤政爱民，制定了许多合理的政策，促进了经济和社会的发展。还有一些残暴无能的皇帝，他们带给了人民无尽的灾难，受到人民的激烈反抗。<br>\n【参考译文:】<br>\n　　Emperor was the supreme ruler of the feudalsociety in China. After Yingzheng, the king of Qin,unified China, he called himself Emperor. Sincethen, China had entered a period of emperors'reign,which lasted for 2,132 years. There were totally 495emperors in the history of China until 1912, when Puyi, the last emperor of China gave up thethrone. Emperors dominated all the rights of policy making and military decision and so on.They were the only ones who could decide the fate of the country and its people. In Chinesehistory many wise emperors were diligent in politics and loved their people. They made manyreasonable policies to promote the development of economy and society. There were alsomany cruel and incompetent emperors who brought endless disasters to the people and wereresisted fiercely.<br>\n【解析：】<br>\n    1.第一句中，“中国封建社会”可用of带出，放在所修饰的名词后面作定语，符合英文表达习惯。<br>\n　　2.第三句中“长达2132年的”译为英语时可用which引导的非限制性定语从句来表达，放在中心词后面，使译文前后平衡，避免头重脚轻。<br>\n　　3.“到1912年中国最后一个皇帝…”一句的主句采用there be句型，说明中国历史上皇帝的数量;再用until对时间范围进行限制;在“1912”后面使用when引导的定语从句，说明该年份的特殊性：最后一个皇帝退位。<br>\n　　4.“皇帝一人掌握…国家和人民的命运”一句偏长，可拆译成两个句子。后半句“决定着国家和人民的命运”翻译时增译主语“皇帝一人”，虽然原文说的是“一个人”，但由于历朝历代都有很多皇帝，因此要处理成复数：theywere the only ones，后面再加who引导的定语从句。<br>\n　　5.最后一句中的“他们带给…”译为who引导的定语从句，指代前面的emperors，使译文避免了代词的重复，也使译文的句式更加多样化。<br>\n七，5G<br>\nChina is expected to launch a commercial operation of 5G (5th generation) mobile networks in 2020, and to realize a large-scale application in 2022 or 2023, an expert with the Ministry of Industry and Information Technology (MIIT) of China said here in a recent interview with Xinhua.<br>\n　　中国将在2020年推出5G(第5代)移动网络的商业运营，并在2022年或2023 年实现大规模应用，中国工业和信息化部(MIIT)的专家最近接受新华社记者采访时说。<br>\n　　Wang Zhiqin, an expert with the China Academy of Telecommunication Research of MIIT, said China started 5G research and development as early as other countries. In 2013, the Chinese government established IMT-2020 (5G) Promotion Group, to boost systematic promotion of 5G.<br>\n　　中国工信部电信研究院专家王志勤说，中国早在其他国家之前就开始了5G的研发。2013年，中国政府成立了IMT-2020(5G)推进组，促进5G系统推广。<br>\n　　As one of the leaders of the group, Wang said MIIT coordinated to conduct the worldwide biggest experiment of 5G technology research and development in January this year, and completed the phase 1 test in September.<br>\n　　作为推进组领导之一的王先生表示，工信部今年1月协调开展了全球最大的5G技术研发实验，并于9月完成了第一阶段的测试。<br>\n　　\"China is willing to formulate a unified global 5G standard with other countries,\" She said, adding that the global research on 5G standard started in March, and it is estimated that the first version will be completed in June, 2018.<br>\n　　“中国愿意与其他国家制定统一的全球5G标准”她说，并补充说，5G标准的全球研究于3月开始，预计第一版将于2018年6月完成。<br>\n　　\"We started early and have accumulated a lot of experience,\" Wang said. \"I hope China can be one of the ’dominant players’ in standard formulation.\"<br>\n　　“我们开始得很早，积累了很多经验，”王说。“我希望中国可以成为标准制定的‘主导者’之一。<br>\n　　She explained that telecommunication is a globalized and huge industry, and customers are looking forward to a unified standard, \"we need to be more responsible and cooperate with the international mainstream enterprises.\"<br>\n　　她解释说，电信是一个全球化的巨大产业，客户期待着统一的标准，“我们需要更加负责任地与国际主流企业合作。”<br>\n　　She said 5G is designed for Internet of Everything (IoE), and 4G offers mobile Internet to people. As the increasing need for low delay and high reliability, 4G faces big challenges.<br>\n　　她说，5G是为一切互联网(IoE)设计的，4G为人们提供移动互联网。随着对低延迟和高可靠性的日益增长的需求，4G面临着巨大的挑战。<br>\n　　\"Time delay of 4G is from 10ms to 20ms, but some application scenarios with low delay and high reliability requires less than 0.5ms,\" Wang said, \"and 5G can do that.\"<br>\n　　“4G的延时是10到20毫秒，但是一些具有低延迟和高可靠性的应用场景要求不到0.5毫秒，”王说，“5G可以做到。”<br>\n　　She took automatic drive as example - \"to realize automatic drive, vehicles should be connected with each other and have the ability to avoid crashes in high speed, which needs a very low time delay.\"<br>\n　　她以自动驾驶为例——“为了实现自动驾驶，车辆应该彼此连接，并具有避免高速撞击的能力，这需要非常低的时间延迟。”<br>\n　　China has attached great importance to 5G in the 13th national Five-Year Plan (2016-2020) and has set the goal of 5G commercialization by 2020.<br>\n　　中国在十三五规划(2016-2020)中十分重视5G，设立到2020年实现5G的商业化目标。</p>\n\t</div>\n</div>\n<div class=\"card\">\n<div class=\"headpic\"><img src=\"https://s2.ax1x.com/2019/12/22/QzVLh6.jpg\" alt=\"QzVLh6.jpg\" border=\"0\" /></div>\n</div>\n<style>\n\t.card{\n\t\tbackground:var(--mj-card-bg);\n\t\twidth:70%;\n\t\tmargin-left: 15%;\n\t\tmargin-top:15px;\n\t\tpadding:15px;\n\t\tborder-radius:15px;\n\t\tbox-shadow: 0 1px 3px rgb(234, 234, 234);\n\t\ttext-align:center;\n\t}\n\t.cardhr{\n\t\twidth: 90%;\n\t\tmargin-left: 5%;\t\t\n\t}\n\t.content{\n\t\ttext-align:left; \n\t\tcolor: var(--mj-fontcolor);\n\t}\n</style>\n</div>","tags":["大学课程"],"categories":["学习笔记"]},{"title":"大学课程 | 《算法分析与设计》笔记","slug":"学习笔记-算法分析与设计","url":"/posts/16050.html","content":"大三算法设计与分析笔记总结与知识点整理\n<!-- more -->\n<h1 style=\"text-align: center;\">笔记总结</h1>\n\n# 第一章 算法引论\n\n## 1.1 算法与程序\n\n- 算法定义：解决问题的方法或过程\n- 算法的性质：\n    - （1）输入：有零个或多个外部量作为算法的输入\n    - （2）输出：算法产生至少一个量作为输出\n    - （3）确定性：组成算法的每条指令是清晰的，无歧义的\n    - （4）有限性：算法中每条指令的执行次数有限，执行每条指令的时间也有限\n    - 有时还会加入通用性或可行性\n- 程序的定义：是算法用某种程序设计语言的具体实现。\n- 程序与算法的区别：程序可以不满足算法的第四点性质即有限性。例如操作系统，是在无限循环中执行的程序。\n\n## 1.2 表达算法的抽象机制\n- 为了将顶层算法与底层算法隔开，使二者在设计时不互相牵制，互相影响，必须对二者的接口进行抽象。让底层只通过接口为顶层服务，顶层也只通过接口调用底层运算。这个接口就是**抽象数据类型**(ADT)。\n\n## 1.3 描述算法\n- 有多种方式，如：自然语言方式，表格方式，高级程序语言方式等...\n\n## 1.4 算法复杂性分析\n- 算法分析的目的：分析算法占用计算机资源的情况，对算法做出比较和评价，设计出更好的算法\n- 算法的复杂性是算法运行时所需的计算机资源的量，需要时间资源的量称为**时间复杂性**，需要空间资源的量称为**空间复杂性**。\n- C=F(N,I,A)，用N，I，A分别表示算法要解的问题的规模，算法的输入和算法本身，F表示是上诉N，I，A的确定的三元函数，C表示复杂性\n- 一般只考虑3种情况下的时间复杂性，即最坏情况，最好情况，平均情况\n- 实践表明，可操作性最好且最有实际价值的是**最坏情况下的时间复杂性**。\n- 复杂性渐进性态：\n```\n对于T(N)，如果存在~T(N)，使得当N→∞时有(T(N)-~T(N))/T(N)→0，那么就说~T(N)是T(N)当N→∞时的渐进性态。\n```\n- 如果存在正的常数C和自然数N0，使得当N≥N0时有f(N)≤Cg(N)，则称函数f(N)当N充分大时上有界，且g(N)是它的一个上界，记为f(N)=O(g(N))。这时还说f(N)的阶不高于g(N)的阶。\n- 对于符号O，有如下运算规则：\n    - O(f)+O(g)=O(max(f,g))\n    - O(f)+O(g)=O(f+g)\n    - O(f)O(g)=O(fg)\n    - 如果g(N)=O(f(N)),则O(f)+O(g)=O(f)\n    - O(Cf(N))=O(f(N)),其中C是一个正的常数\n    - f=O(f)\n\n\n# 第二章 递归与分治策略\n\n## 2.1 递归的概念\n- 直接或间接地调用自身的算法称为**递归算法**。用函数自身给出定义的函数称为`递归函数`\n- 递归函数的两个要素：`边界条件`和`递归方程`\n- 阶乘函数：\n```C++\n#include<iostream>\nusing namespace std;\n\nint factorial(int n){\n    if(n==0) return 1;\n    else{\n        return n*factorial(n-1);\n    }\n}\n```\n- Fibonacci数列：\n```C++\n#include<iostream>\nusing namespace std;\n\nint fibonacci(int n){\n    if(n<=1) return 1;\n    else return fibonacci(n-1)+fibonacci(n-2);\n} \n```\n\n- hanoi塔：\n```python\ndef hanoi(n,a,b,c):\n    #将a上的n个圆盘经过c移动到b\n    if(n>0):\n        hanoi(n-1,a,c,b)\n        move(a,b)\n        hanoi(n-1,c,b,a)\n```\n\n- 递归算法的优点：结构清晰，可读性强，容易用数学归纳法来证明算法的正确性\n- 递归算法的缺点：运行效率低，无论是耗费的计算时间还是占用的存储空间都比非递归算法多。\n\n- 消除递归的方法：①采用一个用户定义的栈来模拟系统的递归调用工作栈，从而达到将递归算法改为非递归算法的目的②用递推来实现递归函数\n\n## 2.2 分治法的基本思想\n- 分治法的基本思想：将一个规模为n的问题`分解`为k个规模较小的子问题，这些子问题`相互独立`且与原问题`相同`。递归地解这些子问题，然后将各子问题的解`合并`得到原问题的解。\n- 分治法的适用条件：\n\t- ①该问题的规模缩小到一定程度容易解决。\n\t- ②该问题可以分解为若干个规模较小的相同问题。即该问题具有最优子结构性质。\n\t- ③该问题分解出的子问题的解可以合并为该问题的解。\n\t- ④子问题间不包含公共的子问题（各子问题相互独立）\n- 分治法的步骤：\n\t- 划分\n\t- 解决\n\t- 合并\n\n## 2.3 二分搜索技术\n```python\ndef binarySearch(a,x):\n\t#a是数组,x是要搜索的数\n\ta=sorted(a)\n\t#a要求有序（从小到大）\n\tn=len(a)\n\tleft,right=0,n-1\n\twhile(left<=right):\n\t\tmiddle=(left+right)//2\n\t\tif(x==a[middle]):\n\t\t\treturn middle\n\t\telif(x>a[middle]):\n\t\t\tleft=middle+1\n\t\telse:\n\t\t\tright=middle-1\n\t#未找到\n\treturn -1\n```\n- 最坏情况下，时间复杂度是O(logn)\n\n## 2.4 大整数乘法\n- 设x和y都是n位的二进制整数，现在要计算他们的乘积xy。如果直接相乘，需要O(n^2)步，而其分治法是：将n位二进制整数X和Y都分为2段，每段的长为n/2位：\n```\nX=[A][B],Y=[C][D],其中X，Y有n位；A，B，C，D均有n/2位\n由此可以得到：\nX=A*2^(n/2)+B , Y=C*2^(n/2)+D\n\nXY=(A*2^(n/2)+B)(C*2^(n/2)+D)\n  =A*C*2^n+(A*D+C*B)*2^(n/2)+B*D\n  =A*C*2^n+((A-B)(D-C)+A*C+B*D)*2^(n/2)+B*D\n\n最后一个式子看起来似乎复杂了，但是它仅需做3次n/2位整数的乘法，6次加减法和2次移位\n```\n\n## 2.5 Strassen矩阵乘法\n- 对于方阵（n\\*n）A,B,C，有C=A\\*B,将它们都分块成4个大小相等的子矩阵，每个子矩阵都是`(n/2)*(n/2)`的方阵\n- ![MhaKxS.png](https://s2.ax1x.com/2019/11/20/MhaKxS.png)\n\n## 2.7 合并排序\n```python\ndef merge(arr,left,mid,right):\n    #left，right为需要合并的数组范围\n    #mid为中间下标，左边比中值小，右边比中值大\n    i=left\n    j=mid+1\n    #复制一个临时数组\n    aux=arr[:]\n    for k in range(left,right+1):\n        #如果左指针超过mid，即右边还有剩余\n        if(i>mid):\n            arr[k]=aux[j]\n            j=j+1\n        #如果右指针超过right，即左边还有剩余\n        elif(j>right):\n            arr[k]=aux[i]\n            i=i+1\n        #如果左边小，则左边合并\n        elif(aux[i]<aux[j]):\n            arr[k]=aux[i]\n            i=i+1\n        #如果右边小\n        else:\n            arr[k]=aux[j]\n            j=j+1\n\n\ndef mergeSort(arr,left,right):\n    #如果已经遍历完\n    if(left>=right):\n        return ;\n    #取中值，拆成左右两边\n    mid=(left+right)//2\n    #对左半边进行归并排序\n    mergeSort(arr,left,mid)\n    #对右半边进行归并排序\n    mergeSort(arr,mid+1,right)\n    #合并算法\n    merge(arr,left,mid,right)\n```\n- 最坏情况下的时间复杂度为O(nlogn)\n\n## 2.8 快速排序\n- 步骤：分解，递归求解，合并\n```python\ndef quicksort(arr,low,high):\n    if low<high :\n        index=getindex(arr,low,high)\n        quicksort(arr,low,index-1)\n        quicksort(arr,index+1,high)\n\n#快速排序算法核心\n#作用：将小于基准值的数放在其左边，大于在右边\ndef getindex(arr,low,high):\n    #默认第一个数字为标准值\n    temp=arr[low]\n    #当未遍历完，即左右指针未相遇\n    while(low<high):\n        #如果右边大于标准值，右指针左移\n        while((low<high)and(arr[high]>=temp)):\n            high=high-1\n        #此时右指针对应值小于标准值，将其复制给左指针位置\n        arr[low]=arr[high]\n        #当左边小于标准值，左指针右移\n        while((low<high)and(arr[low]<=temp)):\n            low=low+1\n        #此时左指针对应值大于标准值，将其复制给右指针位置\n        arr[high]=arr[low]\n    #将标准值赋值给左右指针相遇的位置\n    arr[low]=temp\n    #此时low左边全部小于等于arr[low],low右边全部大于等于arr[low]\n    return low\n```\n\n- 快排平均情况下的时间复杂度是O(nlogn)，最坏情况下的时间复杂度是O(n^2)\n\n## 2.9 线性时间选择\n- 找出一组数中，第X大（小）的数\n- 采用了随机划分算法\n\n## 2.10 最近点对问题\n- 时间复杂度分析O(nlogn)\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 最近点对问题\n\"\"\"\n\n#按x坐标排序的点\nclass Point1:\n    #x,y为坐标，id为序号\n    def __init__(self,xx,yy,index):\n        self.x=xx\n        self.y=yy\n        self.id=index\n\n\n#按y坐标排序的点\nclass Point2(Point1):\n    #x，y为坐标，id为该点按x排序时的序号\n    def __init__(self,xx,yy,index):\n        self.x=xx\n        self.y=yy\n        self.id=index\n        \n#表示输出的平面点对\nclass Pair:\n    #a，b为点，dist为距离\n    def __init__(self, aa, bb,dd):\n        self.a=aa\n        self.b=bb\n        self.dist=dd\n    \n#求平面上任意两点u,v的距离\ndef dist(u,v):\n    dx=u.x-v.x\n    dy=u.y-v.y\n    return dx*dx+dy*dy\n\n#归并排序\ndef merge(S,order,left,mid,right):\n    i=left\n    j=mid+1\n    aux=S[:]\n    #按x排序\n    if(order=='x'):\n        for k in range(left,right+1):\n            if(i>mid):\n                S[k]=aux[j]\n                j=j+1\n            elif(j>right):\n                S[k]=aux[i]\n                i=i+1\n            elif(S[i].x<aux[j].x):\n                S[k]=aux[i]\n                i=i+1\n            else:\n                S[k]=aux[j]\n                j=j+1\n    #按y排序\n    elif(order=='y'):\n        for k in range(left,right+1):\n            if(i>mid):\n                S[k]=aux[j]\n                j=j+1\n            elif(j>right):\n                S[k]=aux[i]\n                i=i+1\n            elif(S[i].y<aux[j].y):\n                S[k]=aux[i]\n                i=i+1\n            else:\n                S[k]=aux[j]\n                j=j+1\n\n#归并排序\ndef mergeSort(S,x,left,right):\n    if(left>=right):\n        return ;\n    mid=(left+right)//2\n    mergeSort(S,x,left,mid)\n    mergeSort(S,x,mid+1,right)\n    merge(S,x,left,mid,right)\n\n#计算最接近点对\ndef closePair(S,Y,Z,l,r):\n    #两个点\n    if(r-l==1):\n        return Pair(S[l],S[r],dist(S[l],S[r]))\n    #三个点\n    if(r-l==2):\n        d1=dist(S[l],S[l+1])\n        d2=dist(S[l+1],S[r])\n        d3=dist(S[l],S[r])\n        if((d1<=d2)and(d1<=d3)):\n            return Pair(S[l],S[l+1],d1)\n        if(d2<=d3):\n            return Pair(S[l+1],S[r],d2)\n        else:\n            return Pair(S[l],S[r],d3)\n    #多于三个点\n    m=(l+r)//2\n    f=l\n    g=m+1\n    for i in range(l,r+1):\n        if(Y[i].id>m):\n            Z[g]=Y[i] \n            g=g+1\n        else:\n            Z[f]=Y[i]\n            f=f+1\n    #递归求解\n    best = closePair(S,Z,Y,l,m)\n    right = closePair(S,Z,Y,m+1,r)\n    #选最近的点对\n    if(right.dist<best.dist):\n        best=right\n    merge(Y,\"y\",l,m,r)\n\n    k=l\n    #距离中线最近的\n    for i in range(l,r+1):\n        if(abs(S[m].x-Y[i].x)<best.dist):\n            Z[k]=Y[i]\n            k=k+1\n    for i in range(l,k):\n        for j in range(i+1,k):\n            if(Z[j].y-Z[i].y<best.dist):\n                dp=dist(Z[i],Z[j])\n                if(dp<best.dist):\n                    best=Pair(S[Z[i].id],S[Z[j].id],dp)\n    #返回最近点对\n    return best\n\n\n#一维点集\ndef cpair1(S):\n    #先设为正无穷\n    min_d=float(\"inf\")\n    S=sorted(S)\n    for i in range(1,len(S)):\n        dist=abs(S[i]-S[i-1])\n        if(dist<min_d):\n            pair=[]\n            min_d=dist\n            pair.append([S[i-1],S[i]])\n        elif(dist==min_d):\n            pair.append([S[i-1],S[i]])\n    print(\"Closest point:\")\n    for i in pair:\n        print(i,end=\" \")\n    print(\"\\nMin_dist:\",min_d)\n\n#二维点集\ndef cpair2(S):\n    Y=[]\n    n=len(S)\n    if(n<2):\n        return ;\n    #按X坐标排序\n    mergeSort(S,\"x\",0,n-1)\n    #以Point2类型赋值\n    for i in range(n):\n        p=Point2(S[i].x,S[i].y,i)\n        Y.append(p)\n    #按y坐标排序\n    mergeSort(Y,\"y\",0,n-1)\n    Z=Y[:]\n    return closePair(S,Y,Z,0,n-1)\n    \n    \ndef main():\n    #输入一维还是二维点平面\n    model=input(\"Please choose model of '1' or '2':\").split()[0]\n    S=[]\n    #一维点对\n    if(model == '1'):\n        point=input(\"Please input a group of number in order:\\n\").split()\n        #如果输入空点对\n        if(len(point)==0):\n            raise ValueError(\"您输入了空点对！\")\n        #转换类型\n        for i in range(len(point)):\n            S.append(int(point[i]))\n        #输出最近点对\n        cpair1(S)\n    #二维点对\n    elif(model == '2'):\n        #输入点数\n        n=int(input(\"Please input how many points:\\n\"))\n        if(n==0):\n            raise ValueError(\"您输入了0个点！\")\n        for i in range(n):\n            words=f\"please input the No.{i+1} point (like: x y) in x order:\"\n            point=input(words).split()\n            p=Point1(int(point[0]),int(point[1]),i)\n            S.append(p)\n        #找到最近的一对点对\n        best=cpair2(S)\n        print(f\"The closest points are ({best.a.x},{best.a.y}) and ({best.b.x},{best.b.y}).\")\n        print(f\"And the distance is {best.dist**0.5}.\")\n    else:\n        raise ValueError(\"没有这个选项！\")\n\nif __name__ == \"__main__\":\n    #异常处理\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n# 第三章 动态规划\n- 动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解，但与分治法不同的是，适用于动态规划法求解的问题，经分解得到的子问题往往不是相互独立的。\n- 动态规划算法的步骤：\n\t- ①找出最优解的性质，并刻画其结构特征\n\t- ②递归地定义最优值\n\t- ③以自底向上的方式计算出最优值\n\t- ④根据计算最优值时得到的信息，构造最优解\n- 动态规划算法的两个基本要素：`最优子结构`与`重叠子问题`\n    - 最优子结构性质：问题的最优解包含子问题的最优解\n    - 重叠子问题：在用递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次\n    - 无后效性：一个问题被划分阶段后，阶段I中的状态只能由I+1中的状态通过状态转移方程得来，与其他状态没有关系，特别是与未发生的状态没有关系\n- 动态规划算法有一个变形方法——备忘录方法，这种方法不同于动态规划算法“自底向上”的填充方向，而是“自顶向下”的递归方向，为每一个解过的子问题建立一个记录项（备忘录）以备需要时查看，也可以避免相同子问题的重复求解\n\n## 3.1 矩阵连乘问题\n- ![MIK2dK.png](https://s2.ax1x.com/2019/11/21/MIK2dK.png)\n- m(i,j)是指从A[i]到A[j]（1≤i≤j≤n）的最少数乘次数\n- 矩阵可乘条件：A的列数等于B的行数，若A是一个p×q矩阵，B是一个q×r矩阵，则AB总共需要pqr次数乘。\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 矩阵连乘问题\n\"\"\"\n\n#计算最优值\ndef matrixChain(p,m,s):\n    #m[i][j]表示A[i]到A[j]所需的最少数乘次数\n    #s[i][j]表示A[i]到A[j]所需的最少数乘法对应的分隔位置\n    n=len(p)-1\n    for r in range(2,n+1):\n        for i in range(1,n-r+2):\n            #沿斜线方向递进\n            j=r+i-1\n            m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]\n            s[i][j]=i\n            k=i+1\n            #寻找i到j间最优分隔k\n            while(k<j):\n                t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]\n                if(t<m[i][j]):\n                    m[i][j]=t\n                    s[i][j]=k\n                k=k+1\n\n#根据S递归输出\ndef traceback(s,i,j):\n    if(i==j):\n        print(f\"A[{i}]\",end=\"\")\n        return ;\n    print(\"(\",end=\"\")\n    traceback(s,i,s[i][j])\n    traceback(s,s[i][j]+1,j)\n    print(\")\",end=\"\")\n\n\n\ndef main():\n    p=[]\n    y=0\n    #输入矩阵个数\n    n=input(\"Please iuput the number of matrix:\").split()\n    #异常处理\n    if(len(n)==0):\n        raise ValueError(\"您输入了空矩阵！\")\n    n=int(n[0])\n    #输入每个矩阵的信息\n    for i in range(n):\n        s=input(f\"Input No.{i+1} Matrix size,eg:5 5\\n\").split()\n        #判断是否能与前一项相乘\n        if(len(p)>=1):\n            if(y!=int(s[0])):\n                raise ValueError(\"您输入的矩阵不能相乘！\")\n        x,y=int(s[0]),int(s[1])\n        p.append(x)\n    p.append(y)\n    m=[]\n    s=[]\n    for i in range(n+1):\n        m.append([0]*(n+1))\n        s.append([0]*(n+1))\n    matrixChain(p,m,s)  \n    traceback(s,1,n)\n    print(\"\\nCount times:\",m[1][n])\n    \n\n    \n\nif __name__ ==\"__main__\":\n    #异常处理\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n## 3.3 最长公共子序列\n- ![MI179S.png](https://s2.ax1x.com/2019/11/21/MI179S.png)\n建立递归关系：\n- ![MI399U.png](https://s2.ax1x.com/2019/11/21/MI399U.png)\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 最长公共子序列问题\n\"\"\"\n\ndef IcsLength(x,y,b):\n    m=len(x)\n    n=len(y)\n    #初始化\n    c=[]\n    for j in range(m+1):\n        c.append([0]*(n+1))\n    #逐个比较\n    for i in range(1,m+1):\n        for j in range(1,n+1):\n            #如果相等那么此时的最长公共长度为去除该位置的最长公共长度+1\n            if(x[i-1]==y[j-1]):\n                c[i][j]=c[i-1][j-1]+1\n                #记录c[i][j]的值是第一类子问题的解得到的\n                b[i][j]=1\n            #如果对应位置不相等，则比较两个序列去掉这个不等值后哪边的最长子序列会更长\n            elif(c[i-1][j]>=c[i][j-1]):\n                c[i][j]=c[i-1][j]\n                b[i][j]=2\n            else:\n                c[i][j]=c[i][j-1]\n                b[i][j]=3\n    return c[m][n]\n\n#根据b[i][j]输出最长子序列\ndef Ics(i,j,x,b):\n    if(i==0 or j==0):\n        return ;\n    #如果是第一类子问题的解，则说明该位置是公共部分\n    if(b[i][j]==1):\n        Ics(i-1,j-1,x,b)\n        print(x[i-1],end=\"\")\n    #如果是第二类子问题的解，则说明此时Zk≠Xm\n    elif(b[i][j]==2):\n        Ics(i-1,j,x,b)\n    #Zk≠Yn\n    else:\n        Ics(i,j-1,x,b)\n\ndef main():\n    #输入字符串\n    A=input(\"Please input No.1 Ics:\").split()\n    B=input(\"Please input No.2 Ics:\").split()\n    b=[]\n    for i in range(len(A)+1):\n        b.append([0]*(len(B)+1))\n    print(\"The longest length:\",IcsLength(A,B,b))\n    Ics(len(A),len(B),A,b)\n\nif __name__==\"__main__\":\n    #异常处理\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不会合法！出错信息如下：\")\n        print(e)\n```\n\n\n## 3.4 凸多边形最优三角剖分\n- 和矩阵连乘相似\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 凸多边形最优三角剖分问题\n\"\"\"\nfrom isConvex import isConvex\n\n#计算最优值\ndef minWeightTriangulation(n,t,s,v):\n    #t[i][j]是凸子多边形vi-1,vi,...,vj的最优三角剖分对应的权函数值\n    for r in range(2,n+1):\n        for i in range(1,n-r+2):\n            j=r+i-1\n            t[i][j]=t[i+1][j]+weight(i-1,i,j,v)\n            s[i][j]=i\n            k=i+1\n            #遍历i到j的所有边\n            while(k<j):\n                u=t[i][k]+t[k+1][j]+weight(i-1,k,j,v)\n                if(u<t[i][j]):\n                    t[i][j]=u\n                    s[i][j]=k\n                k=k+1\n\n#根据s输出划分结果\ndef traceback(s,i,j):\n    if(i==j):\n        print(f\"B[{i}]\",end=\"\")\n        return ;\n    print(\"(\",end=\"\")\n    traceback(s,i,s[i][j])\n    traceback(s,s[i][j]+1,j)\n    print(\")\",end=\"\")\n\n#根据距离计算权重\ndef weight(i,j,k,v):\n    return dist(i,j,v)+dist(i,k,v)+dist(k,j,v)\n\n#计算距离\ndef dist(i,j,v):\n    return (v[i][0]-v[j][0])**2+(v[i][1]-v[j][1])**2\n\ndef main():\n    v=[]\n    #可选择手动输入和使用默认值\n    ans=input(\"Do you want to use default v[]:(y / n )\")\n    if(ans==\"y\" or ans==\"Y\"):\n        v=[[6,1],[13,1],[16,4],[13,7],[6,7],[3,4]]\n        graph=\"\"\"-----@######@-------\\n----#--------#------\\n---#----------#-----\\n--@------------@----\\n---#----------#-----\\n----#--------#------\\n-----@######@-------\\n\"\"\"\n        print(graph)\n        for i in v:\n            print(f\"({i[0]},{i[1]})\",end=\" \")\n    \n    elif(ans==\"n\" or ans==\"N\"):\n        n=int(input(\"Please input the number of points:\\n\"))\n        if(n==0):\n            raise ValueError(\"您输入了0！\")\n        for i in range(n):\n            a=input(f\"Input X and Y of No.{i+1} point:(eg:X Y)\\n\").split()\n            v.append([int(a[0]),int(a[1])])\n        \n    else:\n        raise ValueError(\"对不起没有这个选项！\")\n    #判断是不是图多边形\n    if(not isConvex(v)):\n        raise ValueError(\"您输入的不是凸多边形！请确认是否按顺序输入！\")\n    t=[]\n    s=[]\n    n=len(v)\n    #初始化\n    for i in range(n):\n        t.append([0]*(n))\n        s.append([0]*(n))\n    minWeightTriangulation(n-1,t,s,v)\n    traceback(s,0,n-1)\n\nif __name__==\"__main__\":\n    #异常处理\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n判断是否为凸多边形\n\n```python\n#判断是否为凸多边形\n'''\n计算直线表达式\nparam vertex1: 前一个顶点\nparam vertex2: 后一个顶点\nreturn (type, param): 返回直线的类别及其描述参数\n'''\ndef kb(vertex1, vertex2):\n    x1 = vertex1[0]\n    y1 = vertex1[1]\n    x2 = vertex2[0]\n    y2 = vertex2[1]\n    \n    if x1==x2:\n        return (0, x1)      # 0-垂直直线\n    if y1==y2:              \n        return (1, y1)      # 1-水平直线\n    else:\n        k = (y1-y2)/(x1-x2)\n        b = y1 - k*x1\n        return (2, k, b)    # 2-倾斜直线\n\n'''\n判断是否为凸多边形\nparam vertexes: 构成多边形的所有顶点坐标列表，如[[0，0], [50, 0], [0, 50]]\nreturn convex: 布尔类型，为True说明该多边形为凸多边形，否则为凹多边形\n'''\ndef isConvex(vertexes):\n    # 默认为凸多边形\n    convex = True   \n    \n    # 多边形至少包含三个顶点\n    l = len(vertexes)\n    if l<3:\n        raise ValueError(\"多边形至少包含三个顶点！\")\n    \n    # 对每两个点组成的直线做判断\n    for i in range(l):\n        pre = i\n        nex = (i+1)%l\n        \n        # 得到直线\n        line = kb(vertexes[pre], vertexes[nex])\n        \n        # 计算所有点和直线的距离（可能为正也可能为负）\n        if line[0]==0:\n            offset = [vertex[0]-vertexes[pre][0] for vertex in vertexes]\n        elif line[0]==1:\n            offset = [vertex[1]-vertexes[pre][1] for vertex in vertexes]\n        else:\n            k, b = line[1], line[2]\n            offset = [k*vertex[0]+b-vertex[1] for vertex in vertexes]\n        \n        # 计算两两距离的乘积，如果出现负数则存在两个点位于直线两侧，因此为凹多边形\n        for o in offset:\n            for s in offset:\n                if o*s<0:\n                    convex = False\n                    break\n            if convex==False:\n                break\n                    \n        if convex==False:\n            break\n            \n    # 打印判断结果\n    if convex==True:\n        print(\"该多边形为凸多边形！\")\n    else:\n        print(\"该多边形为凹多边形！\")\n    \n    return convex\n```\n\n## 3.9 0-1背包问题\n- ![MIGH1O.png](https://s2.ax1x.com/2019/11/21/MIGH1O.png)\n- 其中m(i,j)是指背包容量为j，可选择物品为i，i+1，···，n时0-1背包问题的最优值\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 0-1背包问题--动态规划\n\"\"\"\n\n#跳跃点法\ndef knapsack_Pro(n,v,w,C,p,x):\n    #head指向每一阶段跳跃点集合的开始\n    head=[0 for i in range(n+1)]\n    p[0][0],p[0][1]=0,0\n    left,right,pnext,head[1]=0,0,1,1\n    for i in range(n):\n        k=left\n        for j in range(left,right+1):\n            if(p[j][0]+w[i]>C):\n                break \n            y=p[j][0]+w[i]\n            m=p[j][1]+v[i]\n            #重量小于此数的跳跃点直接加进来，不会被支配\n            while(k<=right and p[k][0]<y):\n                p[pnext][0]=p[k][0]\n                p[pnext][1]=p[k][1]\n                pnext+=1\n                k+=1\n            #两个if判断新产生的点能否加入p\n            if(k<=right and p[k][0]==y):\n                if(m<p[k][1]):\n                    m=p[k][1]\n                k+=1\n            if(m>p[pnext-1][1]):\n                p[pnext][0]=y\n                p[pnext][1]=m\n                pnext+=1\n            #取出可以支配的点\n            while(k<=right and p[k][1]<=p[pnext-1][1]):\n                k+=1\n\n        #上面break后\n        while(k<=right):\n            p[pnext][0]=p[k][0]\n            p[pnext][1]=p[k][1]\n            pnext+=1\n            k+=1\n        \n        left=right+1\n        right=pnext-1\n        head[i+1]=pnext\n    traceback_Pro(n,w,v,p,head,x)\n\ndef traceback_Pro(n,w,v,p,head,x):\n    j=p[head[n]-1][0]\n    m=p[head[n]-1][1]\n    print(\"max value:\",m,\"max weight:\",j)\n    for i in range(n)[::-1]:\n        for k in range(head[i],head[i+1]-1):\n            if(p[k][0]+w[i]==j and p[k][1]+v[i]==m):\n                x[i]=1\n                j=p[k][0]\n                m=p[k][1]\n                break\n\n\ndef knapsack(v,w,C,m):\n    #m[i][j]指背包容量为j，可选择物品为i，i+1，...，n时的0-1背包问题的最优值\n    n=len(v)-1\n    #只剩一个物品的情况\n    for j in range(C):\n        m[n][j] = v[n] if j>=min(w[n]-1,C) else 0\n    #普通情况\n    for i in range(1,n)[::-1]:\n        for j in range(C):\n            m[i][j] = max(m[i+1][j],m[i+1][j-w[i]]+v[i]) if j>w[i]-1 else m[i+1][j]\n    #第一件物品\n    if(n>0):\n        m[0][C-1]=m[1][C-1]\n        if C-1>=w[0]:\n            m[0][C-1]=max(m[0][C-1],m[1][C-1-w[0]]+v[0])\n\ndef traceback(m,w,C,x):\n    c=C-1\n    for i in range(len(w)-1):\n        #没选物品i则x[i]=0\n        if (m[i][c]==m[i+1][c]):\n            x[i]=0\n        else:\n            x[i]=1\n            c -= w[i]\n    #对于最后一个物品\n    x[len(w)-1]=1 if m[len(w)-1][c]>0 else 0\n\n#输出格式\ndef cout(x,v,w):\n    total_v=0\n    total_w=0\n    print(\"Choose:\")\n    for i in range(len(v)):\n        if x[i]==1:\n            print(f\"No.{i+1} item: value is {v[i]} , weight is {w[i]}\")\n            total_v +=v[i]\n            total_w +=w[i]\n    print(f\"total value: {total_v}\")\n    print(f\"total weight: {total_w}\")\n\ndef main():\n    v=[]    #物品的价值列表\n    w=[]    #物品的重量列表\n    #输入物品数量\n    n=input(\"Please input the number of items:\\n\")\n    if(n==\"\" or n==\"0\"):\n        raise ValueError(\"您输入了空值或0！\")\n    else:\n        n=int(n)\n    x=[0 for i in range(n+1)]\n    #选择两种算法（课本上的）\n    ans=input(\"Choose Knapsack or Knapsack_Pro?(1 or 2)\\n\").split()[0]\n    if ans=='1':\n        m=[]    #m(i,j)指背包容量为j，可选择物品为i，i+1，...，n时的0-1背包问题的最优值\n        for i in range(n):\n            item=input(f\"please input No.{i+1} item's value(v) and weight(w):(eg:v w)\\n\").split()\n            v.append(int(item[0]))\n            w.append(int(item[1]))\n        C=int(input(\"Please input the max weight of bag:\\n\"))\n        if(C<=0):\n            raise ValueError(\"背包容量不能≤0\")\n        for i in range(n):\n            m.append([0]*C)\n        knapsack(v,w,C,m)\n        traceback(m,w,C,x)\n        cout(x,v,w)\n    elif ans=='2':\n        for i in range(n):\n            item=input(f\"please input No.{i+1} item's value(v) and weight(w):(eg:v w)\\n\").split()\n            v.append(float(item[0]))\n            w.append(float(item[1]))\n        #初始化\n        p=[[0 for i in range(2)]for j in range(n*n)]\n        C=float(input(\"Please input the max weight of bag:\\n\"))\n        if(C<=0):\n            raise ValueError(\"背包容量不能小于等于0\")\n        if(n==1):\n            if(w[0]<=C):\n                x[0]=1\n            else:\n                x[0]=0\n        else:\n            knapsack_Pro(n,v,w,C,p,x)\n        for i in range(n):\n            if(x[i]==1):\n                print(\"choose: value:\",v[i],\"weight:\",w[i])\n    else:\n        raise ValueError(f\"您输入了{ans}没有该选项！\")\n\nif __name__==\"__main__\":\n    #异常处理\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n## 3.10 最优二叉搜索树\n- 二叉搜索树：存储于每个结点中的元素x大于其左子树中任一结点所存储的元素，小于其右子树中任一结点所存储的元素\n\n# 第四章 贪心算法\n- 贪心算法：总是做出在当前看来最好的选择，也就是说贪心算法并不从整体最优考虑它所作出的选择只是在某种意义上的局部最优选择。\n- 使用贪心算法需满足：\n\t- 贪心选择性：指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到\n\t- 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质\n- 贪心算法适合的问题：有n个输入，其解就由这n个输入满足某些事先给定的约束条件的某个子集组成，而把满足约束条件的子集称为该问题的可行解。显然可行解一般来说是不唯一的。那些使目标函数取极值的可行解，成为最优解。\n- 贪心算法是一种分级处理方法，它首先根据题意，选取一种度量标准，然后按这种度量标准对这n个的输入排序，并按序依次输入，如果不满足条件，则不把此输入加到解当中。\n- 贪心算法设计求解的核心问题：选择能产生问题最优解的最优量度标准。\n- 贪心算法正确性的证明：\n    - ①证明算法所求的问题具有优化子结构\n    - ②证明算法所求解的问题具有贪心选择性\n    - ③算法按照②种的贪心选择性进行局部最优选择\n\n## 4.2 活动安排问题\n- 为了选择最多的相容活动，每次选择fi最小的活动，使能够选择更多的活动\n- 度量标准：按照结束时间的非减序排列\n- 如果有序，则O(n)，如果无序，O(nlogn)\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 活动安排问题\n\"\"\"\n\n#活动类，每个活动包括开始时间和结束时间\nclass activity():\n    def __init__(self,ss,ff):\n        self.s=ss\n        self.f=ff\n    \n\ndef greedySelector(arr,a):\n    n=len(arr)-1\n    a[0]=True\n    j=0\n    count=1\n    #满足开始时间大于上一个活动的结束时间的加入（设为True）\n    #O(n)\n    for i in range(1,n+1):\n        if(arr[i].s>=arr[j].f):\n            a[i]=True\n            j=i\n            count+=1\n        else:\n            a[i]=False\n    return count\n\ndef main():\n    activities=[]\n    #输入数据\n    n=int(input(\"please input the number of activities:\\n\"))\n    #异常处理\n    if(n==0):\n        raise ValueError(\"您输入了0！\")\n    print(\"Use greedy selector , activities should be ordered by the end_time.\")\n    for i in range(n):\n        item=input(\"please input the begin-time and end-time:(eg: 3 6)\\n\").split()\n        if(len(item)!=2):\n            raise ValueError(\"您输入的数据个数不合法！\")\n        s=activity(float(item[0]),float(item[1])) \n        activities.append(s)\n    #以结束时间非减序排序\n    activities=sorted(activities,key=lambda x:x.f)\n    #初始化选择集合a\n    a=[False for i in range(n)]\n    count=greedySelector(activities,a)\n    print(\"Maximum number of activities:\",count)\n    print(\"Choose:\",a)\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n## 4.3 最优装载问题\n- O(nlogn)\n\n## 4.4 哈夫曼编码\n- 循环地选择具有最低频率的两个结点，生成一棵子树，直至形成树\n\n```python\n#构建二叉树类型\nclass BinaryTree:\n    def __init__(self,data,left,right,code):\n        self.data=data\n        self.left=left\n        self.right=right\n        self.code=code\n    \n    def getdata(self):\n        return self.data\n\n#哈夫曼树\nclass Huffman:\n    def __init__(self,tree,ww):\n        self.tree=tree\n        self.w=ww\n\n    def getweight(self):\n        return self.w\n\ndef huffmanTree(f):\n    #f是出现频率权值字典\n    H=[]\n    n=len(f)\n    #根据value对键进行从大到小排序\n    for i in sorted(f,key=f.__getitem__,reverse=True):\n        tree = BinaryTree(i,0,0,\"\")\n        w = Huffman(tree,f[i])\n        H.append(w)\n\n    for i in range(1,n):\n        #取出最后两位\n        x=H.pop()\n        y=H.pop()\n        #取权重小的做左孩子，大的是右孩子\n        t=BinaryTree(i,x.tree if x.w<y.w else y.tree,y.tree if y.w>x.w else x.tree,\"\")\n        h=Huffman(t,x.w+y.w)\n        H.append(h)\n        #根据权重从大到小排序\n        H=sorted(H,key=lambda x:x.w,reverse=True)\n\n    return H.pop()\n```\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile \nTitle: 哈夫曼编码\n\"\"\"\n\n#构建二叉树类型\nclass BinaryTree:\n    def __init__(self,data,left,right,code):\n        self.data=data\n        self.left=left\n        self.right=right\n        self.code=code\n    \n    def getdata(self):\n        return self.data\n\n#哈夫曼树\nclass Huffman:\n    def __init__(self,tree,ww):\n        self.tree=tree\n        self.w=ww\n\n    def getweight(self):\n        return self.w\n    \n#计算权重\ndef makedict(s):\n    dic={}\n    for i in s:\n        if i not in dic.keys():\n            dic[i]=1\n        else:\n            dic[i]+=1\n    return dic\n\ndef huffmanTree(f):\n    #f是出现频率权值字典\n    H=[]\n    n=len(f)\n    #根据value对键进行从大到小排序\n    for i in sorted(f,key=f.__getitem__,reverse=True):\n        tree = BinaryTree(i,0,0,\"\")\n        w = Huffman(tree,f[i])\n        H.append(w)\n\n    for i in range(1,n):\n        #取出最后两位\n        x=H.pop()\n        y=H.pop()\n        #取权重小的做左孩子，大的是右孩子\n        t=BinaryTree(i,x.tree if x.w<y.w else y.tree,y.tree if y.w>x.w else x.tree,\"\")\n        h=Huffman(t,x.w+y.w)\n        H.append(h)\n        #根据权重从大到小排序\n        H=sorted(H,key=lambda x:x.w,reverse=True)\n\n    return H.pop()\n\ndef listall(h):\n    m=[]\n    k=[]\n    left,right=h.tree.left,h.tree.right\n    rcode=\"1\"\n    lcode=\"0\"\n    m.append(right)\n    right.code+=rcode\n    m.append(left)\n    left.code+=lcode\n    while(len(m)>0):\n        #如果存在左孩子（左右必同时存在）\n        if(m[-1].left):\n            a=m.pop()\n            c=a.code\n            m.append(a.right)\n            a.right.code=c+rcode\n            m.append(a.left)\n            a.left.code=c+lcode\n        else:\n            b=m.pop()\n            k.append(b)\n    return k\n\ndef back(hfmcode,filename):\n    ans=input(f\"Do you want to decode '{filename}'?（y/n）\\n\")\n    if(ans!=\"y\" and ans!='Y'):\n        return;\n    #读取要解压缩的文件\n    with open(filename,'r') as f:\n        s=f.read()\n    st=\"\"\n    #键和值交换形成新字典\n    new_dict = {v:k for k,v in hfmcode.items()}\n    #写入新文件\n    with open('解压缩.txt','w') as f:\n        for i in s:\n            st+=i\n            if(st in hfmcode.values()):\n                f.write(new_dict[st])\n                st=\"\"\n    print(\"==\"*10)\n    print(\"ok!Please check the file: '解压缩.txt'\")\n    print(\"==\"*10)\n\ndef main():\n    filename1=\"测试用例.txt\"\n    filename2='编码后.txt'\n    #可以选择读文件和输入字符串\n    s=input(f\"Do you want to search {filename1}！（y/n）\\n\")\n    if(s==\"y\" or s==\"Y\"):\n        #读文件\n        with open(filename1,'r') as f:\n            s=f.read()\n        #权值字典\n        dic=makedict(s)\n        print(\"权值：\",dic)\n        #构建哈夫曼树\n        hTree=huffmanTree(dic)\n        #编码\n        k=listall(hTree)\n        print(\"哈夫曼编码：\")\n        for i in k:\n            print(i.data,i.code)\n        #存储值对应的编码\n        hfmcode={}\n        for i in k:\n            hfmcode[i.data]=i.code\n        #写入哈夫曼编码\n        with open(filename2,'w') as f:\n            for i in s:\n                string=hfmcode[i]\n                f.write(string)\n        print(\"==\"*10)\n        print(f\"ok!Please check the file: '{filename2}'\")\n        print(\"==\"*10)\n        back(hfmcode,filename2)\n\n    else:\n        s=input(\"Please input the string:\")\n        dic=makedict(s)\n        print(dic)\n        hTree=huffmanTree(dic)\n        k=listall(hTree)\n        for i in k:\n            print(i.data,i.code)\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n\n## 4.5 单源最短路径\n- 设置顶点集合S并不断地作贪心选择来扩充这个集合，一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知，初始时，S中仅含有源。设u是G的某一个顶点，把从源到u且中间只经过S中顶点的路称为从源到u的特殊路径，并用数组dist记录当前每个顶点所对应的最短特殊路径长度。Dijkstra算法每次从V-S中取出具有最短特殊路径长度的顶点u，将u添加到S中，同时对数组dist作必要的修改。一旦S包含了所有V中顶点，dist就记录了从源到所有其他顶点之间的最短路径长度\n\n## 4.6 最小生成树\n- 设G =(V,E)是无向连通带权图，即一个网络。E中每条边(v,w)的权为`c[v][w]`。如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树上各边权的总和称为该生成树的耗费。在G的所有生成树中，耗费最小的生成树称为G的最小生成树\n- 最小生成树性质（MST性质）：设G=(V,E)是连通带权图，U是V的真子集。如果(u,v)∈E，且u∈U，v∈V-U，且在所有这样的边中，(u,v)的权为`c[u][v]`最小，那么一定存在G的一颗最小生成树，它以(u,v)为其中一条边\n- Prim算法：\n    - 首先置S={1}，然后，只要S是V的真子集，就作如下的贪心选择：\n    - 选取满足条件i∈S，j∈V-S，且`c[i][j]`最小的边，将顶点j添加到S中。这个过程一直进行到S=V时为止。\n    - 在这个过程中选取到的所有边恰好构成G的一棵最小生成树。 \n![MIjycj.png](https://s2.ax1x.com/2019/11/21/MIjycj.png)\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 最小生成树-Prim算法\n\"\"\"\n\ndef prim(n,c):\n    #初始化Prim算法的数组\n    s=[1]\n    p=[1]\n    lowcost=[float('inf') for i in range(n)]\n    m=1\n    #遍历S中的点\n    for r in range(1,n):\n        ns=len(s)\n        for t in range(ns):\n            i=s[t]\n            for j in range(1,n+1):\n                #如果不在S中，且最短则记录\n                if(j not in s) and (c[i][j]<lowcost[m]):\n                    lowcost[m]=c[i][j]\n                    k=j\n                    u=i\n        m+=1\n        s.append(k)\n        p.append(u)\n\n    for i in range(1,len(s)):\n        print(s[i],p[i],c[s[i]][p[i]])\n\ndef main():\n    #输入点数\n    n=int(input(\"Please input the number of points:\\n\"))\n    #初始化边长\n    c=[[float('inf') for i in range(n+1)] for j in range(n+1)]\n    for i in range(1,n+1):\n        c[i][i]=0\n    if(n<=1):\n        raise ValueError(f\"You input {n} point.\")\n    #输入边长\n    g=input(\"Please input the p1,p2 and weight,like: 1 2 4\\nInput end to end.\\n\")\n    while(g!='end'):\n        a=g.split()\n        i=int(a[0])\n        j=int(a[1])\n        w=float(a[2])\n        c[i][j]=w\n        c[j][i]=w\n        g=input(\"Please input the p1,p2 and weight,like: 1 2 4\\nInput end to end.\\n\")\n    \n    prim(n,c)\n\nif __name__==\"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n- Kruskal算法：\n    - 首先，将G的n个顶点看成n个孤立的连通分支。将所有的边按权从小到大排序。\n    - 然后，从第一条边开始，依边权递增的顺序查看每一条边，并按下述方法连接2个不同的连通分支：\n        - 当查看到第k条边(v,w)时，如果端点v和w分别是当前2个不同的连通分支T1和T2中的顶点时，就用边(v,w)将T1和T2连接成一个连通分支，然后继续查看第k+1条边；\n        - 如果端点v和w在当前的同一个连通分支中，就直接再查看第k+1条边。\n        - 这个过程一直进行到只剩下一个连通分支时为止。\n![MIvIdP.png](https://s2.ax1x.com/2019/11/21/MIvIdP.png)\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 最小生成树-Kruskal算法\n\"\"\"\n\nclass Edge:\n    def __init__(self,u,v,w):\n        self.u=u\n        self.v=v\n        self.w=w\n\nclass EdgeNode:\n    def __init__(self,p,g):\n        self.id=p\n        self.g=g\n    \n\ndef kruskal(n,e):\n    e=sorted(e,key=lambda x: x.w)\n    en=len(e)\n    s=[0]\n    e[0].u.g,e[0].v.g=0,0\n    for j in range(en):\n        if(j not in s) and (e[j].u.g!=e[j].v.g):\n            m=e[j].u.g if e[j].u.g<e[j].v.g else e[j].v.g\n            for eachedge in e:\n                if (eachedge.u==e[j].u or eachedge.v==e[j].v or eachedge.u==e[j].v or eachedge.v==e[j].u) and (eachedge.u.g==eachedge.v.g):\n                    m=min(eachedge.u.g,eachedge.v.g,m)\n                    eachedge.u.g=eachedge.v.g=m\n            e[j].u.g=e[j].v.g=m\n            s.append(j)\n    \n    for i in range(len(s)):\n        print(e[s[i]].u.id,e[s[i]].v.id,e[s[i]].w)\n\n\ndef main():\n    #输入点数\n    n=int(input(\"Please input the number of points:\\n\"))\n    if(n<=1):\n        raise ValueError(f\"You input {n} point.\")\n    #输入边长\n    e=[]\n    p={}\n    g=input(\"Please input the p1,p2 and weight,like: 1 2 4\\nInput end to end.\\n\")\n    aa,bb=n,n+1\n    while(g!='end'):\n        a=g.split()\n        i,j,w=int(a[0]),int(a[1]),float(a[2])\n        if(i not in p.keys()):\n            p[i]=EdgeNode(i,aa)\n        if(j not in p.keys()):\n            p[j]=EdgeNode(j,bb)\n        e.append(Edge(p[i],p[j],w))\n        g=input(\"Please input the p1,p2 and weight,like: 1 2 4\\nInput end to end.\\n\")\n        aa+=1\n        bb+=1\n\n    kruskal(n,e)\n\nif __name__==\"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n# 第五章 回溯法\n- 回溯法是一个既带有系统性又带有跳跃性的搜索算法。它在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该节点为根的子树的搜索，逐层向其祖先结点回溯，否则，进入该子树，继续按深度优先策略搜索\n- 具有剪枝函数的深度优先生成法\n- 扩展结点：正在产生儿子的结点称为扩展结点\n- 活结点：自身已生成但其儿子还没有全部生成的结点\n- 回溯法的步骤：\n    - (1)针对所给问题，定义问题的解空间；\n    - (2)确定易于搜索的解空间结构；\n    - (3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索\n\n- 子集树：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。通常有2n个叶子节点，其节点总个数为2n+1-1。如：0-1背包问题\n- 排列树：当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有n！个叶子节点。如：旅行售货员问题。\n- 回溯算法的效率在很大程度上依赖于以下因素：\n    - (1)产生x[k]的时间；\n    - (2)满足显约束的x[k]值的个数；\n    - (3)计算约束函数constraint的时间；\n    - (4)计算上界函数bound的时间；\n    - (5)满足约束函数和上界函数约束的所有x[k]的个数。好的约束函数能显著地减少所生成的结点数。但这样的约束函数往往计算量较大。因此，在选择约束函数时通常存在生成结点数与约束函数计算量之间的折衷。\n\n\n## 5.2 装载问题\n- 如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案。\n    - (1)首先将第一艘轮船尽可能装满；\n    - (2)将剩余的集装箱装上第二艘轮船。\n- 解空间：子集树\n- 可行性约束函数(选择当前元素)：\n- 上界函数(不选择当前元素)：当前载重量cw+剩余集装箱的重量r≤当前最优载重量bestw\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 装载问题（回溯法）\n\"\"\"\n\ndef backtrack(i,c):\n    global w,bestx,x,bestw,r,cw\n    if(i>len(w)-1):\n        if(cw>bestw):\n            for j in range(1,len(w)):\n                bestx[j]=x[j]\n            bestw=cw\n        return ;\n    \n    #逐层搜索子树\n    r-=w[i]\n    if(cw+w[i]<=c):\n        x[i]=1\n        cw+=w[i]\n        backtrack(i+1,c)\n        cw-=w[i]\n    if(cw+r>bestw):\n        x[i]=0\n        backtrack(i+1,c)\n    r+=w[i]\n\n\n\ndef main():\n    global w,bestx,x,bestw,r,cw\n    w=[0]\n    m=input(\"Please input the weight of each items:(eg:1 2 3 4 5)\\n\").split()\n    n=len(m)    #物品数量\n    if(n==0):\n        raise ValueError(\"物品数量不能为空！\")\n    r=0         #剩余的物品容量\n    #转换w类型并初始化r\n    for i in range(n):\n        w.append(int(m[i]))\n        r+=w[i+1]\n    c1=int(input(\"Please input the size of No.1 ship:\\n\"))      #第一艘船载重量\n    c2=int(input(\"Please input the size of No.2 ship:\\n\"))      #第二艘船载重量\n\n    x=[0 for i in range(n+1)]         #记录路径\n    bestx=x[:]                      #最优路径\n    bestw,cw=0,0                    #最优载重量，当前载重量\n    #尽可能的装满第一个\n    backtrack(1,c1)\n    #print(bestx)\n    cw2=0\n    for i in range(1,len(bestx)):\n        if(bestx[i]==0):\n            cw2+=w[i]\n    if(cw2>c2):\n        print(\"不能由两艘船装完！\")\n        return ;\n    else:\n        for i in range(1,len(bestx)):\n            if(bestx[i]==1):\n                print(f\"第{i}个物品，重量{w[i]},装入第1艘船\")\n            else:\n                print(f\"第{i}个物品，重量{w[i]},装入第2艘船\")\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n## 5.6 0-1背包问题\n- n=3, C=30, w={16, 15, 15}, v={45, 25, 25}\n- ![Mo9ygU.png](https://s2.ax1x.com/2019/11/21/Mo9ygU.png)\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 0-1背包问题（回溯法）\n\"\"\"\n\nclass Q:\n    def __init__(self,_id,qq):\n        self.id=_id\n        self.d=qq\n\ndef bound(i):\n    global bestp,cw,cp,n,p,c,w,x,bestx\n    cleft=c-cw\n    bound=cp\n    while(i<=n and w[i]<=cleft):\n        cleft-=w[i]\n        bound+=p[i]\n        i+=1\n    #贪心\n    if(i<=n):\n        bound+=p[i]*cleft/w[i]\n    return bound \n\n\ndef backtrack(i):\n    global bestp,cw,cp,n,p,c,w,x,bestx\n    #到达叶结点\n    if(i>n):\n        if(cp>bestp):\n            for j in range(1,n+1):\n                bestx[j]=x[j]\n        bestp=cp\n        return ;\n    if(cw+w[i]<c):\n        x[i]=1\n        cw+=w[i]\n        cp+=p[i]\n        backtrack(i+1)\n        cp-=p[i]\n        cw-=w[i]\n    if(bound(i+1)>bestp):\n        x[i]=0\n        backtrack(i+1)\n    \n\ndef main():\n    global bestp,cw,cp,n,p,c,w,x,bestx\n    pp=input(\"Please input the price of each items.(eg:1 2 3 4 5)\\n\").split()\n    ww=input(\"Please input the weight of each items.(eg:1 2 3 4 5)\\n\").split()\n    if(len(pp)!=len(ww)):\n        raise ValueError(\"您的输入长度不一致！\")\n    n=len(pp)\n    c=float(input(\"Please input the size of bag:\\n\"))\n    cw=0        #当前重量\n    cp=0        #当前价值\n    bestp=0     #当前最优价值\n    x=[0 for i in range(n+1)]       #初始化临时选择方案\n    bestx=x[:]                      #初始化最优选择方案\n    p=[0]       #价值列表\n    w=[0]       #重量列表\n    #单位重量价值\n    #初始化\n    q=[Q(0,0) for i in range(n)]     \n    for i in range(n):\n        pp[i]=float(pp[i])\n        ww[i]=float(ww[i])\n        q[i].d=pp[i]/ww[i]\n        q[i].id=i\n    q=sorted(q,key=lambda x:x.d)[::-1]                 #从大到小排序\n    for i in range(n):\n        p.append(pp[q[i].id])\n        w.append(ww[q[i].id])\n    #回溯\n    backtrack(1)\n    #打印输出\n    print(\"Max price:\",bestp,\"包括：\")\n    for i in range(len(bestx)):\n        if(bestx[i]==1):\n            print(f\"第{q[i-1].id+1}个,价值：{pp[q[i-1].id]},重量：{ww[q[i-1].id]}\")\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n# 第六章 分支限界法\n- 分支限界法以`广度优先`或以`最小耗费(最大效益)优先`的方式搜索解空间树。其搜索策略是：在扩展结点处，先生成其所有儿子结点，然后再从当前的活结点表中选择下一个扩展结点。为了有效地选择下一扩展结点，加速搜索的进程，在每一格活结点处，计算一个函数值（限界），并根据函数值，从当前活结点表中，选择一个最有利的结点作为扩展结点，使搜索朝着解空间上最优解的分支推进，以便尽快找出一个最优解。\n- 常见两种分支限界法：①队列式（FIFO/LIFO）分支限界法②优先队列式分支限界法\n- 与回溯法对比：\n    - （1）求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。 \n    - （2）搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。 \n![MoPuFI.png](https://s2.ax1x.com/2019/11/21/MoPuFI.png)\n\n## 6.5 0-1背包问题\n\n```python\nclass Q:\n    def __init__(self,_id,qq):\n        self.id=_id\n        self.d=qq\n\nclass BBnode:\n    def __init__(self,par,ch):\n        self.par=par\n        self.ch=ch\n\nclass HeapNode:\n    def __init__(self,bNode,up,pp,ww,lev):\n        self.liveNode=bNode\n        self.up=up\n        self.p=pp\n        self.w=ww\n        self.lev=lev\n\n#插入队列\ndef addlivenode(heap,up,pp,ww,lev,par,ch):\n    b=BBnode(par,ch)\n    node=HeapNode(b,up,pp,ww,lev)\n    heap.append(node)\n\n#上界函数，贪心\ndef bound(i):\n    global cw,cp,n,p,c,w\n    cleft=c-cw\n    bound=cp\n    while(i<=n and w[i]<=cleft):\n        cleft-=w[i]\n        bound+=p[i]\n        i+=1\n    \n    if(i<=n):\n        bound+=p[i]*cleft/w[i]\n    return bound\n\ndef knapsack():\n    global bestp,cw,cp,n,p,c,w,bestx\n    i=1\n    up=bound(i)\n    heap=[]\n    cnode=BBnode(None,None)\n    while(i!=n+1):\n        #左孩子\n        cleft=cw+w[i]\n        if(cleft<c):\n            if(cp+p[i]>bestp):\n                bestp=cp+p[i]\n            addlivenode(heap,up,cp+p[i],cw+w[i],i+1,cnode,True)\n        #右孩子\n        up=bound(i+1)\n        if(up>=bestp):\n            addlivenode(heap,up,cp+p[i],cw+w[i],i+1,cnode,False)\n        #取下一扩展结点\n        node=heap.pop(0)\n        #更新数据\n        cnode=node.liveNode\n        cw=node.w\n        cp=node.p\n        up=node.up\n        i=node.lev\n\n    #最优解\n    for j in range(1,n+1)[::-1]:\n        bestx[j]=1 if cnode.ch==True else 0\n        cnode=cnode.par\n```\n\n实现\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 0-1背包问题（分支限界法）\n\"\"\"\n\nclass Q:\n    def __init__(self,_id,qq):\n        self.id=_id\n        self.d=qq\n\nclass BBnode:\n    def __init__(self,par,ch):\n        self.par=par\n        self.ch=ch\n\nclass HeapNode:\n    def __init__(self,bNode,up,pp,ww,lev):\n        self.liveNode=bNode\n        self.up=up\n        self.p=pp\n        self.w=ww\n        self.lev=lev\n\n#插入队列\ndef addlivenode(heap,up,pp,ww,lev,par,ch):\n    b=BBnode(par,ch)\n    node=HeapNode(b,up,pp,ww,lev)\n    heap.append(node)\n\n#上界函数，贪心\ndef bound(i):\n    global cw,cp,n,p,c,w\n    cleft=c-cw\n    bound=cp\n    while(i<=n and w[i]<=cleft):\n        cleft-=w[i]\n        bound+=p[i]\n        i+=1\n    \n    if(i<=n):\n        bound+=p[i]*cleft/w[i]\n    return bound\n\ndef knapsack():\n    global bestp,cw,cp,n,p,c,w,bestx\n    i=1\n    up=bound(i)\n    heap=[]\n    cnode=BBnode(None,None)\n    while(i!=n+1):\n        #左孩子\n        cleft=cw+w[i]\n        if(cleft<c):\n            if(cp+p[i]>bestp):\n                bestp=cp+p[i]\n            addlivenode(heap,up,cp+p[i],cw+w[i],i+1,cnode,True)\n        #右孩子\n        up=bound(i+1)\n        if(up>=bestp):\n            addlivenode(heap,up,cp+p[i],cw+w[i],i+1,cnode,False)\n        #取下一扩展结点\n        node=heap.pop(0)\n        #更新数据\n        cnode=node.liveNode\n        cw=node.w\n        cp=node.p\n        up=node.up\n        i=node.lev\n\n    #最优解\n    for j in range(1,n+1)[::-1]:\n        bestx[j]=1 if cnode.ch==True else 0\n        cnode=cnode.par\n\ndef main():\n    global bestp,cw,cp,n,p,c,w,bestx\n    #输入\n    pp=input(\"Please input the price of each items.(eg:1 2 3 4 5)\\n\").split()\n    ww=input(\"Please input the weight of each items.(eg:1 2 3 4 5)\\n\").split()\n    if(len(pp)!=len(ww)):\n        raise ValueError(\"您的输入长度不一致！\")\n    n=len(pp)\n    c=float(input(\"Please input the size of bag:\\n\"))\n    cw=0        #当前重量\n    cp=0        #当前价值\n    bestp=0     #当前最优价值\n    bestx=[0 for i in range(n+1)]   #最优解初始化\n    p=[0]\n    w=[0]\n    q=[Q(0,0) for i in range(n)]     #单位重量价值\n    allp=0    #总价值\n    allw=0    #总重量\n    #单位重量价值列表\n    for i in range(n):\n        pp[i]=float(pp[i])\n        ww[i]=float(ww[i])\n        allp+=pp[i]\n        allw+=ww[i]\n        q[i].d=pp[i]/ww[i]\n        q[i].id=i\n    q=sorted(q,key=lambda x:x.d)[::-1]                 #从大到小排序\n    for i in range(n):\n        p.append(pp[q[i].id])\n        w.append(ww[q[i].id])\n    #如果能直接全装\n    if(allw<c):\n        print(f\"All in! Total price is {allp}!\")\n        return ;\n\n    knapsack()\n    print(\"Max price:\",bestp,\"包括：\")\n    for i in range(len(bestx)):\n        if(bestx[i]==1):\n            print(f\"第{q[i-1].id+1}个,价值：{pp[q[i-1].id]},重量：{ww[q[i-1].id]}\")\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法!出错信息如下：\")\n        print(e)\n```\n\n## 6.6 装载问题\n\n```python\n\"\"\"\nCopyright: Copyright (c) 2019\nAuthor: Justlovesmile\nTitle: 装载问题（分支限界法）\n\"\"\"\n\nclass Node:\n    def __init__(self,parent,isleftchild,weight):\n        self.parent=parent\n        self.islchild=isleftchild\n        self.weight=weight\n\ndef maxloading(c):\n    global w,bestx,bestw,r,cw,n\n    i=1\n    r-=w[i]\n    cnode=Node(None,None,-1)    #当前结点\n    q=[cnode]\n    while(True):\n        #左结点\n        cleft=cw+w[i]\n        if(cleft<=c):\n            enode=Node(cnode,True,cleft)\n            if(cleft>bestw):\n                bestw=cleft    \n                bestx=enode\n            if(i<n):\n                q.append(enode)\n            if(i==n):\n                return;\n        #右结点\n        if(cw+r>bestw and i<n):\n            enode=Node(cnode,False,cw)\n            q.append(enode)\n        #出队列\n        cnode=q.pop(0)\n        cw=cnode.weight\n        if(cw==-1):\n            if(len(q)==0):\n                return ;\n            q.append(Node(None,None,-1))\n            cnode=q.pop(0)\n            cw=cnode.weight\n            i+=1\n            r-=w[i]\n\ndef main():\n    global w,bestx,bestw,r,cw,n\n    w=[0]\n    m=input(\"Please input the weight of each items:(eg:1 2 3 4 5)\\n\").split()\n    n=len(m)    #物品数量\n    if(n==0):\n        raise ValueError(\"物品数量不能为空！\")\n    r=0         #剩余的物品容量\n    bestw,cw=0,0\n    #转换w类型并初始化r\n    for i in range(n):\n        w.append(int(m[i]))\n        r+=w[i+1]\n    allweight=r    #总重量\n    x=[0 for i in range(n+1)]\n    tx=[]\n    c1=int(input(\"Please input the size of No.1 ship:\\n\"))      #第一艘船载重量\n    c2=int(input(\"Please input the size of No.2 ship:\\n\"))      #第二艘船载重量\n\n    maxloading(c1)\n    if(bestw+c2<allweight):\n        print(\"不能由两艘船装完！\")\n        return;\n    for i in range(1,n+1)[::-1]:\n        if(bestx.islchild==True):\n            tx.append(1)\n        elif(bestx.islchild==False):\n            tx.append(0)\n        bestx=bestx.parent\n    for i in range(len(tx)):\n        x[i+1]=tx[::-1][i]\n    print(f\"第一艘船载重量{bestw}，包括：\")\n    for i in range(1,n+1):\n        if(x[i]==1):\n            print(f\"第{i}个集装箱\")\n    print(f\"第二艘船载重量{allweight-bestw},包括：\")\n    for i in range(1,n+1):\n        if(x[i]==0):\n            print(f\"第{i}个集装箱\")    \n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        print(\"您的输入不合法！出错信息如下：\")\n        print(e)\n```\n\n\n<h1 style=\"text-align: center;\">知识点整理</h1>\n\n- 算法的特征：`输入，输出，确定性，有限性`\n- θ记号在算法复杂性的表示法中表示`紧致界`\n- 由分治法产生的子问题往往是`原问题的较小模式`，这就为使用`递归`提供了方便\n- 建立计算模型的目的：`为了使问题的计算复杂性分析有一个共同的客观尺度`\n- 基本计算模型：`RAM`,`RASP`,`TM`\n- 拉斯维加斯算法找到的解一定是`正确`的\n- 贪心算法常采用`自顶向下`的方式求解最优解\n- 采用高级语言的主要好处：\n>①更接近算法语言，易学，易掌握②提供了结构化程序设计的环境和工具，使得设计出的程序可读性高，可维护性强，可靠性高③不依赖于机器语言，因此写出的程序可移植性好，重用率高③自动化程度高，开发周期短，程序员可以集中精力从事更重要的创造性劳动，提高程序质量\n\n- 贪心算法的特点：\n>①不能保证最后求得的解是最优的②策略易发现，运用简单，被广泛运用③策略多样，结果也多样④常用到辅助算法：排序\n\n- `平衡子问题`思想：通常分治法在分割原问题，形成若干子问题时，这些子问题的规模都大致相同\n- Prim算法采用`贪心策略`求解`最小生成树问题`，其时间复杂度是O(n^2)。\n- 动态规划算法适用于解具有`某种最优性质`的问题。\n- 贪心算法做出的选择只是适用于在某种意义上的`局部最优`选择\n- 在动态规划算法中，通常不同子问题的个数随问题规模呈`多项式`级增长\n- 动态规划是解决`多阶段决策过程`的最优化问题\n- `选择能产生最优解的贪心准则`是设计贪心算法的核心问题 \n- 分支限界法常以`广度优先`或以`最小耗费（最大效益）优先`的方式搜索问题的解空间树\n- 为什么用分治法设计的算法一般有递归调用？因为子问题的规模还很大时，必须继续使用分治法，反复分治，必然要用到递归\n- 请简述分支限界法找最优解比回溯法高的原因：在分支限界法中，每一个点只有一次机会称为扩展结点。\n- 回溯法的算法框架按照问题的解空间一般分为`子集树`算法框架（如解0-1背包问题）和`排列树`算法框架（如解批处理作业调度问题）\n- ![MIEmhn.png](https://s2.ax1x.com/2019/11/21/MIEmhn.png)\n- 常见的多项式阶：`O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)`\n- 回溯和分支限界：\n    - 相同点：都是以构造一颗状态空间树为基础的，树的结点反映了对一部分解所作的特定选择\n    - 不同点：①他们处理的问题类型不同，回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。②生成状态空间树的顺序不同③对节点存储的常用数据结构以及节点存储特性也各不相同，除由搜索方式决定的不同的存储结构外，分支限界法通常需要存储一些额外的信息以利于进一步地展开搜索\n- ![MoFWQK.png](https://s2.ax1x.com/2019/11/21/MoFWQK.png)\n- ![MoFHJI.png](https://s2.ax1x.com/2019/11/21/MoFHJI.png)\n- NP问题是指还未被证明是否存在多项式算法能够解决的问题，而其中NP完全问题又是最有可能不是P问题的问题类型。所有的NP问题都可以用多项式时间划归到他们中的一个。所以显然NP完全的问题具有如下性质：它可以在多项式时间内求解，当且仅当所有的其他的NP－完全问题也可以在多项式时间内求解。","tags":["算法","大学课程"],"categories":["学习笔记"]},{"title":"Python爬虫 | 如何快速获取LOL英雄皮肤高清图片","slug":"代码编程-python爬取LOL英雄皮肤","url":"/posts/5271.html","content":"- 编写爬虫获取英雄联盟所有英雄的全部皮肤\n![](https://unpkg.com/justlovesmile-img/lol2019.jpg)\n<!--more-->\n\n>- 需要库：\n\t- requests\n\t- re\n\t- json\n\t- os\n\n- 效果：在该代码文件目录下生成n个Hero文件夹保存皮肤图片。\n![](https://unpkg.com/justlovesmile-img/20200722173251.png)\n\n```python\n\"\"\"\nDate: 2019.11.7\nAuthor: Justlovesmile\nLanguage: python3\n\"\"\"\nimport requests\nimport re\nimport json\nimport os\n\ndef getHtml(url):\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n    except:\n        print(url+\"爬取失败！\")\n    else:\n        response = r.text\n        getInfo(response)\n\ndef getInfo(res):\n    lists=re.findall(r'\"keys\":(.*?),\"data\"',res)\n    #print(lists)\n    hero_id=json.loads(lists[0])\n    #print(hero_id)\n    for hero in hero_id.values():\n        getSkin(hero)\n\ndef getSkin(hero):\n    url='https://lol.qq.com/biz/hero/'+hero+'.js'\n    try:\n        r=requests.get(url)\n        r.raise_for_status()\n        r.encoding=r.apparent_encoding\n    except:\n        print(url+\"爬取失败！\")\n    else:\n        html=r.text\n        num=re.findall(r'\"id\":\"(\\d{4,6})\",\"num\"',html)\n        for i in range(len(num)):\n            img_url='https://game.gtimg.cn/images/lol/act/img/skin/big' + num[i] + '.jpg'\n            save_img(hero,img_url)\n\ndef save_img(hero,img_url):\n    root=hero+\"\\\\\"\n    path=root+img_url.split('/')[-1]\n    try:\n        if not os.path.exists(root):\n            os.mkdir(root)\n        if not os.path.exists(path):\n            r=requests.get(img_url)\n            with open(path,'wb') as f:\n                f.write(r.content)\n                f.close()\n                print(\"文件保存成功！\")\n        else:\n            print(\"文件已存在！\")\n    except:\n        print(\"爬取失败！\")\n    print(img_url+\"已下载\")\n\ndef main():\n    url=\"https://lol.qq.com/biz/hero/champion.js\"\n    getHtml(url)\n\nif __name__ == \"__main__\":\n    main()\n```","tags":["Python","爬虫"],"categories":["代码编程"]},{"title":"前端利器 | CodePen.io全球百万前端设计师的灵感社区","slug":"博客相关-CodePen-io-前端利器","url":"/posts/11952.html","content":"\n<p>今天发现了一个神仙前端开源网站CodePen,对于我来说,里面的开源项目简直厉害的不要不要的。</p>\n\n![](https://unpkg.com/justlovesmile-img/twopeople.gif)\n\n#### CodePen\n- CodePen是一个完全免费的前端代码托管服务。它的首页每天都会放上很多有趣的好看的项目。😍\n- [官网入口https://codepen.io/](https://codepen.io/)\n- 引用我在百度上看到的描述：👇\n\n>- 与 GitHub Pages 相比，它最重要的优势有：\n\t- 即时预览。你甚至可以本地修改并即时预览别人的作品。\n\t- 支持多种主流预处理器。你从不需要手写生产级别的代码，无论是 Jade 、 LESS 、 Sass ，还是 CoffeeScript 、 es6+（ Babel ），都能尽情使用。\n\t- 快速添加外部资源文件。只需在输入框里输入库名， CodePen 就会从 cdnjs 上寻找匹配的 css 或 js 库。\n\t- 免费用户支持创建三个模板，不是每个作品都需要从白板开始。\n\t- 优秀的外嵌体验，且支持 oEmbed 。在 WordPress 或 Reddit 等支持 oEmbed 的平台上，只要简单地把链接贴入编辑框，发布后会自动转为嵌入作品。\n\t当然，它不是 Git ，不能记录提交历史。不过有 fork 功能，通常出于“备份他人优秀作品，防止未来该作品消失了或者变了样子”的目的而使用。\n\n- 希望自己有一天也能写出这么好看的前端🙃！","tags":["前端","CodePen"],"categories":["博客相关"]},{"title":"学习笔记 | 《算法导论》之从入门到放弃（4）","slug":"学习笔记-算法导论学习笔记4","url":"/posts/4582.html","content":"算法导论打卡4，主要内容：快速排序\n<!-- more -->\n# 第七章 快速排序\n\n## 快速排序的描述\n- ![KqfUOA.png](https://s2.ax1x.com/2019/11/02/KqfUOA.png)\n- ![KqhK1g.png](https://s2.ax1x.com/2019/11/02/KqhK1g.png)\n- ![KqhwjJ.png](https://s2.ax1x.com/2019/11/02/KqhwjJ.png)\n\n```python\ndef quicksort(arr,low,high):\n    if low<high :\n        index=getindex(arr,low,high)\n        quicksort(arr,low,index-1)\n        quicksort(arr,index+1,high)\n\ndef getindex(arr,low,high):\n\t#PARTITION过程\n    temp=arr[low]\n    while(low<high):\n        while((low<high)and(arr[high]>=temp)):\n            high=high-1\n        arr[low]=arr[high]\n        while((low<high)and(arr[low]<=temp)):\n            low=low+1\n        arr[high]=arr[low]\n    arr[low]=temp\n    return low\n\ndef main():\n    arr=input(\"please input a group of number:\").split()\n    n=len(arr)\n    for i in range(n):\n        arr[i]=int(arr[i])\n    quicksort(arr,0,n-1)\n    for i in arr:\n        print(i,end=\" \")\n\nif __name__ ==\"__main__\":\n    main()\n```\n\n","tags":["Python","算法"],"categories":["学习笔记"]},{"title":"大学课程 | 编译原理知识点","slug":"学习笔记-编译原理知识点","url":"/posts/50753.html","content":"\n大三编译原理复习知识点\n<!-- more -->\n\n问题？\n- 什么是解释器？什么是编辑器？什么是前端后端？分析和综合？遍？翻译过程的输入输出？T型图的意义描述？\n- 词法分析：什么是正则表达式？什么是有穷自动机？DFA？NFA？区别，特点？基本概念？正则表达式到NFA到DFA，再最小化。构建方法。扫描器功能的输入输出？什么是字母表，元符号，正则表达式的三种基本操作\n- 0/1/2/3型文法？什么是最左推导？最右推导？什么是终结符，非终结符？什么是产生式？如何识别二义性，消除方法？语言到文法？\n- 递归下降？LL(1)判断是不是？消除左递归，提取左公因子，First集follow集，构造分析表，对一个句子分析。LL(1)三种基本动作：生成（最左推导），匹配，接受。\n- 自底向上？\n- 语义分析：什么是属性？什么是属性文法？什么是联编？联编的时间？静态语义和动态语义？常见的静态语义？什么是符号表？作用,内容?描述-->属性文法？综合属性，基本属性\n- 了解几种运行环境的特点：Fortran77 完全静态，不允许递归调用。基于栈的C，C++，Pascal。LISP完全动态\n- 中间代码：种类，三元式，四元式，控制表达式，逆波兰，波兰。\n\n\n# 第一章 概论\n\n## 什么是编译器？\n（1）\n- 编译器是将一种语言翻译为另一种语言的计算机程序。\n- 编译器将编写的程序作为输入，而产生用目标语言编写的等价程序\n- 源程序→{编译器}→目标程序\n（2）\n- 编译器是将便于人编写，阅读，维护的高阶计算机语言翻译为计算机能解读，运行的低阶机器语言的程序。\n- 编译器将原始程序作为输入，翻译产生使用目标的等价程序。源代码一般为高阶语言，而目标语言则是汇编语言或目标机器的目标代码，有时也称作机器代码。\n\n\n## 编译器分类结构\n- 根据`语言文法的难易程度`以及`识别它们所需要的算法`分类：如`乔姆斯基分类结构`：\n- 4类：分为0型，1型，2型，3型文法\n\t- 0型文法为：无限制文法\n\t- 1型文法为：上下文有关文法\n\t- 2型文法为：上下文无关文法\n\t- 3型文法为：正则文法\n- 4个文法的定义是逐渐增加限制的\n\n## 与编译器相关的程序\n- （1）解释程序\n- 如同编译器的一种语言翻译程序。与编译器的不同在于：它立即执行源程序而不是在翻译完成之后才执行目标代码。\n- （2）汇编程序\n- 用于特定计算机上的汇编语言的翻译程序\n- （3）连接程序\n- 将分别在不同的目标文件中编译或汇编的代码收集到一个可直接执行的文件中\n- （4）装入程序\n- 可处理所有与指定的基地址或起始地址有关的可重定位的地址\n- （5）预处理器\n- 在真正的翻译开始之前由编译器调用的独立程序\n- （6）编辑器\n- 编译器通常接受由任何生成标准文件 ( 例如  ASCII  文件 ) 的编辑器编写的源程序。编译器如今常与编辑器和其他程序捆绑进一个交互的开发环境--IDE中。\n- （7）调试程序\n- 可在被编译了的程序中判定执行错误的程序。编译器必须为调试程序提供恰当的符号信息。\n- （8）描述器\n- 在执行中搜集目标程序行为统计的程序\n- （9）项目管理程序\n\n## 翻译步骤\n- 编译器内部包括了许多步骤或称为阶段。\n- ![uvUU4U.png](https://s2.ax1x.com/2019/10/13/uvUU4U.png)\n- （1）扫描程序：编译器阅读源程序。扫描程序会执行词法分析，将字符序列收集到称作`记号`的单元中。\n- （2）语法分析程序：从扫描程序获取记号形式的源代码，并完成定义程序结构的语法分析。通常将语法分析的结果表示为`分析树`或者`语法树`。\n- （3）语义分析程序：程序的语义确定程序的运行。但是大多数的程序设计语言都具有在执行前被确定而不易有语法表示和由分析程序分析的特征。这些特征被称为`静态语义`。而语义分析程序的任务就是分析这些语义。由语义分析程序计算的额外信息被称为属性，输出结果为`注释树`\n- （4）源代码优化程序：源代码优化程序可能通过将其输出称为`中间代码`来使用三元式代码。\n- （5）代码生成器：代码生成器得到中间代码，生成`目标机器的代码`。\n- （6）目标代码优化程序：优化目标代码\n\n## 编译器中的主要数据结构\n- 记号\n- 语法树\n- 符号表\n- 常数表\n- 中间代码\n- 临时文件\n\n\n## 什么是遍？\n- 编译过程的几个阶段仅仅是逻辑功能上的一种划分，具体实现时，受不同源语言，设计要求，使用对象和计算机条件（如主存容量）的限制，往往将编译程序组织为若干遍。所谓“遍”就是对源程序或源程序的中间结果从头到尾扫描一次，并作有关的加工处理，生成新的中间结果或目标程序。\n- 通常，每遍的工作由从外存上获得的前一遍的中间结果开始，完成它所含的有关工作之后，再把结果记录于外存，既可以将几个不同阶段合为一遍，也可以把一个阶段的工作分为若干遍。当一遍中包含若干阶段时，各阶段的工作是穿插进行的。\n\n## 什么是前端后端？\n- 通常认为，只依赖于源语言的的操作为前端，只依赖于目标语言的操作为后端。\n- 如：扫描程序，分析程序，语义分析程序为前端。代码生成器为后端。\n- 便于编译器的可移植性\n- ![KwRZlD.png](https://s2.ax1x.com/2019/10/25/KwRZlD.png)\n\n## 什么是分析与综合？\n- 分析：分析源程序以计算其特性的编译器操作\n- 综合：生成翻译代码时所涉及到的操作\n\n## 什么是扫描器？\n- 扫描器就是词法分析程序\n- 其主要功能是依据词法规则，分析由字符组成的源程序，把它分割为一个一个具有独立意义的最小语法单位，即单词。\n\n## 汇编语言的优缺点\n- 优点：汇编语言大大提高了编程的速度和准确度\n- 缺点：编写起来也不容易 , 阅读和理解很难；而且汇编语言的编写严格依赖于特定的机器，所以为一台计算机编写的代码在应用于另一台计算机时必须完全重写。\n\n## 什么是静态语义\n- 程序的语义确定程序的运行，但是大多数的程序设计语言都具有在执行之前被确定而不易由语法表示和由分析程序分析的特征。这些特征被称作`静态语义`。\n- 一般的程序设计语言的典型静态语义包括`声明`和`类型检查`。由语义分析程序计算的额外信息 ( 诸如数据类型 ) 被称为属性，它们通常是作为注释或 “ 装饰 ” 增加到树中 ( 还可将属性添加到符号表中 ) 。\n\n## 编译器中第一个考虑目标机的物理特性的模块是： 代码生成器\n\n## T 型图中S,T,H 分别代表什么？ \n| S T| \n|  H |\n- 语言H( 代表宿主语言 ) 编写的编译器将语言S( 代表源语言 ) 翻译为语言T( 代表目标语言 )\n\n## T 型图描述自举及移植的过程\n- ![KwWwKe.png](https://s2.ax1x.com/2019/10/25/KwWwKe.png)\n\n# 第二章 词法分析\n\n## 什么是词法分析\n- 将源程序读作字符文件并将其分为若干记号\n\n## 记号分类\n- 关键字： 如if，while\n- 标识符：用户定义的串\n- 特殊符号：算术符号，一些多字符符号等\n\n## 正则表达式\n- 是一种表示字符串的格式\n- 三种基本操作：选择，连结，重复（闭包）\n- 元字符/元符号：正则表达式中有特殊含义的字符\n\n## 什么是有穷自动机\n- 是描述特定类型算法的数学方法。\n- 圆圈表示状态，带有箭头的线表示记录一个状态向另一个状态的转换。\n\n## DFA（确定性有穷自动机）\n- ![Kw4VUA.png](https://s2.ax1x.com/2019/10/25/Kw4VUA.png)\n- 给出一个状态和字符，通常肯定会有一个指向单个新状态的唯一转换\n\n## NFA（非确定性有穷自动机）\n- ![Kw4Bb4.png](https://s2.ax1x.com/2019/10/25/Kw4Bb4.png)\n\n# 第三章 上下文无关文法\n\n## 上下文无关文法与正则表达式的主要区别：\n- 上下文无关文法的规则是递归的\n\n## 终结符和非终结符\n- 非终结符：在推导中必须被进一步替换的结构名\n- 终结符：终结推导的字母表中的符号\n\n## 什么是推导\n- 推导是在文法规则的右边进行选择的一个结构名字的替换序列。推导以一个结构名字开始并以记号符号串结束。\n- 最左推导：它的每一步中最左的非终结符都要被替换的推导。\n- 最右推导：它的每一步中最右的非终结符都要被替换的推导。\n- 最左推导和与其相关的分析树的内部节点的前序编号相对应；而最右推导则和后序编号相对应。\n\n## 产生式\n- 文法规则也被称为产生式。\n\n## 二义性文法\n- 可生成两个不同分析树的串的文法\n- 解决方法：一，设置规则，即消除二义性规则。二，将文法改变成一个强制正确分析树构造的格式\n\n## 语法分析器的作用\n- 编译过程中，语法分析器的任务是\n(1)   分析单词串是如何构成语句和说明的\n(2)   分析语句和说明是如何构成程序的\n(3)   分析程序的结构\n\n# 第四章 自顶向下的分析\n\n## 自顶向下的分析\n- 两类程序：回溯分析程序；预测分析程序\n- 两类算法：递归下降分析；LL(1)分析\n\n## LL(1)文法\n- LL(1)分析：第一个`L`指由左向右处理输入，第二个`L`为输入串描绘出一个最左推导，`1`是指先行一个符号\n- 使用显示栈来完成分析\n- 是非二义性的文法\n- 对于文法G，其相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法。\n- LL(1)三种基本动作：生成（最左推导），匹配，接受\n\n## 将BNF写为LL(1)分析算法\n- 消除左递归：![K0df54.png](https://s2.ax1x.com/2019/10/26/K0df54.png)![K0dLVO.png](https://s2.ax1x.com/2019/10/26/K0dLVO.png)\n- 提取左公因子：![K0dOaD.png](https://s2.ax1x.com/2019/10/26/K0dOaD.png)![K0dvPH.png](https://s2.ax1x.com/2019/10/26/K0dvPH.png)\n\n## FIRST集 定义：\n令 X 为一个文法符号（一个终结符或非终结符）或 ε ，则集合 First (X)  由终结符组成，此外可能还有 ε ，它的定义如下：\n1.  若 X 是终结符或 ε ，则 First (X) = {X} 。\n2.  若 X 是非终结符，则对于每个产生式  X → X1 X2 . . . Xn  ， First (X) 都包含了 First (X1 ) - { ε } 。若对于某个 i < n ，所有的集合 First (X1 ), . . . , First (Xi )  都包括了 ε ，则 First (X)  也包括了 First (X i + 1 ) -  { ε } 。若所有集合 First (X1 ), . . . , First (Xn ) 包括了 ε ，则 First (X) 也包括 ε 。\n\n## FOLLOW集 定义：\n给出一个非终结符 A ，那么集合 Follow (A) 则是由终结符组成，此外可能还有 $ 。\n集合 Follo w (A) 的定义如下：\n1.  若 A 是开始符号，则 $ 就在 Follo w (A) 中。\n2.  若存在产生式 B →α A γ，则 First ( γ ) - { ε } 在 Follo w (A) 中。\n3.  若存在产生式 B →α A γ，且在 Firs t  ( γ ) 中，则 F ollo w (A) 包括 Follow (B) 。\n\n## SELECT集 \n1. 定义：\n给定上下文无关文法的产生式A→α, A∈VN,α∈V*, 若α不能推导出ε,则SELECT(A→α)=FIRST(α);如果α能推导出ε则：SELECT(A→α)=（FIRST(α) –{ε}）∪FOLLOW(A)。需要注意的是，SELECT集是针对`产生式`而言的。\n2. LL(1)文法：\n一个上下文无关文法是LL(1)文法的充分必要条件是：对每个非终结符A的两个不同产生式，A→α, A→β,满足SELECT(A→α)∩SELECT(A→β)=空集  其中α，β不同时能推导出ε。\n\n## LL(1) 证明定理\n1.  在每个产生式 A →α 1  |  α 2  | . . . | α n 中，对于所有的 i  和 j ： 1 ≤ i ， j ≤ n ， i ≠ j ， First ( α i  )  ∩ First ( α j ) 为空。\n2.  若对于每个非终结符 A 都有 First (A)  包含了 ε ，那么 First (A) ∩ Follow (A) 为空。\n\n## 构造LL(1)预测分析表\n1. 对于文法G的每一个产生式A→α执行第2，3步\n2. 对每个终结符a∈FIRST(α)，把A→α加到M[A,a]中\n3. 若ε∈FIRST(α)，则对任何b∈FOLLOW(A)把A→α加入[A,b]中\n4. 其余无定义为出错\n- ![](https://unpkg.com/justlovesmile-img/20200722173126.png)\n\n# 第五章 自底向上的分析\n\n## LR(1)\n- LR(1)分析：L表示由左向右处理输入，R表示生成了最右推导，数字1表示先行一个符号\n- 移进规约分析程序：主要任务是判断分析中的下一个句柄\n\n# 第六章 语义分析\n\n## 什么是语义分析\n- 语义分析也可称为`静态语义分析`\n- 语义分析包括：构造符号表，记录声明中建立的名字的含义，在表达式和语句中进行类型推断和类型检查，以及在语言的类型规则作用域内判断正确性\n- 语义分析分为：程序的分析；由编译程序执行的分析\n\n## 什么是属性\n- 属性： 属性是编程语言结构的任意特性。属性在其包含的信息和复杂性等方面变化很大，特别是当它们能确定时翻译 / 执行过程的时间。属性的典型例子有：\n•变量的数据类型。\n•表达式的值。\n•存储器中变量的位置。\n•程序的目标代码。\n•数的有效位数。\n\n## 什么是属性文法\n- 确定语言实体的属性或特性，它们必须进行计算并写成属性等式或语义规则，并描述这些属性的计算如何与语言的文法规则相关。这样的一组属性和等式称作`属性文法`。\n\n## 什么是联编\n- 联编： 属性的计算及将计算值与正在讨论的语言结构联系的过程称作属性的联编。\n- 联编时间： 联编属性发生时编译 / 执行过程的时间称作联编时间 。\n- 执行之前联编的属性是`静态`的，\n- 执行期间联编的属性是`动态`的。\n\n## 静态动态\n- 在如 C 或 Pascal 这样的静态类型的语言中，变量或表达式的数据类型是一个重要的编译时属性。\n- FORTRAN7 7 中所有的变量都是静态分配。\n- 程序的目标代码无疑是一个静态属性。\n- 表达式的值通常是动态的，编译程序要在执行时生成代码来计算这些值。\n- 变量的分配可以是静态的也可以是动态的，这依赖于语言和变量自身的特性\n- LIS P 中所有的变量是动态分配的。\n- C 和 Pasca l 语言混合了静态和动态的两种变量分配。\n- 数 的有效位数在编译期间是一个不被明确探讨的属性。\n\n## 符号表\n- 是一种目录数据结构\n- 符号表的主要操作：插入，查找，删除。\n- 符号表的功能：\n（1）   建立存储信息\n（2）   类型检查\n（3）   数据地址\n\n# 第七章 运行时的环境\n\n## 运行环境\n- 完全静态环境：FORTRAN77，所有数据都是静态的，执行期间保持固定。这样的环境可用来实现没有指针或动态分配，且过程不可递归调用的语言。\n- 基于栈的环境：C，C++，Pascal，Ada。在允许递归调用以及每一个调用中都重新分配局部变量的语言中，不能静态地分配活动记录。相反地，必须以一个基于栈的风格来分配活动记录，即当进行一个新的过程调用 ( 活动记录的压入时，每个新的活动记录都分配在栈的顶部，而当调用退出时则再次解除分配 。\n- 完全动态环境：LISP。因为活动记录仅在对它们所有的引用都消失了才再重新分配，而且这又要求活动记录在执行时可动态地释放任意次，所以称这个环境为完全动态的 。\n\n# 第八章 代码生成\n\n## 中间代码\n- 两种形式：三地址码，P代码\n- 中间代码应具备的特性\n1）便于语法制导翻译\n2）既与机器指令的结构相近,又与具体机器无关.\n\n## 控制语句\n- 控制语句的分类：①无条件转移、②条件转移、③循环语句、④分支语句\n\n## 代码优化\n- 代码优化：对程序进行各种等价变换，使得从变换后的程序出发，能产生更有效的目标代码。\n- 目的：产生高效的目标代码。\n- 级别：局部优化、循环优化、全局优化。\n\n## 补充\n- 活前缀：右句型的前缀，而且其右端不会超过该句型的最右边句柄的末端。\n![](https://unpkg.com/justlovesmile-img/20200722172904.png)\n![](https://unpkg.com/justlovesmile-img/20200722172937.png)","tags":["大学课程","编译原理"],"categories":["学习笔记"]},{"title":"学习笔记 | 《算法导论》之从入门到放弃（3）","slug":"学习笔记-算法导论学习笔记3","url":"/posts/54183.html","content":"算法导论打卡3，主要内容：堆排序\n\n# 第六章 堆排序\n\n## 堆\n- 二叉堆是一个数组，它可以被看成一个近似的完全二叉树。树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。\n- 表示堆的数组A包括两个属性：A.length(通常)给出数组元素的个数，A.heap-size表示有多少个堆元素存储在该数组中。也就是说虽然A[1..A.length]可能都存有数据，但只有A[1..A.heap-size]中存放的是堆的有效元素，这里0≤A.heap-size≤A.length。树的根节点是A[1]，这样给定一个结点的下标i，我们很容易计算得到它的父结点，左孩子和右孩子的下标：\n\n```python\ndef parent(i):\n\treturn i//2\ndef left(i):\n\treturn 2*i\ndef right(i):\n\treturn 2*i+1\n```\n\n- ![Ko9IoQ.md.png](https://s2.ax1x.com/2019/10/31/Ko9IoQ.md.png)\n- 二叉堆可以分为两种形式：最大堆和最小堆。在这两种堆中，结点的值都要满足堆的性质。区别在于：\n\t- 最大堆中，最大堆性质是指除了根以外的所有结点i都要满足：A[PARENT(i)]≥A[i]，即在任一子树中，该子树所包含的所有结点的值都不大于该子树根节点的值。\n\t- 最小堆中，最小堆性质是指除了根以外的所有结点i都要满足：A[PARENT(i)]≤A[i]\n- 在堆排序算法中，我们使用最大堆。最小堆通常用于构造优先队列。\n- 如果把堆看成一棵树，我们定义一个堆中的结点的高度是该节点到叶结点最长简单路径上`边的数目`。既然一个包含n个元素的堆可以看作是一颗完全二叉树，那么该堆的高度是`O(lgn)`\n- 堆结构上的一些基本操作的运行时间至多与树的高度成正比，即时间复杂度为O(lgn).\n\n## 维护堆的性质\n- 通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根结点的子树重新遵循最大堆的性质：\n\n```python\ndef max_heapify(A,i):\n    l,r=2*i,2*i+1\n    heap_size=len(A)-1\n    if(l<=heap_size and A[l]>A[i]):\n        largest=l\n    else:\n        largest=i\n    if(r<=heap_size and A[r]>A[largest]):\n        largest=r\n    if(largest!=i):\n        temp=A[i]\n        A[i]=A[largest]\n        A[largest]=temp\n        max_heapify(A,largest)\n```\n- 对于一个高为h的结点来说，max_heapify的时间复杂度是O(h)。\n\n## 建堆\n\n```python\ndef build_max_heap(A):\n\t#A[0]存储堆元数个数\n    for i in range(1,A[0]//2+1)[::-1]:\n        max_heapify(A,i)\n```\n- 完整代码：\n\n```python\ndef max_heapify(A,i):\n    l,r=2*i,2*i+1\n    heap_size=A[0]\n    if(l<=heap_size and A[l]>A[i]):\n        largest=l\n    else:\n        largest=i\n    if(r<=heap_size and A[r]>A[largest]):\n        largest=r\n    if(largest!=i):\n        temp=A[i]\n        A[i]=A[largest]\n        A[largest]=temp\n        max_heapify(A,largest)\n\ndef build_max_heap(A):\n\t#A[0]存储堆元数个数\n    for i in range(1,A[0]//2+1)[::-1]:\n        max_heapify(A,i)\n\nif __name__ == \"__main__\":\n\t#数组的第一个位置存储堆元素个数，并用于占位\n    A=[9,50, 16, 30, 10, 60,  90,  2, 80, 70]\n    build_max_heap(A)\n    for i in range(1,A[0]+1):\n        print(A[i])\n```\n\n## 堆排序算法\n- 因为数组的最大元素总是在根结点A[1]中，通过把它与A[n]进行互换，我们可以把该元素放到正确的位置上(如从小到大排列)\n\n```python\ndef max_heapify(A,i):\n    l,r=2*i,2*i+1\n    heap_size=A[0]\n    if(l<=heap_size and A[l]>A[i]):\n        largest=l\n    else:\n        largest=i\n    if(r<=heap_size and A[r]>A[largest]):\n        largest=r\n    if(largest!=i):\n        temp=A[i]\n        A[i]=A[largest]\n        A[largest]=temp\n        max_heapify(A,largest)\n\ndef build_max_heap(A):\n\t#A[0]存储堆元数个数\n    for i in range(1,A[0]//2+1)[::-1]:\n        max_heapify(A,i)\n\ndef heapsort(A):\n\tbuild_max_heap(A)\n\tn=A[0]\n\tfor i in range(2,n+1)[::-1]:\n\t\ttemp=A[1]\n\t\tA[1]=A[i]\n\t\tA[i]=temp\n\t\tA[0]-=1\n\t\tmax_heapify(A,1)\n\tA[0]=n\n\nif __name__==\"__main__\":\n\t#数组的第一个位置存储堆元素个数，并用于占位\n    A=[9,50, 16, 30, 10, 60,  90,  2, 80, 70]\n    heapsort(A)\n    for i in range(1,A[0]+1):\n        print(A[i])\n```\n\n- heapsort的时间复杂度是O(nlgn),因为每次调用build_max_heap的时间复杂度是O(n)，而n-1次调用max_heapify，每次的时间是O(lgn)。\n\n## 优先队列\n- 优先队列是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个相关的值，称为关键字。\n- 一个最大优先队列支持以下操作：\n    - insert(S,x)：把元素x插入集合S中。\n    - maximum(S)：返回S中具有最大关键字的元素。\n    - extract-max(S)：去掉并返回S中具有最大关键字的元素。\n    - increase-key(S,x,k)：将元素x的关键字值增加到k，这里假设k的值不小于x的原关键字值。\n- 最小优先队列同理\n- 实现：\n\n```python\ndef heap_maximum(A):\n    return A[1]\n\ndef heap_extract_max(A):\n    heap_size=len(A)-1\n    if(heap_size<1):\n        raise IndexError(\"heap underflow\")\n    Max=A[1]\n    A[1]=A[heap_size]\n    heap_size-=1\n    max_heapify(A,1)\n    return Max\n\ndef heap_increase_key(A,i,key):\n    if(key<A[i]):\n        raise Exception,\"new key is small than current key\"\n    A[i]=key\n    while(i>1 and A[parent[i]]<A[i]):\n        temp=A[i]\n        A[i]=A[parent[i]]\n        A[parent[i]]=temp\n        i=parent[i]\n\ndef max_heap_insert(A,key):\n    heap_size+=1\n    A[heap_size]=float('-inf')\n    heap_increase_key(A,heap_size,key)\n```","tags":["Python","算法"],"categories":["学习笔记"]},{"title":"Python指南 | 在linux上安装python3.7","slug":"折腾记录-在linux上安装python3-7","url":"/posts/39201.html","content":"今天在腾讯云服务器上安装了python3，又学到的知识。\n<!-- more -->\n\n# 如何在Linux环境中安装Python3.7.0以上\n#### 1.下载python\n\n```\ncd /home\nwget http://cdn.npm.taobao.org/dist/python/3.7.4/Python-3.7.4.tgz\n```\n- 使用了wget软件，从指定URL下载文件\n\n#### 2.解压Python安装文件\n\n```\ntar -zxvf Python-3.7.4.tgz\n```\n- tar是Linux自带的解压命令\n\n#### 3.安装编译Python3.7以上的源文件所需的编译环境\n\n```\nyum install -y gcc\nyum install -y zlib*\nyum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel\n```\n\n#### 4.进入Python3 源文件文件夹\n\n```\ncd Python-3.6.5/\n```\n\n#### 5.指定安装目录\n\n```\n./configure --prefix=/usr/local/python3 --with-ssl\n```\n- 不要忘记最前面的“.”\n\n#### 6.编译源文件\n\n```\nmake\n```\n\n#### 7.正式安装\n\n```\nmake install\n```\n#### 8.建立软连接\n\n```\n ln -s /usr/local/python3/bin/python3 /usr/bin/python3 \n ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 \n```\n- 软连接就相当于win下的快捷方式。你可以通过快捷方式打开你想要使用的软件\n\n#### 9.安装Python3的XXXXX包。直接在终端使用如下命令即可：\n\n```\npip3 install XXXXX\n```\n","tags":["Python","Linux"],"categories":["折腾记录"]},{"title":"学习笔记 | 什么是Node.js","slug":"学习笔记-Node-js","url":"/posts/49210.html","content":"开始去了解node.js\n<!-- more -->\n# Node.js简介\n- Node.js是运行在服务端的JavaScript，是一个事件驱动I/O服务端Javascript环境。\n- 查看版本：\n```\nnode -v\n```\n- node版本管理工具nvm\n\n# Node.js应用\n-  Node.js应用的构成：\n    - 引入required模块\n    - 创建服务器\n    - 接收请求与响应请求\n\n## 创建Node.js应用\n- 步骤一：引入required模块\n    - 使用require指令来载入http模块，并将实例化的HTTP复制给变量http，实例如下：\n\n```js\nvar http = require(\"http\");\n```\n\n- 步骤二：创建服务器\n1. 创建一个server.js的文件:\n\n```js\nvar http = require(\"http\");\n\nhttp.createServer(function(request,response){\n    //发送http头部\n    //HTTP状态值：200 ：OK\n    //内容类型：text/plain\n    response.writeHead(200,{'Content-Type':'text/plain'});\n    //发送响应数据 “Hello World”\n    response.end('Hello World\\n');\n}).listen(8888);\n\n//终端打印如下信息\nconsole.log('Server running at http://127.0.0.1:8888/');\n```\n\n2. 使用node命令执行以上代码\n\n```\nnode server.js\n```\n3. 访问http://127.0.0.1:8888/\n\n## npm使用介绍\n- 查看npm版本\n\n```\nnpm -v\n```\n- 升级版本\n\n```\nnpm install npm -g\n```\n- 安装包\n\n```\nnpm install <Module Name>          # 本地安装\nnpm install <Module Name> -g       # 全局安装\n```\n- 查看安装信息\n\n```\nnpm list -g                        # 查看全局安装的模块\nnpm list <Module Name>             # 查看某个模块的版本号\nnpm ls                             # 查看当前目录下的包信息\n```\n- 卸载模块\n\n```\nnpm uninstall <Module Name>\n```\n\n- 更新模块\n\n```\nnpm update <Module Name>\n```\n\n- 搜索模块\n\n```\nnpm search <Module Name>\n```\n\n- 创建模块\n\n```\n$npm init                            # 会自动生成package.json\n\n$npm adduser                         # 在npm资源库中注册用户\nUsername:XXXX\nPassword:XXXXXXX\nEmail: XXXXXXXXX@XXX.XXX\n\n$npm publish                         # 发布模块\n```\n\n## Node.js REPL(交互式解释器)\n- REPL(Read Eval Print Loop:交互式解释器)，Node自带交互式解释器，可以执行`读取`,`执行`,`打印`,`循环`等任务\n- 在Node的REPL中可以执行：\n1. 简单的表达式运算\n\n```\n$ node\n> 1+4\n5\n> 5/2\n2.5\n>  \n```\n2. 使用变量\n\n```\n$ node\n> 1+4\n5\n> 5/2\n2.5\n> x=10\n10\n> var y=10\nundefined\n> x+y\n20\n> console.log(\"Hello World!\")\nHello World!\nundefined\n>  \n```\n\n3. 多行表达式\n\n```\n$ node\n> do {\n... x++;\n... console.log(\"x:\"+x);\n... }while(x<5);\nx:1\nx:2\nx:3\nx:4\nx:5\nundefined\n>       \n```\n\n4. 下划线变量`[使用下划线(_)获取上一个表达式的运算结果]`\n\n```\n$ node\n> var x=10;\nundefined\n> y=10;\n10\n> x+y\n20\n> var sum=_\nundefined\n> console.log(sum)\n20\nundefined\n>\n```\n5. 两次ctrl+c停止REPL\n\n## Node.js的回调函数\n- Node.js异步编程的直接体现就是回调\n- 阻塞代码实例\n- 创建一个文件 input.txt ，内容如下：\n\n```\nHello world!\n```\n- 创建 main.js 文件, 代码如下：\n\n```js\nvar fs = require(\"fs\");\n\nvar data = fs.readFileSync('input.txt');\n\nconsole.log(data.toString());\nconsole.log(\"程序执行结束!\");\n```\n- 以上代码执行结果如下：\n\n```\n$ node main.js\nHello World！\n\n程序执行结束!\n```\n- 非阻塞代码实例\n- 创建一个文件 input.txt ，内容如下：\n\n```\nHello World!\n```\n- 创建 main.js 文件, 代码如下：\n\n```js\nvar fs = require(\"fs\");\n\nfs.readFile('input.txt', function (err, data) {\n    if (err) return console.error(err);\n    console.log(data.toString());\n});\n\nconsole.log(\"程序执行结束!\");\n```\n- 以上代码执行结果如下：\n\n```\n$ node main.js\n程序执行结束!\nHello World!\n```\n\n- 第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。\n- 因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。","tags":["JS"],"categories":["学习笔记"]},{"title":"学习笔记 | 《算法导论》之从入门到放弃（2）","slug":"学习笔记-算法导论学习笔记2","url":"/posts/4966.html","content":"《算法导论》打卡2，主要内容：渐进记号，分治策略，最大子数组问题,矩阵乘法的strassen算法\n<!-- more -->\n# 第三章 函数的增长\n- 当输入规模足够大，使得只有运行时间的增长量级有关时，我们要研究算法的渐进效率。也就是说，我们关心当输入规模无限增加时，在极限中，算法的运行时间如何随着输入规模的变大而增加。\n## 3.1 渐进记号\n- 用来描述算法渐进运行时间的记号根据定义于为自然数集N={0，1，2，...}的函数来定义\n\n### 3.1.1 Θ记号\n- `Θ记号`：对一个给定的函数g(n)，用Θ(g(n))来表示以下函数的集合：\n`Θ(g(n))={f(n):存在正常量c1,c2和n0,使得对所有n≥n0,有0≤c1*g(n)≤f(n)≤c2*g(n)}`\n- ![uFAyV0.png](https://s2.ax1x.com/2019/09/23/uFAyV0.png)\n\n### 3.1.2 O记号\n- `O记号`：当只有一个渐进上界时，使用O记号，对于一个给定的函数g(n)，用O(g(n))来表示以下函数的集合：\n`O(g(n))={f(n):存在正常量c和n0，使得对所有n≥n0，有0≤f(n)≤c*g(n)}`\n\n### 3.1.3 Ω记号\n- `Ω记号`：渐进下界。使用Ω记号，对于一个给定的函数g(n)，用Ω(g(n))来表示以下函数的集合：\n`Ω(g(n))={f(n):存在正常量c和n0，使得对所有n≥n0，有0≤c*g(n)≤f(n)}`\n\n- 定理：`对任意两个函数f(n)和g(n),我们有f(n)=Θ(g(n))，当且仅当f(n)=O(g(n))且f(n)=Ω(g(n))`\n\n### 3.1.4 o记号\n- `o记号`：表示非渐进紧确的上界\n`o(g(n))={f(n):对于任意正常书c>0,存在常量n0＞0，使得对所有n≥n0，有0≤f(n)＜c*g(n)}`\n\n### 3.1.5 w记号\n- `w记号`：表示非渐进紧确的下界\n`w(g(n))={f(n):对任意正常量c＞0，存在常量n0＞0，使得对所有n≥n0，有0≤c*g(n)＜f(n)}`\n\n## 3.2 标准记号与常用函数\n- 单调性\n- 向下取整与向上取整符号\n- 模运算\n- 多项式\n- 指数\n- 对数\n- 阶乘\n- 多重函数\n- 多重对数函数\n- 斐波那契数\n\n# 第四章 分治策略\n- 分治策略的步骤：`分解`，`解决`，`合并`\n- 递归情况：子问题足够大，需要递归求解\n- 基本情况：子问题足够小，递归已“触底”\n- 递归式：通过更小的输入上的函数值来描述一个函数\n- 求解递归式的方法：\n    - 代入法\n    - 递归树法\n    - 主方法\n\n## 4.1 最大子数组问题\n- ![ukpsGd.png](https://s2.ax1x.com/2019/09/24/ukpsGd.png)\n- 由于时间原因，最大化利益不一定是最低价格买入，最高价格卖出，因为存在最高价格先于最低价格出现的可能\n- 暴力破解方法：尝试每一对可能的买入卖出，只要卖出时间在买入时间之后即可。\n- 问题交换：\n- ![ukC7D0.png](https://s2.ax1x.com/2019/09/24/ukC7D0.png)\n- 只有当数组中包含负数时，最大子数组问题才有意义，如果所有数组元素都是非负的，最大数组问题没有任何难度，因为整个数组的和肯定是最大的。\n- 使用分治策略的求解方法：\n- ![ukFJun.png](https://s2.ax1x.com/2019/09/24/ukFJun.png)\n- python\n\n```python\n#python3\n#find max crossing subarray\ndef f_m_c_s(A,low,mid,high):\n    left_sum=float('-inf')\n    right_sum=float('-inf')\n    temp_sum=0\n\n    for i in range(mid,low-1,-1):\n        temp_sum=temp_sum+A[i]\n        if temp_sum>left_sum:\n            left_sum=temp_sum\n            max_left=i\n    temp_sum=0\n    for i in range(mid+1,high+1):\n        temp_sum=temp_sum+A[i]\n        if temp_sum>right_sum:\n            right_sum=temp_sum\n            max_right=i\n    return max_left,max_right,left_sum+right_sum\n\n#find maxmum subarray\ndef f_m_s(A,low,high):\n    if high==low:\n        return low,high,A[low]\n    else:\n        mid=(low+high)//2\n        left_low,left_high,left_sum=f_m_s(A,low,mid)\n        right_low,right_high,right_sum=f_m_s(A,mid+1,high)\n        cross_low,cross_high,cross_sum=f_m_c_s(A,low,mid,high)\n        if left_sum>=right_sum and left_sum>=cross_sum:\n            return left_low,left_high,left_sum\n        elif right_sum>=left_sum and right_sum>=cross_sum:\n            return right_low,right_high,right_sum\n        else:\n            return cross_low,cross_high,cross_sum\n\ndef main():\n    A=[-1,2,3,-4,7,6,3,-22,33,4]\n    print(f_m_s(A,0,len(A)-1))\n\nmain()\n```\n\n- 其他解法如：c++解决n个整数的数列，不超过m的最大子数列和\n\n```c++\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#define N 1000000\nusing namespace std;\n\nint n;\nint m;\nint a[N];\nint sum[N];\nint x;\nint ans;\nint main()\n {\n    scanf(\"%d%d\",&n,&m);\n    int l=1;int r=1;\n    for(int i=1;i<=n;i++)\n     {\n        while(l<=r&&a[l]<i-m)l++;\n        scanf(\"%d\",&x);\n        sum[i]=sum[i-1]+x;\n        ans=max(ans,sum[i]-sum[a[l]]);\n        while(l<=r&&sum[a[r]]>=sum[i])r--;\n        a[++r]=i;\n     }\n    printf(\"%d\",ans);\n }\n```\n\n## 4.2 矩阵乘法的Strassen算法\n- c++如何创建动态二维数组：\n\n```c++\n#include<iostream>\nusing namespace std;\n\nint main(){\n    int n;\n    cin>>n;\n    int **a=new int*[n];\n    for(int i=0;i<n;i++){\n        a[i]=new int[n];\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            cin>>a[i][j];\n        }\n    }\n}\n```\n\n- ![u83cb6.png](https://s2.ax1x.com/2019/09/29/u83cb6.png)\n- python矩阵乘法暴力破解算法\n\n```python\ndef matrixMultiply(A,B):\n    #len(A[0])是A的列数，len(A)是A的行数，B同理\n    C = []\n    if len(A[0]) != len(B):\n         return false\n    for i in range(len(A)):\n        row=[]\n        for j in range(len(B[0])):\n            s = 0\n            for k in range(len(A[0])):\n                s += A[i][k]*B[k][j]\n            row.append(s)\n        C.append(row)\n    return C \n\ndef main():\n    A = [[1,2,3],[4,5,6]]\n    B = [[7,8],[9,10],[11,12]]\n    C = matrixMultiply(A,B)\n    for i in range(len(C)):\n        for j in C[i]:\n            print(j,end=\" \")\n        print(\"\\n\") \n\nif __name__ ==\"__main__\":\n    main()\n```\n\n- 方阵乘法的简单分治算法（前提：**假定A,B都是n等于2的次幂的方阵**）\n- ![ub68Vx.png](https://s2.ax1x.com/2019/10/11/ub68Vx.png)\n- python\n\n```python\ndef division(a):    #矩阵分块函数\n    n=len(a)//2\n    a11=[[0 for i in range(n)]for j in range(n)]\n    a12=[[0 for i in range(n)]for j in range(n)]\n    a21=[[0 for i in range(n)]for j in range(n)]\n    a22=[[0 for i in range(n)]for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            a11[i][j]=a[i][j]\n            a12[i][j]=a[i][j+n]\n            a21[i][j]=a[i+n][j]\n            a22[i][j]=a[i+n][j+n]\n    return (a11,a12,a21,a22)\n \ndef matrix_combination(a11,a12,a21,a22):\n    n2 = len(a11)\n    n=n2*2\n    a = [[0 for col in range(n)] for row in range(n)]\n    for i in range (0,n):\n        for j in range (0,n):\n            if i <= (n2-1) and j <= (n2-1):\n                a[i][j] = a11[i][j]\n            elif i <= (n2-1) and j > (n2-1):\n                a[i][j] = a12[i][j-n2]\n            elif i > (n2-1) and j <= (n2-1):\n                a[i][j] = a21[i-n2][j]\n            else:\n                a[i][j] = a22[i-n2][j-n2]\n    return a\ndef matrix_add(a,b):  #矩阵相加函数\n    n = len(a)\n    c = [[0 for col in range(n)] for row in range(n)]\n    for i in range(0,n):\n        for j in range(0,n):\n            c[i][j] = a[i][j]+b[i][j]\n    return c\n \ndef matrix_devision_multiply(a,b):   #矩阵乘法的简单分治法主程序\n    n=len(a)\n    c = [[0 for col in range(n)] for row in range(n)]#c=[[0]*n for i in range(n)]\n    if n==1:\n        c[0][0]=a[0][0]*b[0][0]\n    else:\n        (a11,a12,a21,a22)=division(a)\n        (b11,b12,b21,b22)=division(b)\n        (c11,c12,c21,c22)=division(c)\n        c11=matrix_add(matrix_devision_multiply(a11,b11),matrix_devision_multiply(a12,b21))\n        c12=matrix_add(matrix_devision_multiply(a11,b12),matrix_devision_multiply(a12,b22))\n        c21=matrix_add(matrix_devision_multiply(a21,b11),matrix_devision_multiply(a22,b21))\n        c22=matrix_add(matrix_devision_multiply(a21,b12),matrix_devision_multiply(a22,b22))\n        c=matrix_combination(c11,c12,c21,c22)\n    return c\n \na=[[1,1,1,1],[1,1,1,1],[2,2,2,2],[2,2,2,2]]\nb=a\nprint(matrix_devision_multiply(a,b))\n```\n\n- 矩阵乘法的Strassen算法\n![uqgrWT.png](https://s2.ax1x.com/2019/10/11/uqgrWT.png)\n![uq6N9S.png](https://s2.ax1x.com/2019/10/11/uq6N9S.png)\n![uq6yNV.png](https://s2.ax1x.com/2019/10/11/uq6yNV.png)\n![uq6oAx.png](https://s2.ax1x.com/2019/10/11/uq6oAx.png)\n![uq6OjH.png](https://s2.ax1x.com/2019/10/11/uq6OjH.png)\n\n```python\n\ndef matrix_strassen(a,b):\n    n=len(a)\n    c = [[0 for col in range(n)] for row in range(n)]\n    if n==1:\n        c[0][0]=a[0][0]*b[0][0]\n    else:\n        (a11,a12,a21,a22)=division(a)\n        (b11,b12,b21,b22)=division(b)\n        (c11,c12,c21,c22)=division(c)\n        s1=matrix_add_sub(b12,b22,0)\n        s2=matrix_add_sub(a11,a12,1)\n        s3=matrix_add_sub(a21,a22,1)\n        s4=matrix_add_sub(b21,b11,0)\n        s5=matrix_add_sub(a11,a22,1)\n        s6=matrix_add_sub(b11,b22,1)\n        s7=matrix_add_sub(a12,a22,0)\n        s8=matrix_add_sub(b21,b22,1)\n        s9=matrix_add_sub(a11,a21,0)\n        s10=matrix_add_sub(b11,b12,1)\n        p1=matrix_strassen(a11,s1)\n        p2=matrix_strassen(s2,b22)\n        p3=matrix_strassen(s3,b11)\n        p4=matrix_strassen(a22,s4)\n        p5=matrix_strassen(s5,s6)\n        p6=matrix_strassen(s7,s8)\n        p7=matrix_strassen(s9,s10)\n        c11=matrix_add_sub(matrix_add_sub(matrix_add_sub(p5,p4,1),p2,0),p6,1)\n        c12=matrix_add_sub(p1,p2,1)\n        c21=matrix_add_sub(p3,p4,1)\n        c22=matrix_add_sub(matrix_add_sub(matrix_add_sub(p5,p1,1),p3,0),p7,0)\n        c=matrix_combination(c11,c12,c21,c22)\n    return c\n \n#矩阵的strssen算法\ndef division(a):                              #对矩阵进行分解操作\n    n=len(a)//2\n    a11=[[0 for i in range(n)]for j in range(n)]\n    a12=[[0 for i in range(n)]for j in range(n)]\n    a21=[[0 for i in range(n)]for j in range(n)]\n    a22=[[0 for i in range(n)]for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            a11[i][j]=a[i][j]\n            a12[i][j]=a[i][j+n]\n            a21[i][j]=a[i+n][j]\n            a22[i][j]=a[i+n][j+n]\n    return (a11,a12,a21,a22)\n \ndef matrix_add_sub(a,b,keys):\n    n = len(a)\n    c = [[0 for col in range(n)] for row in range(n)]\n    if keys==1:\n        for i in range(n):\n            for j in range(n):\n                c[i][j] = a[i][j]+b[i][j]\n    else:\n        for i in range(n):\n            for j in range(n):\n                c[i][j]=a[i][j]-b[i][j]\n    return c\ndef matrix_combination(a11,a12,a21,a22):    #对矩阵进行组合操作\n    n2 = len(a11)\n    n=n2*2\n    a = [[0 for col in range(n)] for row in range(n)]\n    for i in range (0,n):\n        for j in range (0,n):\n            if i <= (n2-1) and j <= (n2-1):\n                a[i][j] = a11[i][j]\n            elif i <= (n2-1) and j > (n2-1):\n                a[i][j] = a12[i][j-n2]\n            elif i > (n2-1) and j <= (n2-1):\n                a[i][j] = a21[i-n2][j]\n            else:\n                a[i][j] = a22[i-n2][j-n2]\n    return a\n \na=[[1,1,1,1],[1,1,1,1],[2,2,2,2],[2,2,2,2]]\nb=a\nprint(matrix_strassen(a,b))\n```","tags":["Python","算法"],"categories":["学习笔记"]},{"title":"学习笔记 | 《算法导论》之从入门到放弃（1）","slug":"学习笔记-算法导论学习笔记1","url":"/posts/4646.html","content":"《算法导论》打卡1，主要内容：插入排序，分治法，归并排序\n<!-- more -->\n# 第一部分 基础知识\n## 第一章 算法在计算中的作用\n### 1.1 算法\n- 算法就是任何良定义的计算过程，该过程取某个值或值的集合作为**输入**并产生某个值或者值的集合作为**输出**。\n- 规范书写：\n\n```\n问题：XXXX\n输入：XXXXXXXX\n输出：XXXXXXXX\n算法步骤：\n1.XXXXXXXXXXX\n2.XXXXXXXXXXX\n```\n\n- 注意问题与问题实例的区别。\n\n### 1.2 作为一种技术的算法\n- 考虑效率：时间与空间资源的消耗\n\n## 第二章 算法基础\n### 2.1 插入排序\n\n```\n输入：n个数的一个序列<a1,a2,...,an>\n输出：输入序列的一个排列<a1’,a2’,...,an’>，满足a1’≤a2’≤...≤an’\n```\n- 算法：\n\n```c++\n#include<iostream>\nusing namespace std;\n\nvoid insertionsort(int *A,int length){\n    //插入排序\n    int key; //暂存当前位置的值\n    int i;\n    for(int j=1;j<length;j++){\n        key = A[j]; //暂存当前位置的值\n        i= j-1;\n        while(i>=0 && A[i]>key){ //如果前面的值比key大，则交换\n            A[i+1]=A[i];\n            i=i-1;\n        }\n        A[i+1]=key;\n    }\n}\nint main(){\n    int A[9]={9,3,4,2,6,7,5,1,8}; //举了个栗子\n    int length=sizeof(A)/sizeof(A[0]); //求数组的长度的一种方法\n    insertionsort(A,length);\n    \n    //输出排序后的序列\n    for(int i=0;i<length;i++){\n        cout<<A[i]<<\" \";\n    }\n    return 0;\n}\n```\n- ![nO9np9.png](https://s2.ax1x.com/2019/09/19/nO9np9.png)\n- 伪代码👇\n- ![uPypCV.png](https://s2.ax1x.com/2019/09/23/uPypCV.png)\n- ![uPynC6.png](https://s2.ax1x.com/2019/09/23/uPynC6.png)\n\n### 2.2 分析算法\n- 时间复杂度：最好的情况下：O(n),最坏的情况下：O(n²),平均情况下：O(n²)\n- ![uP6qTs.png](https://s2.ax1x.com/2019/09/23/uP6qTs.png)\n### 2.3 设计算法\n#### 2.3.1 分治法\n- 分治法：将原问题分解为几个规模较小但类似于原问题的子问题，递归求解这些子问题，然后再合并这些子问题的解来建立原问题的解\n- 归并排序：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid merge(int arr[],int left,int mid,int right)\n{\n    int aux[right-left+1];//开辟一个新的数组，将原数组映射进去\n    for(int m=left;m<=right;m++)\n    {\n        aux[m-left]=arr[m];\n    }\n\n    int i=left,j=mid+1;//i和j分别指向两个子数组开头部分\n\n    for(int k=left;k<=right;k++)\n    {\n        if(i>mid)//右边还有剩余\n        {\n            arr[k]=aux[j-left];\n            j++;\n        }\n        else if(j>right)//左边还有剩余\n        {\n            arr[k]=aux[i-left];\n            i++;\n        }\n        else if(aux[i-left]<aux[j-left])//左边小于右边\n        {\n            arr[k]=aux[i-left];\n                i++;\n        }\n        else//右边小于左边\n        {\n            arr[k]=aux[j-left];\n            j++;\n        }\n    }\n}\n//递归的使用归并排序，对arr[l....right]排序\nvoid merge_sort(int arr[],int left,int right)\n{\n    if(left >=right)\n        return ;\n    int mid=(left+right)/2;\n    merge_sort(arr,left,mid);\n    merge_sort(arr,mid+1,right);\n    merge(arr,left,mid,right);\n}\n\nvoid my_merge_sort(int arr[],int n)\n{\n    merge_sort(arr,0,n-1);\n}\n\nint main()\n{\n    //举个栗子\n    int a[6];\n    for(int i=0;i<6;i++)\n    {\n        cin>>a[i];\n    }\n    my_merge_sort(a,6);\n    for(int i=0;i<6;i++)\n    {\n        cout<<a[i]<<\" \";\n    }\n    return 0;\n}\n```\n- ![uPx85n.png](https://s2.ax1x.com/2019/09/23/uPx85n.png)\n- ![uPxXqg.png](https://s2.ax1x.com/2019/09/23/uPxXqg.png)\n\n#### 2.3.2 分析分治算法\n- ![uiBjot.png](https://s2.ax1x.com/2019/09/23/uiBjot.png)\n- 时间复杂度：平均情况：O(nlogn),最好情况：O(nlogn),最坏情况：O(nlogn)","tags":["算法","C++"],"categories":["学习笔记"]},{"title":"印象笔记APP | 如何将enex格式转化为markdown格式","slug":"折腾记录-enex格式转化为md格式","url":"/posts/10406.html","content":"\n印象笔记导出的enex格式如何转换成markdown格式\n\n# 第一步\n\n- 导出笔记为enex格式\n\n# 第二步\n\n- 确认安装了nodejs环境\n\n# 第三步\n\n- 在对应路径下使用npm安装：\n\n```\nnpm install -g enex-dump\n```\n\n- 导出md文件\n\n```\nenex-dump --src ./XXXXXXXXXX.enex\n```\n\n- 之后会在该路径下生成一个dump文件夹，其中dump/notes 下为转换后的md文件，dump/attachments下为图片与其他资源...","tags":["印象笔记","Markdown"],"categories":["折腾记录"]},{"title":"大学课程 | 计算机操作系统","slug":"学习笔记-计算机操作系统","url":"/posts/8398.html","content":"\n大二计算机操作系统课程笔记\n\n# 计算机操作系统\n\n## 第一章 操作系统引论\n\n- 操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。\n\n### 1.1 操作系统的目标和作用\n\n- ![Image [4]](https://unpkg.com/justlovesmile-img/202109080914112.png)\n- ![Image [3]](https://unpkg.com/justlovesmile-img/202109080911146.png)\n- 操作系统的地位：紧贴于系统硬件之上，所有其他软件之下（是其他软件的共同环境）。\n\n#### 1.1.1 操作系统的目标\n\n---\n\n1. **方便性**：对**用户**方便，提供良好的，一致的用户接口\n2. **有效性**：对**系统管理人员**方便  \n    （1）提高了系统资源的利用率  \n    （2）提高系统吞吐量\n3. **可扩充性**：与OS结构相关，方便添加新的功能和模块  \n    早期无结构→模块化结构→层次结构→微内核结构和客户服务器模式\n4. **开放性**：开放系统互连OSI国际标准，实现应用的可移植性和互操作性\n\n#### 1.1.2 操作系统的作用\n\n---\n\n> 操作系统的非形式化定义（关键点）：**系统软件，程序模块的集合，资源管理和用户接口功能**\n\n1. OS作为用户与计算机硬件系统之间的接口\n\n- 通过三种方式使用计算机：**命令方式**，**系统调用方式**，**图标—窗口方式**\n\n2. OS作为计算机系统资源的管理者\n\n- 对这些资源：<u style=\"line-height: 160%; box-sizing: content-box;\">处理机，存储器，I/O设备以及文件（数据和程序）</u>**有效的管理**。\n\n3. OS实现了对计算机资源的抽象（OS是扩展机，是虚拟机器）\n\n- 在裸机上添加：设备管理、文件管理、存储管理（针对内存和外存）、处理机管理（针对CPU）\n- 合理组织工作流程：作业管理、进程管理。\n\n#### 1.1.3 推动操作系统发展的主要动力\n\n1. 不断提高计算机资源利用率和系统性能\n2. 方便用户\n3. 器件的不断更新换代\n4. 计算机体系结构的不断发展\n5. 不断提出新的应用需求\n\n### 1.2 操作系统的发展过程\n\n#### 1.2.1 未配置操作系统的计算机系统\n\n一， 人工操作方式：\n\n1. 计算机的工作特点\n\n- **用户独占全机**  \n    （用户是程序元，计算机专业人员）  \n    （编程语言是机器语言）  \n    （输入/输出：纸带或卡片）\n- **CPU等待人工操作**：严重降低计算机资源的利用率，存在人机矛盾\n\n2. 主要矛盾（**人机矛盾**）：\n\n- 计算机处理能力的提高，手工操作的低效率（造成浪费）\n- 用户独占全机的所有资源\n\n3. 提高效率的途径：  \n    专门的操作员，批处理\n\n二，脱机输入/输出方式：\n\n1. 工作方式：\n\n- 程序和数据的输入输出都是在外围机的控制下完成的，或者说，是在脱离主机的情况下进行的\n\n2. 优点：\n\n- 减少了CPU空闲时间\n- 提高了I/O速度\n\n#### 1.2.2 单道批处理系统\n\n1. 单道批处理系统的处理过程：\n\n- 通过作业控制语言将磁带（或卡片）上的若干个作业编成作业执行序列，自动实现作业间的自动转换。每个批作业由一个专门的**监督程序**自动依次处理。\n- 程序和数据虽然是成组成批提交，但是<u style=\"line-height: 160%; box-sizing: content-box;\">任一时间只有一个作业运行</u>，因此称为单道批处理。\n- 批处理中的作业的组成：包括用户程序、数据和作业说明书（作业控制语言）\n\n2. 单道批处理系统的特征：\n\n- 自动性\n- 顺序性\n- 单道性\n\n3. 优点：\n\n- 同一批内各作业的自动依次更替，改善了主机CPU和I/O设备的使用效率，提高了吞吐量。\n\n4. 缺点：\n\n- 主要缺点：系统的**资源得不到充分的利用**。CPU和I/O设备使用忙闲不均\n- 磁带或磁盘需要人工装卸，作业需要人工分类\n- 监督程序易遭到用户程序的破坏（由人工干预才可恢复）。\n- I/O与CPU之间的速差造成的CPU空闲\n\n#### 1.2.3 多道批处理系统\n\n1. 多道批处理系统的概念：在系统中，用户所提交的作业先存放在外存上，并排列成一个队列，称为“后备队列”，然后由作业调度程序按一定的算法，从后备队列中选出若干个作业调入内存，使它们共享CPU和系统中的各种资源。在程序A因I/O操作而空闲CPU时，运行程序B，使**多道程序交替运行**。\n\n- 内存中同时存放几个作业：  \n    （1）**宏观上并行运算**  \n    （2）**微观上串行运算**\n    \n- 特点：  \n    （1）**多道性**：  \n    多道程序驻留内存：提高了资源的利用率；  \n    程序并发执行：提高了系统的吞吐量  \n    （2）**无序性**：  \n    作业进入内存先后顺序和完成的先后顺序无对应性  \n    （3）**调度性**：  \n    作业调度  \n    进程调度\n\n2. 优点：  \n    （1）资源利用率高：**并发执行**  \n    （2）系统吞吐量大：①保持忙碌②系统开销小\n    \n3. 缺点：  \n    （1）平均周转时间长  \n    （2）无交互能力\n    \n4. 多道批处理系统需要解决的问题：  \n    （1）处理机争用问题  \n    （2）内存分配和保护问题  \n    （3）I/O设备分配问题  \n    （4）文件的组织和管理问题  \n    （5）作业管理问题  \n    （6）用户与系统的接口问题\n\n- 操作系统是一组控制和管理计算机硬件和软件资源，合理地对各类作业进调度，以及方便用户使用的程序集合\n- 单道与多道的区别：\n- ![Image](https://unpkg.com/justlovesmile-img/202109080906669.png)\n- ![下载](https://unpkg.com/justlovesmile-img/202109080859830.png)\n\n#### 1.2.4 分时系统\n\n1. 分时系统的引入，用户需求具体表现在：  \n    （1）人机交互  \n    （2）共享主机  \n    （3）便于用户上机\n    \n2. 分时系统实现中的关键问题：  \n    （1）及时接收  \n    （2）及时处理：\n    \n    -   作业直接进入内存\n    -   采用轮转运行方式：引入**时间片**\n    -   分为抢先式和非抢先式的OS（CPU让出OS的方式是自动还是强迫）\n3. 分时系统的特征：  \n    （1）多路性：共享主机  \n    （2）独立性：感觉像是用户独占主机  \n    （3）交互性  \n    （4）及时性\n\n#### 1.2.5 实时系统\n\n- 主要特征：将**时间**作为关键参数\n- 特点：（1）**可靠性强**（2）**响应时间短**\n\n1. 实时系统的类型：  \n    工业（武器）控制系统，信息查询系统，多媒体系统，嵌入式系统\n2. 实时任务的类型：  \n    （1）周期性，非周期性：截至时间：①开始截止时间②完成截止时间  \n    （2）硬实时，软实时：\n    -   硬实时：满足对截止时间的要求\n    -   软实时：不严格要求截止时间\n    -   ![Image [2]](https://unpkg.com/justlovesmile-img/202109080908858.png)\n\n#### 1.2.6 \\*微机操作系统的发展\n\n- 软件工程的出现：  \n    操作系统在结构、规模、数量、接口等方面都得到了简化：结构从复杂到简单，规模从大到小，核心外移。  \n    实际系统的数量由于通用、开放和标准化而大量减少。\n    \n- 小型化与网络：  \n    微机操作系统和个人操作系统\n    \n- 网络操作系统：  \n    （1）通过通信设施将物理上分散的具有自治功能的多个计算机系统互连起来的实现信息交换、资源共享、可互操作和协作处理的系统。  \n    （2）在各种计算机操作系统上，按网络体系结构协议标准开发的软件  \n    （3）包括网络管理、通信、安全、资源共享和各种网络应用  \n    （4）目标：是相互通信及资源共享\n    \n- 分布式操作系统：  \n    1）特征：  \n    （1）是一个统一的操作系统  \n    （2）资源进一步共享  \n    （3）透明性：资源共享与分布对用户是透明的  \n    （4）自治性：处于分布式系统的多个主机处于平等地位，无主从关系  \n    （5）处理能力增强、速度更快、可靠性增强  \n    2）网络和分布式的区别：  \n    （1）分布式具有各个计算机间相互通讯，无主从关系；网络有主从关系  \n    （2）分布式系统资源为所有用户共享；而网络有限制地共享  \n    （3）分布式系统中若干个计算机可相互协作共同完成一项任务\n    \n- 嵌入式系统：  \n    （1）在各种设备、装置或系统中，完成特定功能的软硬件系统。它们是一个大设备、装置或系统中的一部分，这个大设备、装置或系统可以不是“计算机”。由于它们被嵌入在各种设备、装置或系统中，因此称为嵌入式系统  \n    （2）EOS（Embedded Operating System）在嵌入式系统中的OS，运行在嵌入式智能芯片环境中  \n    （3）典型嵌入式操作系统的特性：\n    \n    -   完成某一项或有限项功能；不是通用型的\n    -   在性能和实时性方面有严格的限制\n    -   能源、成本和可靠性通常是影响设计的重要因素\n    -   占有资源少、易于连接\n    -   系统功能可针对需求进行裁剪、调整和生成，以便满足最终产品的设计要求\n\n---\n\n1. 单用户单任务操作系统：\n\n- 只允许一个用户上机，且只允许用户程序作为一个任务运行\n- CP/M ， MS-DOS\n\n2. 单用户多任务操作系统：\n\n- 只允许一个用户上机，但允许用户把程序分为若干个任务，并使他们并发执行\n- Windows\n\n3. 多用户多任务操作系统：\n\n- 允许多个用户通过各自的终端，使用同一台机器，共享系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发执行\n- UNIX OS\n\n---\n\n> 操作系统的发展规律:  \n> 操作系统的发展是由底层硬件、软件技术与上层应用需求的发展推动的。  \n> 操作系统的每一步发展都是权衡的结果：可能性与必要性的权衡，性能与代价的权衡，方便和效率的权衡。\n\n| 项目               | 网络OS   | 分布式OS             | 多处理机OS         |\n| ------------------ | -------- | -------------------- | ------------------ |\n| 单处理机           | 不像     | 像                   | 像                 |\n| 相同OS（同质）     | 不需要   | 需要                 | 需要               |\n| 有多少个OS         | n个      | n个                  | 1个                |\n| 通信               | 共享文件 | 通讯协议             | 共享存储器         |\n| 网络协议           | 不需要   | 不需要               | 需要               |\n| 运行队列           | 不需要   | 不需要               | 需要               |\n| 文件共享是否有限制 | 没有     | 有，需要特殊文件说明 | 有限制，需特殊文件 |\n\n### 1.3 操作系统的基本特性\n\n- 四个基本特性：**并发，共享，虚拟，异步**\n\n#### 1.3.1 并发\n\n1. 并行与并发：\n\n- 并行性：两个或多个时间在**同一时刻**发生\n- 并发性：两个或多个时间在**同一时间间隔内**发生\n\n2. 引入进程\n\n- 进程：**在系统中能独立运行并作为资源分配的基本单位**\n- 引入线程是现代操作系统的重要标志\n\n#### 1.3.2 共享\n\n- OS环境下的资源共享或称资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用\n\n1. **互斥共享方式**\n\n- 资源可以提供给多个进程，但应规定在一段时间内，只允许访问一个进程访问该资源\n- 资源分配后到释放之前，不能被其他进程所用\n- 临界资源：一段时间内只允许一个进程访问的资源\n\n2. **同时访问方式**\n\n- 资源允许在一段时间内由多个进程“同时”对它们进行访问\n- 可重入代码，磁盘文件\n- **并发和共享是多用户OS的两个最基本的特征**\n- 资源分配难以达到最优化\n\n#### 1.3.3 虚拟\n\n- 一个物理实体映射为若干个对应的逻辑实体\n- **虚拟是操作系统管理系统资源的重要手段，可提高资源利用率**。\n- CPU－－每个用户（进程）的“虚处理机”\n- 存储器－－每个进程都占有的地址空间（指令＋数据＋堆栈）\n- 显示设备－－多窗口或虚拟终端(virtual terminal)\n\n1. **时分复用技术**：  \n    （1）虚拟处理机技术  \n    （2）虚拟设备技术\n2. **空分复用技术**：\n\n> 虚拟的实现：如果是采用分时复用的方法，即对某一物理设备进行分时使用，设N是某物理设备所对应的虚拟的逻辑设备数，则每台虚拟设备的平均速度必然等于或低于物理设备速度的1/N。类似的如果是采用空分复用技术，此时一台虚拟设备平均占用的空间必然也等于或小于物理设备所拥有的空间的1/N\n\n#### 1.3.4 异步\n\n- 也称不确定性，指进程的执行顺序和执行时间的不确定性；\n- **进程的运行速度不可预知**：分时系统中，多个进程并发执行，“时走时停”，不可预知每个进程的运行推进快慢\n- 判据：无论快慢，应该结果相同， 通过进程互斥和同步手段来保证\n- **难以重现**系统在某个时刻的状态（包括重现运行中的错误）\n- 性能保证：实时系统与分时系统相似，但通过资源预留以保证性能\n\n### 1.4 操作系统的主要功能\n\n#### 1.4.1 处理机管理功能\n\n- 处理机管理的主要功能：创建和撤销进程，对诸进程的运行进行协调，实现进程之间的信息交换以及按照一定的算法把处理机分配给进程\n\n1. **进程控制**：为作业创建进程，撤销（终止）已结束的进程以及控制进程在运行过程中的状态转换\n2. **进程同步**：\n\n- **重要功能**\n- 主要功能：为多个进程的运行进行协调\n- 常用的协调方式：  \n    （1）进程互斥方式  \n    （2）进程同步方式：常用信号量机制\n\n3. 进程通信\n4. 调度：  \n    （1）作业调度：从后备队列中按照一定的算法选择除若干个作业，为它们分配资源，将其调入内存后，为其建立进程，将它们插入就绪队列  \n    （2）进程调度：从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配給它，并为它设置运行现场，使其投入执行\n\n#### 1.4.2 存储器管理功能\n\n- 为多道程序的运行提供良好的环境，提高存储器的利用率，方便用户使用，并能从逻辑上扩充内存\n\n1. **内存分配**  \n    （1）静态分配方式：每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许作业再次申请新的内存空间，也不允许在内存中移动  \n    （2）动态分配方式：允许作业在运行期间继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中移动。\n2. **内存保护**：保证进程间互不干扰、相互保密；如：访问合法性检查、甚至要防止从“垃圾”中窃取其他进程的信息\n3. **地址映射**：\n\n- **主要功能**\n- 进程逻辑地址到内存物理地址的映射；\n\n4. **内存扩充**：\n\n- 从**逻辑上**扩充内存容量\n- 设置内存扩充机制，以实现请求调入功能和置换功能\n\n#### 1.4.3 设备管理功能\n\n- 主要任务：  \n    （1）完成用户进程提出的I/O请求  \n    （2）提高CPU和I/O设备的利用率\n\n1. **缓冲管理**：单缓冲机制，双缓冲机制，公用缓冲池机制\n2. **设备分配**：\n3. **设备处理**：\n\n- 设备处理程序又叫：设备驱动程序，实现CPU和设备控制器之间的通信\n- 根据中断请求的类型，调用相对应的中断处理程序\n\n#### 1.4.4 文件管理功能\n\n- 主要任务：是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性\n\n1. **文件存储空间的管理**：为每一个文件分配必要的外存空间，提高外存的利用率，进而提高文件系统的存取速度\n2. **目录管理**：方便存取，实现共享，提高文件检索的速度\n3. **文件的读/写管理和保护**：  \n    （1）文件的读写/管理  \n    （2）文件保护：防止未经核准的用户存取文件，防止冒名顶替存取文件，防止以不正确的方式使用文件\n4. **软件管理**：软件的版本、相互依赖关系、安装和拆除等\n\n#### 1.4.5 操作系统与用户之间的接口\n\n1. **用户接口**：用户通过该接口直接或间接地控制自己的作业  \n    （1）联机用户接口  \n    （2）脱机用户接口  \n    （3）图形用户接口\n2. **程序接口**：为用户程序在执行中访问系统资源而设定的，是用户程序取得操作系统服务的唯一途径\n\n#### 1.4.6 现代操作系统的新功能\n\n1. 系统安全：  \n    （1）认证技术  \n    （2）密码技术  \n    （3）访问技术  \n    （4）反病毒技术\n2. 网络的功能和服务  \n    （1）网络通信  \n    （2）资源管理  \n    （3）应用互操作  \n    （4）支持多媒体  \n    （1）接纳控制功能  \n    （2）实施调度  \n    （3）多媒体文件的存储\n\n### 1.5 OS结构设计\n\n#### 1.5.1 传统操作系统结构\n\n1. 无结构操作系统\n   \n2. 模块化结构OS  \n    （1）基本概念：按功能精心地划分为若干个具有一定独立性和大小的模块，并仔细规定好各模块的间的接口，使各模块之间能通过接口实现交互。然后再细分为子模块，这种设计方法称为模块-接口法  \n    （2）模块独立性：\n    \n    -   内聚性：子模块内部各部分间联系的紧密程度，内聚性越高，模块独立性高\n    -   耦合度，指模块间相互联系和相互影响的程度，耦合度越低，模块独立性越好\n    \n    （3） 模块接口法的优缺点：  \n    优点：  \n    ①提高OS设计的正确性，可理解性，可维护性  \n    ②增强OS的可适应性  \n    ③加速OS的开发过程  \n    缺点：  \n    ①接口很难满足实际需求  \n    ②无序模块法，无法寻找一个可靠的决定顺序\n    \n3. 分层式结构OS  \n    （1）基本概念：有序分层法，每一步设计都建立在可靠的基础上，**高层仅依赖于紧邻它的底层**  \n    （2）优点：  \n    ①易保证系统的正确性  \n    ②易扩充和易维护性  \n    （3）缺点：系统效率低\n\n#### 1.5.2 客户/服务器模式\n\n1. 客户/服务器模式的由来：  \n    （1）客户机（2）服务器（3）网络系统\n2. 交互：  \n    （1）客户发送请求消息  \n    （2）服务器接受消息  \n    （3）服务器回送消息  \n    （4）客户机接受消息\n3. 优点：  \n    （1）数据的分布式处理和存储  \n    （2）便于集中管理  \n    （3）灵活性和可扩充性  \n    （4）易于改编应用软件\n4. 缺点：\n\n- 不可靠性和瓶颈问题\n\n#### 1.5.3 面向对象的程序设计\n\n1. 基本概念：（1）对象（2）对象类（3）继承\n2. 优点：（1）通过“重用”提高质量和效率（2）易修改性和易扩展性  \n    （3）易于保证正确性和可靠性\n\n#### 1.5.4 微内核OS结构\n\n- 适用于分布式系统环境\n\n1. 基本概念：  \n    （1）足够小的内核：最基本的部分：①与硬件处理紧密相关部分②较基本功能③C/S之间的通信  \n    （2）基于C/S模式  \n    （3）应用“机制和策略分离”原理：机制在低层，策略在系统高层  \n    （4）采用面向对象编程\n2. 微内核的功能：  \n    （1）进程（线程）管理：进程（线程）之间的通信是微内核OS最基本的功能  \n    （2）低级存储器管理：实现用户空间的逻辑地址变换为内存空间的物理地址的页表机制和地址变换机制  \n    （3）中断和陷入处理\n3. 微内核操作系统的优点：  \n    （1）提高可扩展性  \n    （2）增强系统可靠性  \n    （3）可移植性增强  \n    （4）支持分布式系统  \n    （5）融入面向对象技术\n4. 微内核操作系统存在的问题\n\n- 运行效率降低\n\n## 第二章 进程的描述与控制\n\n### 2.1 前趋图和程序执行\n\n#### 2.1.1 前趋图\n\n- **有向无循环**图，可记为DAG，用于描述进程之间的先后顺序。\n- 图中结点：进程或程序段\n- 有向边：结点之间的偏序或前趋关系\n- 权值：每个结点的重量\n\n#### 2.1.2 程序的顺序执行\n\n1. 程序的顺序执行\n2. 程序的顺序执行时的特征：  \n    （1）顺序性：每一个操作必须在下一个操作开始之前结束  \n    （2）封闭性：程序运行时独占全机资源，程序一旦开始执行，其执行结果不受外界因素影响  \n    （3）可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时。都可以得到相同的结果\n\n#### 2.1.3 程序并发执行\n\n- 只有在**不存在前驱关系**的程序之间才有可能并发执行，否则无法并发执行\n- 程序并发执行时的特征：  \n    （1）间断性  \n    （2）失去封闭性  \n    （3）不可在现性\n\n### 2.2 进程的描述\n\n#### 2.2.1 进程的定义和特征\n\n1. 进程的定义：  \n    （1）进程是程序的一次执行  \n    （2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动  \n    （3）进程是具有**独立功能**的**程序**在一个**数据集合**上**运行的过程**，它是系统进行资源分配和调度的一个独立单位。【数据集合说明：需要数据，运行的过程说明：有生命周期】\n\n- 进程控制块（PCB）：描述进程的基本情况和活动过程，进而控制和管理进程\n- 进程实体（进程映像）：包括：程序段，数据段，PCB\n- 一个程序可能对应多个进程（程序的多次执行）\n- 一个进程也可能对应多个程序（进程的多次调用）\n\n2. 进程的特征：  \n    （1）动态性：进程动，程序静  \n    （2）并发性  \n    （3）独立性  \n    （4）异步性：进程暂时的，程序永久的  \n    （5）结构性：程序段，数据段，PCB\n\n#### 2.2.2 进程的基本状态和转换\n\n1. 进程的三种基本状态：  \n    （1）**就绪状态**：n个进程最多n-1个，多个就绪状态的进程排成就绪队列  \n    （2）**执行状态**：单处理机只有一个，多处理机多个  \n    （3）**阻塞状态**：最多n个，正在执行的进程由于发生某事件（如I/O请求，申请缓冲区失败等）暂时无法继续执行时的状态\n    \n2. 三种基本状态的转换：  \n   \n   ![1](https://unpkg.com/justlovesmile-img/202109080910959.png)\n   \n3. 创建状态和终止状态  \n\n    ![1 [2]](https://unpkg.com/justlovesmile-img/202109080916841.png)\n\n    （1）创建状态：进程由创建而产生，创建一个进程的步骤：首先，进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入就绪队列之中。如果进程所需的资源得不到满足，比如系统尚无足够的内存使进程无法装入其中 ，此时<u style=\"line-height: 160%; box-sizing: content-box;\">创建工作尚未完成，进程不能被调度运行</u>，此时进程所处的状态被称为**创建状态**  \n    （2）终止状态  \n    首先，等待操作系统进行善后处理，最后将其PCB清零，并将PCB空间返回系统。当一个进程到达了自然结束点，或是出现了无法克服的错误清零，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入**终止状态**。<u style=\"line-height: 160%; box-sizing: content-box;\">进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录</u>，其中保存状态码和一些计时统计数据，供其他进程收集。\n\n#### 2.2.3 挂起操作和进程状态的转换\n\n- 当操作作用于某个进程时，该进程将被**挂起**，意味着此时此刻进程处于静止状态\n\n1. 挂起操作的引入：  \n    （1）终端用户的需要  \n    （2）父进程的请求  \n    （3）负荷调节的需要  \n    （4）操作系统的需要\n    \n2. 引入挂起原语操作后三个进程状态的转换  \n    （1）活动就绪→静止就绪  \n    （2）活动阻塞→静止阻塞  \n    （3）静止就绪→活动就绪  \n    （4）静止阻塞→活动阻塞  \n    \n    ![3BB2EF998AF2EEF84F0F3C41F998429D](https://unpkg.com/justlovesmile-img/202109080916635.png)\n    \n3. 引入挂起操作后五个进程状态的转换  \n    （1）NULL→创建：  \n    （2）创建→活动就绪  \n    （3）创建→静止就绪  \n    （4）执行→终止\n\n#### 2.2.4 进程管理中的数据结构\n\n1. 操作系统中用于管理控制的数据结构\n\n- 内存表\n- 设备表\n- 文件表\n- 进程表PCB，进程控制块。有总数限制，\n\n2. 进程控制块PCB的作用\n\n- 在OS的核心为每一个进程专门定义了一个PCB，记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息，是操作系统中最重要的记录型数据结构。\n- PCB的作用是**使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程**  \n    （1）**作为独立运行的基本单位的标志**：系统使通过PCB感知进程的存在的，PCB已成为进程存在的唯一标志  \n    （2）**能实现间断性运行方式**：将CPU现场信息保存在中断进程的PCB中，供该进程再次被调度执行时恢复CPU现场时使用  \n    （3）**提供进程管理所需要的信息**  \n    （4）**提供进程调度所需要的信息**  \n    （5）**实现与其他进程的同步与通信**\n\n3. 进程控制块中的信息：  \n    （1）进程标识符：唯一地标识一个进程\n    -   ①外部标识符：由数字，字母构成\n    -   ②内部标识符：为每一个进程赋予唯一的数字标识符，是一个进程的序号  \n        （2）处理机状态：\n    -   处理机状态信息：①通用寄存器②指令计数器③程序状态字PSW④用户栈指针\n    -   CPU现场保护结构：寄存器值，主要由CPU的各种寄存器组成  \n        （3）进程调度信息：①进程状态②进程优先级③进程调度所需其他信息，与进程调度算法有关④事件，即阻塞原因  \n        （4）进程控制信息：①程序和数据的地址②进程同步和通信机制③资源清单④链接指针\n4. 进程控制块的组织方式：  \n    （1）线性方式  \n    （2）链接方式  \n    （3）索引方式\n\n### 2.3 进程控制\n\n- 进程控制一般是由OS内核中的原语来实现的\n\n#### 2.3.1 操作系统内核\n\n- OS内核：一般将OS划分为若干层次,将紧靠硬件的软件层次常驻内存\n- 处理机的执行状态分为系统态和用户态：\n    -   系统态：又称管态，内核态，具有较高特权，能执行一切指令，访问所有的寄存器和存储区\n    -   用户态：又称目态，具有较低权限\n\n1. 支撑功能：  \n    （1）**中断处理**：内核中最基本的功能，是整个操作系统赖以活动的基础  \n    （2）**时钟管理**  \n    （3）**原语操作**：原语：<u style=\"line-height: 160%; box-sizing: content-box;\">是由若干条指令组成的，用于完成一定功能的一个过程</u>，是**原子操作**，即要么都做，要么都不做\n2. 资源管理功能：  \n    （1）进程管理  \n    （2）存储器管理  \n    （3）设备管理\n\n#### 2.3.2 进程的创建\n\n1. 进程的层次结构\n\n- 把创建进程的进程称为父进程，而把被创建的进程称为子进程，子进程还可以创建孙进程\n\n2. 进程图：描述进程间关系的一颗有向树\n3. 引起创建进程的事件：  \n    （1）用户登陆  \n    （2）作业调度  \n    （3）提供服务  \n    （4）应用请求\n4. 进程的创建：  \n    步骤：  \n    （1）申请空白PCB，为新进程获取唯一的数字标识符  \n    （2）为其分配运行时所需的资源，包括物理和逻辑  \n    （3）初始化进程控制块PCB：①初始化标识信息②初始化处理机状态信息③初始化处理机控制信息  \n    （4）如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列\n\n#### 2.3.3 进程的终止\n\n1. 引起进程终止的事件：  \n    （1）正常结束：通常会在程序的最后安排一条Halt指令，用于向OS表示运行已结束  \n    （2）异常结束：\n    -   越界错\n    -   保护错\n    -   非法指令\n    -   特权指令错\n    -   运行超时\n    -   等待超时\n    -   算术超时\n    -   I/O故障  \n        （3）外界干预：\n    -   操作员或操作系统干预\n    -   父进程请求\n    -   因父进程终止\n2. 进程的终止过程：  \n    （1）根据被终止进程的标识符，从PCB集合中检索该进程的PCB，从中读出该进程的状态  \n    （2）若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度  \n    （3）若该进程还有子孙进程，还应将其所有子孙进程也都给予终止，以防他们成为不可控进程  \n    （4）将被终止进程所拥有的全部资源或者归还其父进程，或者归还系统  \n    （5）将被终止进程（PCB）从所在队列（或链表）中移除，等待其他程序来搜集信息\n\n#### 2.3.4 进程的阻塞与唤醒\n\n1. 引起进程阻塞和唤醒的事件：  \n    （1）向系统请求共享资源失败  \n    （2）等待某种操作的完成  \n    （3）新数据尚未到达  \n    （4）等待新任务的到达\n2. 进程阻塞过程\n\n- 进程主动调用阻塞原语block将自己阻塞\n\n3. 进程唤醒过程\n\n- 当被阻塞进程所期待的事件已经发生时，有关程序调用唤醒原语wakeup\n- wakeup：首先从阻塞队列中移除，将其PCB中的现行状态改为就绪，然后将该PCB插入到就绪队列\n\n#### 2.3.5 进程的挂起与激活\n\n1. 进程的挂起：\n\n- 原语suspend：检查被挂起进程的状态，若处于活动就绪状态→静止就绪，对于活动阻塞状态→静止阻塞，为方便用户或父进程考察进程的运行情况，把该进程PCB复制到某指定的内存区域，若被挂起的进程正在执行，则转向调度程序重新调度\n\n2. 进程的激活过程\n\n- OS利用激活原语active：将进程从外存调入内存，检查该进程的现行状态，若静止就绪→活动就绪，若静止阻塞→活动阻塞\n\n### 2.4 进程同步\n\n- 使程序的执行具有可再现性\n\n#### 2.4.1 进程同步的基本概念\n\n1. 两种形式的制约关系  \n    （1）间接相互制约关系：多个进程互斥访问资源  \n    （2）直接相互制约关系：多个进程相互合作\n2. 临界资源\n\n- **硬件或软件，多个进程在对其访问时，必须互斥进行**\n\n3. 临界区\n\n- **临界区**：每个进程中**访问临界资源的那段代码**\n- 进入区：临界区前面增加一段用于进行检查的代码\n- 退出区：临界区后面用于将临界区正在被访问的标志恢复为未被访问的标志\n- 剩余区：除了上诉区外的其他部分代码\n\n4. 同步机制应遵循的规则  \n    （1）**空闲让进**：临界资源空闲，应当允许一个请求进入临界区的进程立即进入自己的临界区，若有多个请求，必须挑一个  \n    （2）**忙则等待**：若有临界资源正在被使用，其他进程需要等待。每次最多一个进程  \n    （3）**有限等待**：每一个进程逗留有限时间  \n    （4）**让权等待**：让出CPU竞争（不参与就绪，参与阻塞状态）\n\n#### 2.4.2 硬件同步机制\n\n1. 关中断：\n\n- 实现互斥的最简单的方法之一\n- 在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断\n\n2. 利用Test-and-Set指令实现互斥  \n    该指令读出标志后设标志置为TRUE\n```\n    boolean TS(boolean *lock) {\n       boolean old;\n       old = *lock;\n       *lock = TRUE;\n       return old;\n    }\n```\n- lock表示资源的两种状态：TRUE表示正被占用，FALSE表示空闲\n- 利用TS实现进程互斥：每个临界资源设置一个公共布尔变量lock，初值为FALSE\n- 在进入区利用TS进行检查：有进程在临界区时，重复检查；直到其它进程退出时，检查通过；\n```\n    do{\n    ...\n        while TS(&lock);\n        critical section;   \n        lock = FALSE;\n        remainder section;\n    }while(TRUE);\n```\n3. 利用Swap指令实现进程互斥\n\n- Swap指令（或Exchange指令）  \n    交换两个字（字节）的内容\n\n```\n       void SWAP(int *a, int *b) \n        {\n            int temp;\n            temp = *a; \n            *a = *b;  \n            *b = temp;\n    \t}\n```\n利用Swap实现进程互斥：每个临界资源设置一个公共布尔变量lock，初值为FALSE。每个进程设置一个私有局部布尔变量key\n```\n    do{\n        key = TRUE；\n        do{\n            swap(&lock,&key);\n        }while （key !=FALSE）;\n        临界区操作；\n        lock = FALSE；\n        ...\n    }while (TRUE);\n```\n\n#### 2.4.3 信号量机制\n\n1. 整型信号量：\n\n- wait和signal操作可描述为：\n\n    wait(int s) \n     {\n        while(s<=0);\n        s--;   \n     }\n    \n    signal(int s)\n    {\n      s++;\n    }\n\n- 为临界资源设置一个互斥信号量mutex(MUTual Exclusion)，其初值为1；\n- 在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间  \n    必须成对使用wait和signal原语：遗漏wait原语则不能保证互斥访问，遗漏signal原语则不能在使用临界资源之后将其释放（给其他等待的进程）；\n- wait、signal原语不能次序错误、重复或遗漏:\n\n2. 记录型信号量机制\n\n- 每个信号量s除一个整数值外s.count，还有一个进程等待队列s.queue，其中是阻塞在该信号量的各个进程的标识\n- 信号量只能通过初始化和两个标准的原语来访问－－作为OS核心代码执行，不受进程调度的打断。\n\n3. AND型信号量\n4. 信号量集\n\n#### 2.4.4 信号量的应用\n\n1. 利用信号量实现进程互斥：\n\n- 利用整型信号量机制实现进程互斥时应注意，wait(mutex)和signal(mutex)必须成对出现\n- 缺少wait(mutex)会导致系统混乱，不能保证对临界资源的互斥访问\n- 缺少signal(mutex)将会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程不再被唤醒\n\n2. 利用信号量实现前趋关系：\n\n- 设有两个并发进程P1和P2。P1中有语句S1，P2中有语句S2，希望在执行完S1后执行S2\n- 为实现这种前趋关系，可让进程P1和P2共享一个公用信号量S，并赋初值为0，将signal(S)操作放在语句S1后面；而在S2语句前插入wait(S)操作\n- 进程P1， S1;signal(S);\n- 进程P2， wati(S); S2;\n- 由于S被初始化为0，若P2先执行，必定阻塞，只有在进程P1执行完使S增为1后，P2才能执行S2操作\n\n#### 2.4.5 管程机制\n\n1. 管程的定义：代表共享资源的**数据结构**以及由对该共享数据结构实施**操作**的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块\n2. 一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据\n3. 管程的组成部分：  \n    （1）管程的名字  \n    （2）局部于管程的共享数据结构说明  \n    （3）对该数据结构进行操作的一组过程  \n    （4）对局部于管程的共享数据设置初始值的语句\n4. 所有进程要访问临界资源时，都只能通过管程间接访问，而管程每次只准许一个进程进入管程，执行管程内的过程，从而实现了进程互斥\n5. 管程的特性：  \n    （1）模块化  \n    （2）抽象数据结构  \n    （3）信息掩蔽\n6. 进程与管程的区别：  \n    （1）进程定义私有数据结构PCB，管程定义的是公共数据结构如消息队列  \n    （2）进程是由顺序程序执行有关操作，管程主要是进行同步操作和初始化操作  \n    （3）设置进程的目的在于实现系统的并发性，管程的设置是解决共享资源的互斥使用问题  \n    （4）进程通过调用管程中的过程对共享数据结构实行操作，因而管程被动，进程主动  \n    （5）进程之间能并发执行，管程不能  \n    （6）进程具有动态性，管程是操作系统中的一个资源管理模块，供进程使用\n7. 条件变量\n\n### 2.5 经典进程的同步问题\n\n#### 2.5.1 生产者-消费者问题\n\n    int in= 0,out= 0;\n    item buffer[n];\n    semaphore mutex = 1,empty = n,full = 0;\n    void producer(){\n        do{\n            producer an item nextp;\n            ...\n            wait(empty);\n            wait(mutex);\n            buffer[in] = nextp;\n            in = (in + 1) % n;\n            signal(mutex);\n            signal(full);\n        }while(TRUE);\n     }\n     void consumer(){\n        do{\n        wait(full);\n        wait(mutex);\n        nextc = buffer[out];\n        out = (out+1)%n;\n        signal(mutex)\n        signal(empty)\n        consumer the item in nextc;\n        ...\n        }while(TRUE);\n     }\n     void main(){\n        cobegin\n            producer();\n            consumer();\n        coend\n    }\n\n#### 2.5.2 哲学家进餐问题\n\n略\n\n#### 2.5.3 读者-写者问题\n\n略\n\n### 2.6 进程通信\n\n- 进程通信：进程间的信息交换\n- 低级进程通信：进程的互斥和同步在进程间交换信息  \n    （1）效率低（2）通信对用户不透明\n- 高级通信：进程间传送大量数据  \n    （1）使用方便（2）高效地传送大量数据\n\n#### 2.6.1 进程通信的类型\n\n- 高级通信机制分为：**共享存储器系统，管道通信系统，消息传递系统，客户机-服务器系统**\n\n1. 共享存储器系统：  \n    （1）基于共享数据结构的通信方式：仅适用于相对少量的数据，通信效率低，属于低级通信  \n    （2）基于共享存储区的通信方式：在内存中划出一块共享存储区域，诸进程可通过对该区域的读或写交换信息，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是OS，属于高级通信\n2. 管道通信系统\n\n- 管道：指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。\n- 提供互斥，同步，确定对方是否存在三个方面的协调能力\n\n3. 消息传递系统\n\n- 以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间传递消息，完成进程间的数据交换\n- （1）直接通信方式，如消息缓冲机制\n- （2）间接通信方式，如电子邮箱系统\n\n4. 客户机-服务器系统\n\n- 实现的三种方法：套接字，远程过程调用，远程方法\n- （1）套接字：是一个通信标识类型的数据结构，包含了通信目的地址，端口号，协议等，是进程通信和网络通信的基本构件\n- 分类：①基于文件型②基于网络型\n- （2）远程过程调用和远程方法调用：远程过程调用PRC，是一个通信协议，用于通过网络连接的系统。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称做远程方法调用\n\n#### 2.6.2 消息传递通信的实现方式\n\n1. 直接消息传递系统：  \n    （1）对称寻址原语：不足：一旦改变进程的名字，则可能需要检查所有其他进程的定义  \n    （2）非对称寻址方式  \n    （3） 消息的格式  \n    （4） 进程的同步方式  \n    （5）通信链路：为使在发送进程和接受进程之间能进行通信，必须在两者之间建立一条通信链路\n\n- 分为：单向通信链路，双向通信链路\n\n2. 信箱通信：\n\n- 信箱通信属于间接通信方式，即进程之间的通信，需要通过某种中间实体来完成。该实体建立在随机存储器的公用缓冲区上，用来暂存发送进程发送给目标进程的消息；接受进程可以从该实体中取出发送进程发送给自己的消息，通常把这种中间实体称为邮箱（或信箱），每个邮箱都有唯一的标识符。  \n    （1）信箱的结构：信箱头，信箱体  \n    （2）信箱通信原语  \n    （3）信箱的类型：①私用信箱②公用信箱③共享信箱\n\n### 2.7 线程的基本概念\n\n- 线程：比进程更小的基本单位\n- 线程目的：提高程序并发执行的程度\n\n#### 2.7.1 线程的引入\n\n- 引入进程的目的：为了多个程序能并发执行，以提高资源利用率和系统吞吐量\n- 引入线程的目的：减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性\n\n1. 进程的两个基本属性：  \n    （1）进程是一个可拥有资源的独立单位  \n    （2）进程同时又是一个可独立调度和分派的基本单位\n2. 程序并发执行所需付出的时空开销  \n    （1）创建进程，分配所需资源，建立PCB  \n    （2）撤销进程，执行回收操作，撤销PCB  \n    （3）进程切换，需保留当前CPU环境，建立新的CPU环境\n3. 线程 ——作为调度和而分派的基本单位\n\n#### 2.7.2 线程与进程的比较\n\n- 传统进程：重型进程，线程：轻型进程/进程元\n\n1. **调度的基本单位**：\n\n- 线程间通信比进程更方便\n- 同一进程的线程，计数器，堆栈资源不同\n- 线程的切换，建立，撤销均快于进程\n- 线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程的线程时，必然会引起进程的切换。\n\n2. **并发性**：一个进程中的多个线程之间亦可以并发执行，甚至还允许在一个进程中所有线程都能并发执行\n3. **拥有资源**：仅有一点必不可少的，能保证独立运行的资源，如：TCB等\n4. **独立性**：同一进程中的不同线程之间的独立性要比不同进程之间的独立性低\n5. **系统开销**：线程低于进程\n6. 支持多处理机系统\n\n#### 2.7.3 线程的状态和线程控制块\n\n1. 线程的三种状态：（1）执行（2）就绪（3）阻塞\n2. **线程控制块TCB**：将所有用于控制和管理线程的信息记录其中\n3. 多线程OS中的进程属性：  \n    （1）进程是一个可拥有资源的基本单位  \n    （2）多个线程可以并发执行  \n    （3）进程已不是可执行的实体，**在多线程OS中，是把线程作为独立运行的基本单位**\n\n### 2.8 线程的实现\n\n#### 2.8.1 线程的实现方式\n\n1. 内核支持线程KST  \n    优点：  \n    （1）在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行  \n    （2）如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理器运行，也可以运行其他进程中的线程  \n    （3）内核支持线程具有很小的数据结构和堆栈，线程切换快，开销小  \n    （4）内核本身采用多线程技术，可以提高系统的执行速度和效率  \n    缺点：  \n    系统开销大\n2. 用户级线程ULT  \n    优点：  \n    （1）线程切换不需要转换到内核空间  \n    （2）调度算法可以是进程专用的  \n    （3）用户级线程的实现与OS平台无关，因为对于线程管理的代码是属于用户程序的一部分  \n    缺点：  \n    （1）系统调用的阻塞问题  \n    （2）进程中只有一个线程能执行\n3. 组合方式\n\n#### 2.8.2 线程的实现\n\n1. 内核支持线程的实现：\n2. 用户级线程的实现：（中间系统）  \n    （1）运行时系统：实质上是用于管理和控制线程的函数的集合  \n    （2）内核控制线程：**轻型进程LWP**，<u style=\"line-height: 160%; box-sizing: content-box;\">可看作是ULT和KLT之间的映射，它把一个或多个ULT映射到一个KLT上。LWP还是核心独立调度的单位，它可以在多个处理器上并行执行</u>\n\n- 注意：核心向用户程序提供的界面是LWP，不提供核心线程和用户级线程，用户程序接触不到核心线程，只能看到LWP和用户态线程。\n- 把这些LWP做成一个线程池，只有连接到LWP上的线程才能与内核通信\n- LWP实现理内核和用户级线程之间的隔离\n\n#### 2.8.3 线程的创建和终止\n\n- 线程具有生命周期\n- 创建完成后返回一个线程标识符\n- 线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行分离函数后，被终止线程才与资源分离\n\n## 第三章 处理机调度与死锁\n\n### 3.1 处理机调度的层次和调度算法的目标\n\n- 调度的实质是一种资源分配，处理机调度是对处理机资源进行分配\n\n#### 3.1.1 处理机调度的层次\n\n1. 高级调度：又称长程调度或**作业调度**，调度对象是作业，高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置\n2. 低级调度：又称**进程调度**或短程调度，调度对象是进程，最基本的调度\n3. 中级调度：又称**内存调度**，目的：提高内存利用率和系统吞吐量。将那些暂时不能运行的进程，调至外存等待，此时进程的状态称为挂起\n\n- 其中进程调度的运行频率最高\n- 作业调度周期最长\n- 中级调度的运行频率介于两者之间\n\n#### 3.1.2 处理机调度算法的目标\n\n1. 处理机调度算法的共同目标  \n    （1）资源利用率：  \n    cpu的利用率=cpu有效工作时间/（cpu有效工作时间+cpu空闲等待时间）  \n    （2）公平性  \n    （3）平衡性  \n    （4）策略强制转换\n2. 批处理系统的目标：  \n    （1）平均周转时间短  \n    （2）系统吞吐量高  \n    （3）处理机利用率高\n3. 分时系统的目标  \n    （1）响应时间快  \n    （2）均衡性\n4. 实时系统的目标  \n    （1）截至时间的保证  \n    （2）可预测性\n\n### 3.2 作业与作业调度\n\n#### 3.2.1 批处理系统中的作业\n\n1. 作业和作业步：  \n    （1）作业：\n    -   作业是用户提交给系统的以向相对独立的工作\n    -   在批处理系统中是以作业为基本单位从外存调入内存的\n\n（2）作业步：  \n- 在作业运行期间，每个作业都必须经过若干个相对独立的，又相互关联的顺序加工步骤才能得到结果。我们把其中的每一加工步骤叫做一个作业步  \n- 一个典型的作业可以分成：编译作业步，链接装配作业步，运行作业步  \n2\\. 作业运行的三个阶段和三种状态：\n\n（1）收容阶段：操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上，在为该作业建立JCB，并把它们放到作业后备队列中。此时作业的状态也叫“后备状态”  \n（2）运行阶段：“运行状态”  \n（3）完成阶段：“完成状态”\n\n#### 3.2.2 作业调度的主要任务\n\n- 主要任务：根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定算法，将作业调入内存，创建进程，分配资源，将新建立的进程排在就绪队列上等待调度，故作业调度也叫接纳调度。\n- 接纳多少个作业\n- 接纳那些作业\n\n#### 3.2.3 先来先服务（FCFS）和短作业有限（SJF）调度算法\n\n1. **先来先服务调度算法（FCFS）**：\n\n- 按照作业的到达的先后次序来调度，即优先考虑等待时间最长的作业\n- 缺点：对于短进程而言，带权周转时间可能非常的大\n- 适用于作业调度和进程调度\n\n2. **短作业有限的调度算法（SJF）**：\n\n- 按照作业的长短来计算优先级，作业越短，其优先级越高\n- 缺点：  \n    （1）必须预知作业的运行时间  \n    （2）对长作业非常不利  \n    （3）在采用SJF时，人机交互无法实现  \n    （4）该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫作业能得到及时处理\n\n#### 3.2.4 优先级调度算法和高响应比调度算法\n\n1. **优先级调度算法（PSA）**\n\n- 根据作业的优先级进行调度\n\n2. 高响应比优先调度算法：\n\n优先权=（等待时间+要求服务时间）/要求服务时间=响应时间/要求服务时间\n\n- 动态优先级\n- 更公平但增加了系统开销\n\n### 3.3 进程调度\n\n#### 3.3.1 进程调度的任务，机制和方式\n\n1. 进程调度的任务：  \n    （1）保存处理机的现场信息  \n    （2）按某种算法选取进程  \n    （3）把处理器分配给进程\n2. 进程调度机制  \n    三个部分  \n    （1）排队器  \n    （2）分派器  \n    （3）上下文切换器\n3. 进程调度方式  \n    （1）非抢占方式：\n\n> 在采用非抢占调度方式时，可能引起进程调度的因素可归结为这样几个：① 正在执行的进程执行完毕， 或因发生某事件而不能再继续执行； ② 执行中的进程因提出I/O请求而暂停执行；③ 在进程通信或同步过程中执行了某种原语操作，如P操作(wait操作)、Block原语、Wakeup原语等。这种调度方式的优点是实现简单、系统开销小，适用于大多数的批处理系统环境。但它难以满足紧急任务的要求——立即执行。\n\n（2）抢占方式  \n主要原则：  \n（1）优先权原则。  \n（2）短作业(进程)优先原则。  \n（3）时间片原则。\n\n#### 3.3.2 轮转调度算法（RR）\n\n- 基于时间片的轮转，非常公平\n- 每个进程每次大约可获得1/n的处理机时间\n\n1. 轮转法的基本原理：系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并每隔一段时间产生一次中断，激活系统中的进程调度，将CPU分配给队首进程，令其执行\n2. 进程切换时机：  \n    （1）若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列队首的进程运行，并启动新的时间片  \n    （2）在一个时间片用完时，计时器中断处理程序被激活，如果进程尚未运行完，调度程序把它送入就绪队列末尾\n3. 时间片大小的确定\n\n- 小：频繁地执行进程调度和进程上下文切换，增加系统开销\n- 大：每个进程都能在一个时间片内完成，算法退化为FCFS\n\n#### 3.3.3 优先级调度算法\n\n1. 优先级调度算法分类：  \n    （1）非抢占式优先级调度算法：优先级低的正在运行时，优先级高的不能抢占CPU  \n    （2）抢占式优先级调度算法\n2. 优先级的类型：  \n    （1）静态优先级：\n    -   在创建进程时确定\n    -   依据：进程类型，进程对资源的需求，用户需求\n    -   简单易行，系统开销小，但不够精确  \n        （2）动态优先级：\n\n- 其值随进程的推进或时间的增加而改变，以获得更好的性能\n\n#### 3.3.4 多队列调度算法\n\n- 该算法将系统中的进程就绪队列从一个拆分成若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同优先级\n\n#### 3.3.5 多级反馈队列调度算法\n\n1. 调度机制：  \n    （1）设置多个就绪队列。第一个队列优先高，时间片最短，其后依此降低优先级，增大时间片  \n    （2）每个队列内采用FCFS算法  \n    （3）调度算法的性能：\n    -   能较好的满足用户的需要\n\n#### 3.3.6 基于公平原则的调度算法\n\n1. 保证调度算法：n个相同类型的进程，每个都获得相同的处理机时间1/n\n2. 公平分享调度算法：分配给每个进程相同的处理机时间，公平性是针对用户而言，要考虑每一个用户的进程数目\n\n### 3.4 实时调度\n\n#### 3.4.1 实现实时调度的基本条件\n\n1. 提供必要的信息：  \n    （1）就绪时间  \n    （2）开始截止时间和完成截止时间  \n    （3）处理时间  \n    （4）资源要求  \n    （5）优先级\n2. 系统处理能力强  \n    （1）单处理机，必须满足下面的限制条件：\n\nc是处理机时间，p是周期时间  \n（2）多处理机，限制条件改为：  \n\n3.采用抢占式调度机制\n\n- 在含有HRT任务的实时系统中，广泛采用抢占式机制，满足对截止时间的要求\n\n4. 具有快速切换机制  \n    （1）对中断的快速响应  \n    （2）快读的任务分派能力\n\n#### 3.4.2 实时调度算法的分类\n\n1. 非抢占式调度算法  \n    （1）非抢占式轮转调度算法  \n    （2）非抢占式优先调度算法\n2. 抢占式调度算法  \n    （1）基于时钟中断的抢占式优先级调度算法  \n    （2）立即抢占的优先级调度算法\n\n#### 3.4.3 最早截止时间优先EDF算法\n\n- 任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队列的队首\n\n1. 非抢占式调度方式用于非周期实时任务\n2. 抢占式调度方式用于周期实时任务\n\n#### 3.4.4 最低松弛度优先LLF算法\n\n- 任务紧急程度越高，赋予该任务的优先级就越高，以使之优先执行\n- 松弛度=必须完成时间-其本身的运行时间-当前时间\n\n#### 3.4.5 优先级倒置\n\n- 高优先级进程被低优先级进程延迟或阻塞\n\n### 3.5 死锁\n\n#### 3.5.1 资源问题\n\n1. 可重用性资源和消耗性资源\n\n- （1）可重用性资源：用户可以重复使用多次的资源\n  \n    -   性质：（1）每一个可重用资源中的单位只能分配给一个进程使用  \n        （2）进程在使用时的顺序：①请求资源②使用资源③释放资源  \n        （3）系统中每一类可重用资源的单元数目都是固定的，进程在运行期间既不能创建也不能删除\n    -   对资源的请求和释放都是利用系统调用来实现的\n- （2）可消耗性资源：又称临时资源\n  \n    -   性质：（1）每一个可消耗性资源的单元数目在进程运行期间是可以不断变化的\n\n2. 可抢占性资源和不可抢占性资源：  \n    （1）可抢占性资源：这类资源不会引起死锁  \n    （2）不可抢占性资源：例如磁带机，打印机\n\n#### 3.5.2 计算机系统中的死锁\n\n- 死锁：多个进程对资源的争夺，不仅对不可抢占性资源争夺会引起死锁，对可消耗性资源的争夺也会引起死锁\n\n1. 竞争不可抢占性资源引起死锁\n2. 竞争可消耗资源引起死锁\n3. 进程推进顺序不当引起死锁\n\n#### 3.5.3 死锁的定义，必要条件和处理方法\n\n1. 死锁的定义：如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的\n2. **产生死锁的必要条件**：\n\n- （1）互斥条件\n- （2）请求和保持条件\n- （3）不可抢占条件\n- （4）循环等待条件\n\n3. 处理死锁的方法：\n\n- （1）预防死锁：设置某些限制条件，破坏产生死锁的四个必要条件\n- （2）避免死锁：在资源的动态分配过程中采取某种方法，使之保持安全状态\n- （3）检测死锁\n- （4）解除死锁：撤销进程，回收资源\n\n### 3.6 预防死锁\n\n- 互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要破坏产生死锁的后三个条件\n\n#### 3.6.1 破坏“请求和保持条件”\n\n1. 第一种协议：所有进程在开始运行钱，必须一次性申请所需全部资源\n    -   简单，易行且安全，但①资源被严重浪费，②进程经常发送饥饿现象\n2. 第二种协议：\n    -   允许进程只获取运行初期所需的资源，便可开始运行，在逐步释放已用毕的全部资源，再请求新的资源\n    -   更快，提高设备的利用率，减少饥饿机率\n\n#### 3.6.2 破坏“不可抢占”条件\n\n- 一个已经保持了某些不可抢占资源的进程，提出新的资源请求而不能得到满足时，必须释放已经保持的多有资源，待以后再申请\n- 实现复杂，延长了进程的周转事件，增加系统开销，降低系统吞吐量\n\n#### 3.6.3 破坏“循环等待” 条件\n\n- 对系统所有资源类型进行线性排序，并赋予不同的序号，必须按照序号递增的顺序请求资源\n- 如果需要多个同类资源单元，则必须一起请求\n- 假如进程已请求到一些序号较高的资源后，后来它又想请求序号低的资源，必须先释放所有具有相同和更高序号的资源后才能申请\n\n### 避免死锁\n\n- 再资源的动态分配过程中，防止系统进入不安全状态，以避免发送死锁\n\n#### 3.7.1 系统安全状态\n\n1. 安全状态：是指系统能按某种顺序，来为每个进程分配其所需资源，直至最大需求，使每个进程都可顺利完成。\n2. 安全序列：  \n    一个进程序列{P1，…，Pn}是安全的，如果对于每一个进程Pi(1≤i≤n），它以后需要的资源量不超过系统当前剩余资源量与所有进程Pj (j < i )当前占有资源量之和，系统处于安全状态。  \n    (安全状态一定是没有死锁发生的)\n\n#### 3.7.2 利用银行家算法避免死锁\n\n> 银行家算法（Banker's Algorithm）\n\n- 概念  \n    银行家算法是一个避免死锁产生的算法。以银行借贷分配策略为基础，判断并保证系统处于安全状态。  \n    客户在第一次申请贷款时，声明所需最大资金量，在满足所有贷款要求并完成项目时，及时归还  \n    在客户贷款数量不超过银行拥有的最大值时，银行家尽量满足客户需要\n\n### 3.8 死锁的检测和解除\n\n允许系统进入死锁状态  \n维护系统的资源分配图  \n定期调用死锁检测算法来搜索图中是否存在死锁  \n出现死锁时，用死锁恢复机制进行恢复\n\n- 解除死锁：  \n    （1）资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便让其他进程继续推进  \n    （2）撤销进程法：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源  \n    （3）进程回退法：让进程回退到足以回避死锁的地步\n    \n- 算法：  \n    (1)银行家算法为死锁避免算法；  \n    (2)死锁检查算法和资源分配图化简法为死锁检测；  \n    (3)资源有序分配算法为死锁预防策略；\n    \n- 所谓CPU繁忙型的作业，是指该类作业需要大量的CPU时间进行计算，而很少请求I/O操作。I/O繁忙型的作业是指CPU处理时，需频繁的请求I/O操作。  \n    (1)周转时间 = 作业完成时间 - 作业提交时间；  \n    (2)平均周转时间 = （作业1的周转时间 + ... + 作业n的周转时间）/ n ；  \n    (3)带权周转时间 = 作业周转时间 / 作业实际运行时间；  \n    (4)平均带权周转时间 = （作业1的带权周转时间 + ... + 作业n的带权周转时间）/ n；  \n    (5)响应比Rp = (等待时间 + 要求服务时间) /要求服务时间；\n\n## 第四章 存储器管理\n\n![Image [5]](https://unpkg.com/justlovesmile-img/202109080918412.png)\n\n### 内存管理：\n\n- 引入目的：更好的支持多道程序并发执行，提升系统性能  \n    \\-‘程序的编译’：由编译程序将用户源代码编译成若干个目标模块；  \n    \\-‘程序的链接’：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块；  \n    （1）静态链接：在程序运行之前链接  \n    （2）装入时动态链接：在装入内存时，采用边装入边链接的链接方式  \n    （3）运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接  \n    \\-‘程序的装入’：由装入程序将装入模块装入内存运行；  \n    （1）绝对装入：适合单道程序环境  \n    （2）静态重定位：适合装入之后不再移动的情况  \n    （3）动态重定位：适合装入之后还会移动的情况\n- ‘地址空间’：  \n    （1）逻辑地址空间：是指一个源程序在编译或者链接装配后指令和数据所用的所有相对地址的空间；  \n    （2）物理地址空间：内存中物理单元的集合；\n- ‘地址重定位’：通过地址转换将逻辑地址转换为物理地址。\n- ‘内存保护’：  \n    （1）上、下限寄存器：分别与上、下限寄存器比较  \n    （2）基址、限长寄存器：与限长寄存器比较，与基址寄存器相加\n- 管理方式：  \n    （1）连续分配：产生内部碎片；用户进程（或作业）在主存中都是连续存放的\n    -   单一连续分配：分配到内存固定区域，只适合单任务系统；\n    -   固定分区分配：分配到内存中不同的固定区域，分区可以相等也可以不等；\n        -   产生内部碎片\n    -   动态分区分配：\n        -   产生外部碎片\n        -   基本概念：按照程序的需要进行动态的划分\n        -   分配算法：  \n            （1）首次适应：空闲区按地址从小到大为序，分配第一个符合条件的分区；  \n            （2）最佳适应：空闲区按空间大小从小到大排序，分配第一个符合条件的分区；  \n            （3）最坏适应：空闲区按空间从大到小排序，分配第一个符合条件的分区；  \n            （4）邻近适应：空闲区按地址地址递增的次序排列，分配内存时从上次查找结束的位置开始继续查找；\n\n（2） 非连续分配：允许一个程序分散地装入到不相邻的内存分区中，需要额外的空间去存储分散区域的索引\n\n- 基本分页：内存分为固定的块，按物理结构划分，会有内部碎片；\n    -   主存、进程都划分为大小固定的块，进程在执行时，以块为单位申请主存中的块空间；\n    -   进程中的块为页，内存中的块为页框。系统为每个进程建立一张页表，页表记录页面在内存中对应的物理块号，实现从页号到物理块号的地址映射；\n    -   页式管理中地址空间是一维的；\n- 基本分段：内存块的大小不固定，按逻辑结构划分，会有外部碎片；\n    -   段式管理方式按照用户进程中的自然段划分逻辑空间。段内要求连续，段间不要求连续。段号和段内偏移量必须由用户显示提供。\n    -   方便编程、共享、保护、动态链接和增长。\n- 段页式：基本分段和基本分页的结合，会有内部碎片；\n    -   作业的逻辑地址分为：段号、页号和页内偏移量；采用分段方法来分配和管理用户地址空间，采用分页方法来管理物理存储空间；开销大。\n- 请求分页存储管理：采用虚拟技术，开始运行时不必将作业全部一次性装入内存；\n- 多级页表：将页表的10页空间也进行地址映射，建立上一级页表，用于存储页表的映射关系；\n\n### 多道程序下的内存扩充：\n\n- 覆盖：预先设定覆盖段，覆盖掉暂时不用的内容，通常在同一个程序之中进行；\n- 交换：把处于等待的程序暂时移到外存，通常在不同程序之间进行；\n- 虚拟内存：只能基于非连续分配技术。\n    -   引入原因：在逻辑上扩充内存\n    -   时间局部性：程序中存在着大量的循环操作；\n    -   空间局部性：程序在一段时间内所访问的地址，可能集中在一定的范围内；\n    -   组成部分：  \n        （1）页表机制：通过查表获取相关信息；  \n        （2）中断机制：要访问页不在内存时产生缺页中断  \n        （3）地址变换机构：把逻辑地址变换成物理地址  \n        （4）内存和外存：需要一定容量的内存和外存支持\n    -   置换算法：  \n        （1）最佳置换算法（OPT）：选择以后不用的页面  \n        （2）先进先出（FIFO）：选择最先装入的页面  \n        （3）最近最久未使用（LRU）：选择最近最近未使用的页面  \n        （4）时钟置换算法（最近未用算法）：选择最近未用的页面  \n        （5）改进型CLOCK：考虑页面修改问题\n    -   地址翻译：TLB->页表（TLB不命中）->Cache->主存->外存\n\n### 页面分配策略：\n\n- 固定分配局置换：每个进程分配一定数目的物理块，在整个运行期间不变，缺页时只在该进程在内存中的页面中进行置换；\n  \n- 可变分配全局置换：为每个进程分配一定数目的物理块，操作系统自身也保持一个空闲物理块队列；\n  \n- 可变分配局部置换：若进程在运行中频繁地缺页，系统再为该进程分配若干物理块；\n  \n- 抖动（颠簸）：刚换出的页面马上又要换入内存；刚换入的页面马上就要换出内存；\n  \n- 工作集（驻留级）：\n  \n    -   指在某段时间间隔内，进程要访问的页面集合。\n- 虚拟内存空间大小：\n  \n    -   <=内存容量和外存容量之和<\n    -   <=计算机的地址位数能容纳的最大容量\n- 虚拟存储的页表项：\n  \n    -   页号\n    -   物理块号\n    -   状态位P：用于指示该页是否已调入内存，供程序访问参考；\n    -   访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考；\n    -   修改位M：标识该页在调入内存后是否被修改过；\n    -   外存地址\n- Belady现象：进程的缺页次数随着分配给进程的页框个数的增加而增加，只有FIFO队列式页面置换算法才有。\n  \n- 快表（联想寄存器TLB）：用来存放当前访问的若干页表项，以加速地址变换的过程，若所需访问页号在快表中则可减少一次内存访问。\n\n## 第五章 虚拟存储器\n\n略\n\n## 第六章 输入输出系统\n\n- I/O管理概述：状态跟踪、设备存取、设备分配、设备控制\n- 设备分类：按传输速率分：  \n    低速：如磁盘、鼠标中速：如行式打印机、激光打印机高速：如磁带机、磁盘机、光盘机按信息交换单位分：  \n    块设备：如磁盘字符设备：如键盘、打印机\n- 控制方式：程序直接控制：程序直接对设备特环测试中断驱动：引入中断机制，当设备准备完成时发生中断DMA：在I/O设备与主存之间开辟直接数据通路，彻底“解放”CPU。  \n    基本数据单位是块；传送的数据从设备直接送入内存（或相反）仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，整块数据的传送是在DMA控制器的控制下完成的；包含的四类控制器：  \n    命令/状态寄存器（CR）内存地址寄存器（MAR）数据寄存器（DR）数据计数器（DC）\n- 通道控制：引入专门的I/O处理机进行管理\n- I/O子系统层次：用户层I/O软件：实现与用户交互的接口设备独立性软件：实现用户程序与设备驱动器的统一接口、设备命令、设备保护以及设备分配与释放设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令中断处理程序：用于处理中断相关事项硬件设备：包括一个机械部件（设备本身）和一个电子邮件（控制器）\n- I/O核心子系统：  \n    I/O调度：确定一个好的顺序来执行这些I/O请求  \n    磁盘高速缓存：指利用内存中的存储空间来暂存从磁盘上读出的一系列盘块中的信息；逻辑上属于磁盘，物理上属于内存；1：在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定2：把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘时I/O共享  \n    缓冲区：位于内存区域  \n    特点：当缓冲区的数据非空的时候，不能往缓冲区冲入数据，只能从缓冲区把数据传出；为空时，可以冲入数据，但必须充满遗憾才能再传出。  \n    引入缓冲区的目的：缓和CPU与I/O设备间速度不匹配的矛盾减少对CPU的中断频率，放宽对CUP中断响应时间的限制解决基本数据单元大小不匹配的问题提高CPU和I/O设备之间的并行性  \n    单缓冲  \n    双缓冲  \n    循环缓冲  \n    缓冲池\n\n|比较|高度缓存|缓冲区|\n| --- | --- | --- |\n|存放数据|存放的是低速设备上的某些数据的复制数据|存放的是低速设备传递给高速设备的数据（或相反）|\n|目的|高速缓存存放的是高速设备经常要访问的数据|高速设备和低速设备的通信都要经过缓冲区，高速设备永远不会直接去访问低速设备|\n|相同点|都是介于高速设备和低速设备之间|都是介于高速设备和低速设备之间|\n\n- 设备的分配与回收：\n    -   分类：  \n        （1）独点式使用设备：设备被使用时不再允许其他进程使用设备  \n        （2）分时共享式使用设备：设备没有独占使用的要求时，可以通过分时共享使用  \n        （3）SPOOLing技术：将独占设备改造成共享设备,实现了虚拟设备的功能；以空间换时间，必须先有独占设备\n    -   设备分配的数据结构：  \n        （1）设备控制表（DCT）：每个设备配置一张DCT，以记录本设备的情况；  \n        （2）控制器控制表（COCT）：每个控制器有一张COCT；  \n        （3）通道控制表（CHCT）：每个通道配置一张CHCT；  \n        （4）系统设备表（SDT）整个系统只有一张SDT，记录已连接到系统中的所有物理设备的情况  \n        （5）SDT中有一个DCT指针，DCT中有一个COCT指针，COCT中有一个CHCT指针，CHCT中有一个COCT指针。\n    -   分配原则：即要求充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开\n    -   分配方式：  \n        （1）静态分配：在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备  \n        （2）动态分配：在进程执行过程中根据执行需要进行分配\n    -   设备分配的安全性：  \n        （1）安全分配方式：每当进程发出I/O请求后便进入阻塞状态，直到其I/O操作完成时才被唤醒。  \n        （2）不安全分配方式：进程发出多个I/O请求并继续运行，仅当进程所请求的设备已被另一进程占用时，才进入阻塞状态。\n    -   设备独立性是指应用程序独立于具体使用的物理设备\n    -   SPOOLing技术：主要包括输入井、输出井、输入缓冲区和输出缓冲区以及输入进程和输出进程。\n    -   输入井和输出井是在磁盘上开辟的两大存储空间；  \n        （1）输入井是模拟脱机输入时的磁盘设备，用于暂存I/O设备输入的数据  \n        （2）输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据\n\n## 第七章 文件管理\n\n- 文件控制块（FCB），类似进程管理的PCB，存放控制文件需要的各种信息的数据结构。\n    -   基本信息：包括文件物理位置\n    -   存取控制信息\n    -   使用信息\n    -   索引结点一个\n- 文件对应一个FCB，而一个文件目录项就是一个FCB。\n- 打开文件操作是讲该文件的FCB存入内存的活跃文件目录表，而不是将文件内容负责到主存，找到指定文件目录是打开文件之前的操作。\n\n### 文件系统基础：\n\n- 逻辑结构：\n    -   无结构文件（流式文件）：将数据按顺序组织成记录并积累保存，（流式文件）则被看成是一个字符流，以字节（Byte）为单位；\n    -   有结构文件：  \n        （1）顺序文件：\n        -   串结构：记录之间的顺序与关键字无关\n        -   顺序结构：记录之间的顺序与关键字有关  \n            （2）索引文件：为变长文件建立索引表，提高查找速度  \n            （3）索引顺序文件：顺序文件和索引文件的结合，将顺序文件中的所有记录分为若干组，为顺序文件建立一张索引表，在索引中为每组的第一个记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针  \n            （4）直接文件（查找文件）Hash File：通过哈希函数直接决定记录地址\n- 目录结构：\n    -   单级：全部文件都放在一个目录下\n    -   两级：在目录下分出用户目录\n    -   多级：将两级结构加以推广，采用树形结构\n    -   无环图：在树形结构上加入一些有向边，便于共享\n\n### 文件共享：\n\n- 基于索引结点（硬链接）：共享文件指向同一个索引节点；链接计数count；\n- 基于符号链（软链接）：有文件拥有者才拥有指向其索引结点的指针，共享该文件的其他用户则只有该文件的路径；\n\n### 文件保护：\n\n- 口令保护：通过口令访问文件\n- 加密保护：对文件进行加密处理\n- 访问控制：根据访问者的身份进行限制\n\n### 文件系统实现：\n\n- 目录实现：线性列表：\n    -   无序：查找文件较慢，新建文件较快\n    -   有序：查找文件较快，新建文件较慢\n    -   哈希表：查找、新建文件都较快，要处理冲突\n- 文件实现：\n    -   连续分配：在磁盘上连续存放文件\n    -   链接分配：隐式：采用类似链表的结构，显式：把隐式文件中的指针单独抽离出来\n    -   索引分配：每个文件所有的盘块号都集中存放，建立索引表\n\n### 存储空间管理：\n\n- 空闲表：把所有空闲块组织成表\n- 空闲链表法：把所有空闲块组织成链表\n- 位示图：利用二进制的每位记录空闲块\n- 成组链接：空闲表和空闲链表的结合，适合大的文件系统\n\n## 第八章 磁盘存储器的管理\n\n### 磁盘管理\n\n- 磁盘地址结构：柱面号、盘面号、扇区号\n- 读写时间：  \n    （1）寻道时间：将磁头移动到指定磁道所需要的时间  \n    （2）延迟时间：磁头定位到某一磁道的扇区所需要的时间  \n    （3）传输时间：从磁盘读出或向磁盘写入数据所经历的时间  \n    （4）启动时间（一般忽略）：控制器的启动时间\n- 调度算法：  \n    （1）先来先服务（FCFS）：根据进程请求访问磁盘的先后顺序进行调度  \n    （2）最短寻找时间优先（SSTF）：选择当前磁头所在的磁道距离最近的磁道  \n    （3）扫描（SCAN）算法（电梯算法）：在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求  \n    （4）循环扫描（C-SCAN）：在扫描算法的基础上规定磁头单向移动来提供服务\n- 磁盘管理：\n    -   初始化：对磁盘进行低级格式化和逻辑化\n    -   引导块：存放自举程序\n    -   坏块：对于损坏扇区的处理\n","tags":["大学课程","操作系统"],"categories":["学习笔记"]},{"title":"Hexo主题 | Hexo-yilia的配置","slug":"博客相关-Hexo-yilia的配置","url":"/posts/48052.html","content":"\n\n我在使用yilia这个主题时用到的一些设置\n\n# 获取Yilia主题\n\n```\n$ cd /hexo\n$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n![nMNdc4.png](https://s2.ax1x.com/2019/09/06/nMNdc4.png)\n- 其中/languages存放语言包，/layout存放主题布局文件，/source存放静态文件，如图片，图标等，/source-src存放外部引用资源\n\n# 添加新页面\n![nMUhGT.png](https://s2.ax1x.com/2019/09/06/nMUhGT.png)\n- 打开`/hexo/theme/yilia/_config.yml`文件，在menu处修改为：\n\n```\nmenu:\n  主页: /\n  分类: /categories\n  标签: /tag\n```\n\n- 新建页面\n\n```\nhexo new page categories\n```\n\n- 其会在/hexo/source下生成一个categories文件夹，其下有index.md文件，修改categories/index.md：\n\n```\n---\ntitle: 文章分类\ndate: 2019-07-10 18:52:02\ntype: \"categories\"\nlayout: \"categories\"\ncomments: false\n---\n```\n\n- 在hexo/theme/yilia/source/main.0cf68a.css文件中添加内容：\n\n```\ncategory-all-page {\n    margin: 30px 40px 30px 40px;\n    position: relative;\n    min-height: 70vh;\n  }\n  .category-all-page h2 {\n    margin: 20px 0;\n  }\n  .category-all-page .category-all-title {\n    text-align: center;\n  }\n  .category-all-page .category-all {\n    margin-top: 20px;\n  }\n  .category-all-page .category-list {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n  .category-all-page .category-list-item-list-item {\n    margin: 10px 15px;\n  }\n  .category-all-page .category-list-item-list-count {\n    color: $grey;\n  }\n  .category-all-page .category-list-item-list-count:before {\n    display: inline;\n    content: \" (\";\n  }\n  .category-all-page .category-list-item-list-count:after {\n    display: inline;\n    content: \") \";\n  }\n  .category-all-page .category-list-item {\n    margin: 10px 10px;\n  }\n  .category-all-page .category-list-count {\n    color: $grey;\n  }\n  .category-all-page .category-list-count:before {\n    display: inline;\n    content: \" (\";\n  }\n  .category-all-page .category-list-count:after {\n    display: inline;\n    content: \") \";\n  }\n  .category-all-page .category-list-child {\n    padding-left: 10px;\n  }\n```\n\n- 新建/hexo/theme/yilia/layout/categories.ejs文件，输入：\n\n```\n<article class=\"article article-type-post show\">\n  <header class=\"article-header\" style=\"border-bottom: 1px solid #ccc\">\n  <h1 class=\"article-title\" itemprop=\"name\">\n    <%= page.title %>\n  </h1>\n  </header>\n\n  <% if (site.categories.length){ %>\n  <div class=\"category-all-page\">\n    <h2>共计&nbsp;<%= site.categories.length %>&nbsp;个分类</h2>\n    <%- list_categories(site.categories, {\n      show_count: true,\n      class: 'category-list-item',\n      style: 'list',\n      depth: 2,\n      separator: ''\n    }) %>\n  </div>\n  <% } %>\n</article>\n```\n\n- 在写文章时加入：\n\n```\n---\ntitle: hexo-yilia的配置\ndate: 2019-09-06 17:53:09\ntags: [hexo,学习笔记]\ncategories: [hexo,学习笔记]\n---\n```\n\n# 设置打赏\n- 将二维码图片放到/yilia/source/img中\n- 打开主题目录下的_config.yml文件，在reward_wording处修改\n\n```\n# 打赏\n# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏\nreward_type: 1\n# 打赏wording\nreward_wording: '给作者点一杯奶茶吧'\n# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg\nalipay: /img/alipay.png\n# 微信二维码图片地址\nweixin: /img/weixinpay.png\n```\n\n- 在需要的文章添加：\n\n```\n---\ntitle: hexo-yilia的配置\ndate: 2019-09-06 17:53:09\ntags: [hexo,学习笔记]\ncategories: [hexo,学习笔记]\nreward: true\n---\n```\n\n# 点击所有文章提示缺失模块\n- 确保 node 版本大于 6.2\n- 在博客根目录/hexo执行以下命令：`npm install hexo-generator-json-content --save`\n- 在 hexo博客根目录`_config.yml` 里添加配置，关掉 `hexo s` 之后执行 `hexo g` 重新生成：\n\n```\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: false\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n\n# 配置智能菜单\n\n```\n# 智能菜单\n# 如不需要，将该对应项置为false\n# 比如\n#smart_menu:\n#  friends: false\nsmart_menu:\n  innerArchive: '所有文章'\n  friends: false\n  aboutme: '关于我'\n\nfriends:\n  #HEXO: https://hexo.io/zh-cn/index.html\n  #LIVE2d: https://www.npmjs.com/package/hexo-helper-live2d\n  #Python: https://www.python.org/\n  #Bootstrap: https://www.bootcss.com/\n  #我的github: https://github.com/Justlovesmile\n  #我的微博: https://www.weibo.com/5252319712/profile?topnav=1&wvr=6\n\naboutme: 孜孜不倦<br>认真且怂<br>正在努力提升自己\n```\n\n# 设置主页展示截断\n- 在md文件中添加内容`<!-- more -->`：\n\n```\n---\ntitle: xxx\ndata: xxxx\ntag: XXX\ncategories: xxx\n---\n简短介绍\n<!-- more -->\n```\n\n- 可在`/yilia/_config.yml`中修改：\n\n```\n# 文章太长，截断按钮文字\nexcerpt_link: more\n# 文章卡片右下角常驻链接，不需要请设置为false\nshow_all_link: '展开全文'\n```\n\n# 添加live2d模型\n![nMBBuD.png](https://s2.ax1x.com/2019/09/06/nMBBuD.png)\n- live2d的[官网](https://www.npmjs.com/package/hexo-helper-live2d)\n- 首先，安装npm包：\n\n```\nnpm install --save hexo-helper-live2d\n```\n- 所有模型列表如下：\n\n```\nlive2d-widget-model-chitose\nlive2d-widget-model-epsilon2_1\nlive2d-widget-model-gf\nlive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)\nlive2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)\nlive2d-widget-model-haruto\nlive2d-widget-model-hibiki\nlive2d-widget-model-hijiki\nlive2d-widget-model-izumi\nlive2d-widget-model-koharu\nlive2d-widget-model-miku\nlive2d-widget-model-ni-j\nlive2d-widget-model-nico\nlive2d-widget-model-nietzsche\nlive2d-widget-model-nipsilon\nlive2d-widget-model-nito\nlive2d-widget-model-shizuku\nlive2d-widget-model-tororo\nlive2d-widget-model-tsumiki\nlive2d-widget-model-unitychan\nlive2d-widget-model-wanko\nlive2d-widget-model-z16\n```\n- 然后下载模型\n\n```\nnpm install live2d-widget-model-koharu\n```\n\n- 然后在hexo的配置文件_config.yml中添加如下配置，详细配置可以参考官网文档：\n\n```\n# 添加萌妹子效果\nlive2d:\n  enable: true\n  scriptFrom: local\n  model:\n    use: live2d-widget-model-koharu\n    scale: 1\n    hHeadPos: 0.5\n    vHeadPos: 0.618\n  display:\n    superSample: 2\n    position: left\n    width: 112.5\n    height: 225\n    hOffset: 0\n    vOffset: -20\n\n  mobile:\n    show: true\n    scale: 0.5\n  react:\n    opacityDefault: 0.7\n    opacityOnHover: 0.2\n```\n\n- 主要是配置model.use使用的模型名称，mobile是移动端效果\n\n# 左侧导航栏设置背景图片\n![nMDbee.png](https://s2.ax1x.com/2019/09/06/nMDbee.png)\n- 找到`/yilia/layout/_partial/left-col.ejs`文件,修改为：\n\n```\n<% var defaultBg = '#4d4d4d'; %>\n<div class=\"overlay\" style=\"background: <%= theme.style && theme.style.header ? theme.style.header : defaultBg %>\">\n<% if (theme.leftimg){ %>\n        <img src=\"<%=theme.leftimg%>\" alt=\"background.jpg\" border=\"0\"/>\n      <% } %>\n</div>\n<div class=\"intrude-less\">\n\t<header id=\"header\" class=\"inner\">\n\t\t<a href=\"<%=theme.root%>\" class=\"profilepic\">\n\t\t\t<img src=\"<%=theme.avatar%>\" class=\"js-avatar\">\n\t\t</a>\n\t\t<hgroup>\n\t\t  <h1 class=\"header-author\"><a href=\"<%=theme.root%>\"><%=theme.author%></a></h1>\n\t\t</hgroup>\n\t\t<% if (theme.subtitle){ %>\n\t\t<p class=\"header-subtitle\"><%=theme.subtitle%></p>\n\t\t<%}%>\n\n\t\t<nav class=\"header-menu\">\n\t\t\t<ul>\n\t\t\t<% for (var i in theme.menu){ %>\n\t\t\t\t<li><a href=\"<%- url_for(theme.menu[i]) %>\"><%= i %></a></li>\n\t        <%}%>\n\t\t\t</ul>\n\t\t</nav>\n\t\t<nav class=\"header-smart-menu\">\n    \t\t<% for (var i in theme.smart_menu){ %>\n    \t\t\t<% if(theme.smart_menu[i]){ %>\n    \t\t\t<a q-on=\"click: openSlider(e, '<%-i%>')\" href=\"javascript:void(0)\"><%= theme.smart_menu[i] %></a>\n    \t\t\t<% } %>\n            <%}%>\n\t\t</nav>\n\t\t<nav class=\"header-nav\">\n\t\t\t<div class=\"social\">\n\t\t\t\t<% for (var i in theme.subnav){ %>\n\t\t\t\t\t<a class=\"<%= i %>\" target=\"_blank\" href=\"<%- url_for(theme.subnav[i]) %>\" title=\"<%= i %>\"><i class=\"icon-<%= i %>\"></i></a>\n\t\t        <%}%>\n\t\t\t</div>\n\t\t</nav>\n\t</header>\t\t\n</div>\n```\n- 在`/yilia/_config.yml`中添加：\n\n```\nleftimg: 图片的链接，不加引号即可\n``` \n\n# 最后给大家推荐几个博主\n一个主题可以添加或修改很多东西，但是逐步让它变成自己的东西是一门技术活。\n由于可以加的东西很多，给大家推荐几个博主，他们写的文章给我提供了很大的帮助，希望也能帮到更多人\n- [小丁的个人博客](https://tding.top/archives/9a232bbe.html)\n- [Tigerliu的博客](http://tigerliu.site/2017/06/hexo-1/)","tags":["Hexo"],"categories":["博客相关"]},{"title":"Hexo博客 | 加密！给你的文章添加密码","slug":"博客相关-Hexo添加博客加密功能","url":"/posts/43010.html","content":"\n今天看到了一个很有趣的Hexo插件，可以轻松实现文章加密功能😋。\n下面是添加加密功能的操作：\n\n# 安装hexo-blog-encrypt插件\n- 在hexo目录下`npm install hexo-blog-encrypt`\n- 在`/Hexo/_config.yml`文件中添加内容:\n\n```\nencrypt:\n\tenable:true\n```\n\n# 使用插件\n- 在想要使用加密功能的Blog头部加上对应文字：\n\n```\n---\ntitle: Hexo加密功能\ndate: 2019-09-04 23:20:00   \ntags: [学习笔记,Hexo]\ncategories: Hexo      \npassword: smile   \nabstract: Welcome to my blog, enter password to read. \nmessage: 密码输入框上描述性内容\n---\n```\n- 其中：\n\t- password: 该Blog使用的密码\n\t- abstract: Blog摘要文字（少量）\n\t- message: 密码框上的描述性文字","tags":["Hexo","插件"],"categories":["博客相关"]},{"title":"学习笔记 | Flask学习从入门到放弃（2）","slug":"学习笔记-Flask笔记2","url":"/posts/3494.html","content":"\nFlask Web学习笔记之Flask与HTTP\n\n# 2.1 请求响应循环\n- 每一个Web应用都包含这种处理模式：客户端发出请求，服务器端处理请求并返回响应\n- HTTP是客户端和服务器端沟通的桥梁，当用户点击URL时，浏览器会生成http请求，经互联网发送到对应的web服务器，Web服务器端接收请求，通过WSGI将HTTP格式数据转换成能用的数据，并生成响应又依次返回给客户端\n\n# 2.2 HTTP请求\n\n## 2.2.1 报文\n- 常见HTTP方法：GET，POST，PUT，DELETE，HEAD，OPTIONS\n\n## 2.2.2 Request对象\n- 当Flask接收到请求后，请求对象会提供多个属性来获取URL的各个部分，除了URL，请求报文中的其他信息都可以通过request对象提供的属性和方法获取\n- 常用属性和方法如：`args`,`cookies`,`data`,`form`,`files`,`json`,`method`,`user_agent`,`get_json()`等等\n\n## 2.2.3 在Flask中处理请求\n\n### 1. 路由匹配\n- 程序实例中存储了一个路由表(app.url_map)，当请求发来后，Flask会根据请求报文中的URL来尝试与该表中所有的URL规则匹配，调用匹配成功的视图函数。\n- 可使用`flask routes`查看路由\n\n### 2. 设置监听的HTTP方法\n- 当查看了路由表后可以发现，每一个路由还包含了一个监听的HTTP方法。\n- 我们可以在app.route()装饰器中使用methods参数传入一个包含监听的HTTP方法的可迭代对象。\n\n```python\n@app.route('/hello',methods=['GET','POST'])\ndef hello():\n\treturn \"<h1>Hello,Flask!</h1>\"\n```\n\n- 当请求的方法不符合要求时，请求将无法被正常处理（出现405错误响应），因此我们可以为同一个URL根据请求方式定义多个视图函数\n\n### 3. URL处理\n- URL中的变量部分默认类型是字符串，但Flask提供了一些转换器可以在URL规则中使用\n\n|转换器|说明|\n| --- | --- |\n|string|不包含斜线的字符串（默认值）|\n|int|整型|\n|float|浮点数|\n|path|包含斜线的字符串，static路由的URL规则中的filename变量就是使用了这个转换器|\n|any|匹配一系列给定值中的一个元素|\n|uuid|UUID字符串|\n\n- 规则：`<转换器：变量名>`,例如：`<int:year>`\n\n```python\n@app.route('/hello/<int:year>')\ndef hello():\n\treturn '<p>hello,I am %d years old!</p>'%(year-2019)\n```\n\n- 在这个例子中，如果不使用int转换器，默认的string转换器会将其转换成string类型，为了计算数值，需要使用int转换器将变量转换成整型\n- 在用法上比较独特的是any转换器，`<any(value1,value2...):变量名>`\n\n```python\n@app.route('/colors/<any(blue,white,red):color>')\ndef three_colors(color):\n    return '<p>You choose %s</p>'%color  \n```\n\n## 2.2.4 请求钩子\n- Flask提供一些请求钩子(HOOK)，来对请求进行预处理和后处理，它们可以用来注册在请求处理的不同阶段执行的回调函数\n\n|钩子|说明|\n| --- | --- |\n|before_first_request|注册一个函数，在处理第一个请求前运行|\n|before_request|注册一个函数，在处理每个请求前运行|\n|after_request|注册一个函数，如果没有未处理的异常抛出，会在每个请求结束后运行|\n|teardown_request|注册一个函数，即使有未处理的异常抛出，会在每个请求结束后运行。如果发送异常，会传入异常对象作为参数到注册的函数中|\n|after_this_request|在注册函数内注册一个函数，会在这个请求结束后运行|\n\n```python\n@app.before_request\ndef do_something():\n    pass #这里的代码会在每个请求处理前执行\n```\n\n# 2.3 HTTP响应\n\n## 2.3.1 响应报文\n\n- 响应报文主要由**协议版本**,**状态码**(status code),**原因短语**(reason phrase),**响应首部**和**响应主体**组成。\n- 响应报文的首部包含一些关于响应和服务器的信息，这些内容由Flask生成，而我们在视图函数中返回的内容即为响应报文中的主题内容\n- HTTP状态码用来表示请求处理的结果\n\n<table>\n<!-- rowspan是要跨的行数，colspan是要跨的列数 -->\n    <tr>\n        <th>类型</th>\n        <th>状态码</th>\n        <th>原因短语</th>\n        <th>说明</th>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">成功</td>\n        <td>200</td>\n        <td>OK</td>\n        <td>请求被正常处理</td>\n    </tr>\n    <tr>\n        <td>201</td>\n        <td>Created</td>\n        <td>请求被处理,并创建了一个新资源</td>\n    </tr>\n    <tr>\n        <td>204</td>\n        <td>No Content</td>\n        <td>请求处理成功，但无内容返回</td>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">重定向</td>\n        <td>301</td>\n        <td>Moved Permanently</td>\n        <td>永久重定向</td>\n    </tr>\n    <tr>\n        <td>302</td>\n        <td>Found</td>\n        <td>临时性重定向</td>\n    </tr>\n    <tr>\n        <td>304</td>\n        <td>Not Modified</td>\n        <td>请求的资源未被修改，重定向到缓存的资源</td>\n    </tr>\n    <tr>\n        <td rowspan=\"4\">客户端错误</td>\n        <td>400</td>\n        <td>Bad Request</td>\n        <td>请求无效，即请求报文中存在错误</td>\n    </tr>\n    <tr>\n        <td>401</td>\n        <td>Unauthorized</td>\n        <td>表示请求的资源需要获取授权信息，在浏览器中会弹出认证弹窗</td>\n    </tr>\n    <tr>\n        <td>403</td>\n        <td>Forbidden</td>\n        <td>请求的资源被服务器拒绝访问</td>\n    </tr>\n    <tr>\n        <td>404</td>\n        <td>Not Found</td>\n        <td>服务器上无法找到请求的资源或者URL无效</td>\n    </tr>\n    <tr>\n        <td rowspan=\"1\">服务器端错误</td>\n        <td>500</td>\n        <td>Internet Server Error</td>\n        <td>服务器内部发送错误</td>\n    </tr>\n\n</table>\n\n## 2.3.1 在Flask中生成响应\n- 视图函数可以返回：响应主体，状态码，首部字段\n\n### 1. 重定向\n\n```python\nfrom flask import Flask,redirect\n\n@app.route('/hello')\ndef hello():\n    return redirect('http://justlovesmile.top')\n```\n\n- redirect函数默认的状态码是302即临时重定向，可以通过code关键字传入或作为第二参数传入修改\n\n- 如果要在程序内重定向到其他视图，只需在redirect函数中使用url_for()函数生成目标URL\n\n```python\nfrom flask import Flask,redirect,url_for\n\n@app.route('/hi')\ndef hi():\n    ...\n    return redirect(url_for('hello'))\n\n@app.route('/hello')\ndef hello():\n    ...\n```\n\n### 2. 错误响应\n\n-  使用Flask提供的abort()函数，手动返回错误响应\n- abort()函数前不需要执行使用return语句，一旦abort函数被调用，其之后的代码不被执行\n\n```python\nfrom flask import Flask,abort\n\n@app.route('/404')\ndef not_found():\n    abort(404)\n```\n\n## 2.3.2 响应格式\n- 默认情况下Flask使用html格式响应，在特定情况下，也会使用其他格式，不同的响应数据格式需要设置不同的MIME类型，MIME类型在首部的Content-Type定义，以默认的html类型为例\n`Content-Type: text/html;charset=utf-8`\n- 如果想使用其他的MIME类型，可以通过Flask提供的make_response()方法,生成对应响应对象，传入响应的主体作为参数，然后使用响应对象的mimetype属性设置MIME类型\n\n```python\nfrom flask import Flask\nfrom flask import make_response\n\n@app.route('/foo')\ndef foo():\n    response=make_response('Hello World')\n    response.mimetype='text/plain'\n    return response\n```\n\n- 常用MIME类型：\n    - 纯文本：`text/plain`\n    - HTML：`text/html` \n    - XML：`application/xml`\n    - json: `application/json`\n\n- 对于json数据，python的json模块具有`dumps()`和`load()`等方法,并且Flask提供了包装好的更方便的`jsonify()`函数\n\n```python\nfrom falsk import Flask,make_response,json\n@app.route('/foo')\ndef foo():\n    data={\n      'name':'justlovesmile',\n      'gender':'male'\n    }\n    response=make_response(json.dumps(data))\n    response.mimetype='application/json'\n    return response\n```\n\n等价于\n\n```python\nfrom flask import Flask,jsonify\n\n@app.route('/foo')\ndef foo():\n    return jsonify({name='justlovesmile',gender='male'})\n```\n\n- jsonify()函数默认返回码为200，可以附加状态码自定义响应类型\n\n```python\n@app.route('/foo')\ndef foo():\n    return jsonify({name='',gender=''}),500\n```\n\n## 2.3.3 来一块Cookie\n","tags":["Python","Flask"],"categories":["学习笔记"]},{"title":"学习笔记 | Flask学习从入门到放弃（1）","slug":"学习笔记-Flask笔记1","url":"/posts/3302.html","content":"\nFlask web开发学习笔记之初识Flask\n\n- Flask是使用python编写的Web微框架\n- Flask有两个主要依赖：\n\t- WSGI（Web Server Gateway Interface，Web服务器网关接口）\n\t- Jinja2模块引擎\n\n# 1.1搭建开发环境\n\n## 1.1.1 Pipenv工作流\n- 可看作是pip加强版，是pip和pipfile和virtualenv的结合体，使得包安装，包依赖管理和虚拟环境管理更加方便\n- python3.4及以上版本自带pip工具，使用    `$ pip --version`     查看已安装版本\n- 安装pipenv： `$ pip install pipenv`\n- 选择并进入工作目录，创建虚拟环境： `$ pipenv install`\n- 虚拟环境文件夹的目录名称的形式是'当前项目目录名+一串随机字符'\n- 显式激活虚拟环境： `$ pipenv shell` ,使用`exit`退出\n- 非显式激活虚拟环境： `$ pipenv run python xxxx.py`\n- 管理依赖（会使用到的python包）,查看Pipfile和Pipfile.lock文件,或者输入`$ pipenv graph`或者在虚拟环境中输入 `$ pip list`\n\n## 1.1.2 安装Flask\n- 在虚拟环境中安装Flask： `$ pipenv install Flask`\n\n## 1.1.3 集成开发环境IDE\n- pycharm\n- 点击File → Setting → Project：XXX → Project Interpreter → Add local Python Interpreter → Virtualenv Environment → Existing environment → （输入 `$ pipenv --venv` 查看对应虚拟环境路径，找到其下的python.exe文件，linux/MacOS在bin，windows在Scripts）\n- 推荐使用浏览器 Firefox 和 Chorme\n\n# 1.2 第一的程序\n\n```python\nfrom flask import Flask //导入Flask类\napp=Flask(__name__)     //实例化这个类\n\n@app.route('/')\t\t\t//注册路由\ndef index():\t\t\t//视图函数\n\treturn '<h1>Hello World!</h1>'\n\nif __name__ == \"__main__\":\n\tapp.run(debug=True)\n```\n\n## 1.2.1 创建程序实例\n- 导入Flask类，实例化这个类\n\n## 1.2.2 注册路由\n- 为函数附加app.route()装饰器，并传入URL规则作参数\n- 可以为一个视图函数绑定多个URL\n\n```python\n@app.route('/hi')\n@app.route('/hello')\ndef say():\n\treturn '<h1>hello</h1>'\n```\n\n- 动态URL：使用‘<变量名>’表示变量\n\n```python\n@app.route('/greet/<name>')\ndef greet(name):\n\treturn '<h1>hello, %s!</h1>' % name\n```\n\n- URL中包含变量时，如果用户访问的URL中没有包含变量，则会返回错误，所以可以设置装饰器使用defaults参数设置变量的默认值\n\n```python\n@app.route('/greet',defaults={'name':'programmer'})\n@app.route('/greet/<name>')\ndef greet(name):\nreturn '<h1>Hello, %s!</h1>' % name\n\n//等价于\n@app.route('/greet')\n@app.route('/greet/<name>')\ndef greet(name='programmer'):\nreturn '<h1>Hello, %s!</h1>' % name\n```\n\n# 1.3 启动开发服务器\n\n## 1.3.1 运行\n- `$ flask run`\n- 自动发现程序实例：（Linux/macOS）`$ export FlASK_APP=XXX `或（Windows）`set FlASK_APP=XXX `,但是当我在Windows使用powershell时我输入`set FLASK_APP=appname.py`时，出错了，解决办法是输入`$env:FLASK_APP=\"appname.py\"` \n- 管理环境变量： 安装python-dotenv,`pip install python-dotenv`,在项目根目录下创建两个文件：.env（存储敏感信息的环境变量）和.flaskenv（存储与flask相关公开环境变量）,每行一个，以#为注释的键值对\n- 使用pycharm运行,需要配置一系列变量.....\n\n## 1.3.2 更多启动选项\n- 设置主机地址：`flask run --host=0.0.0.0`\n- 设置端口： `flask run --port=8000`\n- 设置开发环境：可在.flaskenv文件中写入`FALSK_ENV=development`，在开发环境下，调试模式自动开启，通过FALSK_DEBUG控制是(=1)否(=0)开启.\n- 调试模式下，会激活调试器和重载器，调试器允许在错误页面输入PIN码调试，重载器可以检测文件变动，重启服务器。\n- 内置stat重载器性能一般，可以使用watchdog，`pipenv install watchdog --dev`,添加--dev的目的是声明为开发依赖。\n\n# 1.4 shell\n- python shell与flask shell\n\n# 1.5 Flask扩展\n- 即使用Flask提供的API接口编写的Python库\n\n# 1.6 项目配置\n- 配置变量都是通过Flask对象的app.config属性作为统一的接口来设置和获取\n- 单个设置：`app.cofig['ADMIN_NAME']='xiaoming'`,也可以保存在文件中\n- 多个设置：\n\n```python\napp.config.update{\n\tTESTING=True,\n\tSECRET_KEY='XXXXXXXXXXX'\n}\n```\n\n- 获取：`value=app.config['ADMIN_NAME']`\n\n# 1.7 URL与端点\n- 使用Flask提供的url_for()函数获取URL，第一个参数是端点名（默认是视图函数名）,其后还可以加动态参数，形如：name='Jack',得到的URL是相对的URL（内部的URL）\n\n# 1.8 Flask命令\n- flask run/flask shell/flask --help等等\n- 注册flask命令：\n\n```python\n@app.cli.command()\ndef hello():\n\tclick.env('Hello , Human!')\n```\n\n然后在控制台输入：`flask hello` \n\n# 1.9 模板和静态文件\n- 项目结构示例：templates中存放html文件，static中存放css和js文件\n\n```\nhello/\n   - templates/\n   - static/\n   - app.py\n```\n\n# 1.10 Flask与MVC框架\n- MVC框架最初是设计桌面程序的，在MVC框架中，程序被分成了三个组件：数据处理（Model），用户界面（View），交互逻辑（Controller）\n- 严格来说Flask不是MVC架构的框架","tags":["Python","Flask"],"categories":["学习笔记"]},{"title":"生活琐事 | 新加坡国立大学短期交流总结","slug":"生活琐事-新加坡国立大学短期交流总结","url":"/posts/92550e63.html","content":"\n\n{% gallery %}\n![](https://unpkg.com/justlovesmile-img/nus18.jpeg)\n![](https://unpkg.com/justlovesmile-img/nus17.jpeg)\n![](https://unpkg.com/justlovesmile-img/nus16.jpeg)\n![](https://unpkg.com/justlovesmile-img/nus15.jpeg)\n![](https://unpkg.com/justlovesmile-img/nus14.jpeg)\n![](https://unpkg.com/justlovesmile-img/nus13.jpeg)\n![](https://unpkg.com/justlovesmile-img/nus12.jpeg)\n![](https://unpkg.com/justlovesmile-img/nus11.jpeg)\n![](https://unpkg.com/justlovesmile-img/nus19.jpg)\n{% endgallery %}\n\n\n## 赴新加坡国立大学交流学习总结\n\n姓名：Justlovesmile\t时间：2019年8月\n\n首先非常感谢学校给我们创造了如此难得的条件赴新加坡国立大学（National University of Singapore）交流学习。我非常庆幸自己能拥有如此有趣的学习和生活经历。那21天的生活，转瞬即逝，尽管异国的生活环境和教育体系是小小的阻碍，但是我们收获的却是更多的，受益终生的知识和眼界。对于这21天的学习生活我做了如下总结：\n\n## 一，\t课程学习\n\n在来到新加坡国立大学之前，我们就已经在学校官网上选择了cluster。我选择的cluster是人工智能和信息安全。其下有很多分支，需要在学习了这个cluster下所有课的先导课后再做决定。在新加坡国立大学学习了先导课后，我选择了深度学习，这是一门非常有意思的课程，我非常喜欢。\n·对于我的项目内容：\n\n- 我选择的是`deep learning `课题，这个课题最后是和智能小车一起接受检查。最开始的时候我们是在教授的带领下，去对`deep learning`进行系统学习，但是由于时间有限，所以讲的都十分快。之后我们就开始根据教授提供的文件和资料对之前所讲的，稍做练习。然后就是给我们时间去做第一个任务，即控制小车去走迷宫，并识别各种位置，可能被部分遮挡或颠倒的猫的图片，并分析出四种猫的种类。最开始我们的工作是选择出一个较好的模型。所以我们在网上找了这四种猫的大量图片做训练集和测试集。然后在经过了多次训练和测试后保存了效果比较好的权重文件。之后我们和小车组的队友一起合作，使用小车树莓派相机拍照，并传到我的电脑上分析。最终我们每一张图片都准确的识别出来了。在完成了第一个任务之后，我们又开始了最终项目的讨论，在教授的帮助和我们的研讨之下，我们决定做一个小车跟随目标前进并自动避障的项目。在老师的建议下，我们使用了`YOLO（You Only Look Once）`目标检测方法。经过我们的不懈努力，终于完成了项目，得到了教授的赞赏。\n\n对于课程学习我有如下的体会：\n\n1.\t英语非常重要，最基本的就是要会听说读。在新加坡国立大学全英文的教学模式下，课程学习的难点就是听懂教授所讲的东西，并且大多数印度籍和新加坡本地的老师的英语口音非常重，需要你认真去听，去结合前后语句去理解。\n2.\t一定要多问。在新加坡国立大学的学习生活中，由于我们的时间有限，所以教授只是对每一个知识点简要讲解，所以最后要做项目时，必然会遇到很多问题，无论是项目所使用的方法，还是编程时遇到的bug等等，如果你只是自己琢磨，必然会花费大量的时间，费力不讨好，正确的做法是，先自己谷歌或百度，如果发现不能解决，立即去询问同学，助教和教授，这样才能高效的解决问题。\n3.\t多和同学沟通。在我的课题，教授要求同一学校的学生不能组队，所以我们的队友都是来自不同的学校的陌生人，所以为了接下来的学习和工作，我们一定要和队友处好关系，并且我所选的课题是深度学习，是和智能小车课题的小组合作，所以我们不仅需要和队友时常沟通，加强友谊，还需要随时了解合作小组的学习进度和技术，以便最后合作时能够尽快的成功。\n4.\t课后多专研。对于我们的课题，由于深度学习可以使用的预训练模型和方法比较多，但是不同的人由于数据集和参数的设置不同，会有不同的正确率，所以，在课后可以选择多个模型结合学校提供的GPU，自己训练以获得更好的权重，来满足项目要求。再比如我们在使用训练好的权重时，经常会遇到问题，例如读取权重的函数在主文件中可以运行，但是在其他文件中调用时会出错。在经过我们的不断调试以及谷歌百度下，终于得到解决。\n5.\t融会贯通。由于最后我们的检验标准是做一个项目，所以我们需要掌握多种编程语言，和其他技术，并且需要你能将这些都结合起来一起使用。\n\n## 二，\t异国生活\n\n1. 住宿。这次交流项目，我们是住在新加坡国立大学的学生宿舍（位于`University Town`）。新加坡国立大学的宿舍都非常人性化，一人一间，各项设施一应俱全，宿舍楼层内设有卫生间，淋浴，厨房，洗衣房，活动室。可以说是非常全面了。并且每个房间都有空调和风扇。\n![](https://unpkg.com/justlovesmile-img/nus1.jpg)\n![](https://unpkg.com/justlovesmile-img/nus2.jpg)\n![](https://unpkg.com/justlovesmile-img/nus3.jpg)\n2. 饮食。由于新加坡人口有70%是华人，所以新加坡的饮食很多是偏向中式餐饮的，当然也有很多印度菜，泰国菜等。价格方面普遍偏贵。新加坡国立大学食堂比较多，我只探索了三个食堂。下附图片：\n![](https://unpkg.com/justlovesmile-img/nus4.jpg)\n![](https://unpkg.com/justlovesmile-img/nus5.jpg)\n![](https://unpkg.com/justlovesmile-img/nus6.jpg)\n3. 交通。新加坡的交通非常便利，新加坡国立大学给每个学生办了一张`Ezlink`卡片，里面预存了钱，无论去哪都比较方便。并且Ezlink卡可以在地铁站和便利店里充值（便利店会收取少量手续费）。\n4. 通讯。在我们到达新加坡国立大学时，新加坡国立大学的助教会拿我们的护照去帮我们免费办理电话卡，并预存了话费和流量，足够我们的21天的通讯和上网所需。并且NUS是WiFi全覆盖的，所以无需担心上网问题，值得注意的是在新加坡蹭网是违法的。\n5. 生活所需。我们住的地方位于新加坡国立大学（NUS）的`University town`里面有食堂，有超市，有餐厅，有自习室，生活所需都能满足。并且`u-town`里面有一个大草坪叫做`Town green`，每天都有很多人在上面玩耍，非常适合在草坪上休息。\n![](https://unpkg.com/justlovesmile-img/nus7.jpg)\n![](https://unpkg.com/justlovesmile-img/nus8.jpg)\n![](https://unpkg.com/justlovesmile-img/nus20.jpg)\n![](https://unpkg.com/justlovesmile-img/nus21.jpg)\n6. 法律。在来到新加坡之前，我就听说新加坡的法律非常严格，罚款很重，并且还保留了鞭刑这种刑法。但是实际上到了新加坡之后，发现新加坡也没有传说中的那么可怕，只要你规规矩矩的，一般也没有人会去举报你。对于新加坡的法律，经常听到的就是：地铁公交上不能吃喝东西；不能嚼口香糖（虽然也买不到）；不能裸露（即使别人拿望眼镜偷看你家窗户，但是我看见了一个裸上半身跑步的也没被抓啊...）；等等\n7. 旅游。新加坡的旅游景点还是蛮多的。比如鱼尾狮公园，植物园，夜间动物园，环球影城，牛车水，小印度，克拉码头，圣淘沙岛，滨海湾公园，乌节路等等…在学习生活之余，我们也会去这些地方，去感受一下新加坡的魅力。旅游不仅可以增长见识，还可以放松心情，劳逸结合。\n8. 烟花。每年8月9日是新加坡的国庆日，虽然这次我们没能赶上新加坡 的国庆，但是我们赶上了国庆烟花预演，美丽的烟花表演让人称叹。\n\n![](https://unpkg.com/justlovesmile-img/nus9.jpg)\n![](https://unpkg.com/justlovesmile-img/nus10.jpg)\n![](https://unpkg.com/justlovesmile-img/nus22.jpg)\n\n## 三，\t心得体会\n\n在新加坡国立大学的21天学习生活转瞬即逝，回想这些日子的学习和生活的点点滴滴，感触颇多。\n\n- 来新加坡之前，我深切的感受到了办理签证的繁琐，对异国生活的忐忑和激动。真正来到这个陌生的地方后，却发现这里有着70%的华人人口，无论是饮食还是生活都和国内区别极小，唯一需要注意的只是语言方面，通过这一次的交流学习，我深刻的认识到了语言的重要性，这更加激励了我认真学习语言，尤其是当你直面某些问题时，例如和你同届的同学能够在课堂上和教授愉快的互动，而你还在揣测教授说的话时，你就会真正的看见一些差距。\n\n- 对于新加坡国立大学组织的这次交流活动，我觉得最珍贵的就是开阔眼界，在世界一流大学感受他们的学习氛围，并且和来自全国各地的队友们自相比较，认识到自己的不足，并给自己定下一个小小的目标，做一个有追求的人。再者就是认识更多的人，更加的了解这个世界，举个小小的例子，我们在香港转机时，坐我旁边的是一位新加坡小姐姐，当她得知我是中国内地的时候，会拿出她随身带的报纸，和我分享她对于香港前段时间发生的问题的看法。我认为这些都是一些宝贵的回忆，会或多或少的影响我们的思维，以至于影响我们的人生。\n\n- 在学习之余，旅游也是不错的选择，去感受文化的差异，去了解每一个国家的生活方式。正所谓读万卷书，行万里路，一路走来，你就会发现自己也学到了很多书本上不能学到的知识。每个人都应该有适合自己的独特的生活方式，只有去探索过后你才会发现适合自己的生活，无论现在还是将来，最重要的是，做自己。\n\n- 这21天的时间，我学到了太多太多，无论是以前了解的还是不熟悉的知识，最重要，最宝贵的就是那些永远留在我们脑海中的记忆，特别感谢学校给我们这样的机会，让我们能无感受新的世界，这些天，我收获了知识，增长了见识。世界很大，生命很短，让我们放开眼界，活在当下，享受人生。","tags":["NUS","实习"],"categories":["生活琐事"]},{"title":"大学课程 | 计算机网络学习笔记","slug":"学习笔记-计算机网络","url":"/posts/28758.html","content":"大二计算机网络课程笔记\n<!-- more -->\n\n## 第一章 概述\n\n### 1.1 计算机网络在信息时代中的作用\n1. 21世纪的重要特征：数字化，网络化，信息化\n2. 21世纪是以网络为核心的信息时代\n3. 常见三类网络：电信网络，有线电视网络，计算机网络\n4. Internet 的中文译名：\n（1）因特网\n（2）互联网：由数量极大的各种计算机网络互连起来\n5. 互联网具有两个重要的特点：**连通性**和**共享**\n（1）连通性：互联网使上网用户之间不管相距多远，都可以非常方便的交换各种信息，好像这些用户中端是直接连通的\n（2）共享：就是指资源共享，资源包括信息，软件，硬件\n6.  互联网+\n\n### 1.2 互联网概述\n\n#### 1.2.1 网络的网络\n1.计算机网络：由若干**结点**和连接这些结点的**链路**组成。\n- 结点包括：计算机，集线器，交换机，路由器\n2.**互连网**：网络之间通过路由器互连起来，就构成了一个覆盖范围更大的计算机网络，因此互连网是“网络中的网络”\n3.网络：网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机称为**主机**。\n4.计算机网络的三种定义：\n- 广义观点：实现远程信息处理的系统或能进一步达到资源共享的系统\n- 资源共享观点：以能够相互共享资源的方式互联起来的自治计算机系统的集合\n- 用户透明性观点：存在一个能为用户自动管理资源的网络操作系统，它能够调用用户所需要的资源，而整个网络就像一个大的计算机系统一样对用户是透明的\n\n#### 1.2.2 互联基础结构发展的三个阶段\n1.第一阶段：**单个网络ARPANET**向互连网发展的过程\n- 互联网的雏形：单个的分组交换网ARPANET\n- 1983年TCP/IP协议成为ARPANET的标准协议\n- internet（互连网）：泛指由多个计算机网络互连而成的计算机网络\n- Internet（互联网）：指当前全球最大的，开放的，由众多网络相互连接而成的特定互连网，它采用TCP/IP协议族作为通信的规则，且前身为美国的ARPANET\n2.第二阶段：**三级结构的互联网**\n- 三级计算机网络：主干网，地区网，校园网（或企业网）\n3.第三阶段：形成了**多层次的ISP结构的互联网**\n- 互联网服务提供者ISP\n- 流程：\n（1）ISP向互联网管理机构申请很多IP地址，同时拥有通信线路以及路由器等连网设备\n（2）任何机构和个人只要向某个ISP交纳规定的费用，就可以从该ISP获取所需IP地址的使用权，并可通过该ISP接入到互联网\n- ISP层次:主干ISP，地区ISP，本地ISP\n4.**互联网交换点IXP**：\n- 作用：**允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组**。\n- IXP常采用工作在数据链路层的网络交换机，这些网络交换机都用局域网互连起来\n5.**万维网WWW**：\n>万维网（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。\n>                                                                      ---百度百科\n\n#### 1.2.3 互联网的标准化工作\n- 互联网协会（ISOC）\n    - 互联网体系结构委员会IAB\n        - 互联网工程部IETF\n            - 互联网工程指导小组IESG：主要针对协议的开发和标准化\n        - 互联网研究部IRTF\n            - 互联网研究指导小组IRSG：（RFC“请求评论”）\n                - 指定互联网标准的三个阶段：\n                    （1）互联网草案\n                    （2）建议标准\n                    （3）互联网标准\n\n### 1.3 互联网的组成\n- 从工作方式上看：\n（1）边缘部分：用户直接使用的部分（主机）\n（2）核心部分：为边缘部分提供服务的（连通性和交换）（网络和路由器）\n- 从组成部分来看：\n（1）硬件\n（2）软件\n（3）协议\n- 从功能组成上来看：\n（1）通信子网（数据传输，交换，控制，存储）\n（2）资源子网（实现硬件，软件，数据资源共享的设备及其软件的集合）\n\n#### 1.3.1 互联网的边缘部分\n- 端系统：处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统\n- 端系统之间的通信方式：客户-服务器方式(C/S)；对等方式（P2P）\n1.客户-服务器方式：\n主机A运行客户程序<------------>主机B运行服务器程序\n- A向B发出服务请求，B向A提供服务\n- 客户是服务的请求方，服务器是服务的提供方\n- 对于客户程序：\n（1）被用户**调用后运行**，在通信时**主动**向远地服务器发起通信，因此客户程序**必须知道服务器程序的地址**\n（2）不需要特殊的硬件和很复杂的操作系统\n- 对于服务器程序：\n（1）是一种专门来提供某种服务的程序，可**同时处理多个**客户请求\n（2）系统启动后**自动调用**并不断运行，**被动等待**接受来自各地的客户的请求，因此服务器**不需要知道客户程序的地址**\n（3）一般需要有强大的硬件和高级的操作系统支持\n2.对等连接方式：P2P\n- P2P方式：只要两台主机都运行了对等连接软件（P2P软件），就能进行平等的，对等连接通信\n\n#### 1.3.2 互联网的核心部分\n- 在网络中心起特殊作用的是**路由器**，它是一种专用计算机（但不叫主机）\n- 路由器是实现**分组交换**的关键构件，其任务是**转发收到的分组**，这是网络核心部分最重要的功能\n- 互联网的核心部分是由许多网络和把它们互连起来的路由器组成，而主机处在互联网的边缘部分\n- 互联网核心部分中的路由器之间一般是用高速链路连接，而在网络边缘的主机接入到核心部分则通常以相对较低速率的链路相连接\n1. 电路交换的特点\n    - N 部电话机两两直接相连，需 N(N – 1)/2 对电线。这种直接连接方法所需要的电线对的数量与电话机数量的平方（ N2 ）成正比。\n    - 当电话机的数量增多时，就要使用**交换机**来完成全网的交换任务。\n    - **电路交换** (circuit switching)：每一部电话都直接连接到交换机上，而交换机使用交换的方法，让电话用户彼此之间可以很方便地通信。 \n![nFaU7d.png](https://s2.ax1x.com/2019/09/03/nFaU7d.png)\n    - 交换：按照某种方式动态的分配传输线路的资源\n    - 电路交换必定是**面向连接**的\n    - 电路交换的三个阶段：\n    （1）**建立连接**：（占用通信资源）\n    （2）**通信**：（一直占用）\n    （3）**释放连接**：（归还通信资源）\n    - 在通话的全部时间内，通话的两个用户始终占用端到端的通信资源（利用率低）\n    - 计算机数据具有突发性\n2. 分组交换的主要特点：\n\t- 分组交换网采用**存储转发**技术\n\t- 分组交换是面向无连接的\n\t- Internet网络层是分组交换\n\t- **报文**：要发送的整块数据\n\t- 在发送端，先把较长的报文划分成较短的，固定长度的**数据段**\n\t- 在每一个数据段前面添加上**首部**构成**分组**，分组又叫“包”，而分组的首部也可以称为“包头”\n\t- 主机是为用户进行信息处理的；路由器则是用来转发分组的，即进行分组交换\n\t- 分组是在互联网中传送的**数据单元**。依次把各分组发送到接收端\n\t- 分组的首部包含了目的地址，源地址等重要控制信息。\n\t- 分组交换网中的结点交换机根据收到的分组首部的地址信息，把分组转发到下一个结点交换机\n\t- 每一个分组在互联网中独立地选择传输路径\n\t- 接收端收到分组后剥去首部还原成报文\n\t- 路由器处理分组的过程：\n（1）把收到的**分组先放入缓存**（暂时存储）；\n（2）**查找转发表**，找出到某个目的地址应从哪个端口转发；\n（3）把分组送到适当的**端口转发**出去。 \n\n| 优点 |所采用的手段  |\n| --- | --- |\n| 高效 |在分组传输过程中动态分配传输带宽，对通信链路是逐段占用  |\n| 灵活 |为每一个分组独立地选择最合适的转发路由|\n| 迅速 |以分组作为传送单位，可以不先建立连接就能向其他主机发送分组 |\n| 可靠 |保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性 |\n\n- 分组交换带来的问题：\n（1）分组在各结点存储转发时需要**排队**，这就会造成一定的**时延**。 \n（2）分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的**开销**。 \n3. 三种交换的比较：\n![nFaTjU.png](https://s2.ax1x.com/2019/09/03/nFaTjU.png)\n- 电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送（面向连接）\n- 报文交换：整个报文先传送到相邻结点，全部存储下来后查询转发表，转发到下一个结点。（面向无连接）\n- 分组交换：单个分组传送到相邻结点，存储下来后查找转发表，转发到下一个结点（面向无连接）\n\n### 1.4 计算机网络在我国的发展\n- 规模最大的就是下面这五个：\n(1) 中国电信互联网 CHINANET（也就是原来的中国公用计算机互联网）\n(2) 中国联通互联网 UNINET\n(3) 中国移动互联网 CMNET\n(4) 中国教育和科研计算机网 CERNET\n(5) 中国科学技术网 CSTNET\n\n### 1.5 计算机网络的类别\n\n#### 1.5.1 计算机网络的定义\n\n- 定义：<u>计算机网络主要是由一些**通用的、可编程的硬件**互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些**可编程的硬件**能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</u>\n- 根据定义：\n(1) 计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机。\n(2) 计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）\n- 可编程的硬件表明<u>这种硬件一定包含有中央处理机CPU</u>\n\n#### 1.5.2 计算机网络的类别\n1. 按照网络的作用范围进行分类：\n（1）广域网WAN\n（2）城域网MAN\n（3）局域网LAN\n（4）个人区域网PAN\n    - 无线个人区域网WPAN\n- 若中央处理机之间的距离非常近（如仅1米的数量级甚至更小些），则一般就称之为**多处理机系统**，而不称它为计算机网络。 \n2. 按照网络使用者分类：\n（1）公用网\n（2）专用网\n3. 用来把用户接入到互联网的网络\n- 接入网AN，它又称为本地接入网或居民接入网\n- 接入网是一类比较特殊计算机网络，用于讲用户接入互联网\n- <u>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。</u>\n- 接入网是从某个**用户端系统**到**互联网**中的**第一个路由器**（也称为**边缘路由器**）**之间**的一种网络。\n\n### 1.6 计算机网络的性能\n\n#### 1.6.1 计算机网络的性能指标\n\n1. **速率**：\n- **比特**（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。\n- 速率是计算机网络中最重要的一个性能指标，指的是**数据的传送速率**，它也称为**数据率** (data rate)或**比特率** (bit rate)。\n- 速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s 等。例如 4 × 10^10 bit/s 的数据率就记为 40 Gbit/s。\n- **速率往往是指额定速率或标称速率，非实际运行速率**。\n2. **带宽**：\n- 两种不同意义：\n（1）“带宽”(bandwidth) 本来是指信号具有的频带宽度，其单位是赫（或千赫、兆赫、吉赫等）。（频域）\n（2）在计算机网络中，带宽用来表示网络中某**通道**传送数据的能力。表示在单位时间内网络中的某信道所能通过的“**最高数据率**”。单位是 bit/s ，即 “比特每秒”（时域）\n3. **吞吐量**：\n- 吞吐量 (throughput) 表示在**单位时间**内通过某个网络（或信道、接口）的**数据量**。\n- 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道**实际上**到底有多少数据量能够通过网络。\n- 吞吐量受网络的带宽或网络的额定速率的限制。  \n4. **时延**：\n- 时延是指数据（一个报文或分组，甚至比特）从网络（或链路）的**一端传送到另一端**所需的时间。\n- 有时也称为延迟或迟延。\n- 网络中的时延由以下几个不同的部分组成：\n(1) 发送时延（传输时延）：指主机或路由器发送数据帧所需要的时间\n![nFdpjO.png](https://s2.ax1x.com/2019/09/03/nFdpjO.png)\n(2) 传播时延：是电磁波在信道中传播一定的距离需要花费的时间\n![nFdCuD.png](https://s2.ax1x.com/2019/09/03/nFdCuD.png)\n**发送时延发送在机器内部的发送器中，与传输信道的长度无关**，**传播时延发生在机器外部的传输信道媒体上**，与信号的发送速率无关。**信号传送的距离越远，传播时延就越大**\n(3) 处理时延\n- 主机或路由器在**收到分组时**，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。 \n(4) 排队时延\n- 分组在路由器输入输出队列中排队**等待处理所经历的时延**。\n- 排队时延的长短往往取决于网络中当时的通信量。\n\n总时延 = 发送时延+传播时延+处理时延+排队时延\n- 对于**高速网络链路**，我们提高的仅仅是数据的**发送速率**而不是比特在链路上的传播速率。 \n- 提高链路**带宽**减小了数据的**发送时延**。\n5. 时延带宽积：\n- 链路的时延带宽积又称为以比特为单位的链路长度。\n![nFweo9.png](https://s2.ax1x.com/2019/09/03/nFweo9.png)\n- 只有在代表链路的管道都充满比特时，\n链路才得到了充分利用。\n6. 往返时间RTT：\n- 互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。\n- <u>往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间</u>。\n- 在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。\n- 发送时间=数据长度/发送速率\n- 有效数据率=数据长度/（发送时间+RTT）\n7. 利用率：\n- 利用率分为**信道利用率**和**网络利用率**\n- 信道利用率**不是**越高越好，根据排队论的理论，当某信道的**利用率增大**时，该信道引起的**时延也就迅速增加**。 \n- 若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0之间的关系： \n![nFwJdH.png](https://s2.ax1x.com/2019/09/03/nFwJdH.png)\n- 信道或网络利用率过高会产生非常大的时延\n\n#### 1.6.2 计算机网络的非性能指标\n1. 费用\n2. 质量\n3. 标准化\n4. 可靠性\n5. 可扩展性和可升级性\n6. 易于管理和维护\n\n### 1.7 计算机网络体系结构\n#### 1.7.1 计算机网络体系结构的形成\n- 计算机网络是个非常复杂的系统。\n- 相互通信的两个计算机系统必须**高度协调工作**才行，而这种“协调”是相当复杂的。 \n- “分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。 \n- 1974 年，美国的 IBM 公司宣布了**系统网络体系结构SNA** (System Network Architecture)。这个著名的网络标准就是按照**分层**的方法制定的。\n- 由于<u>网络体系结构的不同，不同公司的设备很难互相连通</u>。\n- 为了使不同体系结构的计算机网络都能互连，国际标准化组织 ISO 于 1977 年成立了专门机构研究该问题。他们提出了一个试图<u>使各种计算机在世界范围内互连成网的标准框架</u>，即**著名的开放系统互连基本参考模型 OSI/RM** (Open Systems Interconnection Reference Model)，简称为**OSI**。\n- <u>只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。</u>\n- 开放是指非独家垄断，系统是指在现实的系统中与互连有关的各部分\n- OSI 只获得了一些理论研究的成果，在市场化方面却失败了\n- **法律上的国际标准 OSI** 并没有得到市场的认可。非国际标准 TCP/IP 却获得了最广泛的应用。**TCP/IP** 常被称为**事实上的国际标准**。\n\n#### 1.7.2 协议与划分层次\n- 计算机网络中的数据交换必须遵守事先约定好的规则。 **这些规则明确规定了所交换的数据的格式以及有关的同步问题**（**同步含有时序**的意思）。\n- **网络协议** (network protocol)，简称为协议，是**为进行网络中的数据交换而建立的规则、标准或约定**。 \n- 协议主要由以下三个要素组成：\n（1）语法：数据与控制信息的结构或格式\n（2）语义：需要发出何种控制信息，完成何种动作以及做出何种响应\n（3）同步：事件实现顺序的详细说明\n- 协议的两种形式：\n（1）一种是使用便于人来阅读和理解的**文字描述**。\n（2）另一种是使用让计算机能够理解的**程序代码**。\n    - 这两种不同形式的协议都必须能够对网络上信息交换过程做出精确的解释。\n- 分层的好处：\n（1）各层之间是独立的。\n（2）灵活性好。\n（3）结构上可分割开。\n（4）易于实现和维护。\n（5）能促进标准化工作\n缺点：\n（1）降低效率。\n（2）有些功能会在不同的层次中重复出现，因而产生了额外开销。\n- 通常各层要完成的功能：\n（1）差错控制\n（2）流量控制\n（3）分段和重装\n（4）复用和分用\n（5）连接建立和释放\n- 计算机网络的**体系结构** (architecture) 是**计算机网络的各层及其协议的集合**。 \n- 体系结构就是这个计算机网络及其部件所应完成的功能的精确定义。\n- **实现** (implementation) 是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。\n- **体系结构**是**抽象**的，而**实现**则是**具体**的，是真正在运行的计算机硬件和软件。   \n\n#### 1.7.3 具有五层协议的体系结构\n\n![nFwNFA.png](https://s2.ax1x.com/2019/09/03/nFwNFA.png)\n1. 应用层：\n- 通过应用进程间的交互来完成特定网络应用\n- 应用层协议定义的是应用程序间通信和交互的规则\n- 例如：域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议\n- 我们把应用层交互的数据单元称为报文\n2. 运输层：\n- 负责向两台主机中进程之间的通信提供通用的数据传输服务\n- 两种主要协议：\n    - **传输控制协议TCP**：**面向连接**，其数据传输的单位是**报文段**\n    - **用户数据报协议UDP**：**面向无连接**，尽最大努力，数据传输的单位是**用户数据报**\n3. 网络层：\n- 负责为分组交换网上的不同主机提供通信服务\n- 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传输\n- 在TCP/IP协议中，分组称为IP数据报\n- 互联网是由大量异构网络通过路由器相互连接起来的。\n- 互联网使用的网络层协议是无连接的网络协议IP和许多种路由选择协议\n4. 数据链路层\n- 数据链路层将网络层交下来的IP数据报**组装成帧**，在两个相邻结点间的链路上传送帧。每一帧包括**数据**和必要的**控制信息**\n- 控制信息可以使接受端能检测到所接收的帧有无差错，有则丢弃。\n5. 物理层\n- 在物理层上所传输的数据的单位是比特。\n![nFw0Qf.png](https://s2.ax1x.com/2019/09/03/nFw0Qf.png)\n\n- PDU (Protocol Data Unit)：协议数据单元。\nOSI 参考模型把对等层次之间传送的数据单位称为该层的协议数据单元 PDU。\n- 任何两个同样的层次把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“对等层”(peer layers)之间的通信。\n- 各层协议实际上就是在各个对等层之间传递数据时的各项规定。\n\n#### 1.7.4 实体，协议，服务和服务访问点\n\n- **实体** (entity) 表示**任何可发送或接收信息的硬件或软件进程**。 \n- **协议**是**控制两个对等实体进行通信的规则的集合**。 \n- 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。\n- 要实现本层协议，还需要使用下层所提供的服务。 \n- 协议的实现保证了能够向上一层提供服务。\n- 本层的服务用户只能看见服务而无法看见下面的协议。即下面的协议对上面的服务用户是透明的。 \n- 协议是“水平的”，即协议是控制对等实体之间通信的规则。\n- 服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。\n- 上层使用服务原语获得下层所提供的服务。\n- 同一系统相邻两层的实体进行交互的地方，称为**服务访问点 SAP** (Service Access Point)。 \n- 服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口。\n- OSI把层与层之间交换的数据的单位称为服务数据单元 SDU (Service Data Unit)。\n- SDU 可以与 PDU 不一样，例如，可以是多个 SDU 合成为一个 PDU，也可以是一个 SDU 划分为几个 PDU。\n- 协议必须把**所有**不利的条件**事先都估计**到，而<u>不能假定一切都是正常的和非常理想的</u>。 \n- 看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，还必须非常仔细地检查这个**协议能否应付各种异常情况**。 \n\n#### 1.7.5 TCP/IP的体系结构\n- ![nFwfS0.png](https://s2.ax1x.com/2019/09/03/nFwfS0.png)\n- 另一种表示方法：\n![nFw4yT.png](https://s2.ax1x.com/2019/09/03/nFw4yT.png)\n- 还有一种表示方法：\n![nFwTw4.png](https://s2.ax1x.com/2019/09/03/nFwTw4.png)\n- TCP/IP协议可以为各式各样的应用提供服务，允许IP协议在各式各样的网络构成的互联网上运行。\n\n## 第二章 物理层\n\n### 2.1 物理层的基本概念\n\n1. 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\n2. 物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。\n用于物理层的协议也常称为物理层规程 (procedure)。\n3. 物理层的主要任务描述为确定与传输媒体的接口有关的一些特性：\n（1）机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。\n（2）电气特性：指明在接口电缆的各条线上出现的电压的范围。\n（3）功能特性：指明某条线上出现的某一电平的电压表示何种意义。\n（4）过程特性：指明对于不同功能的各种可能事件的出现顺序。 \n4. 数据在计算机内部多采用并行传输方式，但在<u>通信线路的传输方式</u>一般都是**串行传输**\n\n### 2.2 数据通信的基础知识\n\n#### 2.2.1 数据通信系统的模型\n\n1. 一个数据通信系统可以分为三个部分：\n（1）**源系统**（发送端，发送方）\n（2）**传输系统**（传输网络）\n（3）**目的系统**（接收端，接受方）\n2. 源系统包括：\n- 源点\n- 发送器\n- 接收器\n- 终点\n3. 常用术语：\n- 通信的目的是传送**消息**.\n- **数据**是运送消息的实体\n- **信号**则是数据的电气或电磁的表现\n    - 模拟信号（**连续信号**）：消息的参数的取值是连续的\n    - 数字信号（**离散信号**）：消息的参数的取值是离散的\n\n#### 2.2.2 有关信道的几个基本概念\n1. 信道：一般用来表示向<u>某一个方向</u>传送信息的媒体。\n- 单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互\n- 双向交替通信（半双工通信）：通信的双方都可以发送信息，当不能双方同时发送与接收\n- 双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息\n\n2. **基带信号**：来自信源的信号。、\n3. **调制**：为了解决许多信道不能传输这种低频分量或直流分量\n- **基带调制**：仅对基带信号的波形进行变换，使它能够与信道特性相适应。**变换后的信号仍然是基带信号**。把这种过程称为**编码** (coding)。\n- **带通调制**：使用**载波** (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并**转换为模拟信号**，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。\n- 带通信号 ：经过载波调制后的信号。\n4. 常用编码方式：\n（1）**不归零制**：正电平代表 1，负电平代表 0。\n（2）**归零制**：正脉冲代表 1，负脉冲代表 0。\n（3）**曼彻斯特编码**：位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。\n（4）**差分曼彻斯特编码**：在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。\n[![nFwbk9.png](https://s2.ax1x.com/2019/09/03/nFwbk9.png)](https://imgchr.com/i/nFwbk9)\n>- 从信号波形中可以看出，曼彻斯特 (Manchester) 编码和差分曼彻斯特编码产生的信号频率比不归零制高。\n>- 从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫作没有自同步能力），<u>而曼彻斯特编码和差分曼彻斯特编码具有**自同步能力**</u>。\n\n\n5. 基本的带通调制方法\n（1）基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行**调制** (modulation)。 \n（2）最基本的二元制调制方法有以下几种：\n- **调幅**(AM)：载波的振幅随基带数字信号而变化。 \n- **调频**(FM)：载波的频率随基带数字信号而变化。\n- **调相**(PM) ：载波的初始相位随基带数字信号而变化\n（3）正交振幅调制QAM\n\n#### 2.3 信道的极限容量\n1. 码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。 \n2. 限制码元在信道上的传输速率的因素：\n（1）信道能通过的频率范围：\n码间串扰，奈式准则\n<u>在任何信道种，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（识别）成为不可能</u>\n（2）信噪比\n信噪比 = 信号的平均功率/噪声的平均功率\n常记为 S/N，并用分贝 (dB) 作为度量单位。即：\n&nbsp;&nbsp;信噪比(dB) = 10 log10(S/N)    (dB) \n>例如，当 S/N = 10 时，信噪比为 10 dB，而当 S/N = 1000时，信噪比为 30 dB。  \n\n - 1984年，香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的**极限、无差错的**信息传输速率（**香农公式**）。\n信道的极限信息传输速率 C 可表达为：\n```\nC = W log2(1+S/N)    (bit/s) \n```\n- 其中：\tW 为信道的带宽（以 Hz 为单位）；\n\t\tS 为信道内所传信号的平均功率；\n\t\tN 为信道内部的高斯噪声功率。  \n- 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 \n- **只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输**。 \n- 若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。\n- 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。  \n- 对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法**提高信息的传输速率**。\n- 这就是：**用编码的方法让每一个码元携带更多比特的信息量**。 \n\n### 2.3 物理层下面的传输媒体\n- **传输媒体**也称为<u>传输介质或传输媒介</u>，它就是<u>数据传输系统中在发送器和接收器之间的物理通路</u>。\n- 传输媒体可分为两大类，即**导引型传输媒体**和**非导引型传输媒体**。\n- 在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。\n- 非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。\n\n#### 2.3.1 导引型传输媒体\n\n1. 双绞线：\n- 最常用的传输媒体。\n- 模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。\n- **屏蔽双绞线** STP (Shielded Twisted Pair)   \n带金属屏蔽层\n- **无屏蔽双绞线** UTP (Unshielded Twisted Pair) \n\n>室内传送数据的无屏蔽双绞线和屏蔽双绞线的标准 EIA/TIA-568。\n布线标准更新为 EIA/TIA-568-A。\n此标准规定了 5 个种类的 UTP 标准（从 1 类线到 5 类线）。\n**对传送数据来说，现在最常用的 UTP 是5类线**（Category 5 或 CAT5）。\n\n2. 同轴电缆：\n- 同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。\n- 同轴电缆的带宽取决于电缆的质量。\n- 50 Ω 同轴电缆 —— LAN / 数字传输常用\n- 75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用\n\n3. 光缆：\n- 光纤是光纤通信的传输媒体。\n- 由于可见光的频率非常高，约为 108 MHz 的量级，因此一个<u>光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽</u>。\n- 多模光纤\n- 单模光纤\n- 光线通信的优点：\n(1) 通信容量非常大。\n(2) 传输损耗小，中继距离长。\n(2) 抗雷电和电磁干扰性能好。\n(3) 无串音干扰，保密性好。\n(4) 体积小，重量轻。\n\n#### 2.3.2 非引导型传输媒体\n- 将自由空间称为“非导引型传输媒体”。\n- 无线传输所使用的频段很广。紫外线和更高的波段目前还不能用于通信\n- **短波通信**（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。\n- **微波**在空间主要是直线传播。\n- 传统微波通信有两种方式： \n    - 地面微波接力通信\n    - 卫星通信  ：通信距离远，传播时延大\n\n### 2.4 信道复用技术\n#### 2.4.1 频分复用，时分复用和统计时分复用\n- **复用** (multiplexing) 是通信技术中的基本概念。它允许用户使用一个<u>共享信道</u>进行通信，降低成本，提高利用率。\n- **频分复用**FDM：**频分复用的所有用户在同样的时间占用不同的带宽资源**（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 \n- **时分复用**：\n    - 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。\n    - 每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）。\n    - TDM 信号也称为**等时**(isochronous)信号。\n    - **时分复用的所有用户是在不同的时间占用同样的频带宽度**。\n    - 使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。\n\n- 在进行通信时，复用器和分用器成对的使用\n- **统计时分复用**STDM：（异步时分复用）\nSTDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。\n- **波分复用**WDM：波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号。\n- **码分复用**CDM：\n    - 常用的名词是**码分多址** CDMA \n    (Code Division Multiple Access)。\n    - 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。\n    - 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 \n    - 每一个比特时间划分为 m 个短的间隔，称为**码片** (chip)。\n    - 每个站被指派一个唯一的 m bit 码片序列。\n        - 如发送比特 1，则发送自己的 m bit 码片序列。\n        - 如发送比特 0，则发送该码片序列的二进制反码。 \n    - 例如，S 站的 8 bit 码片序列是 00011011。\n        - 发送比特 1 时，就发送序列 00011011，\n        - 发送比特 0 时，就发送序列 11100100。\n    - S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)\n    - 假定S站要发送信息的数据率为 b bit/s。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit/s，同时 S 站所占用的频带宽度也提高到原来数值的 m 倍。\n    - 这种通信方式是**扩频**(spread spectrum)通信中的一种。\n    - 扩频通信通常有两大类：\n        - 一种是**直接序列扩频DSSS** (Direct Sequence Spread Spectrum)，如上面讲的使用码片序列就是这一类。\n        - 另一种是**跳频扩频FHSS** (Frequency Hopping Spread Spectrum)。\n    - 每个站分配的码片序列不仅**必须各不相同**，并且还**必须互相正交** (orthogonal)。\n    - 在实用的系统中是使用**伪随机码序列**。 \n    - 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量。 \n    - 两个不同站的码片序列正交，就是向量 S 和T 的**规格化内积** (inner product) 等于 0：\n    - <u>任何一个码片向量和该码片向量自己的规格化内积都是 1 </u>。\n    - <u>一个码片向量和该码片反码的向量的规格化内积值是 –1。 </u>\n    \n\n### 2.5 数字传输系统\n- 与模拟通信相比，数字通信无论是在传输质量上还是经济上都有明显的优势\n- 目前，长途干线大都采用PCM是数字传输方式\n- 脉码调制PCM体制，最初是为了在电话局之间的中继线上传送多路的电话\n- 由于历史原因PCM有两个不兼容的国际标准：T1，E1\n- 当需要有更高的数据率时，可以采用复用的方法\n- 旧的数字传输系统存在许多缺点:\n(1)速率标准不统一\n(2)不是同步传输\n- <u>同步光纤网</u>SONET的各级时钟都来自一个非常精确的主时钟\n- <u>同步数字系列</u>SDH，适用于微波和卫星传输\n\n### 2.6 宽带接入技术\n- 用户要接入互联网，必须先连接到某个ISP\n- 美国联邦通信委员会FCC认为只要双向速率之和超过200 kbit/s就是**宽带**\n- 从宽带接入的媒体来看，可以划分为两大类：\n    - 有线宽带接入\n    - 无线宽带接入 \n\n#### 2.6.1 ADSL技术\n- **非对称数字用户线ADSL**：用数字技术对现有的模拟电话用户线进行改造\n- ADSL技术就是把0~4 kHz<u>低端频谱给传统电话使用</u>，而把**原来没有被利用的高端频谱留给用户上网使用**\n- DSL就是**数字用户线**\n- ADSL的传输距离取决于数据率和用户线的途径\n- ADSL所得到的最高数据传输速率与实际的用户线上的信噪比密切相关\n- ADSL的特点：\n    - 上行（用户到ISP）和下行（ISP到用户）带宽不对称\n    - ADSL在用户线的两端各安装一个ADSL调制解调器\n    - 我国目前采用的方案是离散多音调DMT调制技术\n        - 多音调：指多载波/多子信道\n        - DMT技术：\n            - 采用频分复用\n            - 相当于在一对用户线上使用许多小的调制解调器并行的传送数据。\n- ADSL的数据率：\n    - ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率\n    - ADSL不能保证固定的数据率\n- 第二代ADSL：\n    - 通过提高调制效率得到更高的数据率\n    - 采用无缝速率自适应技术\n\n#### 2.6.2 光线同轴混合网\n- HFC网是在目前覆盖面很广的有线电视网CATV基础上开发的一种居民宽带接入网\n- HFC网对CATV网进行了改造\n- HFC网将原CATV网中的同轴电缆**主干部分该换为光纤**，并使用模拟光纤技术\n- 在模拟光纤中采用光的振幅AM\n- 模拟光纤从头端连接到光纤结点，即光分配结点ODN\n- HFC网采用**结点体系**\n- HFC网具有双向传输功能，扩展了传输频带\n- 用户接口盒UIB要提供三种连接：\n    - 使用同轴电缆连接到机顶盒，然后再连接到用户的电视机\n    - 使用双绞线连接到用户的电话机\n    - 使用电缆调制解调器来连接到用户的计算机\n       -  电缆调制解调器是为HFC网而使用的调制解调器\n\n#### 2.6.3 FTTx技术\n\n- FTTx是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式\n\n## 第三章 数据链路层\n- 数据链路层使用的信道主要有以下两种类型：\n    - 点对点信道====》 一对一\n    - 广播信道====》一对多，采用专用的共享信道协议\n- 路由器只包含网络层，链路层，物理层\n- 不同链路层可能采用不同的数据链路层协议\n\n### 3.1 使用点对点信道的数据链路层\n\n#### 3.1.1 数据链路和帧\n\n- **链路**（物理链路）：一条无源的点到点的物理线路段，中间没有任何其他的交换结点\n- 一条链路只是一条通路的一个组成部分\n- **数据链路**（逻辑链路）：除了**物理线路**外，还必须有**通信协议**软件来控制这些数据的传输。若是把实现这些协议的硬件和软件加到链路上，就构成了数据链路。\n   - 最常用的方法是使用**网络适配器**（即网卡）来实现这些协议的硬件和软件。\n   - 一般适配器都包括了数据链路层和物理层这两方面的功能\n- 早期的数据通信协议就做通信**规程**，在数据链路层中，规程和协议是同义语。\n- **帧**-数据链路层的协议数据单元\n- **IP数据报**：网络层的协议数据单元\n- 数据链路层不必考虑物理层如何实现比特传输的细节，只考虑数据的封装等\n\n#### 3.1.2 三个基本问题\n\n1. **封装成帧**：\n- 封装成帧就是在一段数据的前后分别添加首部和尾部；\n- 首部和尾部的一个重要作用就是**帧定界**\n- 每一种链路层协议都规定了所能传送的帧的**数据部分长度上限---最大传送单元MTU**\n- 当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的**帧定界符**。\n- 控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。\n\n2. **透明传输**：\n- 如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。\n- 解决方法：**字节填充** (byte stuffing) 或**字符填充** (character stuffing)。\n- 发送端的数据链路层在**数据中**出现控制字符“SOH”或“EOT”的**前面插入一个转义字符“ESC”** (其十六进制编码是 1B)。\n- 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。\n- 如果转义字符也出现在**数据当中**，那么应在**转义字符前面插入一个转义字符 ESC**。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 \n\n3. **差错检验**：\n- 在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。\n- 在一段时间内，传输错误的比特占所传输比特总数的比率称为**误码率** BER (Bit Error Rate)。\n误码率与信噪比有很大的关系。\n- 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 \n- 循环冗余检验：\n    - 在发送端，先把数据划分为组。假定每组 k 个比特。 \n    - 假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位**冗余码**一起发送。  \n    - 冗余码的计算：\n        - 用二进制的模 2 运算进行 2^n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。\n        - 得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。 \n        - 将余数 R 作为冗余码拼接在数据 M 后面发送出去。\n        >- 冗余码的计算举例:\n        >现在 k = 6, M = 101001。\n    设 n = 3, 除数 P = 1101，\n    被除数是 2^n\\*M = 101001000。 \n    模 2 运算的结果是：商 Q = 110101，\n               余数 R = 001。\n    把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2^n\\*M + R \n       即：101001001，共 (k + n) 位。 \n- 在数据后面添加上的冗余码称为**帧检验序列FCS**\n- CRC是一种常用的检错方法，FCS是添加在数据后面的冗余码\n- FCS可以用CRC这种方法得出，但是CRC并非用来获得FCS的唯一方法\n- 检验结果：\n(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。\n(2) 若余数 R ≠ 0，则判定这个帧有差错，就丢弃。\n- 但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。\n- 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的**概率**就很小很小。 \n- 注意：\n    - 仅用循环冗余检验 CRC 差错检测技术只能做到**无差错接受** (accept)。\n    - “**无差错接受**”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。\n    - 也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。\n    - **要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制**。  \n    - 应当明确，“**无比特差错**”与“**无传输差错**”是不同的概念。\n- 在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。\n- 本章介绍的数据链路层协议都**不是可靠传输**的协议。\n\n### 3.2 点对点协议PPP\n- 数据链路层能实现可靠传输的高级数据链路控制HDLC\n- 目前使用得最广泛的数据链路层协议：点对点协议PPP\n\n### 3.2.1 PPP协议的特点\n\n1. PPP协议应满足的需求：\n（1）**简单**：**首要需求**，提高互操作性\n（2）**封装成帧**：规定特殊的字符作为**帧定界符**\n（3）**透明性**：必须保证数据传输的透明性\n（4）**多种网络层协议**：**在同一条物理链路上同时支持多种网络层协议**\n（5）**多种类型链路**：\n（6）**差错检验**：检测并丢弃有差错的帧\n（7）**检测连接状态**：\n（8）**最大传送单元**：MTU是数据链路层的帧可以载荷的**数据部分**的最大长度，而**不是帧的总长度**\n（9）**网络层地址协商**：\n（10）**数据压缩协商**：\n2. PPP协议不需要的功能：\n（1）纠错：因为可靠传输由运输层的TCP协议负责\n（2）流量控制\n（3）序号\n（4）多点线路：因为PPP只支持点对点的链路通信\n（5）半双工或单双工：因为PPP只支持全双工链路\n3. PPP协议的组成：\n（1）一个将IP数据报封装到串行链路的方法\n（2）链路控制协议LCP：用来建立，配置，和测试数据链路的连接\n（3）网络控制协议NCP：\n\n#### 3.2.2 PPP协议的帧格式\n\n1. 各字段的意义：\n\n- ppp帧的首部和尾部分别为4个字段和2个字段\n- 标志字段F规定为0x7E（即01111110），标志一个帧的开始和结束\n- 地址字段A规定为0xFF（即111111）\n- 控制字段C规定为0x03（即00000011）\n- 协议字段，两个字节\n \n2. 字节填充 \n- **PPP是面向字节的，所有的PPP帧的长度都是整数字节**\n- 透明传输问题：\n    - PPP用在同步传输链路时，协议规定采用硬件来完成**比特填充**\n    - 当PPP用在异步传输时，就使用一种特殊的**字符填充法**\n    - 把转义字符定义为0x7D（即011111101）\n    - PPP协议用在SONET/SDH链路时，使用同步传输，这时PPP协议采用**零比特填充**方法实现透明传输\n3. 零比特填充\n- 只要发现有5个连续的1，则立即填入一个0，因此经过这种填充后的数据不会出现六个连续的1.（因为几个特殊字段内有111111）\n\n#### 3.2.3 PPP协议的工作状态\n\n- PPP协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。\n- 链路静止状态\n- 链路建立状态\n- 链路打开状态\n- 链路终止状态\n\n### 3.3 使用广播信道的数据链路层\n\n#### 3.3.1 局域网的数据链路层\n\n- 局域网最主要的**特点**是：\n    - 网络为一个单位所拥有；\n    - 地理范围和站点数目均有限。 \n- 局域网具有如下主要**优点**：\n    - 具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 \n    - 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。\n    - 提高了系统的可靠性、可用性和残存性。\n- 局域网按拓扑结构分类：\n    - 星型网，集线器\n    - 总线网，匹配电阻\n    - 环形网，干线耦合器\n- 局域网中的主要传输媒体： 双绞线\n- 当数据率很高时，往往需要使用光纤作为传输媒体\n- 媒体共享技术：\n    - 静态划分信道：频分复用，时分复用，波分复用，码分复用\n    - 动态媒体接入控制（多点接入）：\n        - 随机接入:所有用户可随机地发送信息。但是同一时刻发送信息，会产生碰撞（冲突），故需要解决碰撞的网络协议。\n        - 受控接入：用户不能随机发送信息，必须服从一定控制：如多点线路探询，轮询。\n1. 以太网的两个标准：\n- DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。\n- IEEE 802.3 是第一个 IEEE 的以太网标准。\n- IEEE 802 委员会就将局域网的数据链路层拆成两个子层：\n    - 逻辑链路控制 LLC (Logical Link Control)子层；\n    - 媒体接入控制 MAC (Medium Access Control)子层。\n- 与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。\n- **不管采用何种协议的局域网，对 LLC 子层来说都是透明的**。\n\n2. 适配器的作用：\n- 网络接口板又称为**通信适配器** (adapter) 或**网络接口卡** NIC (Network Interface Card)，或“**网卡**”。 \n- 适配器的重要功能：\n    - 进行串行/并行转换。\n    - 对数据进行缓存。\n    - 在计算机的操作系统安装设备驱动程序。\n    - 实现以太网协议。  \n- 适配器在接受和发送各种帧时，不适用计算机的CPU。当收到有差错的帧时，**直接丢弃**而不必通知计算机。当收到正确的帧时，使用**中断**来通知计算机，并交付协议栈中的网络层 。\n当计算机要发送IP数据报时，，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网\n\n#### 3.3.2 CSMA/CD协议\n\n- 总线的特点：当一台计算机发送数据时，总线上所有的计算机都能检测到这个数据\n- 为了在总线上实现一对一的通信，可以使适配器拥有一个独一无二的地址\n- 为了通信简便，以太网采用：\n    - 采用较为灵活的无连接的工作方式 \n        - 不必先建立连接就可以直接发送数据。\n        - 对发送的数据帧不进行编号，也不要求对方发回确认。\n        - 这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。 \n        - 以太网提供的服务是**不可靠的交付**，即**尽最大努力的交付**。\n        - 当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。**差错的纠正由高层来决定。**\n        - 如果高层发现丢失了一些数据而进行重传，但**以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送**。  \n\n    - 以太网发送的数据都**使用曼切斯特**编码：\n        - 缺点：占用的频带宽度比原始的基带信号增加了一倍\n        - CSMA/CD协议：\n            - CSMA/CD 含义：**载波监听多点接入 / 碰撞检测**  (Carrier Sense Multiple Access with Collision Detection) 。\n            - “**多点接入**”表示许多计算机以多点接入的方式连接在一根总线上。\n            - “**载波监听**”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 \n            - “**碰撞检测**”是指边发送边监听\n            - 总线上并没有什么“载波”。因此， **“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号**。\n            - 检测到碰撞后 ： 每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要**立即停止发送**，免得继续浪费网络资源，然后**等待一段随机时间**后再次发送。\n            - 由于电磁波在总线上的传播速率是有限的，当某个站监听到总线是空闲时，也可能总线并非真正是空闲的所以需要在发送期间进行碰撞检测，以检测冲突。  \n- 在使用CSMA/CD协议时，一个站不可能同时进行发送和接收（但必须边发送边监听信道）\n- 因此CSMA/CD协议不可能进行全双工通信只能进行双向交替通信（**半双工通信**）\n- 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 \n- 这种**发送的不确定性**使整个以太网的平均通信量远小于以太网的最高数据率。 \n- 最先发送数据帧的站，在发送数据帧后**至多**经过时间**2τ （两倍的端到端往返时延）** 就可知道发送的数据帧是否遭受了碰撞。\n- 以太网的端到端往返时延 2τ 称为**争用期**，或**碰撞窗口**。\n- **经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞**。\n- 二进制指数型退避算法：\n    - 发生碰撞的站在停止发送数据后，要推迟（退避）一个**随机时间**才能再发送数据。\n    - 基本退避时间取为争用期 2τ。\n    - 从整数集合 [0, 1, … , (2k-1)] 中**随机**地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。\n    - 参数 k 按下面的公式计算：\n                 **k = Min[重传次数, 10]**\n    - 当 k ≤ 10 时，参数 k 等于重传次数。\n    - 当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。\n    - 以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。**最短有效帧长为 64 字节**\n- 强化碰撞：当发送数据的站一旦发现发生了碰撞时：\n(1) 立即停止发送数据；\n(2) 再继续发送若干比特的**人为干扰信号**以便让所有用户都知道现在已经发生了碰撞。  \n- CSMA/CD协议的要点：\n（1）准备发送\n（2）检测信道\n（3）检查碰撞\n\n#### 3.3.3 使用集线器的星形拓扑\n\n- 特点：\n- （1）使用集线器的以太网在**逻辑上仍是一个总线网**，各站**共享逻辑上的总线**，各适配器使用的还是CSMA/CD协议，并且同一时刻只允许一个站发送数据\n- （2）一个集线器很像一个多接口的转发器\n- （3）**集线器工作在物理层**，它的每一个接口仅仅简单地转发比特，不进行碰撞检测\n- （4）采用专门的芯片\n\n#### 3.3.4 以太网的信道利用率\n\n - 要提高以太网的信道利用率，就必须减少τ与T0之比，在以太网中定义了参数a，它是以太网**单程端到端时延τ**与**帧的发送时间T0**：\n a=τ/T0；\n - α →0，表示一发生碰撞就立即可以检测出来， 并立即停止发送，因而信道利用率很高。\n- **α 越大，表明争用期所占的比例增大**，每发生一次碰撞就浪费许多信道资源，**使得信道利用率明显降低**。 \n- 为提高利用率，以太网的参数a的值应当尽可能小些。\n- 对以太网参数 α 的要求是：\n    - 当数据率一定时，以太网的连线的长度受到限制，否则 τ 的数值会太大。\n    - 以太网的帧长不能太短，否则 T0 的值会太小，使 α 值太大。 \n    - 只有当参数 a 远小于 1 才能得到尽可能高的极限信道利用率。\n- **理想情况下的极限信道利用率**Smax为：\nSmax=T0/（T0+τ）=1/（1+a）\n\n#### 3.3.5 以太网的MAC的层\n\n1. MAC层的硬件地址：\n- 在局域网中，**硬件地址**又称为**物理地址**，或**MAC 地址**。 \n- IEEE 802标准为局域网规定了一种48位的全球地址，是指局域网上的每一台计算机中**固化在适配器的ROM中的地址**\n- IEEE的RA是局域网全球地址的法定管理结构，它负责分配地址字段的6个字节的前三个字节。生产局域网适配器的厂家需要向IEEE购买由这三个字节构成的组织唯一标识符OUI\n- 厂家自行指派后三个字节，称为扩展标识符，用这种方法得到的48位地址称为EUI-48\n- IEEE 规定地址字段的第一字节的最低位为I/G位：I/G位为0时，地址段表示单个站地址；I/G位为1时表示组地址，用来多播\n- IEEE规定地址字段第一字节的最低第二位为G/L位：G/L位为0时是全球管理，为1时是本地管理\n- 适配器由**过滤功能**，从网络上每收到一个MAC帧就先用硬件检查MAC帧中的目的地址。\n- 发往本站的帧：单播帧，广播帧，多播帧\n- 所有的适配器都至少能够识别前两种帧，即能够识别单播地址和广播地址。\n- 有的适配器可用编程方法识别多播地址。\n- 只有目的地址才能使用广播地址和多播地址。\n- 以**混杂方式** (promiscuous mode) 工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来。\n\n2. MAC帧的格式\n- 最常用的MAC帧是以太网V2格式\n- 最后一字段是4字节的帧检验序列FCS（使用CRC检验）\n- 无效的MAC帧：\n    - 长度不是整数个字节\n    - 收到的FCS帧检验序列查出错误\n    - 数据位置错误\n\n\n### 3.4 扩展的以太网\n\n#### 3.4.1 在物理层扩展以太网\n\n1. 使用光纤扩展\n2. 使用集线器扩展（碰撞域）\n- 优点\n（1）使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。\n（2）扩大了以太网覆盖的地理范围。\n- 缺点\n（1）碰撞域增大了，但总的吞吐量并未提高。\n（2）如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。   \n\n#### 3.4.2 在数据链路层扩展以太网\n\n- 早期使用**网桥**，现在使用以太网**交换机**\n1. 以太网交换机的特点\n- 实质上是一个多接口网桥\n- 工作在全双工方式\n- 相互通信的主机都是独占传输媒体，无碰撞地传输数据\n    - 具有并行性，能使多对主机同时通信\n- 许多以太网交换机对收到的帧采用存储转发方式进行转发，但是也有一些交换机采用直通的交换方式\n\n2. 以太网交换机的自学习功能\n- 即插即用，帧交换表\n\n3. 从总线以太网到星形以太网\n-  仍然采用以太网的帧结构\n\n#### 3.4.3 虚拟局域网\n\n-  **虚拟局域网 VLAN** 是由一些局域网网段构成的与**物理位置无关的逻辑组**，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。\n- **虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。**\n\n### 3.5 高速以太网\n\n#### 3.5.1  100BASE-T 以太网\n\n- 速率达到或超过100Mbit/s的以太网称为高速以太网\n- 100BASE-T以太网又叫快速以太网\n- 可在全双工方式下工作而无冲突发生\n\n#### 3.5.2  吉比特以太网\n\n- 在半双工方式下使用 CSMA/CD 协议，全双工方式不使用 CSMA/CD 协议。\n- 载波延伸\n- 分组突发\n\n#### 3.5.3  10吉比特以太网 (10GE) 和更快的以太网\n- 只工作在全双工方式\n\n#### 3.5.4  使用以太网进行宽带接入\n- 可以提供双向的宽带通信。\n- 可以根据用户对带宽的需求灵活地进行带宽升级。\n- 可以实现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率且降低了传输的成本。\n- 但是不支持用户身份鉴别。\n\n## 第四章 网络层\n\n### 4.1 网络层提供的两种服务\n\n- **面向连接**还是**无连接**\n- 互联网采用的设计思路是这样的：**网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务**。\n- **网络层不提供服务质量的承诺**\n- 通信之前先建立**虚电路**，以保证双方通信所需的一切网络资源。\n- 虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送\n\n### 4.2 网际协议IP\n\n- 与IP协议配套使用的三个协议：\n    - 地址解析协议ARP\n    - 网际控制协议ICMP\n    - 网际组管理协议IGMP\n- 由于网际协议IP是用来使互连起来的许多计算机网络能够进行通信的，因此TCP/IP体系中的网络层常常被称为网际层或IP层\n\n\n#### 4.2.1 虚拟互连网络\n\n- 没有一种单一的网络能够适应所有用户的需求\n- 将网络互相连接起来要使用一些中间设备：\n    - 物理层中继系统：**转发器** (repeater)。\n    - 数据链路层中继系统：**网桥** 或 **桥接器** (bridge)。\n    - 网络层中继系统：**路由器** (router)。\n    - 网桥和路由器的混合物：**桥路器** (brouter)。\n    - 网络层以上的中继系统：**网关** (gateway)。  \n- 网络互连都是指用路由器进行网络互连和路由选择。\n- 由于历史的原因，许多有关 TCP/IP 的文献将网络层使用的路由器称为网关。\n- 所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。\n- 使用 IP 协议的虚拟互连网络可简称为 IP 网。\n- 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。\n- 如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网 (Internet)。\n- 互联网可以由多种异构网络互连组成\n\n#### 4.2.2 分类的IP地址\n1. IP地址及其表示方法：\n- 整个互联网就是一个**单一的，抽象的网络**。IP地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个全世界范围内是唯一的32位的标识符\n- IP地址现在由**互联网名字和数字分配机构ICANN**进行分配\n- IP地址的编制方法经过三个历史阶段：\n（1）分类的IP地址\n（2）子网的划分\n（3）构成超网\n- 分类的IP地址：就是将IP地址划分位若干个固定类。\n- A，B，C类地址都是由两个固定长度的字段组成，其中第一个字段是网络号，是唯一的。第二个字段是主机号，在当前网络范围内是唯一的\n- 由此可见，一个IP地址在整个互联网范围内是唯一的\n- A，B，C类是单播地址，D类地址用于多播，E类地址保留\n- 点分十进制记法\n2. 常用的三种类别的IP地址\n- A类地址，**网络号**全0表示本网络，全1表示本地软件环回测试\n- A类地址，**主机号**全0表示本主机连接的单个网络地址，全1表示该网络上所有的主机\n- 一般不用的特殊的IP \n-IP地址的特点：\n（1）IP是分等级的地址结构，IP地址管理机构**只分配网络号，主机号由得到网络号的单位自行分配，路由器仅根据目的主机网络号来转发分组**，减小了路由表所占的存储空间以及查找路由表的时间\n（2）IP地址标志一台主机和一条链路的**接口**，当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须不同。这种主机也叫做**多归属主机**\n（3）一个网络时指具有相同网络号net-id的主机的集合，故，**用转发器或网桥连接起来的若干局域网仍是一个网络**。具有不同网络号的局域网必须用路由器进行互连\n（4）在IP地址中，所有分配到网络号的网络都是平等的\n- 当两个路由器直接相连时，为了节省IP地址资源，常常不给这段连线分配IP地址，通常把这段特殊的网络叫做无编号网络或无名网络\n#### 4.2.3 IP地址与硬件地址\n- 区分IP地址与硬件地址：从层次上来看，**物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址**。\n- 在发送数据时，数据从高层向下到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了。MAC帧在传送时使用的源地址和目的地址都是硬件地址，这两个地址都写在MAC帧的头部。连接在通信链路上的设备在收到MAC帧时，根据MAC帧首部的硬件地址决定抛弃与否，只有在剥去MAC帧的首部和尾部后把MAC层的数据上交给网络层后，网络层才能在IP数据报的首部找到源IP地址和目的IP地址\n- 注意：\n（1）在IP层抽象的互联网上只能看到IP数据报\n（2）路由器只根据目的站的IP地址的网络号进行路由选择\n（3）在局域网的链路层，只能看见MAC帧\n（4）IP层抽象的互联网频闭下层这些很复杂的细节。\n\n#### 4.2.4 地址解析协议ARP\n- ARP常被划分为网络层的协议\n- ARP协议的用途：为了从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。\n- **地址解析协议ARP**解决这个问题的方法是在主机**ARP高速缓存**中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新\n- 当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存查看有无主机B的IP地址。如果有，查出硬件地址并写入MAC帧，如果没有，（1）ARP在本局域网广播发送一个ARP请求分组（2）在本局域网的所有主机上运行的ARP进程都收到了请求分组（3）主机B的IP地址与请求分组中要查询的IP地址一致，收下这个请求分组，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的硬件地址（4）主机A收到主机B的ARP分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射\n- 每一个映射地址项目都设置生存时间\n- ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题\n- 从IP地址到硬件地址的解析是自动进行的，**主机的用户对这种地址解析过程是不知道的**\n\n#### 4.2.5 IP数据报的格式\n1. IP数据报首部的固定部分中的各字段\n（1）版本\n（2）首部长度\n（3）区分服务\n（4）总长度：指首部和数据之和的长度\n（5）标识\n（6）标志：占3位，最低位MF；中间位DF\n（7）片偏移\n（8）生存时间TTL：跳数限制\n（9）协议\n（10）首部检验和：只检验数据报的首部，但不包括数据部分\n（11）源地址\n（12）目的地址\n\n2. IP层转发分组的流程\n- 在互联网上转发分组时，是从一个路由器转发到下一个路由器\n- 在路由表中，对每一条路由最主要的是以下两个信息：**目的网络地址，下一跳地址**。\n- 虽然互联网所有的分组转发都是**基于目的主机所在的网络**，但是存在着对特定的目的主机指明一个路由。这种路由叫做**特定主机路由**。\n- 默认路由：减小路由表所占用的空间和搜索路由表所用的时间\n- 分组转发算法：\n    - （1）从数据报首部提取目的主机IP地址D，得到目的网络N\n    - （2）若N就是与此路由器直接相连的某个网络地址，则进行直接交付，否则，间接交付\n    - （3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给下一跳路由器，若无则（4）\n    - （4）若路由器有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳，否则（5）\n    - （5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器，否者（6）\n    - （6）报告转发分组失败\n\n### 4.3 划分子网和构造超网\n#### 4.3.1 划分子网\n1. 从两级IP地址到三级IP地址\n- IP地址设计不合理：\n（1）IP地址空间的**利用率有时很低**\n（2）给每个物理网络分配一个网络号会**使路由表变得太大**\n（3）两级IP地址不够灵活\n- 为了解决上诉问题，IP地址中又增加了“子网号字段”，使两级地址变成三级地址----这种做法也叫划分子网或子网寻址或子网路由选择\n- 划分子网的基本思路：\n（1）一个拥有许多物理网络的单位，可将所属的物理网络划分为若干各子网。划分子网纯属一个单位内部的事情。本网络以外的网络看不见这个网络是由多少各子网组成，因为其对外仍然表现为一个网络\n（2）划分子网的方法是从网络的**主机号**借用若干位作为**子网号**，当然主机号也就减少了同样的位数，于是两级IP地址在本单位内就变成了三级IP地址，网络号，子网号和主机号\n（3）凡是从其他网络发送来的IP数据报，仍是根据目的网络号找到路由器，此路由器收到IP数据报后，再按照目的网络号和子网号找到目的子网，把IP数据报交付目的主机\n2. 子网掩码\n- 从IP数据报的首部无法看出源主机或目的主机多连接的网络是否进行了子网的划分。因此使用子网掩码。\n- 将子网掩码与收到的数据报的目的IP地址**逐位相与**，得到子网的网络地址\n- 再路由器的路由表中也必须有子网掩码，如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码\n- 子网掩码是一个网络或一个子网的重要属性\n- 划分子网增加了灵活性，但却减少了能够连接在网络上的主机总机数\n- 相同的IP地址和不同的子网掩码可以得到相同的网络地址\n\n#### 4.3.2 使用子网时分组的转发\n- 路由表中必须包含：目的网络四肢，子网掩码，下一跳地址\n- 划分子网的情况下，路由器转发分组的算法:\n（1）从收到的IP数据报的首部提取目的IP地址D\n（2）先判断是否为直接交付，否则执行（3）\n（3）若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由器中所指明的下一跳路由器，否则执行（4）\n（4）对路由表中的每一行，用其中的子网码和D逐位相“与”，其结果为N。若N与该行的目的地址匹配，则把数据报传送给该行指明的下一跳路由器；否则执行（5）\n（5）若路由器中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则执行（6）\n（6）报告转发分组出错\n\n#### 4.3.3 无分类编址CIDR（构造超网）\n1. 网络前缀\n- IPv4地址空间不够，IPv6出现\n- 使用变长子网掩码VLSM\n- 无分类域间路由选择CIDR：\n（1）消除了传统的ABC类地址以及划分子网的概念，更能有效的分配地址空间。CIDR将地址空间分为前后两部分，前部分是网络前缀，用来指明网络，后面部分指明主机。CIDR使用斜线记法，在IP地址后面加一斜线，后面写网络前缀所占的位数\n（2）CIDR把网络前缀都相同的连续的IP地址组成一个“CIDR地址块”，CIDR使用32为的地址掩码，例如：/20地址块的地址掩码是：11111111 11111111 11110000 0000000（即斜线后的数字是地址掩码中1的个数）\n- 由于CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。这种地址的聚合常称为路由聚合。\n- 除个别外，每一个CIDR地址块都包含了多个c类地址，这就是构成超网\n- 网络前缀越短，其地址块中包含的地址数就越多\n\n2. 最长前缀匹配\n- 在查找路由表时，应当从匹配结果中选择出具有最长网络前缀的路由。\n3. 使用二叉线索查找路由表\n\n### 4.4网际控制报文协议ICMP\n - 为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP\n - ICMP允许主机或路由器报告差错情况和提供异常情况的报告\n\n#### 4.4.1 ICMP报文的种类\n- ICMP报文有两种，即ICMP差错报告报文，ICMP询问报文\n- ICMP差错报告报文的类型：\n（1）终点不可达\n（2）时间超过\n（3）参数问题\n（4）改变路由（重定向）\n- ICMP询问报文的类型：\n（1）回送请求和回答\n（2）时间戳请求和回答\n\n#### 4.4.2 ICMP的应用举例\n- ICMP的一个重要应用就是分组间探测PING，用来测试两台主机之间的连通性\n- ping使用了ICMP回送请求与回送回答报文\n- traceroute/tracert\n\n### 4.5 互联网的路由选择协议\n\n#### 4.5.1 有关路由选择协议的几个基本概念\n1. 理想的路由算法\n（1）算法必须是正确的和完整的\n（2）算法在计算上应简单\n（3）算法应能适应通信量和网络拓扑的变化\n（4）算法应具有稳定性\n（5）算法应是公平的\n（6）算法应是最佳的\n\n- 从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即静态路由选择策略（非自适应路由选择）和动态路由选择策略（自适应路由选择）。\n\n2. 分层次的路由选择协议\n- 互联网采用的路由选择协议主要是自适应，分布式路由选择协议\n- 自治系统AS：在单一技术管理下的一组路由器，这些路由器使用一种自治系统内部的路由选择协议和共同的度量。\n- 一个AS对其他的AS表现出的是一个单一的和一致的路由选择策略\n- 互联网把路由选择协议划分为两大类：\n    - 内部网关协议IGP（AS内部）：包括RIP，OSPF\n    - 外部网关协议EGP（AS之间）：例如：BGP\n\n#### 4.5.2 内部网关协议RIP\n1. 工作原理：\n- RIP是一种分布式的**基于距离向量的路由选择协议**\n- RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一各目的网络的**距离记录**：\n    - 从一路由器到直接连接的网络的距离定义为1\n    - 从一路由器到非直接连接的网络的距离定义为所经过的路由器数加1\n    - RIP协议的“距离”也称为“跳数”，只适用于小型的互联网\n- RIP协议的特点：\n（1）仅和相邻路由器交换信息\n（2）路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表\n（3）按固定的时间间隔交换路由信息\n- 路由器再刚刚开始工作时，它的路由表是空的，然后路由器就得出到直接相连的几个网络的距离。接着每一个路由器也之和数目非常有限的相邻路由器交换，并更新路由信息\n- “收敛”：在自治系统中所有的结点都得到正确的路由选择信息的过程\n- 路由表更新的言责是找出到每一个目的网络的最短距离。这种更新算法又称为距离向量算法。\n2. 距离向量算法\n路由器收到相邻路由器（其地址为 X）的一个 RIP 报文：\n(1) 先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。\n(2) 对修改后的 RIP 报文中的每一个项目，重复以下步骤：\n     若项目中的目的网络不在路由表中，则把该项目加到路由表中。\n         否则\n             若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。\n                否则 \n                    若收到项目中的距离小于路由表中的距离，则进行更新，\n              否则，什么也不做。\n(3) 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为 16（表示不可达）。\n(4) 返回。\n\n3. RIP协议的报文格式\n- RIP协议使用运输层的用户数据报UDP进行传送\n- RIP报文由**首部**和**路由**部分组成\n- 问题：**当网络出现故障时，要经过比较长度的时间才能将此信息传送到所有的路由器**\n- 特点：好消息传播的快，坏消息传播的慢\n- 优点：是实现简单，开销较小\n\n#### 4.5.3 内部网关协议OSPF\n1. OSPF协议的基本特点：\n- 开放最短路径优先OSPF：使用了Dijkstra提出的最短路径算法SPF\n- OSPF只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”\n- OSPF最主要的特征是使用分布式的**链路状态协议**\n（1）向本自治系统中所有路由器发送信息，洪泛法（RIP只相自己相邻的路由器发送信息）\n（2）发送的信息就是与本路由器相邻的所有路由器的**链路状态**（与哪些路由器相邻+度量）\n（3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息\n\n- 所有的路由器最终都能建立一个**链路状态数据库**，这个数据库实际上就是**全网的拓扑结构图**，这个拓扑结构图在全网范围内是一致的（链路状态数据库的同步）\n- OSPF的更新过程收敛快----优点\n- OSPF将一个自治系统划分为若干个**区域**\n- 主干区域，区域边界路由器（R3，R4，R7），主干路由器（R3，R4，R5，R6，R7），自治系统边界路由器（R6）\n- OSPF不用UDP而是直接用IP数据报传送\n- OSPF首部各字段意义：\n（1）版本\n（2）类型\n（3）分组长度\n（4）路由器标识符\n（5）区域标识符\n（6）检验和\n（7）鉴别类型\n（8）鉴别\n- OSPF的特点：\n（1）OSPF对于不同类型的业务看计算出不同的路由\n（2）负载平衡\n（3）鉴别\n（4）OSPF支持CIDR\n（5）OSPF让每一个链路状态带上序号，序号越大，状态越新\n\n2. OSPF的五种分组类型\n（1）类型1，问候 (Hello) 分组。\n（2）类型2，数据库描述 (Database Description) 分组。\n（3）类型3，链路状态请求 (Link State Request) 分组。\n（4）类型4，链路状态更新 (Link State Update) 分组，\n                用洪泛法对全网更新链路状态。\n（5）类型5，链路状态确认 (Link State Acknowledgment)\n                 分组。 \n- OSPF采用的是可靠的洪泛法（收到更新分组后要发送确认）\n- OSPF每隔一段时间要刷新一次数据库中的链路状态\n- OSPF协议对多点接入的局域网采用了**指定的路由器**的方法\n\n#### 4.5.4 外部网关协议BGP\n- 内部网关协议主要是设法使数据报在**一个AS中**尽可能有效地从源站传送到目的站\n- 使用BGP的原因：\n（1）**互联网的规模太大，使得自治系统AS之间路由选择非常困难**\n（2）**自治系统AS之间的路由选择必须考虑有关策略**\n- 边界网关协议BGP只能是力求寻找一条能够到达目的网络且**比较好**的路由，而**并非要寻找一条最佳路由**\n- BGP采用了**路径向量路由选择协议**\n- BGP发言人与其他AS的BGP发言人要交换路由信息，就要先建立TCP连接，然后在此连接上交换BGP报文以建立**BGP会话**，利用BGP会话交换路由信息。\n- 使用TCP连接交换路由信息的两个BGP发言人彼此成为对方发邻站或对等站\n- BGP报文：OPEN，UPDATE，KEEPALIVE，NOTIFICATION\n\n#### 4.5.5 路由器的构成\n1. 路由器的结构\n- 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组，按照分组要去的目的地，从合适的端口转发给下一跳路由器。\n- 路由器的转发分组正是网络层的主要工作\n- 路由器结构划分为两大部分：\n（1）**路由选择部分**：控制部分，核心构件是路由选择处理机，任务：①根据路由选择协议构造路由表②不断更新和维护路由表\n（2）**分组转发部分**：由三部分组成：交换结构，一组输入端口，一组输出端口，\n\n- 路由器的作用： 连接不同的网络\n2. 交换结构\n- 也叫（交换组织），作用：根据**转发表**对分组进行处理，从合适的端口转发出去。\n- 路由表是根据路由选择算法得出，而转发表是从路由表得出的\n- 输入端口中的查找和转发功能在路由器的交换功能中是最重要的。\n- 路由器的端口收到分组时，就用中断方式通知路由选择处理机\n- 路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。\n- 通过存储器\n- 通过总线\n- 通过纵横交换结构\n\n### 4.6 IPv6\n\n- 双栈协议：IPv4向IPv6过渡\n- 隧道技术\n\n#### 4.6.1 IPv6的基本首部\n- 变化：\n（1）更大的地址空间，128位\n（2）扩展的地址层次结构\n（3）灵活的首部格式\n（4）改进的选项\n（5）允许协议继续扩充\n（6）支持即插即用\n（7）支持资源的预分配\n（8）IPv6首部改为8字节对齐\n- IPv6数据报由两大部分组成：基本首部和有效载荷（净负荷）\n- IPv6 把原来 IPv4 首部中选项的功能都放在**扩展首部**中，并将扩展首部留给路径两端的源站和目的站的主机来处理。\n- 数据报途中经过的路由器都不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部）。\n- 这样就大大提高了路由器的处理效率。 \n\n#### 4.6.2 IPv6的地址\n- 单播\n- 多播\n- 任播\n- IPv6 将实现 IPv6 的主机和路由器均称为**结点**。\n- 一个结点就可能有多个与链路相连的接口。\nIPv6 地址是分配给结点上面的接口的。\n    - 一个接口可以有多个单播地址。\n    - 其中的任何一个地址都可以当作到达该结点的目的地址。即**一个结点接口的单播地址可用来唯一地标志该结点**。\n- 为了使地址再稍简洁些，IPv6 使用冒号十六进制记法\n- 冒号十六进制记法可以允许零压缩 (zero compression)，即一连串连续的零可以为一对冒号所取代。\n    FF05:0:0:0:0:0:0:B3    可压缩为：   \n    FF05::B3\n- 注意：在任一地址中只能使用一次零压缩。\n\n### 4.7 多播\n\n### 4.8 虚拟专用网和网络地址转换NAT\n\n### 4.9 多协议标记交换MPLS\n\n## 第五章 运输层\n\n### 5.1 运输层协议概述\n\n#### 5.1.1 进程之间的通信\n\n- **运输层向它上面的应用层提供通信服务**\n- 它属于**面向通信部分的最高层**，同时也是**用户功能的最低层**\n- 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 \n- 从IP层来说，通信的两端是两台主机，但是严格来说，真正进行通信的实体是在主机中的进程（运输层）\n- 网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信\n- 在一台主机中经常有**多个应用进程**同时分别和另一台主机中的多个应用进程通信。\n- 这表明运输层有一个很重要的功能——**复用** (multiplexing)和**分用** (demultiplexing)。\n- 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即**面向连接的 TCP** 和**无连接的 UDP** 。\n- 运输层向高层用户**屏蔽**了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程**看见的就是好像**在两个运输层实体之间有一条端到端的逻辑通信信道。\n- 当运输层采用**面向连接的 TCP 协议**时，尽管**下面的网络是不可靠**的（只提供**尽最大努力服务**），但这种逻辑通信信道就**相当于**一条**全双工的可靠信道**。\n- 当运输层采用**无连接的 UDP 协议**时，这种逻辑通信信道是一条**不可靠信道**。\n\n#### 5.1.2 运输层的两个主要协议\n\n- TCP/IP 的运输层有两个主要协议：\n(1) **用户数据报协议 UDP** (User Datagram Protocol)\n(2) **传输控制协议 TCP** (Transmission Control Protocol)\n- 两个对等运输实体在通信时传送的数据单位叫作**运输协议数据单元 TPDU** \n- TCP 传送的数据单位协议是 **TCP 报文段**\n-  UDP 传送的数据单位协议是 **UDP 报文**或**用户数据报**。 \n- UDP：传输前不需要建立连接，不可靠\n- TCP：传输数据前建立连接，传输后释放，其下网络是不可靠的，但是TCP提供可靠的面向连接的运输服务，TCP不提供广播，多播服务\n\n#### 5.1.3 运输层的端口\n- 复用：应用层所有的应用进程都可以通过运输层再传送到IP层\n- 分用：运输层从IP层收到发送给个应用进程的数据后，必须分别交付指明的各应用进程\n- 运行在计算机中的进程是用**进程标识符**来标志的。\n- <u>但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符</u>。这是因为在互联网上使用的计算机的操作系统种类很多，而**不同的操作系统又使用不同格式的进程标识符**。\n- 为了**使运行不同操作系统的计算机的应用进程能够互相通信**，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。 即使用**协议端口号**\n- 在协议栈层间的抽象的协议端口是**软件端口**。\n路由器或交换机上的端口是**硬件端口**。\n- 端口号只具有**本地意义**，即端口号只是为了标志**本计算机应用层中的各进程**\n- 由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的 **IP 地址**（为了找到对方的<u>计算机</u>），而且还要知道对方的**端口号**（为了找到对方计算机中的<u>应用进程</u>）。\n\n### 5.2 用户数据报协议UDP\n\n#### 5.2.1 UDP概述\n\n- UDP具有复用，分用，差错检验的功能\n- UDP的特点：\n(1) **UDP 是无连接的**，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。\n(2) **UDP 使用尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。\n(3) **UDP 是面向报文的**。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。<u>UDP 一次交付一个完整的报文</u>。\n(4) **UDP 没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 选择合适大小的报文\n(5) **UDP 支持一对一、一对多、多对一和多对多的交互通信**。\n(6) **UDP 的首部开销小**，只有 8 个字节，比 TCP 的 20 个字节的首部要短。\n\n#### 5.2.2 UDP的首部格式\n\n- 首部字段很简单，只有8个字节（4个字段，每个字段2个字节）：\n（1）源端口\n（2）目的端口\n（3）长度\n（4）检验和\n- 计算检验和时，再UDP用户数据报之前增加12个字节的伪首部（仅用于计算检验和）\n- IP数据报的检验和**只检验IP数据报的首部**，而UDP的检验和是**把首部和数据部分一起都检验**\n\n### 5.3 传输控制协议TCP概述\n\n#### 5.3.1 TCP最主要的特点\n\n（1）**TCP 是面向连接的运输层协议**。\n（2）每一条 TCP 连接**只能有两个端点** ，每一条 TCP 连接只能是**点对点**的（一对一）。 \n（3）TCP 提供**可靠交付**的服务。\n（4）TCP 提供**全双工通信**。\n（5）**面向字节流**\n- TCP 中的“流”(stream)指的是流入或流出进程的字节序列。\n- “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。\n- TCP 连接是一条虚连接而不是一条真正的物理连接\n- TCP不关心应用进程一次把多长的报文发送到TCP的缓存中\n- TCP 根据对方给出的**窗口值**和**当前网络拥塞的程度**来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）\n\n#### 5.3.2 TCP的连接\n\n- TCP 把连接作为**最基本的抽象**。\n- 每一条 TCP 连接有**两个端点**。\n- TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。\n- TCP 连接的端点叫做**套接字** (socket) 或插口。\n- **端口号拼接到 (contatenated with) IP 地址即构成了套接字**。   \n- 套接字socket = （IP地址：端口）\n- 每一条TCP连接**唯一**地被通信两端的**两个端点**（两个套接字）\n- TCP 连接 ::= {socket1, socket2} = {(IP1: port1)，(IP2: port2)}\n- TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。\n- 同一个 IP 地址可以有多个不同的 TCP 连接。\n- 同一个端口号也可以出现在多个不同的 TCP 连接中。\n- 同一个名词socket可以表示多种不同的意思\n\n### 可靠传输的工作原理\n\n- 理想的传输条件有以下两个特点：\n(1) 传输信道不产生差错。\n(2) 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。\n- 然而实际的网络都不具备以上两个理想条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。\n\n#### 5.4.1 停止等待协议\n\n- 停止等待：每发送完一个分组就通知发送，等待对方的确认。在收到确认后再发送下一个分组\n1. 无差错情况\n2. 出现差错\n- 在接收方 B 会出现两种情况：\n    - B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。\n    - M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。\n- 在这两种情况下，B 都不会发送任何信息。\n- 如何保证 B 正确收到了 M1 呢？\n- 解决方法：**超时重传**\nA 为每一个已发送的分组都设置了一个**超时计时器**。\nA 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。\n- A需要暂时保留已发送的分组的副本，且必须有编号，并且超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长\n3. 确认丢失和确认迟到\n- 使用上述的确认和重传机制，我们可以**在不可靠的传输网络上实现可靠的通信**（自动重传请求ARQ）\n4. 信道利用率\n- 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用**流水线传输**。\n- **流水线传输**就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。\n- 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。\n\n#### 5.4.2 连续ARQ协议\n\n- 滑动窗口协议比较复杂，是 TCP 协议的精髓所在。\n- 发送方维持的**发送窗口**，它的意义是：**位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认**。这样，信道利用率就提高了。\n- 连续 ARQ 协议规定，发送方每收到一个**确认**，就把发送窗口向前**滑动一个分组**的位置。\n- 接收方一般采用**累积确认**的方式。即不必对收到的分组逐个发送确认，而是**对按序到达的最后一个分组发送确认**，这样就表示：<u>到这个分组为止的所有分组都已正确收到了</u>。\n- 优点：容易实现，即使确认丢失也不必重传。\n- 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。\n- 如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 **Go-back-N** （回退 N），<u>表示需要再退回来重传已发送过的 N 个分组</u>。\n\n### 5.5 TCP报文段的首部格式\n\n- TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是**报文段**。\n- 一个 TCP 报文段分为**首部**和**数据**两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。\n- TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。\n- 首部固定部分各字段的意义：\n（1）源端口和目的端口\n（2）序号：报文段序号，每一个字节按顺序编号\n（3）确认号：期望收到对方下一个报文段的第一个数据字节的序号\n（4）数据偏移：\n（5）保留：\n（6）紧急URG：为1时，表示紧急\n（7）确认ACK：为1确认号字段有效\n（8）推送PSH：\n（9）复位RST\n（10）同步SYN\n（11）终止FIN\n（12）窗口：窗口值作为接收方让发送方设置器发送窗口的依据\n（13）检验和\n（14）紧急指针\n（15）选项：①**最大报文段长度MSS**，每一个TCP报文段中的**数据字段的最大长度**\n②窗口扩大选项③时间戳选项④选择确认选项\n\n### 5.6 TCP可靠传输的实现\n\n#### 5.6.1 TCP以字节为单位的滑动窗口\n\n- 根据 B 给出的窗口值，A 构造出自己的发送窗口。\n- 发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 \n- 发送窗口里面的序号表示允许发送的序号。\n- 显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。\n- 描述发送窗口的状态：需要三个指针，p1，p2，p3，指针都指向序号\n- **收到确认后，发送窗口向前滑动**\n- A 的发送窗口内的序号都已用完，但还没有再收到确认，必须**停止发送**。 \n- 发送窗口中的序号全是发送未确认的或未发送的\n- 发送窗口只是发送缓存中的一部分\n- **发送缓存**用来暂时存放：\n    - 发送应用程序传送给发送方 TCP 准备发送的数据；\n    - TCP 已发送出但尚未收到确认的数据。\n- **接收缓存**用来暂时存放：\n    - 按序到达的、但尚未被接收应用程序读取的数据；\n    - 不按序到达的数据。 \n- 注意：\n（1）第一，A 的发送窗口**并不总是**和 B 的接收窗口一样大（因为有一定的**时间滞后**）。\n（2）第二，TCP 标准**没有规定**对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。\n（3）第三，TCP 要求接收方必须有**累积确认**的功能，这样可以减小传输开销。  \n- TCP是全双工通信，每一方都有自己的发送窗口和接受窗口\n\n#### 5.6.2 超时重传时间的选择\n- **重传机制**是 TCP 中最重要和最复杂的问题之一。TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。重传时间的选择是 TCP 最复杂的问题之一。\n- TCP 采用了一种**自适应算法**，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是**报文段的往返时间 RTT**。\n- TCP 保留了 RTT 的一个**加权平均往返时间 RTTS**（这又称为**平滑的往返时间**）。\n- 第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：\n- **超时重传时间RTO** (Retransmission Time-Out) 应略大于上面得出的加权平均往返时间 RTTS。\nRFC 2988 建议使用下式计算 RTO：\n- RTTD 是 RTT 的**偏差**的加权平均值。\nRFC 2988 建议这样计算 RTTD。第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTD：\nβ 是个小于 1 的系数，其推荐值是 1/4，即 0.25。\n- Karn算法：**在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本**，但是这又引起新的问题。当报文段的时延突然增大了很多时，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新报文段\n- 修正后的Karn算法：**报文段每重传一次，就把超时重传的时间RTO增大一点。典型的做法是取新的重传时间为原来的重传时间的2倍**，当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。\n\n#### 5.6.3 选择确认SACK\n- 接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。\n\n### 5.7 TCP流量控制\n\n#### 5.7.1 利用滑动窗口实现流量控制\n\n- 流量控制：**让发送方的发送速率不要太快，要让接收方来得及接收**\n- 可能出现**死锁**：B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。如果没有其他措施，这种互相等待的**死锁**局面将一直延续下去。\n- 为了解决这个问题，TCP 为每一个连接设有一个**持续计时器** (persistence timer)。\n只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。\n若持续计时器设置的时间到期，就发送一个**零窗口探测报文段**（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。\n    - 若窗口仍然是零，则收到这个报文段的一方就**重新设置**持续计时器。\n    - 若窗口不是零，则死锁的僵局就可以打破了。 \n\n#### 5.7.2 TCP的传输效率\n- 控制 TCP 报文段的发送时机:\n（1）第一种机制是 TCP 维持一个变量，它等于**最大报文段长度 MSS**。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。\n（2）第二种机制是由发送方的**应用进程指明**要求发送报文段，即 TCP 支持的推送 (push)操作。\n（3）第三种机制是发送方的一个**计时器**期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。\n- **Nagle算法**：\n    - 若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都**缓存**起来。\n    - 当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。\n    - 只有在收到对前一个报文段的确认后才继续发送下一个报文段。\n    - 当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。\n- 糊涂窗口综合征：接收方缓存已满，应用程序一次只读取一个，导致发送方每次只发送一个字节数据，效率降低\n    - 解决方法：让接收方等待一段时间，使得接收缓存已有足够空间容纳一个最长的报文段，或等待接收缓存已有一半空闲空间，只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小\n\n### 5.8 TCP的拥塞控制\n\n#### 5.8.1 拥塞控制的一般原理\n\n- **拥塞**：在某段时间，若对网络中某一资源的**需求**超过了该资源所提供的**可用部分**，网络性能变坏的情况\n- 问题的**实质**是整个系统的各个部分（速率，缓存大小等）不匹配\n- **拥塞控制**：**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载**\n- 拥塞控制的前提：**网络能够承受现有的网络负荷**，这是一个**全局性**的过程\n- 区分流量控制和拥塞控制：流量控制往往是指点对点通信量的控制，是端到端的问题\n- 实践证明，拥塞控制是很难设计的，因为它是一个**动态**的（而不是静态的）问题。\n- 当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丢失是网络发生拥塞的**征兆**而不是原因。\n- 在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。 \n- 分类：\n    - **开环控制**方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。 \n    - **闭环控制**方法是基于反馈环路的概念。属于闭环控制的有以下几种措施： \n    (1) 监测网络系统以便检测到拥塞在何时、何处发生。\n    (2) 将拥塞发生的信息传送到可采取行动的地方。\n    (3) 调整网络系统的运行以解决出现的问题。\n\n#### 5.8.2 TCP的拥塞控制方法\n\n- TCP 采用**基于窗口**的方法进行**拥塞控制**。该方法属于**闭环控制**方法。\n- TCP发送方维持一个**拥塞窗口 CWND** (Congestion Window)拥塞窗口的大小取决于网络的拥塞程度，并且**动态地**在变化。\n- 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。\n- 所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况\n- 判断网络拥塞的依据是出现**超时**\n- TCP进行拥塞控制的算法：**慢开始，拥塞避免，快重传，快恢复**\n1. 慢开始和拥塞避免\n- 慢开始算法：当主机开始发送数据时，由于并不清楚网络的负荷情况，所以如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞，经验证明，较好的方法是先探测以下，即**由小到大逐渐增大发送窗口**，也就是说，**由小到大逐渐增大拥塞窗口数值**\n- 慢开始规定，在每收到一个**对新的报文段的确认**后，可以把拥塞窗口增加最多一个SMSS（发送方的最大报文段）的数值。\n拥塞窗口CWND每次的增加量：min（N，SMSS）\n- 使用慢开始算法后，每经过一个**传输轮次** (transmission round)，拥塞窗口 cwnd 就加倍。 \n- 一个**传输轮次**所经历的时间其实就是**往返时间 RTT**。\n- “传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。\n- 例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 \n- **慢开始门限 ssthresh** 的用法如下：\n    - 当 cwnd < ssthresh 时，使用慢开始算法。\n    - 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\n    - 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。\n- **拥塞避免**算法：让**拥塞窗口 cwnd 缓慢地增大**，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按**线性规律缓慢增长**。\n- 因此在拥塞避免阶段就有“**加法增大**”  (Additive Increase) 的特点。这表明在拥塞避免阶段，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。\n\n2. 快重传算法：\n- 采用**快重传FR** (Fast Retransmission) 算法可以让发送方尽早知道发生了个别报文段的丢失。\n- 快重传 算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要**立即发送确认**，<u>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</u>\n- 发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。\n- 使用快重传可以使整个网络的吞吐量提高约20%。 \n- 不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 \n3. 快恢复算法\n\n#### 5.8.3 主动队列管理\n\n### 5.9 TCP的运输连接管理\n- TCP是面向连接的协议，运输连接是用来传送TCP报文的\n- 运输连接有三个阶段：\n    - 连接建立：采用C/S方式\n    - 数据传送\n    - 连接释放\n\n#### 5.9.1 TCP的连接建立\n\n- TCP建立连接的过程叫做**握手**\n- 握手需要在客户和服务器之间交换三个 TCP 报文段。称之为**三报文握手**。\n- 采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。\n- 一开始B的TCP服务器进程先创建传输控制块TCB，A的TCP客户进程也是首先创建传输控制模块TCB\n- A 的 TCP 向 B 发出连接请求报文段，其首部中的**同步位 SYN = 1**，并**选择序号 seq = x**，表明传送数据时的第一个数据字节的序号是 x。TCP规定SYN报文段不能携带数据，但要消耗一个序号\n- B 的 TCP 收到连接请求报文段后，如同意，则发回确认。\n  B 在**确认报文段**中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。\n- A 收到此报文段后向 B 给出确认，其 ACK = 1， 确认号 ack = y + 1。 A 的 TCP 通知上层应用进程，连接已经建立。   \n- B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。\n\n#### 5.9.2 TCP的连接释放\n\n- 数据传输结束后，通信的双方都可释放连接。\n- TCP 连接释放过程是**四报文握手**。\n- 连接释放报文段首部的**终止控制位**FIN\n- 数据传输结束后，通信的双方都可释放连接。\n-  现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP连接。\n- A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。\n- B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。\n- TCP 服务器进程通知高层应用进程。\n- 从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。\n- 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。 \n- A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1，然后进入TIME-WAIT状态。 \n\n- 为什么A在TIME-WAIT状态必须等待2MSL：\n（1）第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。\n（2）第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，**再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失**。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。\n- 保活计时器\n\n## 第六章 应用层\n- 应用层协议是为了解决某一类应用问题，而问题的解决往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。\n- 应用层的具体内容就是规定应用进程在通信时所遵循的协议\n- 应用层的许多协议都是基于C/S模式，客户和服务器都是通信中所涉及的两个应用进程\n\n### 6.1 域名系统DNS\n\n#### 6.1.1 域名系统概述\n\n- 许多应用层软件经常直接使用**域名系统 DNS** (Domain Name System)，但计算机的用户只是**间接**而不是直接使用域名系统。 \n- 互联网采用层次结构的命名树作为主机的名字，并使用**分布式**的域名系统 DNS。\n- 名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为**域名服务器**。  \n\n\n- 互联网采用了**层次树状结构**的命名方法。\n- 任何一个连接在互联网上的主机或路由器，都有一个**唯一**的层次结构的名字，即**域名**。\n- 域名的结构由标号序列组成，各标号之间用点隔开：\n`… . 三级域名 . 二级域名 . 顶级域名`\n- 各标号分别代表不同级别的域名。  \n- 域名只是个**逻辑概念**，并不代表计算机所在的物理地点。\n- 变长的域名和使用有助记忆的字符串，是为了便于人来使用\n- 每一个域名中“点”的数目则不一定正好是三个\n- 顶级域名：\n    - （1）国家顶级域名 nTLD\n    .cn表示中国\n    .us表示美国\n    .uk表示英国\n    等等\n    - （2）通用顶级域名 gTLD\n    最早的顶级域名\n    .com公司和企业\n    .net网络服务机构\n    .org非盈利性组织\n    .edu美国专用教育机构\n    .gov美国专用政府部门\n    .mil美国专用军事部门\n    .int国际组织\n    新增通用顶级域名\n    .aero\n    .biz\n    .cat\n    .name\n    等等\n    - （3）基础结构域名 \n    这种顶级域名只有一个，即**arpa**\n    用于反响域名解析，因此又称为**反向域名**\n \n#### 6.1.3 域名服务器\n- 一个服务器所管辖的范围叫做**区**\n- 各单位根据具体情况来**划分**自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。\n- 每一个区设置相应的**权限域名服务器**，用来保存该区中的所有主机的域名到 IP 地址的映射。\n- DNS 服务器的管辖范围不是以“域”为单位，而是以“**区**”为单位。  \n- 域名服务器有以下四种类型：\n    - **根域名服务器**\n        - 最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。\n        - 不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。\n        - 根域名服务器并不直接把域名直接转换成 IP 地址。\n        - 在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的 IP 地址告诉本地域名服务器。\n        - **根域名服务器共有 13 套装置，不是 13 个机器**（a~m）\n    - **顶级域名服务器**\n        - 顶级域名服务器（即 TLD 服务器）负责管理在该顶级域名服务器注册的所有**二级域名**。\n    - 权限域名服务器\n        - 负责一个区的域名服务器\n    - 本地域名服务器\n        - 当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器\n        - 这种域名服务器有时也称为**默认域名服务器**；\n- 提高域名服务器的可靠性：\n    - DNS 域名服务器都把**数据复制**到几个域名服务器来保存，其中的一个是**主域名服务器**，其他的是**辅助域名服务器**。\n    - 当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。\n    - 主域名服务器**定期**把数据复制到辅助域名服务器中，而更改数据**只能在主域名服务器**中进行。这样就保证了数据的一致性。 \n- 域名解析过程：\n    - 主机向**本地域名服务器**的查询一般都是采用**递归查询**。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。\n    - 本地域名服务器向**根域名服务器**的查询通常是采用**迭代查询**。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。\n- **每个域名服务器都维护一个高速缓存**，存放**最近用过**的名字以及从何处获得名字映射信息的记录\n\n### 6.2 文件传送协议\n\n#### 6.2.1 FTP概述\n\n- **文件传送协议 FTP** (File Transfer Protocol) 是互联网上使用得最广泛的文件传送协议。\n- FTP 提供**交互式**的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。\n- FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。\n- 文件传送非常困难。原因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大\n\n#### 6.2.2 FTP的基本工作原理\n\n- 网络环境下复制文件的复杂性：\n(1) 计算机存储数据的格式不同。\n(2) 文件的目录结构和文件命名的规定不同。\n(3) 对于相同的文件存取功能，操作系统使用的命令不同。\n(4) 访问控制方法不同。 \n- FTP的特点：\n（1）只提供文件传送的一些基本的服务\n（2）使用TCP可靠的运输服务\n（3）减少消除在不同操作系统下处理文件的不兼容性\n（4）FTP使用C/S模式。一个FTP服务器进程可以同时为多个客户进程提供服务。\n（5）FTP的服务器进程有两大部分：\n    一个主进程，负责接受新的请求；\n    若干个从属进程，负责处理单个请求\n\n- 两个连接：\n    - 控制连接：控制进程\n    - 数据连接：数据传送进程\n- 当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的**熟知端口** (21)，同时还要告诉服务器进程自己的**另一个端口号码**，用于建立数据传送连接。接着，服务器进程用自己传送数据的熟知端口 (20) 与客户进程所提供的端口号码建立数据传送连接。由于 FTP 使用了**两个不同的端口号**，所以数据连接与控制连接不会发生混乱。\n- 使用两个不同端口号：\n    - 使协议更加简单和更容易实现。\n    - 在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。 \n- NFS：\n    - NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。\n    - NFS 在网络上传送的只是**少量的修改数据**\n\n#### 6.2.3 简单文件传送协议TFTP\n\n- TFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议。\n- TFTP 使用**客户服务器方式**和使用 **UDP** 数据报，因此 TFTP 需要有自己的差错改正措施。\n- TFTP 只支持文件传输而不支持交互。\n- TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 \n- 特点：\n(1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。\n(2) 数据 **PDU** 也称为**文件块** (block)，每个块按序编号，从 1 开始。\n(3) 支持 ASCII 码或二进制传送。\n(4) 可对文件进行读或写。\n(5) 使用很简单的首部。 \n- TFTP 的工作很像停止等待协议\n\n### 6.3 远程终端协议TELNET\n\n- **TELNET** 是一个简单的**远程终端协议**，也是互联网的正式标准。\n- 用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。\n- TELNET 也使用**客户-服务器方式**。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。\n- 和 FTP 的情况相似，服务器中的**主进程**等待新的请求，并产生**从属进程**来处理每一个连接\n- TELNET 使用网络虚拟终端 NVT 格式 \n\n### 6.4 万维网WWW\n\n#### 6.4.1 万维网概述\n\n- **万维网** WWW (World Wide Web) 并非某种特殊的计算机网络。\n- 万维网是一个大规模的、联机式的**信息储藏所**。\n- 万维网用**链接**的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。这种访问方式称为“**链接**”。\n- 万维网提供**分布式服务**：\n- 万维网是**分布式超媒体** (hypermedia) 系统，它是**超文本**系统的扩充。\n- **一个超文本由多个信息源链接成**。利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在互联网上的超文本系统中。超文本是万维网的基础。\n- **超媒体与超文本的区别是文档内容不同**。超文本文档<u>仅包含文本信息</u>，而超媒体文档还包含<u>其他表示方式的信息</u>，如图形、图像、声音、动画，甚至活动视频图像。\n- 万维网的工作方式：\n（1）万维网以**客户-服务器方式**工作。\n（2）**浏览器**就是在用户计算机上的万维网**客户程序**。万维网**文档所驻留的计算机**则运行**服务器程序**，因此这个计算机也称为**万维网服务器**。\n（3）客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的**万维网文档**。\n（4）在一个客户程序主窗口上显示出的万维网文档称为**页面** (page)。\n- 万维网解决的问题：\n    -  怎样标志分布在整个互联网上的万维网文档？ \n        - 使用**统一资源定位符 URL** 来标志万维网上的各种文档。\n        - 使每一个文档在整个互联网的范围内具有**唯一**的标识符 URL。 \n    - 用何协议实现万维网上各种超链的链接？ \n        - 在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是**超文本传送协议 HTTP**。\n        - HTTP (HyperText Transfer Protocol) 是一个**应用层协议**，它使用 **TCP 连接**进行可靠的传送。 \n    - 怎样使各种万维网文档都能在互联网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？ \n        - **超文本标记语言 HTML** 使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 \n    - 怎样使用户能够很方便地找到所需的信息？ \n        - 为了在万维网上方便地查找信息，用户可使用各种的**搜索工具**（即**搜索引擎**）。 \n\n#### 6.4.2 同一资源定位符URL\n1.URL的格式：URL 相当于一个文件名在网络范围的扩展\n- 字符对大小写无要求\n- ://是格式规定\n- <主机>是存放资源的主机在互联网中的域名\n- :<端口>/<路径>   有时可以省略（http的默认端口80）\n\n#### 6.4.3 超文本传送协议HTTP\n1. HTTP的操作过程\n- HTTP是**面向事务的**应用层协议\n2. HTTP的主要特点\n- HTTP是**面向事务**的**客户-服务器协议**\n- HTTP协议是**无状态**，**持续连接**的\n    - 持续连接有两种工作方式：非流水线方式；流水线方式\n- HTTP协议本身也是**无连接**的，他使用了面向连接的TCP向上提供的服务 \n3. 代理服务器：\n- **代理服务器** (proxy server) 又称为**万维网高速缓存** (Web cache)，它代表浏览器发出 HTTP 请求。\n- 万维网高速缓存把**最近的**一些请求和响应暂存在本地磁盘中。\n- 当与暂时存放的请求**相同**的新请求到达时，万维网高速缓存就**把暂存的响应发送出去**，而不需要按 URL 的地址再去互联网访问该资源\n- 使用高速缓存可以**减少**访问互联网服务器的时延\n4. HTTP的报文结构：\n- HTTP有两种报文：\n    - 请求报文\n    - 响应报文\n- HTTP是面向正文的，因此在报文中的每一个字段都是一些ASCll码串\n- 报文由三个部分组成，即**开始行**、**首部行**和**实体主体**。\n- 在**请求报文**中，开始行就是请求行。\n- “**方法**”是面向对象技术中使用的专门名词。所谓“方法”就是**对所请求的对象进行的操作**，因此这些方法实际上也就是一些**命令**。因此，请求报文的类型是由它所采用的方法决定的。 \n- 在**响应报文**中，开始行就是状态行\n- 状态行包括三项内容，即 **HTTP 的版本**，**状态码**，以及解释状态码的**简单短语**。 \n- 状态码都是三位数字：\n**1xx 表示通知信息**的，如请求收到了或正在进行处理。\n**2xx 表示成功**，如接受或知道了。\n**3xx 表示重定向**，表示要完成请求还必须采取进一步的行动。\n**4xx 表示客户的差错**，如请求中有错误的语法或不能完成。\n**5xx 表示服务器的差错**，如服务器失效无法完成请求。\n4. 在服务器上存放用户的信息\n- 万维网站点使用 **Cookie** 来跟踪用户。\n- Cookie 表示在 HTTP 服务器和客户之间传递的**状态信息**。\n- 使用 Cookie 的网站服务器为用户产生一个**唯一的识别码**。利用此识别码，网站就能够跟踪该用户在该网站的活动。  \n\n#### 6.4.4 万维网的文档\n\n1. 超文本标记语言HTML\n- 超文本标记语言 HTML 中的 Markup 的意思就是“设置标记”。\n- HTML 定义了许多用于**排版的命令**（即标签）。\n- HTML 把各种标签嵌入到万维网的页面中。这样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。   \n- 仅当 HTML 文档是以 .html 或 .htm 为后缀时，浏览器才对此文档的各种标签进行解释\n- HTML还规定了链接的设置方法。每个链接都有一个起点和终点。\n- **远程链接**：超链的终点是其他网点上的页面。\n- **本地链接**：超链指向本计算机中的某个文件\n- **XML**：\n- XML (Extensible Markup Language)是**可扩展标记语言**，它和HTML很相似。\n- 但XML的设计宗旨是**传输数据**，而不是显示数据（<u>HTML是为了在浏览器上显示数据</u>）。\n- XML 不是要替换 HTML，而是对 HTML 的补充\n- XHTML：是可扩展超文本标记语言，是更为严格的HTML版本\n- CSS是**层叠样式表**，用于为 HTML 文档定义布局。\n    - CSS 与 HTML 的区别就是：HTML 用于结构化内容，而 CSS 则用于格式化结构化的内容\n2. 动态万维网文档：\n- **静态文档**是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。 \n- **动态文档**是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。\n- 动态文档和静态文档之间的主要差别体现在**服务器**一端。这主要是**文档内容的生成方法不同**。而从浏览器的角度看，这两种文档并没有区别。\n- **通关网关接口CGI**：<u>定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用</u>\n- CGI 程序的正式名字是 **CGI 脚本** (script)或cgi-bin脚本。\n- “脚本”指的是一个程序，它被另一个程序（解释程序）而不是计算机的处理机来解释或执行。\n- 脚本运行起来要比一般的编译程序要慢，因为它的每一条指令先要被另一个程序来处理（这就要一些附加的指令），而不是直接被指令处理器来处理\n\n3. 活动万维网文档\n- **活动文档** (active document) 技术把所有的工作都**转移给浏览器端**，提供屏幕连续更新技术。\n\n### 6.5 电子邮件\n\n#### 6.5.1 电子邮件概述\n\n-  **电子邮件** (e-mail) 是互联网上使用得最多的和最受用户欢迎的一种应用\n- 电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人**邮箱**中，收件人可随时上网到自己使用的邮件服务器进行读取\n- 传递迅速，费用低廉\n- 发送邮件的协议：**简单邮件传送协议SMTP**（7位ASCll码邮件）\n读取邮件的协议：**邮局协议POP3** 和 **IMAP**\n- **通用互联网邮件扩充MIME** 在其邮件首部中说明了邮件的数据类型(如文本、声音、图像、视像等)，使用 MIME 可在邮件中同时传送多种类型的数据。 \n- 一个电子邮件系统应该具有三个主要组成构件：\n    - **用户代理**\n    - **邮件服务器**\n    - **邮件发送协议，邮件读取协议**\n- 用户代理UA（电子邮件客户端软件）：\n    - 用户代理的功能：**撰写，显示，处理，通信**\n    - 邮件服务器按照**客户-服务器方式**工作\n- 电子邮件的组成：\n    - **信封**\n    - **内容**\n- 电子邮件的传输程序根据邮件信封上的信息来传送邮件。用户在从自己的邮箱中读取邮件时才能见到邮件的内容\n- TCP/IP 体系的电子邮件系统规定**电子邮件地址**的格式如下：\n     收件人邮箱名@邮箱所在主机的域名\n- 符号“@”读作“at”，表示“在”的意思。 \n\n\n#### 6.5.2 简单邮件传送协议SMTP\n- SMTP 所规定的就是在**两个相互通信的 SMTP 进程之间应如何交换信息**。\n- 由于 SMTP 使用**客户服务器方式**，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。\n- SMTP 规定了 14 条命令和 21 种应答信息。每条命令用 4 个字母组成，而每一种应答信息一般只有一行信息，由一个 3 位数字的代码开始，后面附上（也可不附上）很简单的文字说明\n- SMTP通信的三个阶段：\n1. **连接建立**：**SMTP不使用中间的邮件服务器**\n2. **邮件传送**\n3. **连接释放**：邮件发送完毕，SMTP应释放TCP连接\n\n#### 6.5.3 电子邮件的信息格式\n- 一个电子邮件分为**信封**和**内容**两大部分。\n- RFC 822 只规定了邮件**内容**中的**首部**(header) 格式，而对邮件的**主体** (body )部分则让用户自由撰写。\n- 用户写好首部后，邮件系统将自动地将信封所需的信息提取出来并写在信封上。所以用户不需要填写电子邮件信封上的信息。\n- 邮件内容首部包括一些关键字，后面加上冒号。最重要的关键字是：To（写到地址簿） 和 Subject（主题）。   \n- 其他还有 ：\n“Cc”：抄送，复写副本； \n“Bcc”：盲复写副本，暗送；\n“From”：发送人的电子邮件地址\n“Date”：发信日期\n\n#### 6.5.4 邮件读取协议POP3和IMAP\n- 邮局协议POP使用C/S方式\n- 网际报文存取协议IMAP：C/S方式，联机协议\n\n#### 6.5.5 基于万维网的电子邮件\n- 浏览器和互联网上的邮件服务器之间传送邮件时，使用HTTP协议\n- 个邮件服务器之间传送邮件时，使用SMTP协议\n\n### 6.6 动态主机配置协议DHCP\n- 为了将软件协议做成通用的和便于移植，协议软件的编写者把协议软件参数化，一台计算机和另一台计算机的区别，都可通过一些不同的参数来体现，在协议软件中给这些参数赋值的动作叫做**协议配置**\n- 互联网广泛使用的**动态主机配置协议 DHCP**，提供了**即插即用连网**的机制。\n- 需要 IP 地址的主机在启动时就向 DHCP 服务器**广播发送发现报文**\n- 本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文\n- DHCP 服务器的回答报文叫做**提供报文**\n- DHCP **中继代理**，它配置了 DHCP 服务器的 IP 地址信息","tags":["大学课程","网络"],"categories":["学习笔记"]},{"title":"大学课程 | 软件工程知识点","slug":"学习笔记-软件工程知识点","url":"/posts/38368.html","content":"大二软件工程课程笔记\n<!-- more -->\n## 软件工程要点\n1.\t软件是指令的集合，数据结构和软件描述信息的集合\n2.\t软件与硬件的区别：软件不会磨损，但会退化，退化的根本原因是不断变更\n3.\t软件工程是（1）将系统化的，规范的，可量化的方法应用于软件的开发，运行和维护.（2）对（1）中方法的研究\n4.\t工程化：系统化的，规范的，可量化的\n5.\t软件工程是一种层次化的技术，包含工具，方法，过程，质量关注点。\n6.\t软件工程的三要素：工具，方法，过程\n7.\t软件过程是工作产品构建是所执行的一系列活动，动作和任务的集合\n8.\t五种通用过程框架活动：沟通，策划，建模，构建，部署\n9.\t软件工程整体实践的原则：存在价值；保持简洁；保持愿景；关注使用者；面向未来；提前计划复用；认真思考\n10.\t四种过程流：线性过程流；迭代过程流；演化过程流；并行过程流；\n11.\t惯用过程模型：瀑布模型；V模型；增量过程模型；原型模型，螺旋模型；并发模型\n12.\t专用过程模型：基于构件；形式化方法模型；面向方面\n13.\t统一建模语言UML\n14.\tUP统一过程的五个阶段：起始阶段；细化阶段；构建阶段；转换阶段；生产阶段\n15.\tUP的五个阶段不是顺序进行，而是阶段性的并发进行\n16.\t敏捷原则（12条）\n17.\t普遍存在的变更是敏捷的基本动力\n18.\t需求工程是一个软件工程的动作，开始于沟通并持续到建模活动\n19.\t需求工程的7项任务：起始，获取，细化，协商，规格说明，确认，管理\n20.\t分析模型的作用：为基于计算机的系统提供必要的信息，功能和行为域的说明\n21.\t分析模型的元素：基于场景的元素；基于类的元素；行为元素数据流元素；\n22.\t需求建模动作结果：场景模型；面向类的模型；基于行为和模式的模型；数据模型；面向流的模型\n23.\t域分析：识别，分析和详细说明某个特定应用领域的共同需求以便确定可以在整个邻域内复用的对象\n24.\t需求建模的方法：结构化分析；面向对象分析（UML和UP）\n25.\t用例间的关系：包含关系（一个用例总是使用另一个用例的功能）；扩展关系；泛化关系（子类与夫类的关系）\n26.\tUML活动图：两端为半圆的矩形—特定的系统功能；箭头—通过系统的流；菱形—分支；实水平线—并行发生的活动\n27.\t泳道图：参与者职责由纵向分割图中的并行条表示\n28.\t类的分类：实体类；边界类；控制类\n29.\t类间关系：关联；继承；依赖\n30.\t面向对象的目的是封装，但仍保持对的数据以及对数据的操作\n31.\t潜在类的特征：保留信息；所需服务；多个属性；公共属性；公共操作；必要需求\n32.\tCRC模型：是表示类的标准索引卡片的集合\n33.\tCRC评审模型\n34.\tUML状态图：箭头—状态转移\n35.\t时序图（顺序图）\n36.\t四种设计模型：构件级设计；接口设计；体系结构设计；数据/类设计；\n37.\t设计概念包括：抽象，体系结构，模式，关注点分离，模块化，信息隐蔽，功能独立。求精，方面，重构，面向对象，设计类（完整性与充分性，原始性，高内聚性，低耦合性），依赖倒置，测试设计\n38.\t软件体系结构：程序或计算系统的软件结构是指系统的一个或多个结构，它包括软件构建，构建的外部可见属性以及他们之间的相互关系\n39.\t设计是体系结构的一个实例\n40.\t体系结构的风格包括：（1）完成系统需要的某种功能的一组构件；（2）能使构件间实现“通信，合作和协调”的一组连接件（3）定义构件如何集成为系统的约束（4）语义模型，能使设计者通过分析系统组成成分的已知属性来理解西戎的整体性质\n41.\t体系结构风格的分类：以数据为中心的体系结构；数据流体系结构；调用和返回体系结构；面向对象体系结构；层次体系结构\n42.\t构件：系统中模块化的，可部署的和可替换的部件，该部件封装了实现对外提供一组接口\n43.\t基本设计原则：开闭原则；Liskov替换原则；依赖倒置原则；接口分离原则；发布复用等价性原则；共同封装原则，共同复用原则\n44.\t内聚性：功能内聚；分层内聚；通信内聚\n45.\t耦合性：内容耦合；公共耦合；外部耦合；控制耦合（由强到弱）\n46.\t构件3C模型：概念，内容，环境\n47.\t用户界面黄金原则：（1）把控制权交给用户（2）减轻用户的记忆负担（3）保持界面一致\n48.\t软件测试策略：单元测试集成测试确认测试系统测试\n49.\t集成测试包括：自顶向下集成；自底向上集成；回归测试；冒烟测试\n50.\t面向对象的集成测试：基于线程的测试；基于使用的测试；簇测试\n51.\tα测试和β测试的区别：α测试是由有代表性的最终用户在开发者的场所进行。即α测试是在受控环境下进行。而β测试在一个或多个最终用户场所进行。与α测试不同，开发者通常不在场\n52.\t系统测试包括：恢复测试；安全测试；压力测试；性能测试；部署测试\n53.\t调试方法：蛮干法；回溯法；原因排除法\n54.\t白盒测试：（结构化测试）\n（1） 逻辑覆盖\n（2） 路径覆盖：①流图：箭头—边/连接/控制流；边和结点限制的区域—域；包含条件的结点—判定结点② 环复杂性：（1）V(G)=边数-节点数+2（2）V(G)=判定结点数+1（3）V(G)=域数③ 生成基本测试用例：（1）以设计或源代为基础画出相应的流图（2）确定所得流图的环复杂性（3）确定线性独立路径的基本集合（4）准备测试用例，强制执行基本集合中的每一条路径\n55.\t黑盒测试：（行为测试/功能测试）白盒测试在测试早期执行，黑盒测试倾向于在测试后期\n（1）等价类法\n（2）边界值法\n（3）错误猜测法\n56.\t软件配置：在软件过程中产生的所有信息项\n57.\t软件配置管理：一组用于在计算机软件的整个生命周期内管理变更的活动\n58.\t软件过程输出信息可以分为：计算机程序；文档；数据或内容\n59.\t系统工程第一定律：不管你处在系统生命周期的什么阶段，系统都可能发生变更，并且在整个生命周期中将会持续不断的提出变更的要求\n60.\t配置管理系统的元素：构件元素；过程元素；构建元素；人员元素；\n61.\t基线：已经通过正式评审和批准的规格说明或产品，它可以作为进一步开发的基础，并且只有通过正式的变更控制规程才能修改它\n62.\tSCM中心存储库：是一组机制和数据结构，它使软件团队可以有效地管理变更\n63.\tSCM特征：版本控制；依赖性跟踪和变更管理；需求跟踪；配置管理；审核跟踪\n64.\t软件项目管理的4P：人员，产品，过程，项目\n65.\tW5HH原则\n66.\t软件度量：过程度量，项目度量，产品度量\n67.\t软件测试：\n（1） 面向规模度量：LOC（代码行）\n（2） 面向功能度量：FP（功能点）\n（3） 面向对象度量\n（4） 面向用例度量\n\n68.\t软件质量：测试指标：正确性；可维护性；完整性；可用性；\n（1） 正确性：每千行代码的缺陷数\n（2） 可维护性：平均变更时间MTTC\n（3） 完整性：=∑(1-(危险性×(1-安全性)))\n69.\t缺陷排除效率：\n（1） DRE=E/(E+D)\n（2） E是软件交付给最终用户之前发现的错误数\n（3） D是软件交付之后发现的错误数\n70.\t三类主要软件工程资源：人员，可复用的软件构件，开发环境（硬件和软件工具）\n（1） 对每类资源都要说明四个特征：资源描述，可用性说明，何时需要资源，使用资源的持续时间\n71.\t基于问题估算：\n（1） S=（Sopt+4Sm+Spess）/6\n（2） Sopt乐观值，Sm可能值，Spess悲观值\n72.\t基于LOC的估算：\n（3） LOC/pm--人月\n73.\t基于FP的估算：\n（4） FPestimated=总计×（0.65+0.01×∑Fi）\n\n## 软件工程简答题及答案\n\n### 1.简述软件的定义及特征\n软件是：计算机系统中与硬件相互依存的另一部分，它包括程序，数据及其相关文档的完整集合。\n（1）指令的集合（计算机程序），通过执行这些指令可以满足预期的特性、功能和性能需求；\n（2）数据结构，使得程序可以合理利用信息；\n（3）软件描述信息，用来描述程序的操作和使用。 \n- 软件的特征是：\n\t- 软件不会“磨损”，但会退化，退化的根本原因是不断变更；\n\t- 软件是开发、设计出来的，不是生产出来的；\n\t- 大多数软件是按照实际客户要求定制的。\n### 2.简述软件工程的定义及软件过程的5种框架活动\n- 软件工程是：\n（1）将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护，即将工程化方法应用于软件；\n（2）对（1）中所述方法的研究。\n- 软件工程过程框架通常包含以下5个活动：\n\t- 沟通、策划、建模、构建、部署。\n### 3.画图说明软件过程流的各种类型\n略\n### 4.画图说明软件过程的增量模型及适用情形和特点\n略\n- 适用情形：初始的软件需求有明确的定义，但是整个开发过程却不宜单纯运用线性模型。迫切需要为用户迅速提供一套功能有限的软件产品，然后在后续版本中再进行细化和扩展功能。\n- 特点：增量模型综合了线性过程流和并行过程流的特征。每个线性序列生产出软件的可交付增量且第一个增量往往是核心产品，满足了基本的需求。客户使用后进行评估，根据评估结果制定下一个增量计划。每一个增量的交付都会重复这一过程，直到最终产品产生。\n### 5.画图说明软件过程的原型模型及适用情形和特点\n略\n- 适用情形：客户定义了软件的一些基本任务，但是没有详细定义功能和特性需求。开发人员可能对算法的效率、操作系统的适用性和人机交互的形式等情况并没有把握。\n- 特点：在大多数项目中，构建的第一个系统很少是好用的，可能太慢了、太大了、太难用了，或者同时具备上述三点。一般作为被丢弃的系统。开发者没有考虑整体软件质量和长期的可维护性。软件工程师经常会使用不合适的操作系统或程序设计语言或低效的算法。但是原型开发对于软件工程来说仍是有效的范型。\n### 6.画图说明统一过程的各个阶段\n略\nUP：\n-\t起始阶段，细化阶段，构建阶段，转换阶段，生产阶段\n-\t五个UP阶段不是顺序进行，而是阶段性地并发进行。（可能在构建转换生产同时，下一个软件增量的工作已经开始）\n### 7.简述敏捷原则\n（1） 我们最优先要做的是通过尽早、持续交付有价值的软件来使客户满意。\n（2） 即使在开发的后期，也欢迎需求变更。敏捷过程利用变更为客户创造竞争优势。\n（3） 经常交付可运行软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。\n（4） 在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。\n（5） 围绕有积极性的个人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作。\n（6） 在团队内部，最富有效果和效率的信息传递方法是面对面交谈。\n（7） 可运行软件是进度的首要度量标准。\n（8） 敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够长期保持稳定的开发速度。\n（9） 不断地关注优秀的技能和好的设计会增强敏捷能力。\n（10） 简单——使不必做的工作最大化的艺术——是必要的。\n（11） 最好的架构、需求和设计出自于自组织团队。\n（12） 每隔一定时间，团队会反省如何才能更有效地工作，并相应调整自己的行为。\n### 8.简述需求建模的模型\n（1）场景模型：出自各种系统“参与者”观点的需求。 \n（2）面向类的模型：表示面向对象类（属性和操作）的模型，其方式为通过类的协作获得系统需求。\n（3）基于行为和模式的模型：描述如何将软件行为看作外部“事件”后续的模型。\n（4）数据模型：描述问题信息域的模型。\n（5）面向流的模型：表示系统的功能元素并且描述当功能元素在系统中运行时怎样进行数据变换。\n### 9.简述CRC模型的评审步骤\n①所有参加评审的人员拿到一部分CRC模型索引卡。拆分协作卡片。\n②分类管理所有的用例场景。\n③评审组长细致地阅读用例。当评审组长看到一个已命名的对象时，给拥有相应类索引卡的人员一个令牌。\n④当令牌传递时，该类卡的拥有者需要描述卡上记录的职责。评审组确定职责是否满足用例需求。\n⑤如果记录在索引卡上的职责和协作不能满足用例，就需要修改卡片，包括定义新类。\n### 10.简述行为建模的步骤\n（1）评估所有的用例，以保证完全理解系统内的交互顺序；\n（2）识别驱动交互顺序的事件，并理解这些事件如何与特定的对象相互关联；\n（3）为每个用例生成序列；\n（4）创建系统状态图；\n（5）评审行为模型以验证准确性和一致性。\n### 11.画图说明从需求模型到设计模型的转换\n 略\n### 12.简述模块的功能独立及评估标准\n\t通过开发具有“专一”功能和“避免”与其他模块过多交互的模块，可以实现功能独立。\n\t独立性可以通过两条定性的标准进行评估：内聚性和耦合性。内聚性显示了某个模块相关功能的强度；耦合性显示了模块间的相互依赖性。\n### 13.简述重构的定义及重构时的检查要点\n\t重构是使用这样一种方式改变软件系统的过程：不改变代码的外部行为而是改进其内部结构。\n\t在重构软件时，检查现有设计的冗余性、没有使用的设计元素、低效的或不必要的算法、拙劣的或不恰当的数据结构以及其他设计不足。\n### 14.简述体系结构风格描述的4个要素及其分类\n四个要素：\n（1）完成系统需要的某种功能的一组构件；\n（2）能使构件间实现“通信、合作和协调”的一组连接件；\n（3）定义构件如何集成为系统的约束；\n（4）语义模型，能使设计者通过分析系统组成成分的已知属性来理解系统的整体性质。\n分类：以数据为中心的体系结构、数据流体系结构、调用和返回体系结构、面向对象体系结构、层次体系结构。\n### 15.简述构件级设计的7个基本原则\n①开闭原则。模块（构件）应该对外延具有开放性，对修改具有封闭性。 \n②Liskov替换原则。子类可以替换它们的基类。 \n③依赖倒置原则。依赖于抽象，而非具体实现。\n④接口分离原则。多个客户专用接口比一个通用接口要好。\n⑤发布复用等价性原则。复用的粒度就是发布的粒度。\n⑥共同封装原则。一同变更的类应该合在一起。\n⑦共同复用原则。不能一起复用的类不能被分到一组。\n### 16.简述黄金规则中把控制权交给用户的规则\n①以不强迫用户进入不必要的或不希望的动作的方式来定义交互模式。 \n②提供灵活的交互。\n③允许用户交互被中断和撤销。\n④当技能水平高时可以使交互流线化并允许定制交互。\n⑤使用户与内部技术细节隔离开来。\n⑥设计应允许用户与出现在屏幕上的对象直接交互。\n### 17.简述黄金规则中减轻用户记忆负担的原则\n①减少对短期记忆的要求。\n②建立有意义的默认设置。\n③定义直观的快捷方式。\n④界面的视觉布局应该基于真实世界的象征。\n⑤以一种渐进的方式揭示信息。\n### 18.简述黄金规则中保持界面一致的原则\n①允许用户将当前任务放入有意义的环境中。\n②在完整的产品线内保持一致性。\n③如果过去的交互模型已经建立起了用户期望，除非有不得已的理由，否则不要改变它。\n### 19.简述面向对象软件测试中集成测试的3种策略\n①基于线程的测试，对响应系统的一个输入或事件所需的一组类进行集成。\n②基于使用的测试，通过测试很少使用服务类的那些类开始系统的构建。 \n③簇测试，借助试图发现协作错误的测试用例来测试协作的类簇。\n### 20.简述压力测试并举例说明\n\t压力测试的目的是使软件面对非正常的情形。压力测试要求以一种非正常的数量、频率或容量的方式执行系统。\n\t例如：（1）在平均每秒出现1~2次中断的情形下，可以设计每秒产生10次中转的测试用例；（2）将输入数据的量提高一个数量级以确定输入功能将如何反应；（3）执行需要最大内存或其他资源的测试用例；（4）设计可能在实际的运行系统中产生惨败的测试用例；（5）创建可能会过多查找磁盘驻留数据的测试用例。\n### 21.简述单元测试中桩模块和驱动模块的作用？ \n\t驱动程序只是一个“主程序”，它接受测试用例数据，将这些数据传递给构件，并打印相关结果。\n\t桩程序的作用是替换那些从属于被测构件的模块。桩程序或“伪程序”使用从属模块的接口，可能做少量的数据操作，提供入口的验证，并将控制返回到被测模块。\n### 22.简述测试中症状与原因之间的关系\n\t症状与原因出现的地方可能相隔很远。也就是说，症状可能在程序的一个地方出现，而原因实际上可能在很远的另一个地方。高度耦合的构建加剧了这种情况的发生。\n### 23.简述软件的基线及SCI和项目数据库之间的关系\n基线的定义是：已经通过正式评审和批准的规格说明或产品，它可以作为进一步开发的基础，并且只有通过正式的变更控制规程才能修改它。\n基线是软件开发中的里程碑，其标志是在正式技术评审中已经获得批准的一个或多个软件配置项的交付。\n软件配置项是在软件工程过程中创建的信息。在现实中，是将SCI组织成配置对象，这些配置对象具有自己的名字，并且按类别存储在项目数据库中。配置对象具有一个名称和多个属性，并通过关系来表示与其他配置对象的“关联”。\n \n### 24.简述选择软件团队结构时应考虑的7个因素\n①待解决问题的难度； \n②开发程序的规模，以代码行或者功能点来度量；\n③团队成员需要共同工作的时间 (团队生存期)；\n④能够对问题做模块化划分的程度；\n⑤待开发系统的质量要求和可靠性要求；\n⑥交付日期的严格程度；\n⑦项目所需要的友好交流的程度。\n### 25.简述软件团队的组织范型\n①封闭式范型。按照传统的权利层次来组织团队。\n②随机式范型。松散地组织团队，团队工作依赖于团队成员个人的主动性。\n③开放式范型。试图以一种既具有封闭式范型的控制性，又包含随机式范型的创新性的方式来组织团队。\n④同步式范型。依赖于问题的自然划分，组织团队成员各自解决问题的一部分，他们之间没有什么主动的交流。\n### 26.简述如何避免“团队毒性”\n为了避免狂乱的工作环境，项目经理应该确保团队可以获取完成工作所需的所有信息；而且，主要目标一旦确定下来，除非绝对必要，否则不应该修改。给予软件团队尽可能更多的决策权，这样能使团队避免挫败。通过理解将要开发的产品和完成工作的人员，以及允许团队选择过程模型，可以避免选择不适当的软件过程，团队本身应该建立自己的责任机制。团队本身应该建立自己的责任机制，并规定一系列当团队成员未能完成任务时的纠正方法。最后，避免失败的关键是建立基于团队的信息反馈方法和解决问题的技术。\n","tags":["大学课程","软件工程"],"categories":["学习笔记"]},{"title":"Github | 学习Git&Github","slug":"学习笔记-学习Git-Github","url":"/posts/42803.html","content":"关于Git与Github的基础知识的笔记\n<!-- more -->\n# GitHub与Git区别\n- Git属于分散型版本管理系统，开发者使用Git将源代码存入名叫“Git仓库”的资料库中并加以使用。\n- GitHub事在网络上提供Git仓库的一项服务，使用GitHub可以实现多人协作\n\n#  Git初始设置\n## git config命令的--global参数\n- 设置Git提交时的姓名与邮箱\n```bash\n$ git config --global user.name \"justlovesmile\"\n$ git config --global user.email \"865717150@qq.com\"\n```\n- 让命令的输出具有更高的可读性\n```bash\n$ git config --global color.ui auto\n```\n\n## 创建版本库\n- 把这个目录编程Git可以管理的仓库\n```bash\n$ git init\n```\n- 将文件添加到仓库缓冲区\n```bash\n$ git add hello_world.php\n```\n- 添加说明并正式提交 \n```bash\n$ git commit -m \"wrote a file\"\n[master (root-commit) a4207ca] wrote a file\n 1 file changed, 3 insertions(+)\n create mode 100644 hello_world.php\n```\n- 查看提交日志\n```bash\n（1）$ git log（+文件名）\n\ncommit a4207cab55e08e29847031903c3d885f522483d3 (HEAD -> master)\nAuthor: justlovesmile <865717150@qq.com>\nDate:   Thu Jun 13 11:04:29 2019 +0800\n    wrote a file\n\n（2）$ git log --pretty=oneline\n\ndb0644b6e8c15385d34c80b44fab5a2124289526 (HEAD -> master) add one line\n5022ed9f401a7a95b2c325d1f57ef7c9c291e860 wrote a read.txt\na4207cab55e08e29847031903c3d885f522483d3 wrote a file\n\n（3）$ git log -p查看文件改动\n```\n- 查看仓库状态\n```bash\n$ git status\n```\n- 查看修改的不同之处\n```bash\n$ git diff read.txt \n```\n- 回退版本到上一个版本\n```bash\n$ git reset --hard HEAD^\n```\n（回退后就看不见之前那个了，但是如果还没关命令窗口可以向上查找commit id然后再👇）\n```bash\n$ git reset --hard 1094a（id不一定要写全）\n```\n- 使用cat查看文件内容\n```bash\n$ cat read.txt\n```\n- Git提供了查看你的每一次命令的方法\n```bash\n$ git reflog\n```\n- 丢弃工作区修改（当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时）\n```bash\n$ git checkout -- read.txt\n```\n- 撤销暂存区的修改（当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了工作区的修改，再执行👆）\n```bash\n$ git reset HEAD read.txt\n```\n- 删除文件\n```bash\n$ rm read.txt\n```\n- 删除版本库\n```bash\n$ git rm read.txt\n```\n- 误删恢复\n（用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”，但是会失去最近一次提交后的修改内容）\n```bash\n$ git checkout -- test.txt\n```\n# 远程仓库\n- 创建SSH Key\n```bash\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\n```\n- 查看id_rsa.pub文件，并复制\n```bash\n$ cat ~/.ssh/id_rsa.pub\n```\n- 然后再在github中添加ssh key\n\n- 输入命令测试\n```bash\n$ ssh -T git@github.com\n```\n- 在github中创建一个git仓库\n\n- 关联远程库\n```bash\n$ git remote add origin git@github.com:Justlovesmile/Hello-World.git\n```\n- 将本地库的所有内容推送到远程库上\n```bash\n$ git push -u origin master\n```\n- 从现在起，只要本地作了提交，就可以通过命令：\n```bash\n$ git push origin master\n```\n- 克隆远程库到本地库\n```bash\n$ git clone git@github.com:Justlovesmile/practice.git\n```\n\n# 分支管理\n## 创建于合并\n- 创建dev分支，并切换\n```bash\n$ git checkout -b dev\n（即\n$ git branch dev\n$ git checkout dev\n）\n```\n- 查看分支\n```bash\n$ git branch\n```\n- 在切换到分支后，可以在分支上继续修改文件，再提交\n- 然后切回master\n```bash\n$ git checkout master\n```\n此时，master上看不见分支\n\n- 将分支的工作结果与master合并\n```bash\n$ git merge dev\n```\n- 合并完成后删掉分支\n```bash\n$ git branch -d dev\n```\n## 出现冲突的情况\n- 如果创建了分支，并进行了修改与提交\n- 而master也进行了提交，那么两者就不能直接进行合并，需要检查冲突手动修改\n```bash\n$ git status（会告述你哪里冲突了）\n```\n- 查看合并情况图\n```bash\n$ git log --graph --pretty=oneline --abbrev-commit\n```\n\n## 分支管理\n- 一般master仅用来发布新版本，其他工作，修改在分支上进行\n\n- 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n```bash\n$ git merge --no-ff -m \"merge with no-ff\" dev\n```\n## bug分支\n- 当工作只进行了一半，但是又要修改另外的bug时，可以将工作现场先储藏起来\n```bash\n$ git stash\n```\n- 然后再创建一个分支，例如叫issue，在这上面修改bug\n- 再提交，然后切换回master合并，最后删除这个分支\n- 切回之前工作的分支，恢复工作现场\n\n## 强制删除分支\n- 如果分支中的修改已经提交，但是发现不能加到master中，并且，该修改属于机密，所以你需要强制删除该分支（因为系统会提示你该修改未合并，使用D）\n```bash\n$ git branch -D feature\n```\n## 多人协作\n- 查看远程库的信息\n```bash\n$ git remote\norigin\n```\n- 查看远程库的详细信息\n```bash\n$ git remote -v\norigin  git@github.com:Justlovesmile/Hello-World.git (fetch)\norigin  git@github.com:Justlovesmile/Hello-World.git (push)\n```\n- 推送master主分支\n```bash\n$ git push origin master\n```\n- 推送其他分支\n```bash\n$ git push origin dev\n```\n- 抓取分支\n```bash\n$ git clone git@github.com:Justlovesmile/Hello-World.git\n```\n\n- 多人协作的工作模式通常是这样：\n    - 首先，可以试图用`git push origin <branch-name>`推送自己的修改；\n    - 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；\n    - 如果合并有冲突，则解决冲突，并在本地提交；\n    - 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！\n- 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`。\n\n\n# 标签\n## 创建标签\n- 切换到需要打标签的分支上\n```bash\n$ git branch\n* dev\n  master\n$ git checkout master\nSwitched to branch 'master'\n```\n- 创建标签\n```bash\n$ git tag v1.0\n```\n- 给对应的版本打上标签\n```bash\n$ git tag v0.9 f52c633\n```\n- 标签它是按字母排序的，查看标签\n```bash\n$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)\nAuthor: Michael Liao <askxuefeng@gmail.com>\nDate:   Fri May 18 21:56:54 2018 +0800\n    add merge\ndiff --git a/readme.txt b/readme.txt\n```\n- 创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n```bash\n$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb\n```\n## 操作标签\n- 删除标签\n```bash\n$ git tag -d v0.1\n```\n- 推送某个标签到远程\n```bash\n$ git push origin v1.0\n```\n- 一次性推送全部尚未推送到远程的本地标签：\n```bash\n$ git push origin --tags\n```\n- 如果标签已经推送到远程，又想要删除标签，先从本地删除\n```bash\n$ git tag -d v0.9\n```\n然后再从远程删除\n```bash\n$ git push origin :refs/tags/v0.9\n```\n# github\n- 对于感兴趣的项目，先点Fork克隆仓库，然后再从自己的账号下clone\n```bash\ngit clone git@github.com:michaelliao/clone.git\n```\n# 码云gitee.com\n- 国内的Git托管服务\n\n# 自定义git命令\n- 自定义st表示status\n```bash\n$ git config --global alias.st status\n```\n- 修改在配置文件.gitconfig中","tags":["Git","Github"],"categories":["学习笔记"]},{"title":"学习笔记 | 什么是比特币？","slug":"学习笔记-比特币","url":"/posts/4475.html","content":"\n第一次去了解比特币，看了B站上的视频后做了一点笔记\n\n# 比特币\n\n1.比特币是一种电子货币，数字货币\n2.其来自于中本聪《白皮书》\n3.去中心化的电子记账系统，每个人的账本都是公开的\n4.每个人的消费账本都会广播给其他所有人（billboard），将账单打包成一个块，就是区块，一块大小大约1M，可以存储4000多条记录，区块连接在一起形成区块链\n5.以谁为准？\n- 中本聪提出 工作量证明 的方法，即 挖矿。\n- 可以理解为通过做一个很难的数学题，如果做出来了，你就可以打包，去获得奖励。但是这个数学题很难，只能用计算机算出来\n- SHA256：安全哈希函数，正向算容易，反向算非常困难，得到256位的二进制数\n- 挖矿原理:区块链中每个区块要包含头部，以及其他信息，例如：\n    - 字符串包含前块的头部+账单+时间戳+随机数\n    - Hash=sha256(sha256（字符串）)\n    - Hash（256位）要求前n位是0\n    - 满足上述条件则算对\n- 所以一般来说，谁的计算能力强，谁就更可能算出来\n- 中本聪要求每10分钟，就打包一个块，所以，通过调节n的值，就可以满足要求，例如：\n    - 如果有10000台矿机，每台矿机计算能力是14T/s=1.4×10^13,那么1.4×10^13×10000×600s=8×10^19\n    - 对于SHA256的结果，前n个二进制数的概率是（1/2）^n，次数就是2^n次\n    - 即此时n=66，则满足中本聪的要求\n6.为什么记账？为什么别人发的账本我们要接受，花自己的电脑资源去记录？\n- 记账有奖励。有手续费收益较低。手续费由付费方出\n- 打包的人有奖励，每过四年减半：\n比特币打包一次要一个小时，连续不断的打包，第一个四年，每打包一次奖励50bitcoin：可以得下式：50×6×24×365×4×（1+1/2+（1/2）×（1/2）+......）=2100万\n也就是说比特币最多2100万个\n7.怎么防伪？\n- 身份认证：电子签名\n    - 用户注册时生成随机数，通过随机数产生私钥字符串（重要），又通过私钥产生公钥字符串（公开）和一个地址（公开）\n    - 私钥可以对一个数据加密，公钥用于解密（非对称加密）\n    - 如果A要付给B钱：则A先进行记录，再用hash函数计算摘要，再用私钥进行加密，产生密码，对全网广播  A给B钱+公钥+刚刚的密码，其他人拿到接受的信息，进行摘要计算，再用公钥解密，比较两个值是否相等，若果不对，则其他用户不承认\n8.如何对付双重支付？\n- 余额检查（追溯）：区块链中包含很多信息，当A要给B钱时，其他用户就检查区块链中的信息，查看A的余额是否足够\n- 双重支付：指一个人同时给两个人支付钱\n- 如果A只有10bitcoin但是A同时给B和C支付10bitcoin，其他人先接受到的消息可能不一样，如果有个人接受消息后最先找到解，打包了一个块并加到主链上，并包含其中一个消息，则这个消息被承认，另一个不被承认。\n9.如何防止串改？\n- 比特币有最长链原则：即如果有两个人同时挖到矿，并且广播出去，其他人先接受到的消息不相同，但是只接受一个，即站队后他们各自算自己的区块，哪个支链长，那个支链就最有可能成为主链（被大多数人认可）\n- 防止篡改：如果有一个人想要修改之前的一个记录，他就在包含那条记录的链的位置创造一条新支链，但是只有当你在其后添加的区块超过当时全世界在主链上的区块数后，你的链才会成为主链，这是不太现实的。\n","tags":["比特币"],"categories":["学习笔记"]},{"title":"大学课程 | 数据库基础","slug":"学习笔记-数据库基础","url":"/posts/41347.html","content":"大二数据库课程笔记\n<!-- more -->\n\n## 第一章  绪论\n\n### 1.1数据库系统概述\n\n- 应用数据库的主要目的是为了：**共享数据**。\n\n#### 1.1.1 数据库的4个基本概念\n1.四个基本概念：**数据**（data），**数据库**（DB），**数据库管理系统**（DBMS）和**数据库系统**（DBS）\n\n- 数据：\n    - <u>定义：描述事物的**符号记录**称为数据</u>\n    - 数据是数据库中存储的基本对象\n    - 数据的含义称为数据的语义，数据与其语义是不可分的\n    - 记录是计算机表示和存储数据的一种格式或方法\n- 数据库：\n    - <u>定义： 数据库是**长期存储**在计算机内，**有组织的**，**可共享**的**大量数据**的集合，数据库中的数据按一定的数据模型**组织**，**描述**和**存储**，具有**较小的冗余度**，**较高的数据独立性**和**易扩展性**，并可为各种**用户共享**。</u>\n- 数据库管理系统：\n    - 数据库管理系统是位于<u>用户与操作系统</u>之间的一层<u>数据管理软件</u>\n    - 数据库管理系统和操作系统一样是计算机的<u>基础软件</u>\n    - 主要功能：\n       （1）数据定义功能：\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  数据定义语言（DDL）\n       （2）数据组织，存储和管理\n&nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  提高存储空间利用率和方便存取\n       （3）数据操纵功能\n&nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  数据操纵语言（DML）\n       （4）数据库的事务管理和运行管理\n&nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  1. 保证安全性完整性，多用户对数据的并发使用\n&nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  2，发生故障后的系统恢复\n       （5）数据库的建立和维护功能\n&nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  \n       （6）其他功能\n&nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  \n- 数据库系统：\n    - <u>定义：数据库系统是由**数据库**，**数据库管理系统**（及其应用开发工具），**应用程序**和**数据库管理员**（DBA）组成的**存储，管理，处理和维护数据**的系统。</u>\n         \n\n\n#### 1.1.2数据管理技术的产生和发展\n***\n- 数据管理是指对数据进行分类，组织，编码，存储，检索和维护\n- 数据处理是指对各种数据进行收集，存储，加工和传播的一系列活动的总和\n- 数据库管理的三个阶段\n\n||人工管理阶段|文件系统阶段|数据库系统极端|\n|---|---|---|---|\n|硬件背景|无直接存取存储设备|磁盘，磁鼓|大容量磁盘，磁盘阵列|\n|软件背景|没有操作系统|有文件系统|有数据库管理系统|\n|处理方式|批处理|联机实时处理|联机实时处理，分布处理，批处理|\n|数据的共享程度|无共享，冗余度较大|共享性差，冗余度大|共享性高，冗余度小|\n|数据的独立性|不独立，完全依赖于程序|独立性差|具有高度的物理独立性和一定的逻辑独立性|\n|数据的结构化|无结构|记录内有结构，整体无结构|整体结构化，用数据模型描述|\n|数据控制能力|应用程序自己控制|应用程序自己控制|由数据库管理系统提供数据安全性，完整性，并发控制和恢复能力|\n\n\n\n#### 1.1.3 数据库系统的特点\n***\n- 数据**结构化**：数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。数据之间具有联系\n- 数据的**共享性高**，**冗余度低**且**易扩充**\n- 数据独立性高：**物理独立性**（物理存储），**逻辑独立性**（逻辑结构）\n- 数据由数据库管理系统统一管理和控制\n（1）数据的安全性保护：防止不合法使用造成的数据泄密和破坏\n（2）数据的完整性保护：正确性，有效性和相容性\n（3）并发控制\n（4）数据库的恢复\n\n综上所述：\n>*数据库*是**长期存储**在计算机内的**有组织，大量，共享**的数据集合。它可以供各种用户**共享**，具有**最小冗余度**和**较高的数据独立性**。数据库管理系统在数据库<u>建立，运算和维护</u>时对数据库进行统一控制，以保证数据的<u>完整性和安全性</u>，并在<u>多用户</u>同时使用数据库时进行<u>并发控制</u>，在发生<u>故障后</u>对数据库进行<u>恢复</u>。\n\n\n### 1.2 数据模型\n***\n- 数据模型：是对现实世界数据特征的抽象\n- 数据模型是数据库系统的核心和基础\n\n#### 1.2.1 两类数据模型\n***\n- **概念模型**：也叫信息模型，是按**用户观点**来对数据和信息建模，主要用于数据库设计\n- **逻辑模型和物理模型**：\n逻辑模型主要包括层次模型，网状模型，关系模型，面向对象模型和对象关系数据模型，半结构化数据模型等。\n物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向**计算机系统**的。按**计算机观点**。\n\n#### 1.2.2 概念模型\n***\n1. 信息世界中的基本概念\n（1）实体：客观存在并可相互区别的事物。\n（2）属性：实体所具有的某一特性。\n（3）码：唯一标识实体的属性集。\n（4）域：属性的取值范围\n（5）实体性：用实体名及其属性名集合来抽象和刻画同类实体\n（6）实体集：同一类型实体的集合\n（7）联系：分为实体内联系和实体间联系。实体间联系有1对1，1对多，多对多。\n- 不同实体是根据**属性值**去区分的。\n\n2. 概念模型的一种表示方法：实体-联系方法（E-R图/E-R模型）\n\n#### 1.2.3 数据模型的组成要素\n***\n- <u>数据模型</u>通常由**数据结构，数据操作**和**数据的完整性约束条件**三部分组成。\n1. 数据结构：描述数据库的组成对象以及对象之间的联系。是对系统的**静态特性**的描述。\n2. 数据操作：是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。是对系统的**动态特性**的描述。\n3. 数据的完整性约束条件：是一组完整性规则。包括：实体完整性，参照完整性，自定义完整性约束\n\n\n#### 1.2.4 常用的数据模型\n***\n- 层次模型\n- 网状模型\n- 关系模型\n- 面向对象数据模型\n- 对象关系数据模型\n- 半结构化数据模型\n\n#### 1.2.5 层次模型\n***\n1. 层次模型的数据结构\n（1）有且只有一个结点没有双亲结点，这个结点称为根结点\n（2）根以外的其他结点有且只有一个双亲结点\n&nbsp;&nbsp;- 层次模型像一颗倒立的树，结点的双亲是唯一的。 \n2. 层次结构的数据操纵和完整性约束条件\n3. 层次结构的优缺点：\n优点：\n（1）层次模型的数据结构比较简单清晰\n（2）层次数据库的查询效率高\n（3）提供了良好的完整性支持\n缺点：\n（1）显示生活中很多联系是非层次性的\n（2）可能会引入冗余数据\n（3）查询子女结合点必须经过双亲结点\n（4）由于结构严密，层次命令趋于程序化\n\n#### 1.2.6 网状模型\n***\n- 网状数据模型的典型代表是DBTG系统，亦称CODASYL系统\n1. 网状模型的数据结构：\n（1）允许一个以上的结点无双亲\n（2）一个结点可以有多于一个的双亲\n- 层次模型中子女结点与双亲结点的联系是唯一的而在网状模型中这种联系可以不唯一。\n2.网状模型的数据操纵与完整性约束\n3. 网状模型的优缺点：\n优点：\n（1）直接描述现实世界\n（2）良好的性能，存取效率较高\n缺点：\n（1）结构比较复杂\n（2）网状模型的DDL，DML复杂，不易掌握\n（3）记录之间的联系是通存取路径实现的，加重用户编写负担\n\n#### 1.2.7 关系模型\n***\n1. 关系模型的数据结构：\n术语：\n- 关系：通常来说对应一张表\n- 元组：表中的一行\n- 属性：\n- 码：唯一确定一个元组\n- 域：属性的取值范围\n- 分量：元组的一个属性值\n- 关系模式：关系模式要求关系是规范化的，最基本的一条是每一个分量是一个不可分的数据项。\n2. 关系模型的数据操纵与完整性约束条件：\n- 数据操纵包括：查询，插入，删除和更新数据（集合操作，操作对象和操作结果都是关系）\n- 完整性约束条件包括三大类：**实体完整性，参照完整性和用户定义的完整性**。\n3.关系模型的优缺点：\n优点：\n（1）严格的数学概念\n（2）概念单一\n（3）存取路径对用户透明\n缺点：\n（1）存取路径对用户隐蔽\n（2）查询效率不如格式化数据模型\n\n### 1.3 数据库系统的结构\n\n####  1.3.1 数据库系统模式的概念\n***\n- 在数据模型中有“型”和“值”的概念：型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。\n- 模式（schema）是数据库中全体数据的逻辑结构和特征的描述。它仅仅涉及型的描述，不涉及具体的值\n- 模式相对稳定，实例相对变动\n\n\n#### 1.3.2 数据库系统的三级模式结构\n\n- 数据的三级模式：**外模式，模式，内模式**\n1. 外模式：也称为子模式（subschema）或用户模式，是数据库**用户能够看见和使用的局部数据的逻辑结构和特征的描述**，是数据库**用户的数据视图**，是与某一应用有关的数据的逻辑表示。\n2. 模式：模式也称为逻辑模式，是数据库中**全体数据的逻辑结构和特征**的描述，是**所有用户的公共数据视图**。\n3. 内模式：内模式也称为存储模式，一个数据库只有一个内模式，它是数据**物理结构和存储方式**的描述，是数据库内部的组织方式。\n\n\n#### 1.3.3 数据库的二级映像功能和数据独立性\n***\n1. 外模式/模式映像：\n- 模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。\n- 同一个模式可以有任意多个外模式。\n- 当模式改变时，由数据库管理员对各个外模式/模式映像作相应的改变，可以使外模式保持不变。\n- 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。\n\n2. 模式/内模式映像：\n- 数据库中只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的\n- 当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性\n\n>在数据库的三级模式结构中，数据库模式即全局逻辑结构是数据库的中心和关键\n\n\n### 1.4 数据库系统的组成\n***\n1.硬件平台及数据库：\n要求：\n（1）足够大的内存，存放操作系统，DBMS的核心模块，数据缓冲区，应用程序\n（2）足够大磁盘等设备存方数据库，以及备份\n（3）较高通道能力，提高数据传输率\n2，软件：\n（1）DBMS\n（2）os\n（3）与数据库接口的高级语言及其编译系统\n（4）以DBMS为核心的应用开发工具\n（5）为特定应用环境开发的数据库应用系统\n3，人员\n- 数据库管理员：\n（1）决定数据库中的信息内容和结构\n（2）决定数据库的存储结构和存取策略\n（3）定义数据的安全性要求和完整性约束条件\n（4）监控数据库的使用和运行\n（5）数据库的改进和重组，重构\n- 系统分析员：\n- 数据库设计人员：\n- 应用程序员：\n- 最终用户：\n（1）偶然用户（2）简单用户（3）复杂用户\n\n## 第二章 关系数据库\n\n### 2.1 关系数据结构及形式化定义\n\n#### 2.1.1 关系\n***\n1. 域：一组具有相同数据类型的值的集合\n2. 笛卡儿积：域上的一种集合运算\n3. 关系：R（D1，D2 ... Dn）\n4. 候选码：某一属性组的值能唯一标识一个元组，而其子集不能\n5. 主码，全码\n6. 关系可以有三种类型：**基本关系（基本表），查询表，视图表**\n- 基本关系的性质：\n（1）列是同质的，每一列来自同一域\n（2）不同的列可出自同一域\n（3）列的顺序无所谓\n（4）任意两个元组的候选码不能取相同的值\n（5）行的顺序无所谓\n（6）分量必须取原子值，即**每一个分量都必须是不可分的数据项**\n\n#### 2.1.2 关系模式\n***\n- 关系模式：关系的描述 R（U，D，DOM，F）\nR是关系名，U为组成该关系的属性名的集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系\n\n#### 2.1.3 关系数据库\n***\n- 关系数据库的型也称为关系数据库模式，是对关系数据库的描述\n- 关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库\n\n#### 2.1.4 关系模式的存储结构\n***\n- 在关系数据库中实体及实体间的联系都用表来表示\n- 表是关系数据库的逻辑模型\n- 在关系数据库的物理组织中，有的物理数据组织由操作系统完成，有的自己申请文件，进行存储管理\n\n\n### 2.2 关系操作\n***\n#### 2.2.1 基本的关系操作\n***\n- 常用操作：**查询，插入，删除，修改**\n- 查询又包括：<u>选择，投影，连接，除，并，差，交，笛卡儿积</u>\n\n#### 2.2.2 关系数据语言的分类\n- **关系代数** 和 **关系演算**\n- 介于两者之间的结构化查询语言SQL（高度非过程化的语言）\n\n\n### 2.3 关系的完整性\n***\n- 三类完整性约束：实体完整性，参照完整性，用户定义的完整性。\n\n#### 2.3.1 实体完整性\n- 主属性不能为空\n\n#### 2.3.2 参照完整性\n- 若属性F是基本关系R的外码，他与基本关系S的住吗相对应，则对于R中的每一个元组在F上的值：\n（1）要么，全为空\n（2）要么，都与S中的元组的主码值相对应\n\n- 外码：若F是R中的一个或一组属性，但不是关系R的码，K是S的主码，如果F与K相对应，则称F是R的外码，并称基本关系R是参照关系，基本关系S为被参照关系（R与S可为同一个）\n- 外键并不一定要与相应的主键同名\n\n### 2.4 关系代数\n***\n- 关系代数是一种抽象的查询语言，它用对关系的运算来表达查询\n\n#### 2.4.1 传统的集合运算\n1. 并（union）\n2. 差（except）\n3. 交（intersection）\n4. 笛卡儿积（cartesian product）\n- 条件：①目相同（属性数相同）②相对应的属性来自同一域\n\n#### 2.4.2 专门的关系运算\n- 作为关系数据系统 ，最小应具备的关系运算是 <u>**选择、投影、连接**</u>  \n- 数据库中五种基本运算：交，并，投影，选择，笛卡儿积\n1. 选择σ\n\n2. 投影Π\n\n3. 连接▷◁\n（1）等值连接\n（2）非等值连接\n（3）自然连接：两个关系中进行比较的分量必须是**同名的属性组**，并且在结果中把**重复的属性列去掉**。\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;- 悬浮元组：被舍弃的元组\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;- 外连接：连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;- 自动去重\n4. 除运算（÷）\n\n### 2.5 元组演算*\n\n## 第三章 关系数据库标准语言SQL\n\n### 3.1 SQL概述\n\n#### 3.1.1 SQL的产生和发展\n\n- 不同软件厂商对SQL的基本命令集进行了不同程度的扩充和修改\n\n#### 3.1.2 SQL的特点\n\n1. 综合统一：SQL集**数据定义语言，数据操纵语言，数据控制语言**的功能于一体。\n2. 高度非过程化\n3. 面向集合的操作方式\n4. 以同一种语言结构提供多种使用方式（既独立又可嵌入）\n5. 功能简洁，易学易用\n\n#### 3.1.3 SQL的基本概念\n***\n- <u>外模式包括若干视图和部分基本表，模式包括若干基本表，内模式包括若干存储文件</u>。\n- 基本表是本身独立存在的表。在关系数据库管理系统中，一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，一个表可以带若干个索引，索引也可以放在存储文件中\n- **存储文件的逻辑结构组成了关系数据库的内模式**。存储文件的物理结构对最终用户隐蔽\n- 视图是从一个或多个基本表导出的虚表。它本身不独立存在数据库中，即**数据库中只存放视图的定义**而不存放视图的数据。\n- 视图建立后，在**数据字典**中存放的是 <u>**产生视图的表定义**</u> \n- 在SQL中，视图是由**基本表或视图**产生的虚表。\n\n\n### 3.2 学生-课程数据库实例\n```SQL\ncreate database S_T;\nuse S_T;\ncreate table Student\n(Sno char(9) primary key,\nSname char(20) unique,\nSsex char(2),\nSage smallint,\nSdept char(20)\n);\ncreate table Course\n(Cno char(4) primary key,\nCname char(40) not null,\nCpno char(4),\nCcredit smallint,\nforeign key(Cpno) references Course(Cno)\n);\ncreate table SC\n(Sno char(9),\nCno char(4),\nGrade smallint,\nprimary key (Sno,Cno),\nforeign key (Sno) references Student(Sno),\nforeign key (Cno) references Course(Cno)\n);\n```\n\n### 3.3 数据定义\n\n#### 3.3.1 模式的定义与删除\n\n1. 定义模式\n```SQL\ncreate schema <模式名> authorization <用户名>;\n```\n若没指定模式名，隐含为用户名\n在模式定义后可以紧接表定义\n```SQL\ncreate schema test authorization xiemingjie\ncreate table tab1\n(no char(9) primary key,\nname char(20) unique,\nsex char(2),\nage smallint,\n);\n```\n2. 删除模式\n```sql\ndrop schema <模式名> <CASCADE | RESTRICT>；\n```\nCASCADE为级联，表示在删除时同时把该模式下所有数据对象全部删除\nRESTRICT为限制，表示只有没有任何向下属的对象时才执行删除操作\n\n#### 3.3.2 基本表的定义，删除与修改\n- 数据类型\n\n\n| 数据类型 |含义  |\n| --- | --- |\n|char(n),character(n)  |长度为n的定长字符串  |\n|varchar(n),charactervarying(n)  |最大长度为n的变长字符串  |\n|clob  |字符串大对象  |\n|blob  |二进制大对象  |\n|int，integer  |长整数（4字节）  |\n|smallint  |短整数（2字节）  |\n|bigint  |大整数（8字节）  |\n|numeric（p，d）  |定点数，由p位数字（不包括符号，小数点）组成，小数点后面有d位数字  |\n|decimal（p，d），dec（p，d）  |同numeric  |\n|double precision  |取决于机器精度的双精度浮点数  |\n|real  |取决于机器精度的单精度浮点数  |\n|float（n）  |可选精度的浮点数，精度至少为n位数字  |\n|boolean  |逻辑布尔量  |\n|date  |日期，格式YYYY-MM-DD  |\n|time|时间，格式 HH：MM：SS|\n|timestamp|时间戳类型|\n|interval|时间间隔类型|\n\n1. 定义基本表\n```SQL\ncreate table <表名>\n(col1 类型 条件\ncol2 .........\n)；\n```\n\n2. 修改基本表\n```SQL\nALTER TABLE<表名>\n[ADD [COLUMN]<新列名><数据类型>[完整性约束]]\n[ADD <表级完整性约束>]\n[DROP [COLUMN]<列名>[ CASCADE | RESTRICT ]]\n[DROP CONSTRAINT<完整性约束名>[ RESTRICT | CASCADE ]]\n[ALTER COLUMN<列名><数据类型>];\n\n```\n3. 删除基本表\n```SQL\nDROP　TABLE<表名>[RESTRICE|CASCADE]；\n```\n\n#### 3.3.3 索引的建立与删除\n\n- 建立索引：加快查询速度的有效手段\n- 类型：顺序文件索引，B+树索引，散列索引，位图索引\n\n1. 建立索引：\n```SQL\nCREATE [UNIQUE] [CLUSTER] INDEX <索引名>\nON <表名>（<列名>[<次序>][,<列名>[<次序>]]…）;\n```\n次序有：ASC（升序），DESC（降序）\nunique指此索引的每一个索引值只对应唯一的数据记录\ncluster 建立的索引是聚簇索引\n\n2. 修改索引\n```SQL\nALTER INDEX　<旧索引名> RENAMA TO <新索引名>；\n```\n\n3. 删除索引\n```SQL\nDROP INDEX <索引名>；\n```\n\n- 删除索引时，系统会同时从数据字典中删去有关该索引的描述\n- **数据字典：记录了数据库中所有的定义信息**\n\n### 3.4 数据查询\n\n#### 3.4.1 单表查询\n\n```SQL\nSELECT  [ ALL | DISTINCT ] <目标列表达式>[,<目标列表达式>]…\nFROM <表名或视图名> [（<SELECT语句>）[AS]<别名> ]\n[WHERE <条件表达式>]\n[GROUP BY <列名1>[ HAVING <条件表达式> ] ]\n[ORDER BY <列名2>[ ASC|DESC ] ];\n```\n\n- 用户可以指定别名来改变查询结果的列标题\n- select不仅可以是表中属性列，也可以是表达式\n- 在select语句中使用group by Sno  时， Sno 必须出现在<u> **select**  </u>子句中\n\n1.where子句 常用的查询条件\n\n\n| 查询条件 |谓词  |\n| --- | --- |\n|比较  | =,>,<,>=,<=,!=,<>,!>,!<; not+上述比较运算符 |\n|确定范围  |between（下限）and（上限），not between and  |\n|确定集合  |in ，not in  |\n|字符匹配  |like， not like（通配符%:任意长度，_ ：单个字符）（若本身含有通配符需要 ：ESCAPE转义） |\n|空值  | is null ，is not null    |\n|多重条件（逻辑运算） |and，or，not  |\n\n```SQL\nselect Cno,Ccredit\nfrom Course\nwhere Cname like 'DB\\_Design' ESCAPE '\\' ;\n```\n- ESCAPE ‘\\' ：表示“\\”为转码字符\n- 注：%可代表任意长度的字符串，例：a%b（aghjgb，avb，ab…）\n       _可代表任意单个字符，例：a_b   (acb，aob… )\n       \n2.选择若干元组\n- 消除取消重复的行： \n```SQL\nSELECT DISTINCT Sno\nFROM SC；\n```\n3.order by子句\n```SQL\nselect Sno,Grade\nfrom SC\nwhere Cno='3'\norder by Grade DESC;\n```\n- 对于空值，排列时的次序由具体系统实现决定\n\n4.聚集函数\n```SQL\nCOUNT（*）                                 /* 统计元组个数*/\nCOUNT（[DISTINCT|ALL]<列名>）    /*统计一列中值的个数*/\nSUM（[DISTINCT|ALL]<列名>）        /*计算一列值的总和*/\nAVG  （[DISTINCT|ALL]<列名>）       /*计算一列值的平均值*/\nMAX  （[DISTINCT|ALL]<列名>）      /*求一列值中的最大值*/\nMIN    （[DISTINCT|ALL]<列名>）     /*求一列值中的最小值*/\n```\n注：where 子句中是不能用聚集函数作为条件表达式\n\n但可以用having：\n```SQL\nSELECT Sno，AVG（Grade）\nFROM SC\nGROUP 　BY　Ｓｎｏ\nHAVING AVG（Grade）>=90;\n```\n\n- <u>**聚集函数只能用在select子句和group by 中的having子句**</u>\n- <u>当聚集函数遇到空值时，除了count（\\*）外，都跳过空值只处理非空值</u>\n\n#### 3.4.2 连接查询\n\n1. 等值与非等值连接查询：\n连接查询的where 子句用来连接两个表的条件称为  <u>连接条件</u> 或  <u>连接谓词</u> 连接谓词中的列名 称为 <u>连接字段</u>\n- 一般格式：[<表名1>.]<列名1><比较运算符>[<表名2>.]<列名2>\n2. 自身连接：一个表与自己连接，取别名\n3. 外连接：\n- 连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。\n`\nselect Student.Sno,Sname,Ssex,Sage,Cno,Grade\nfrom Student left outer join SC on (Student.Sno=SC.Sno)\n`\n4. 多表连接\n`\nselect Student,Sno,Sname,Cname,Grade\nfrom Student,SC,Course\nwhere Student.Sno=SC.Sno and SC.Cno = Course.Cno\n`\n\n#### 3.4.3 嵌套查询\n\n- 查询块：一个select-from-where 语句\n1. 带IN谓词的子查询：\n```SQL\nSELECT Sname\nFROM Student \nWHERE Sno IN\n                   （SELECT Sno\n                      FROM  SC\n                      WHERE Cno=‘2’ ）；\n```\n- 父查询，子查询\n-子查询的select语句中不能使用order by 子句（只能最终查询结果使用）\n-不相关子查询：子查询条件不依赖于父查询\n- 相关子查询：子查询条件依赖于父查询\n\n2. 带有比较运算符的子查询：\n3. 带有any（some）或all谓词的子查询\n```SQL\nselect Sname\nfrom Student\nwhere Sage<ALL\n(select Sage \nfrom Student\nwhere Sdept='CS'\n);\n```\n4. 带有exists谓词的子查询：exists谓词的子查询不返回任何数据，只产生逻辑真值或逻辑假值。\n```SQL\nselect Sname\nfrom Student\nwhere exists\n(select * \nfrom sc\nwhere Sno=Student.Sno and Cno='1'\n);\n```\n\n#### 3.4.4 集合查询\n- 并UNION\n- 交INTERSECT\n- 差EXCEPT\n\n\nSelect 。。。\nFrom。。。\nWhere。。。\n**Union**\nSelect。。。\nFrom。。。\nwhere。。。;\n\n#### 3.4.5 基于派生表的查询\n- 派生表：出现在from子句中的子查询\n```SQL\nselect Sno,Cno\nfrom SC,(select Sno,Avg(Grade) from SC group by Sno) as Avg_sc(avg_sno,avg_grade)\nwhere SC.Sno = Avg_sc.avg_sno and SC.Grade > Avg_sc.avg_grade\n``` \n\n### 3.5 数据更新\n\n#### 3.5.1 插入数据\n\n1. 插入\n（1）插入元组：\n```SQL\nINSERT INTO<表名>[(<属性列1>[,<属性列2>]…)]\nVALUES（<常量1>[,<常量2>]…）;\n```\n（2）插入子查询结果：\n```SQL\nINSERT INTO <表名>[(<属性列1>[,<属性列2>…])]\n子查询；\n```\n2. 修改数据（更新）\n```SQL\nUPDATE<表名>\nSET<列名>=<表达式>[,<列名>=<表达式>]…\n[WHERE<条件>]；\n```\n3. 删除数据\n```SQL\nDELETE\nFROM <表名>\n[WHERE <条件>]；\n```\n\n### 3.6 空值的处理\n1. 空值的产生\n2. 空值的判断（is null ，is not null）\n3. 空值的约束条件（定义中有**not null**或**unique**或**码属性**不能为空）\n4. 空值的算术运算，比较运算和逻辑运算\n\n### 3.7 视图\n\n#### 3.7.1 定义视图\n\n1. 建立视图：\n```SQL\nCREATE VIEW<视图名>[(<列名>[,<列名>]…)]\nAS <子查询>\n[WITH CHECK OPTION];\n```\n- WITH CHECK OPTION；加上这句话后，以后对该视图进行插入，修改，删除操作时，自动加上满足视图定义的条件。\n- **行列子集视图**：<u>从单个基本表导出的，并且只去掉某些行和某些列，但保留了主码的视图</u>\n\n- 带表达式的视图：带虚拟列，如2019-Sage\n- 分组视图：带有聚集函数和group by 子句\n\n\n2. 删除视图\n`\nDROP VIEW<视图名>[CASCADE]；\n`\n\n#### 3.7.2 查询视图\n- 与基本表的查询相似\n- 视图消解：对视图查询时进行有效性检查，若存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成对基本表的查询，然后再执行修正了的查询\n\n#### 3.7.3 更新视图\n- 视图是不实际存储数据的虚表\n- 并不是所有的视图都是可更新的，一般的，行列子集视图是可更新的\n- DB2规定：\n(1)若视图是由两个以上基本表导出的,则此视图不允许更新\n(2)若视图的字段来自字段表达式或常数,则不允许对此视图执行 INSERT和 UPDATE操作,但允许执行 DELETE操作。\n(3)若视图的字段来自聚集函数,则此视图不允许更新。\n(4)若视图定义中含有 GROUP BY子句,则此视图不允许更新。\n(5)若视图定义中含有 DISTINCT短语,则此视图不允许更新\n(6)若视图定义中有嵌套查询,并且内层查询的FROM子句中涉及的表也是导出该视图的基本表,则此视图不允许更新。\n\n#### 3.7.4 视图的作用\n1. 视图能简化用户的操作\n2. 视图使用户能以多个角度看待统一数据\n3. 视图对重构数据库提供了一定程度的逻辑独立性\n4. 视图能够对机密数据提供安全保护\n5. 适当利用视图可以更清晰地表达查询\n\n## 第四章 数据库安全性\n\n### 4.1 数据库安全性概述\n\n- 数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露，更改或破坏\n\n#### 4.1.1 数据库的不安全因素\n1. 非授权用户对数据库的恶意存取和破坏\n措施：（1）用户身份鉴别（2）存取控制（3）视图\n2. 数据库中重要或敏感的数据被泄露\n措施：（1）强制存取控制（2）数据加密存储（3）加密传输（4）审计日志\n3. 安全环境的脆弱性\n\n#### 4.1.2 安全标准简介\n\n- TCSEC和CC\n- 四个方面描述安全性级别：安全策略，责任，保证，文档\n\n### 4.2 数据库安全性控制\n\n#### 4.2.1 用户身份鉴别\n\n1. 静态口令鉴别\n2. 动态口令鉴别\n3. 生物特征鉴别\n4. 智能卡鉴别\n\n#### 4.2.2 存取控制\n\n- 存取控制机制包括**定义用户权限**和**合法权限检查**两部分\n（1）定义用户权限：\n权限：用户对数据对象的操作权力称为权限，用户权限定义后经过编译存储再数据字典中，被称为安全规则或授权规则\n（2）合法权限检查：\n每当用户发出存取数据库的操作请求后(请求一般应包括操作类型、操作对象和操作用户等信息)数据库管理系统查找数据字典,根据<u>安全规则</u>进行<u>合法权限检查</u>,若用户的操作请求<u>超出了定义的权限</u>,系统将<u>拒绝</u>执行此操作。\n定义用户权限和合法权限检查机制一起组成了数据库管理系统的<u>存取控制子系统</u>\n- 在**自主存取控制**方法中,用户对于不同的数据库对象有不同的存取权限,不同的用户对同一对象也有不同的权限,而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。\n- 在**强制存取控制**方法中,每一个数据库对象被标以一定的密级,每一个用户也被授予某一个级别的许可证。对于任意一个对象,只有具有合法许可证的用户才可以存取。强制存取控制因此相对比较严格。\n\n#### 4.2.3 自主存取控制方法\n\n- 用户权限是由两个要素组成的：**数据库对象**和**操作类型**\n- 在数据库系统内，定义存取权限称为**授权**\n- 在关系数据库中，存取控制的对象不仅有数据本身，还有数据库模式\n- 关系数据库系统中的<u>**存取权限**</u>：\n\n（1）对于数据库模式：\n\n| 对象 |操作类型  |\n| --- | --- |\n| 模式 |create schema  |\n| 基本表 |create table，alter table  |\n| 视图 | create view |\n| 索引 |create index |\n\n（2）对于数据：\n\n| 对象 |操作类型  |\n| --- | --- |\n|基本表和视图  |select，insert，update，delete，references，all privileges  |\n|属性列  |select，insert，update，references，all privileges  |\n\n#### 4.2.4 授权：授予与收回\n\n- 在SQL中使用grant 和revoke语句向用户授予或收回对数据的操作权限\n1. GRANT\n- 一般格式为：\n```SQL\nGRANT  <权限>[，<权限>]...\non <对象类型> <对象名>[,<对象类型><对象名>]...\nto <用户> [，<用户>]...\n[with grant option]；\n```\n```SQL\ngrant select\non table Student\nto user1;\n```\n将指定操作对象的指定操作权限授予指定的用户。\n如果指定了with grant option子句，则获取某种权限的用户还可以把这种权限再授予其他的用户，没有则只能使用该权限。\n\n2. REVOKE\n- 一般格式：\n```SQL\nREVOKE <权限> [,<权限>]...\non <对象类型><对象名>[,<对象类型><对象名>]...\nfrom <用户>[,<用户>]...[cascade|restrict]；\n```\n```SQL\nrevoke select \non table Student\nfrom public;     /*收回所有用户对Student表的查询权限*/\n```\n- 用户可以“自主”地决定将数据的存取权限授予何人，决定是否也将“授权”的权限授予他人。因而称这样的存取控制是自主存取控制。\n\n3. 创建数据库模式的权限\n- 一般格式：\n```SQL\ncreate user <username> [ with ] [ DBA | RESOURCE | CONNECT ]\n```\n- 只有系统的超级用户才有权建立一个新的数据库用户\n- 新创建的数据库用户有三种权限：connect，resource，dba\n- 若没有指明权限，则默认该用户connect权限，不能创建新用户，不能创建模式，基本表，只能登陆数据库。\n- 拥有resource权限的用户能创建基本表和视图，并成为其属主，不能创建模式与新用户，属主可以使用grant语句\n- 拥有DBA权限的用户是系统中的超级用户\n\n#### 4.2.5 数据库角色\n- 数据库角色是被命名的一组与数据库操作相关的的权限，角色是权限的集合。\n1. 角色创建\n```SQL\ncreate role <角色名>\n```\n2. 给角色授权\n```SQL\ngrant <权限>[,<权限>]...\non <对象类型> 对象名\nto <角色> [,<角色>]\n```\n3. 将一个角色授予其他的角色或用户\n```SQL\ngrant <角色1>[,<角色2>]\nto <角色3>[,<用户1>]\n[with admin option]\n```\n4. 角色权限收回\n```SQL\nrevoke <权限>[,<权限>]...\non <对象类型> <对象名>\nfrom <角色>[,<角色>]...\n```\n\n#### 4.2.6 强制存取控制方法\n\n- 在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体。\n- 主体：系统中的活动实体，包括实际用户和用户的各进程\n- 客体：系统中的被动实体，包括文件，表，索引等\n- 敏感度标记：绝密→机密→可信→公开\n- 主体的敏感度标记：许可证级别\n- 客体的敏感度标记：密级\n\n### 4.3 视图机制\n\n- 通过视图机制把要保密的数据对无权存取的用户隐藏\n\n### 4.4 审计\n\n- 审计是数据库管理系统达到c2以上安全级别必不可少的一项指标。\n- 审计功能把用户对数据库的所有操作自动记录下来放入审计日志，审计员可以利用审计日志监控数据库的各种行为，重现导致现状的一系列事件。\n- 审计事件：（1）服务器事件（2）系统权限（3）语句事件（4）模式对象事件\n- 审计功能：（1）基本功能（2）多套审计规则（3）审计分析和报表（4）审计日志管理（5）查询审计设置及审计记录信息的专门视图\n- AUDIT语句和NOAUDIT语句\n```SQL\naudit alter,update\non SC;\n\nnoaudit alter,update\non SC;\n```\n\n### 4.5 *数据加密\n- 加密的基本思想是根据一定算法将**明文**变换为**密文**\n- 数据加密包括：\n（1）存储加密\n（2）传输加密\n\n### 4.6 *其他安全性保护\n- 除**自主存取控制**和**强制存取控制**外，还有**推理控制**，以及数据库应用中**隐蔽信道**和**数据隐私保护**等技术\n\n## 第五章 数据库完整性\n- 数据库的**完整性**是指<u>数据的**正确性**和**相容性。**</u>\n（1）正确性：数据符合现实世界语义\n（2）相容性：同一对象在不同关系表中符合逻辑\n- 注意完整性和安全性的联系与区别！\n- 如何维护完整性：\n（1）提供定义完整性约束条件的机制\n（2）提供完整性检查的方法\n（3）进行违约处理\n\n\n### 5.1 实体完整性\n\n#### 5.1.1 定义实体完整性\n\n- 主码不能为空\n```SQL\ncreate table student\n(no char(9) primary key,     /*列级定义主码*/\nname char(20) not null\n);\ncreate table student\n(no char(9),\nname char(20) not null，\nprimary key（no）            /*表级定义主码*/\n);\n```\n- **定义属性组为主码只能在表级定义**\n\n#### 5.1.2 实体完整性检查和违约处理\n1. 检查主码值是否唯一\n2. 检查主码的各个属性是否为空\n\n### 5.2 参照完整性\n#### 5.2.1 定义参照完整性\n- 使用references 指明外码参照的主码\n```SQL\ncreate table sc\n（no char（9） not null，\nname char（20）not null，\ngrade smallint，\nprimary key（no，name）\nforeign key（no）references student（no），\n）;\n```\n\n#### 5.2.2 参照完整性检查和违约处理\n1. 拒绝操作\n2. 级联操作\n3. 设置为空值\n\n\n### 5.3 用户定义的完整性\n\n#### 5.3.1 属性上的约束条件的定义\n- 包括：\n（1）列值非空（not null）\n（2）列值唯一（unique）\n（3）检查是否满足一个表达式（check）\n```SQL\ncreate table sc\n(no char(9) unique not null,\nname char(20),\nsex char(2) check(sex in ('男','女'))\n);\n```\n\n#### 5.3.2 元组上的约束条件\n- 定义：\n```SQL\ncreate table sc\n(no char(9) not null,\nname char(20),\nsex char(2),\nprimary key (no),\ncheck (sex='女' or name not like 'Ms.%')\n);\n```\n\n### 5.4 完整性约束命名子句\n1. 完整性约束名命子句\n```SQL\ncreate table student\n（\nno char(9)\n  constraint C1 check (no between 90000 and 99999),\nname char(20)\n  constraint C2 check not null\n）；\n```\n- constraint <完整性约束条件名> <完整性约束条件>\n2. 修改表中的完整性约束条件：\n```SQL\nalter table student\n    drop constraint C1;\nalter table student\n    add constraint C2 check(no between 100 and 100000)\n```\n\n### 5.6 断言\n- 通过声明性断言来指定更具一般性的约束。\n1. 创建断言的语句格式\n```SQL\ncreate assertion <断言名> <check 子句>\n```\n\n### 5.7 *触发器\n- 触发器：是用户定义在关系表上的一类由事件驱动的特殊过程。\n#### 5.7.1 定义触发器\n- 触发器又叫事件-条件-动作 规则\n- 一般格式：\n```SQL\nCREATE TRIGGER<触发器名>  /*每当触发事件发生时,该触发器被激活*/\n{BEFORE| AFTER}<触发事件>ON<表名>   \n                            /*指明触发器激活的时间是在执行触发事件前或后*/\nREFERENCING NEWOLD ROW AS<变量>\n                                /* REFERENCING指出引用的变量*/\nFOR EACH {ROW I STATEMENT}\n                                /*定义触发器的类型,指明动作体执行的频率*/\n[ WHEN <触发条件>]<触发动作体>\n                                /*仅当触发条件为真时才执行触发动作体*/\n```\n\n>(1)只有表的拥有者,即创建表的用户才可以在表上创建触发器,并且一个表上只能创建一定数量的触发器。触发器的具体数量由具体的关系数据库管理系统在设计时确定。\n(2)触发器名\n触发器名可以包含模式名,也可以不包含模式名。同一模式下,触发器名必须是唯一的,并且触发器名和表名必须在同一模式下。\n(3)表名\n触发器只能定义在基本表上,不能定义在视图上。当基本表的数据发生变化时,将激活定义在该表上相应触发事件的触发器,因此该表也称为触发器的目标表\n(4)触发事件\n触发事件可以是 INSERT、 DELETE或 UPDATE,也可以是这几个事件的组如\nINSERT OR DELETE等,还可以是 UPDATE OF<触发列,…>,即进一步指明修改哪些列时激活触发器。 AFTER/BEFORE是触发的时机。 AFTER表示在触发事件的操作执行之后激活触发器; BEFORE表示在触发事件的操作执行之前激活触发器。\n(5)触发器类型\n触发器按照所触发动作的间隔尺寸可以分为行级触发器( FOR EACH ROW)和语句级触发器( FOR EACH STATEMENT)\n6)触发条件\n触发器被激活时,只有当触发条件为真时触发动作体才执行,否则触发动作体不执行。如果省略WHEN触发条件,则触发动作体在触发器激活后立即执行。\n(7)触发动作体\n触发动作体既可以是一个匿名 PLSQL过程块也可以是对已创建存储过程的调用,如果是行级触发器,用户可以在过程体中使用NEW和OLD引用 UPDATE/INSERT事件之后的新值和 UPDATE/DELETE事件之前的旧值;如果是语句级触发器,则不能在触发动作体中使用NEW或OLD进行引用。\n如果触发动作体执行失败,激活触发器的事件(即对数据库的增、删、改操作)就会终止执行,触发器的目标表或触发器可能影响的其他对象不发生任何变化。\n\n```SQL\ncreate trigger insert_or_update_sal /*插入或更新时激活触发器*/\nbefore insert or update on Teacher /*before触发事件*/\nreferencing new row as newTuple \nfor each row                              /*这是行级触发器*/\nbegin                                       /*定义触发动作体*/\n    if(newtuple.Job='教授')and(newtuple.Sal<4000)\n        then newtuple.Sal :=4000;\n    end if;\nend;                                         /*触发动作体结束*/\n```\n- 删除触发器\ndrop trigger <触发器名> on <表名>;\n\n## 第六章 关系数据理论\n### 6.1 问题的提出\n- 1NF：每一个分量必须时不可分的数据项\n- 关系是关系模式在某一时刻的状态或内容\n- 关系模式是静态的\n\n### 6.2 规范化\n\n#### 6.2.1 函数依赖\n\n1. **函数依赖**：\n某个属性集决定另一个属性集时，称另一属性集依赖于该属性集，Y函数依赖于X，X函数决定Y记作：X→Y\n2. 函数依赖属于语义范畴\n3. 非平凡的函数依赖：X→Y，但Y不包含于X\n4. 平凡的函数依赖：X→Y，但Y包含于X\n5. 若X→Y，则称X为**决定因素**\n6. **完全函数依赖**：若X→Y，并且对于任意X的一个真子集x'，都有Y不函数依赖于x',则称Y完全函数依赖于X，\n否则为**部分函数依赖**\n7. 传递函数依赖：\n若X→Y（Y不包含于X），Y-/->X，Y→Z（Z不包含于Y），则称 Z对X**传递函数依赖**\n- 当B属性函数依赖于A属性是，属性A对B的联系是 <u>**多对1**</u> .\n\n#### 6.2.2 码\n1. 设K是R<U，F>中的属性或属性组，若U完全函数依赖于K，则K为R的候选码。\n2. 如果U函数依赖于K，即：K→U，则K称为超码\n3. 包含在任何一个候选码中的属性称为主属性\n，否则为非主（码）属性\n4. 整个属性组是码，称为全码\n\n#### 6.2.3 范式\n- 规范化：一个低一级范式的关系模式通过模式分解可以转化为若干个高一级范式的关系模式的集合\n- 规范化的过程主要是为了克服：**插入异常，删除异常，修改复杂**\n1. **1NF**：每一个分量必须是不可分的数据项\n2. **2NF**：若R∈1NF，且每一个非主属性完全函数依赖于任何我一个候选码\n3. **3NF**：在2NF基础上，任何非主属性不依赖于其它非主属性(在2NF基础上消除传递依赖)\n4. **BCNF**：\n（1）每一个决定因素都包含码\n（2）所有非主属性对每一个码都是完全函数依赖\n（3）所有主属性对每一个不包含它的码也是完全函数依赖\n（4）没有任何属性完全函数依赖于非码的任何一组属性\n5. 多值依赖：\n设R(U)是一个属性集U上的一个关系模式， X、 Y和Z是U的子集，并且Z＝U－X－Y，多值依赖 X→→Y成立当且仅当对R的任一关系r，r在（X，Z）上的每个值对应一组Y的值，这组值仅仅决定于X值而与Z值无关\n- 多值依赖具有对称性，传递性\n6. **4NF**：关系模式R<U，F>∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y 不包含于 X），X都含有候选码，则R∈4NF。\n- 4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖\n\n\n\n### 6.3 数据依赖的公理系统\n1.  **逻辑蕴含**\n    对于满足一组函数依赖 F 的关系模式R <U，F>，其任何一个关系r，若函数依赖X→Y都成立, 则称 F逻辑蕴含X →Y .\n2.  **Armstrong 公理系统**：\n关系模式R <U，F >来说有以下的推理规则：\nAl.自反律（Reflexivity）： 若Y ≦ X ≦ U，则X →Y为F所蕴含。\nA2.增广律（Augmentation）：若X→Y为F所蕴含，且Z ≦ U，则XZ→YZ为F所蕴含。\nA3.传递律（Transitivity）：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含。\n- 注意：由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F\n- 根据A1，A2，A3这三条推理规则可以得到下面三条**推理规则**：\n 合并规则：由X→Y，X→Z，有X→YZ。\n       （A2， A3）\n 伪传递规则：由X→Y，WY→Z，有XW→Z。\n       （A2， A3）\n 分解规则：由X→Y及 Z ≦ Y，有X→Z。\n       （A1， A3）\n3.  **闭包**:\n(1) 在关系模式R<U，F>中为F所逻辑蕴含的函数依赖的全体叫作 F的闭包，记为F+。\n(2) 设F为属性集U上的一组函数依赖，X ≦ U， XF+ ={ A|X→A能由F 根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F 的闭包。\n\n- 设F为属性集U上的一组函数依赖，X，Y ≦ U，X→Y能由F 根据Armstrong公理导出的充分必要条件是Y ≦ XF+\n\n4. **最小依赖集**：\n\n- <u>覆盖</u>：如果G+=F+，就说函数依赖集F覆盖G（F是G的覆盖，或G是F的覆盖），或F与G等价。\n- F+ = G+ 的充分必要条件是     ：F ≦ G+ ，和G  ≦  F+ \n- 如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集。亦称为最小依赖集或最小覆盖。\n     (1) F中任一函数依赖的右部仅含有一个属性。\n    (2) F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。\n    (3) F中不存在这样的函数依赖X→A， X有真子集Z使得F-{X→A∪{Z→A}与F等价。\n\n### 6.4 模式分解\n- 模式分解的等价定义\n（⒈）分解具有无损连接性\n（⒉）分解要保持函数依赖\n（⒊）分解既要保持函数依赖，又要具有无损连接性\n- 关系模式R<U,F>的一个分解：\nρ={ R1<U1,F1>，R2<U2,F2>，…，Rn<Un,Fn>}\n    U=U1∪U2∪…∪Un，且不存在  Ui  Uj，Fi 为 F在 Ui 上的投影\n- 函数依赖集合{X→Y | X→Y ≦ F+∧XY ≦Ui} 的一个覆盖 Fi 叫作 F 在属性 Ui 上的投影\n- 设关系模式R<U,F>被分解为若干个关系模式\n      R1<U1,F1>，R2<U2,F2>，…，Rn<Un,Fn> \n（其中U=U1∪U2∪…∪Un，且不存在Ui  Uj，Fi为F在Ui上的投影）。\n若F所逻辑蕴含的函数依赖一定也由分解得到的某个关系模式中的函数依赖Fi所逻辑蕴含，则称关系模式R的这个分解是保持函数依赖的(Preserve Dependency）\n- 判别一个分解的无损连接性\n- 转换为3NF的保持函数依赖的分解。（合成法）\n- 转换为3NF既有无损连接性又保持函数依赖的分解\n- 转换为BCNF的无损连接分解（分解法）\n- 达到4NF的具有无损连接性的分解\n\n\n- 对关系模式进行分解时，要求保持**函数依赖**，最高可以达到   <u>**3NF**</u> 。\n- <u>关系模式分解为BCNF后，**函数依赖关系可能被破坏**。</u>\n- 模式分解具有无损连接性和保持函数依赖的**两个互相独立的标准**。具有无损连接性的分解不一定保持函数依赖，保持函数依赖的分解不一定具有无损连接性\n\n## 第七章 数据库设计\n\n### 7.1 数据库设计概述\n\n1. 数据库设计：数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效的存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。\n\n#### 7.1.1 数据库设计的特点\n\n1. 数据库建设的基本规律：\n“三分技术，七分管理，十二分基础数据”\n- 强调了数据的收集，整理，组织和不断更新是数据库建设中的重要一环。\n2.结构（数据）设计和行为（处理）设计相结合\n\n#### 7.1.2 数据库设计方法\n\n- 计算机的基础知识\n- 软件工程的原理和方法\n- 程序设计的方法和技巧\n- 数据库的基础知识\n- 数据库设计技术\n- 应用领域的知识\n\n#### 7.1.3 数据库设计的基本步骤\n1. 需求分析：最困难，最耗时，设计过程的基础\n2. 概念设计：数据库设计的关键\n3. 逻辑结构设计：\n4. 物理结构设计：\n5. 数据库实施\n6. 数据库运行和维护\n\n\n| 设计阶段 |设计描述  |\n| --- | --- |\n|需求分析|数据字典，全系统数据项，数据结构，数据流，数据存储的描述|\n|概念结构设计  |概念模型（E-R图），数据字典  |\n|逻辑结构设计  |某种数据模型  |\n|物理结构设计  |存储安排，存取方法选择，存取路径建立  |\n|数据库实施 |创建数据库模式，数据载入，应用程序的编码和调试，运行  |\n|数据库运行和维护  |性能监测，转储/恢复，数据库重组，重构  |\n\n### 7.2 需求分析\n\n#### 7.2.1 需求分析的任务\n\n- 详细调查现实世界要处理的对象，充分了解工作概况，明确用户各种需求，在此基础上确定功能。\n- 调查重点是数据和处理，通过调查，收集，分析，获取用户对数据库的如下要求：\n（1）信息要求（内容和性质）\n（2）处理要求（处理性能）\n（3）安全性与完整性要求\n\n#### 7.2.2 需求分析的方法\n1. 调查机构情况\n2. 调查业务活动\n3. 协助用户明确要求\n4. 确定新系统边界\n\n#### 7.2.3 数据字典\n- 数据字典是进行详细的数据收集和数据分析所获得的主要成果。\n- 数据字典是关于数据库中数据的描述，即元数据，而不是数据本身。\n- 数据字典是在需求分析阶段建立，在数据库设计过程中不断修改，充实，完善的，在数据库设计中占有很重要的地位\n- 数据字典通常包括：数据项，数据结构，数据流，数据存储和处理过程。\n（1）数据项是**数据的最小组成单位**，数据项是**不可再分的数据单位**，若干数据项可以组成数据结构。\n（2）数据结构反映了数据之间的组合关系\n（3）数据流是数据结构在系统内传输的路径\n（4）数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。\n（5）处理过程的具体处理逻辑一般用判定表，判定树来描述\n\n### 7.3 概念结构设计\n\n#### 7.3.1 概念模型\n\n- 特点：\n（1）真实，充分反映现实世界\n（2）易于理解\n（3）易于更改\n（4）易于向关系，网状，层次等转化\n\n#### 7.3.2 E-R模型\n\n- 从数据流图构造E-R图时，选择实体一般应先考虑数据流图中的<u> **数据存储**</u> 。\n1. 实体之间的联系：1对1，1对多，多对多\n2. E-R图：\n（1）实体型用矩形\n（2）属性用椭圆形\n（3）联系用菱形\n3. 作为属性，不能再具有需要描述的性质\n4. 属性不能与其他实体具有联系\n5. E-R图之间的冲突有三类：\n（1）属性冲突：①属性域冲突②属性取值单位冲突\n（2）命名冲突：①同名异义②异名同义\n（3）结构冲突：\n    - ①同一对象在不同应用种具有不同的抽象\n    - ②同一实体在不同子系统的E-R图中所包含的属性个数和属性排列次序不完全相同\n    - ③实体间的联系在不同的E-R图中为不同的类型。\n\n### 7.4 逻辑结构设计\n\n#### 7.4.1 E-R图向关系模型的转化\n\n- 1:1联系的转换方法\n联系转换为一个独立的关系：与该联系相连的各实体的码以及联系\n本身的属性均转换为关系的属性，且每个实体的码均是该关系的候选码。\n将1:1联系与某一端实体集所对应的关系合并，则需要在被合并关系中增\n加属性，其新增的属性为联系本身的属性和与联系相关的另一个实体集的码。\n\n>联系形成的关系独立存在：\n>职工表（职工号，姓名，年龄）主码：职工号\n产品表（产品号，产品名，价格）主码：产品号\n负责（职工号，产品号）主码：职工号或产品号\n\n- 1:n联系的转换方法\n一种方法是将联系转换为一个独立的关系，其关系的属性由与该联系相连的各实体集的码以及联系本身的属性组成，而该关系的码为n端实体集的码；另一种方法是在n端实体集中增加新属性，新属性由联系对应的1端实体集的码和联系自身的属性构成，新增属性后原关系的码不变\n\n>联系形成的关系独立存在。\n>仓库（仓库号，地点，面积）主码：仓库号\n>产品（产品号，产品名，价格）主码：产品号\n>仓储（仓库号，产品号，数量）主码：产品号\n合并后方案：联系形成的关系与n端对象合并。\n仓库（仓库号，地点，面积）\n产品（产品号，产品名，价格，仓库号，数量）\n\n- m:n联系的转换方法\n在向关系模型转换时，一个m:n联系转换为一个关系。转换方法为：与该联系相连的各实体集的码以及联系本身的属性均转换为关系的属性，新关系的码为两个相连实体码的组合（该码为多属性构成的组合码）。\n\n>选课\n•该模型包含两个实体集（学生、课程）和一个m:n联系\n•该模型可转换为三个关系模式：\n学生（学号，姓名，性别，年龄）主码：学号\n课程（课程号，课程名，学分）主码：课程号\n选课（学号，课程号，成绩）主码：学号+课程号\n\n\n#### 7.4.2 数据模型的优化\n- 并不是规范化程度越高的关系就越优\n\n#### 7.4.3 设计用户子模式\n\n### 7.5 物理结构设计\n- 物理结构设计：为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程\n- 步骤：（1）确定数据库的物理结构（2）对物理结构进行评价\n\n#### 7.5.1 数据库物理设计的内容和方法\n- 内容主要包括：关系模式选择存取方法 ，以及设计关系，索引等数据库文件的物理存储结构\n\n#### 7.5.2 关系模式存取方法选择\n\n- 常用方法：索引方法和聚簇方法\n（1）B+树索引存取方法：索引并不是越多越好，会降低更新的效率\n（2）hash索引存取方法：选择条件①关系的大小不可知②关系大小动态改变\n（3）聚簇存取方法：  \n     - 聚簇：把这个或这些属性上具有相同值的元组集中放在连续的物理块中\n     - 该属性（组）称为聚簇码\n     - 建立和维护聚簇的开销相当大。聚簇码值要相对稳定，以减小开销\n\n#### 7.5.3确定数据库的存储结构\n- 考虑：存取时间，存储空间利用率，维护代价\n1. 确定数据存放位置\n2. 确定系统配置\n\n### 7.6 数据库的实施和维护\n\n#### 7.6.1 数据的载入和应用程序的调试\n- 两项重要工作：数据的载入，应用程序的编码和调试\n- 数据库应用程序的设计应该与数据库设计同时进行\n\n#### 7.6.2 数据库的试运行\n- 先输入小批量数据作调试用，带试运行基本合格后再大批量输入数据\n- 做好数据库的转储和恢复工作\n\n#### 7.6.3 数据库的运行和维护\n1. 数据库的转储和恢复\n2. 数据库的安全性，完整性控制\n3. 数据库性能的监督，分析和改造\n4. 数据库的重组织与重构造\n- 重组织不修改原设计的逻辑和物理结构\n- 重构造部分修改数据库的模式和内模式\n\n## 第八章 数据库编程（无）\n\n## 第九章 关系查询处理和查询优化\n\n### 9.1 关系数据库系统的查询处理\n\n#### 9.1.1 查询处理步骤\n- 四个阶段：**查询分析，查询检查，查询优化，查询执行**\n1. 查询分析：**语法检查**，对查询语句进行扫描，词法分析，语法分析\n2. 查询检查：\n（1）**语义检查**，根据数据字典中的模式定义和用户权限和完整性约束定义\n（2）检查通过后转化为等价的关系代数表达式\n（3）关系数据库管理系统一般都用**查询树**，也叫**语法分析树**\n3. 查询优化：\n（1）按照优化层次分为：代数优化，物理优化\n（2）代数优化策略是通过对<u>关系代数表达式</u>的<u>**等价变换**</u>来提高查询效率。\n（3）物理优化则是指存取路径和底层操作算法的选择。选择的依据：①基于规则②基于代价③基于语义\n4. 查询执行：依据优化器得到的执行策略生成查询执行计划\n\n#### 9.1.2 实现查询操作\n1. 选择操作的实现：一般采用全表扫描或者基于索引的算法\n2. 连接操作的实现：是查询处理中最常用也最耗时的操作之一，一般采用：嵌套循环算法，排序-合并算法，索引连接算法，hash join算法\n\n### 9.2 关系数据库系统的查询优化\n- 查询优化的优点不仅在于用户不必考虑如何更好的表达查询以获得较高效的效率，而且在于系统可以比用户程序的优化做得更好\n\n### 9.3 代数优化\n\n#### 9.3.1 关系代数表达式等价变换规则\n\n- <u>代数优化策略是通过对关系代数表达式的**等价变换**来提高查询效率</u>。\n- 常用代数优化策略：\n（1）连接，笛卡儿积的交换律\n（2）连接，笛卡儿积的结合律\n（3）投影的串接定律\n（4）选择的串接定律\n（5）选择与投影操作的交换律\n（6）选择与笛卡儿积的交换律\n（7）选择与并的分配律\n（8）选择与差运算的分配律\n（9）选择对自然连接的分配律\n（10）投影与笛卡儿积的分配律\n（11）投影与并的分配律\n\n#### 9.3.2 查询树的启发式优化\n1. <u>选择运算应尽可能先做</u>\n2. <u>把投影运算和选择运算同时进行</u>\n3. 把投影同其前或后的双目运算结合\n4. 把某些选择同它前面要执行的笛卡儿积结合起来成为一个连接运算\n5. 找出公共子表达式\n\n### 9.4 物理优化\n- 选择的方法：（1）基于规则的启发式优化（2）基于代价估算的优化（3）两者结合的优化\n\n## 第十章 数据库恢复技术\n\n### 10.1 事务的基本概念\n1. 事务\n- 事务：用户定义的一个**数据库操作序列**，这些<u>操作要么全做，要么全不做</u>，是一个不可分割的**工作单位**\n- 事务可以是一条或多条sql语句，一个或多个程序\n- 定义事务的语句：\n（1）begin transaction\n（2）commit\n（3）rollback\n- 事务以begin transaction 开始，以commit或rollback结束\n- commit 表示提交事务的所有操作，将事务中所有对象对数据库的更新写回到磁盘上的物理数据库中去\n- rollback 表示回滚，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态\n\n2. 事务的ACID特性\n- 四个特性：原子性，一致性，隔离性，持续性\n- 原子性：事务是数据库的逻辑工作单位\n- 一致性\n- 隔离性：一个事务的执行不被其他事务打扰\n- 持续性：**事务一旦提交，改变即永久**，也叫永久性\n\n### 10.2 数据库恢复概述\n- 从错误状态恢复到某一已知正确状态\n\n### 10.3 故障的种类\n1. **事务故障**：例如：并发事务发生**死锁**，**违反完整性**约束而被终止，**运算溢出**\n（1）多是非预期的，不能由应用程序处理的。\n（2）这类恢复操作成为事务撤销\n2. **系统故障**：例如：**cpu故障，os故障，DBMS代码故障，断电**\n（1）造成系统停止运转的任何事件\n（2）需要**重做**所有已提交的事务\n3. **介质故障**：例如：**磁盘损坏，磁头碰撞，瞬时强磁场干扰**\n- 系统故障称为软故障，介质故障称为硬故障，如外存故障\n4. **计算机病毒**\n\n---\n- 恢复的基本原理：**数据冗余**\n\n### 10.4 恢复的实现技术、\n- 建立**冗余数据**最常用的技术就是**数据转储**和**登记日志文件**\n\n#### 10.4.1 数据转储\n- 转储：数据库管理员定期地将数据库复制到其他存储介质上保存起来\n- 这些备用的数据叫做：**后备副本**\n- 转储分为静态转储和动态转储，还可分为海量转储和增量转储\n- 为恢复到某一时刻的正确状态需要把转储期间的<u>各事务对数据库的修改活动</u>登记下来，即建立：**日志文件**\n\n#### 10.4.2 登记日志文件\n1. 日志文件：用来记录事务对数据库的更新操作的文件\n2. 登记内容：事务的开始，结束，所有更新操作\n3. 内容：事务标记，操作类型，操作对象，更新前旧值，更新后新值\n4. 作用：事务故障恢复，系统故障恢复，协助后备副本进行介质故障恢复\n5. 登记日志文件注意：\n（1）登记次序严格按并发事务执行的事件次序\n（2）必须先写日志文件，后写数据库\n\n### 10.5 恢复策略\n\n#### 10.5.1 事务故障的恢复\n1. 务故故障是指事务在运行至正常终止点前被终止,这时恢复子系统应**利用日志文件撤销(UNDO)此事务已对数据库进行的修改**。事务故障的恢复是由系统自动完成的,对用户是透明的。\n- 系统的恢复步骤是：\n(1)反向扫描日志文件(即从最后向前扫描日志文件),查找该事务的更新操作。\n(2)对该事务的更新操作执行逆操作,即将日志记录中“更新前的值”写入数据库\n(3)继续反向扫描目志文佚,查找该事务的其他更新操作,并做同样处理。\n(4)如此处理下去,直至读到此事务的开始标记,事务故障恢复就完成了。\n\n#### 10.5.2 系统故障的恢复\n- 系统故障造成数据库不一致状态的原因有两个,一是未完成事务对数据\n库的更新可能已写入数据库,二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。因此恢复操作就是要**撤销故障发生时未完成的事务,重做已完成的事务**。\n- 系统故障的恢复是由系统在重新启动时自动完成的,不需要用户干预。\n- 系统的恢复步骤是:\n(1)正向扫描日志文件(即从头扫描日志文件),找出在故障发生前已经提交的事务，将其事务标记入重做队列( REDO-LIST)，同时找出故障发生时尚完成的事务（只有BEGIN 无commit），将其事务标识记撤销队列(UNDO-LIST)。\n(2)对撤销队列中的各个事务进行撤销(UNDO)处理\n进行撤销处理的方法是,反向扫描日志文件,对每个撤销事务的更新操作执行逆操作,即将日志记录中“更新前的值”写入数据库。\n(3)对重做队列中的各个事务进行重做处理\n进行重做处理的方法是:正向扫描日志文件,对每个重做事务重新执行日志文件登记的操作,即将日志记录中“更新后的值”写入数据库。\n\n#### 10.5.3 介质故障的恢复\n- 发生介质故障后,磁盘上的物理数据和日志文件被破坏,这是最严重的一种故障,恢复方法是**重装数据库,然后重做已完成的事务**。\n(1)装入最新的数据库后备副本(离故障发生时刻最近的转储副本),使数据库恢复到最近一次转储时的一致性状态\n- 对于动态转储的数据库副本,还需同时装入转储开始时刻的日志文件副本,利用恢复系统故障的方法(即REDO+UNDO),才能将数据库恢复到一致性状态。\n(2)装入相应的日志文件副本(转储结束时刻的日志文件副本),重做已完成的\n即首先扫描日志文件,找出故障发生时已提交的事务的标识,将其记入重做队列:然后正向扫描日志文件,对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。这样就可以将数据库恢复至故障前某一时刻的一致状态了。\n- 介质故障的恢复需要数据库管理员介入,但数据库管理员只需要重装最近转储的数据库副本和有关的各日志文件副本,然后执行系统提供的恢复命令即可,具体的恢复操作仍由数据库管理系统完成。\n\n### 10.6 具有检查点的恢复技术\n- 记录检查点( checkpoint)记录：增加一个重新开始文件,并让恢复子系统在登录日志文件期间动态地维护日志\n- 检查点记录内容：\n（1）建立检查点时刻所有正在执行的事务清单\n（2）这些事务最近一个日志记录的地址\n- 动态维护日志文件方法：周期性地执行建立检查点保存数据库状态的操作\n- 使用检查点的方法可以改善恢复效率\n\n### 10.7 *数据库镜像\n- 通过复制数据实现，用于数据库恢复\n\n## 第十一章 并发控制\n- 事务可以一个一个地串行执行，即每个时刻只有一个事务运行\n- 多处理机下，事务可以实现多个事务并行运行，即同时并发方式\n- 为保证多用户环境中数据的完整性和一致性，DBMS采用的控制称为**并发控制**\n\n### 11.1 并发控制概述\n1. **事务**是并发控制的基本单位\n2. 并发控制是对用户的**并发操作**加以控制和协调 \n3. 并发操作造成 <u>不一致性</u> 的问题包括：\n（1）**丢失修改**：\n    - 考虑飞机订票系统中的一个活动序列:\n>甲售票点（甲事务）读出某航班的机票余额A,设A=16.\n乙售票点（乙事务）读出同一航班的机票余额A,也为16.\n甲售票点卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库.\n乙售票点也卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库.\n结果明明卖出两张机票，数据库中机票余额只减少1。\n归纳起来就是：两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。\n\n（2）**不可重复读**：\n   - 不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。具体地讲，不可重复读包括三种情况：\n事务T1读取某一数据后，事务T2对其做了修改，当事务1再次读该数据时，得到与前一次不同的值。\n>例如，T1读取B=100进行运算，T2读取同一数据B，对其进行修改后将B=200写回数据库。T1为了对读取值校对重读B，B已为200，与第一次读取值不一致。\n事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神密地消失了。\n事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。（这也叫做幻影读） \n\n（3）**读“脏”数据**:\n   - 读\"脏\"数据是指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤消，这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，则T2读到的数据就为\"脏\"数据，即不正确的数据。\n4. 产生上述数据不一致性的**主要原因**是，**并发操作破坏了事务的隔离性**\n- 产生数据不一致性的**根本原因**是：**数据冗余**\n5. 并发控制的主要技术：\n（1）封锁\n（2）时间戳\n（3）乐观控制法\n（4）多版本并发控制\n\n### 11.2 封锁\n1. 封锁是实现并发控制的一个重要技术\n2. 封锁的类型：**排他锁（写锁），共享锁（读锁）**\n\n### 11.3 封锁协议\n- 三级封锁协议\n\n### 11.4 活锁和死锁\n\n#### 11.4.1 活锁\n- 避免活锁的简单方法是采用**先来先服务**的策略\n\n#### 11.4.2 死锁\n1. 死锁的预防：\n（1）一次封锁法\n（2）顺序封锁法\n2. 死锁的诊断与解除：\n诊断：\n（1）超时法\n（2）等待图法（DBMS普遍采用）\n解除：选择一个代价最小的事务，进行撤销\n\n### 11.5 并发调度的可串行性\n- 可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。\n- 可串行性：是并发事务正确调度的准则\n- **冲突可串行化调度**是可串行化调度的**充分条件**\n- **事务遵守两段锁协议**是可串行化调度的**充分条件**\n- 冲突操作是指不同的事物对同一数据的读写操作和写写操作\n- <u>遵守两段锁协议的事务也可能会死锁</u>\n\n### 11.6 两段锁协议\n- 第一阶段：封锁（扩展阶段）\n- 第二阶段：释放封锁（收缩阶段）\n- 事物遵守**两段锁协议**是可串行化调度的充分条件，而不是必要条件\n\n### 11.7 封锁的粒度\n- 封锁粒度：封锁对象的大小\n- 封锁对象可以是逻辑单元，也可以是物理单元\n- 封锁粒度与系统的**并发度**和并发控制的**开销**密切相关\n- 多粒度封锁：\n（1）显式封锁\n（2）隐式封锁\n- 意向锁：如果对一个结点加意向锁，则说明该节点的下层结点正在被加锁。\n分类：\n（1）意向共享锁（IS锁）\n（2）意向排他锁（IX锁）\n（3）共享意向排他锁（SIX锁）\n\n## 第十二章 *数据库管理系统（无）","tags":["大学课程","数据库"],"categories":["学习笔记"]},{"title":"Hexo博客 | 第一次搭建BLOG","slug":"博客相关-Hexo-第一次搭建BLOG","url":"/posts/33244.html","content":"\n这是我写的第一个blog，关于我怎么搭建这个blog\n\n# 第一次使用hexo搭建个人博客的步骤\n\n## 1 准备工作\n- 注册了github的账号\n- 安装了node.js和npm\n- 安装并配置了git\n\n## 2 创建仓库\n- 在github中创建了一个‘username.github.io’的仓库\n\n## 3 使用hexo\n- 安装hexo： $ npm install -g hexo\n- 初始化一个文件夹： \n\t- $ cd /e/hexo/\n\t- $ hexo init\n- 生成服务：$ hexo g\n- 启动服务：$ hexo s\n\t- 默认是localhost:4000\n- 因为自带的主题不好看，所以：\n\t-  $ cd /f/Workspaces/hexo/\n\t- $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n\t- 修改hexo根目录下的`_config.yml`中的\t`theme: landscape`改成`theme： yilia` ,(注意冒号：后面有一个空格),然后重新执行 hexo g\n\n- 修改hexo根目录下的文件`_config.yml`中的deploy：\n\t- deploy:\n\t\ttype： git\n\t\trepository： git@github.com:username/username.github.io.git\n\t\tbranch: master\n\n- 上传到github：$ hexo d -g\n\n- 查看blog: https://username.github.io\n\n## 写博客\n- hexo new 'first-blog'\n- hexo自动生成一个md文件，修改md内容\n\t- 头部如：\n\n```\n\t---\n\ttitle: postName #文章页面上的显示名称\n\tdate: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改\n\tcategories: 默认分类 #分类\n\ttags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意冒号:后面有个空格\n\tdescription: 摘要\n\t---\n```\n\t\t- 如果没有categories：$ hexo new page categories 然后修改生成的 index.md文件，添加`type: \"categories\"`\n\t\t- 如果没有tags同理\n\n","tags":["Hexo"],"categories":["博客相关"]}]