{"title":"大学课程 | 《微机原理与接口技术》笔记","slug":"学习笔记-微机原理与接口技术","date":"2020-09-05T10:05:39.000Z","updated":"2020-09-05T10:05:39.000Z","comments":true,"path":"api/articles/学习笔记-微机原理与接口技术.json","excerpt":"大学课程《微机原理与接口技术》学习笔记整理","covers":["https://npm.elemecdn.com/justlovesmile-img/20200605180344.png","https://npm.elemecdn.com/justlovesmile-img/20200605180420.png","https://npm.elemecdn.com/justlovesmile-img/20200605180737.png","https://npm.elemecdn.com/justlovesmile-img/20200626171551.png","https://npm.elemecdn.com/justlovesmile-img/20200626181818.png","https://npm.elemecdn.com/justlovesmile-img/20200626182906.png","https://npm.elemecdn.com/justlovesmile-img/20200626201755.png","https://npm.elemecdn.com/justlovesmile-img/20200626203308.png","https://npm.elemecdn.com/justlovesmile-img/20200626204137.png","https://npm.elemecdn.com/justlovesmile-img/20200626204453.png","https://npm.elemecdn.com/justlovesmile-img/20200626210751.png","https://npm.elemecdn.com/justlovesmile-img/20200627102608.png","https://npm.elemecdn.com/justlovesmile-img/20200627102624.png","https://npm.elemecdn.com/justlovesmile-img/20200627103549.png","https://npm.elemecdn.com/justlovesmile-img/20200627104125.png","https://npm.elemecdn.com/justlovesmile-img/20200829201509.png","https://npm.elemecdn.com/justlovesmile-img/20200627113916.png","https://npm.elemecdn.com/justlovesmile-img/20200627120345.png","https://npm.elemecdn.com/justlovesmile-img/20200627120517.png","https://npm.elemecdn.com/justlovesmile-img/20200627121105.png","https://npm.elemecdn.com/justlovesmile-img/20200627121240.png","https://npm.elemecdn.com/justlovesmile-img/20200627143039.png","https://npm.elemecdn.com/justlovesmile-img/20200627143427.png","https://npm.elemecdn.com/justlovesmile-img/20200627144642.png","https://npm.elemecdn.com/justlovesmile-img/20200627145513.png","https://npm.elemecdn.com/justlovesmile-img/20200907143459.png","https://npm.elemecdn.com/justlovesmile-img/20200627145857.png","https://npm.elemecdn.com/justlovesmile-img/8253-1.PNG","https://npm.elemecdn.com/justlovesmile-img/8255-1.PNG","https://npm.elemecdn.com/justlovesmile-img/8259-1.PNG","https://npm.elemecdn.com/justlovesmile-img/20200907141224.png"],"content":"<p>大学课程《微机原理与接口技术》学习笔记整理</p>\n<span id=\"more\"></span>\n\n<h1 id=\"第一章-微型计算机基础概论\"><a href=\"#第一章-微型计算机基础概论\" class=\"headerlink\" title=\"第一章 微型计算机基础概论\"></a>第一章 微型计算机基础概论</h1><h2 id=\"第一讲-关于\"><a href=\"#第一讲-关于\" class=\"headerlink\" title=\"第一讲 关于\"></a>第一讲 关于</h2><ul>\n<li>计算机的主要应用：数值计算，信息处理，过程控制</li>\n<li>微机原理与接口技术包括：数值信息表示，微型机基本原理，汇编程序设计，半导体存储器及其接口设计，输入输出技术</li>\n</ul>\n<h2 id=\"第二讲-微型计算机系统组成\"><a href=\"#第二讲-微型计算机系统组成\" class=\"headerlink\" title=\"第二讲 微型计算机系统组成\"></a>第二讲 微型计算机系统组成</h2><ul>\n<li>计算机系统：<ul>\n<li>硬件系统<ul>\n<li>主机系统：CPU，存储器，输入输出接口，总线</li>\n<li>外部设备</li>\n</ul>\n</li>\n<li>软件系统</li>\n</ul>\n</li>\n<li>能够与CPU直接进行信息交换的部件属于主机系统，不能够与CPU直接进行信息交换的部件属于外部设备</li>\n<li>CPU<ul>\n<li>微处理器简称CPU，是计算机的核心</li>\n<li>主要包括：运算器，控制器，寄存器组</li>\n</ul>\n</li>\n<li>存储器：<ul>\n<li>计算机中的记忆装置。用于存放计算机工作过程中需要操作的数据和程序</li>\n<li>内存储器 ：<ul>\n<li>存取速度较快，容量相对较小</li>\n<li>内存按单元组织，每单元都对应一个惟一的地址 </li>\n<li>每个内存单元中存放1Byte数据【每8位0或1称 为1字节（Byte）】</li>\n<li>内存单元个数称为内存容量</li>\n<li>按工作方式分类：随机存取存储器（RAM），只读存储器（ROM） </li>\n</ul>\n</li>\n<li>外存储器 <ul>\n<li>联机外存：硬磁盘 </li>\n<li>脱机外存：各种移动存储设备</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>输入/输出接口 <ul>\n<li>接口是CPU与外部设备间的桥梁</li>\n<li>主要功能：<ul>\n<li>数据缓冲寄存；</li>\n<li>信号电平或类型的转换；</li>\n<li>实现主机与外设间的运行匹配。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总线 <ul>\n<li>是一组导线和相关的控制、驱动电路的集合。</li>\n<li>是计算机系统各部件之间传输地址、数据和控制信息的通道 </li>\n<li>地址总线（AB） 数据总线（DB） 控制总线（CB） </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第三讲-微机工作过程\"><a href=\"#第三讲-微机工作过程\" class=\"headerlink\" title=\"第三讲 微机工作过程\"></a>第三讲 微机工作过程</h2><ul>\n<li>计算机的工作就是按照一定的顺序，一条条地执行指令</li>\n<li>指令： 由人向计算机发出的、能够为计算机所识别的命令 </li>\n<li>过程：<strong>取指令</strong>-&gt;<strong>分析指令</strong>-&gt;读取操作数-&gt;<strong>执行指令</strong>-&gt;存放结果 </li>\n<li>顺序执行： 一条指令执行完了再执行下一条指令。 <ul>\n<li>执行时间=取指令+分析指令+执行指令 </li>\n<li>设：三个部分的执行时间均为Δt，则：执行n条指令时间T0为：  </li>\n<li>T0=3nΔt </li>\n</ul>\n</li>\n<li>并行执行： 同时执行两条或多条指令。 <ul>\n<li>仅第1条指令需要3 Δt时间，之后每经过1 Δt，就有一条指令执行结束</li>\n<li>执行时间： T =3Δt +（ n-1）Δt </li>\n</ul>\n</li>\n<li>并行： 更高的效率，更高的复杂度 </li>\n<li>相对于顺序执行方式，指令并行执行的优势用加速比S表示： <ul>\n<li>S=顺序执行花费的时间/并行执行花费的时间 </li>\n<li>例： 3n Δt /（3Δt +（ n-1）Δt) =3n/（2+n） </li>\n</ul>\n</li>\n<li>冯 • 诺依曼计算机的工作原理: 存储程序工作原理,结构特点:运算器为核心 </li>\n<li>冯 • 诺依曼机的工作过程 <ul>\n<li>取一条指令的工作过程： <ul>\n<li>① 将指令所在地址赋给程序计数器PC； </li>\n<li>② PC内容送到地址寄存器AR，PC自动加1； </li>\n<li>③ 把AR的内容通过地址总线送至内存储器，经地址译码器译码，选中相应单元。 </li>\n<li>④ CPU的控制器发出读命令。 </li>\n<li>⑤ 在读命令控制下，把所选中单元的内容（即指令操作码）读到数据总线 DB。 </li>\n<li>⑥ 把读出的内容经数据总线送到数据寄存器DR。 </li>\n<li>⑦ 指令译码:数据寄存器DR将它送到指令寄存器IR，然后再送到指令译码器ID </li>\n</ul>\n</li>\n<li>特点： <ul>\n<li>程序存储，共享数据，顺序执行 </li>\n<li>属于顺序处理机，适合于确定的算法和数值数据的处理。</li>\n</ul>\n</li>\n<li>不足： <ul>\n<li>与存储器间有大量数据交互，对总线要求很高；</li>\n<li>执行顺序由程序决定，对大型复杂任务较困难；</li>\n<li>以运算器为核心，处理效率较低；</li>\n<li>由PC控制执行顺序，难以进行真正的并行处理。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>哈佛结构 <ul>\n<li>指令和数据分别存放在两个独立的存储器模块中； </li>\n<li>CPU与存储器间指令和数据的传送分别采用两组独立的总线；</li>\n<li>可以在一个机器周期内同时获得指令操作码和操作数。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第四讲-常用数制\"><a href=\"#第四讲-常用数制\" class=\"headerlink\" title=\"第四讲 常用数制\"></a>第四讲 常用数制</h2><ul>\n<li>计算机中的常用计数制：十进制 ，二进制数 ，十六进制数 ，八进制数 </li>\n</ul>\n<h2 id=\"第五讲-编码\"><a href=\"#第五讲-编码\" class=\"headerlink\" title=\"第五讲 编码\"></a>第五讲 编码</h2><ul>\n<li>编码：<ul>\n<li>信息从一种形式或格式转换为另一种形式的过程</li>\n<li>用代码来表示各种信息，以便于计算机处理。 </li>\n</ul>\n</li>\n<li>需要编码的信息种类：数值，字符，声音，图形，图像 </li>\n<li>所有需要由计算机处理的信息，都需要编码，使所有信息都以二进制码形式表示</li>\n<li>计算机中的编码 <ul>\n<li>数值编码：<ul>\n<li>二进制码</li>\n<li>BCD码 </li>\n</ul>\n</li>\n<li>西文字符编码<ul>\n<li>ASCII码 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>BCD（Binary Coded Decimal）码 <ul>\n<li>用二进制表示的十进制数</li>\n<li>特点： <ul>\n<li>保留十进制的权，数字用0和1表示。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>8421BCD编码： <ul>\n<li>用4位二进制码表示1位十进制数，每4位之间有一个空格 </li>\n<li>1010—1111是非法BCD码</li>\n<li>（0001 0001 .0010 0101）BCD    =11 .25    =（1011 .01）B </li>\n</ul>\n</li>\n<li>BCD码在计算机中的存储方式 <ul>\n<li>以压缩BCD码形式存放：<ul>\n<li>用4位二进制码表示1位BCD码</li>\n<li>一个存储单元中存放2位BCD数</li>\n</ul>\n</li>\n<li>以扩展BCD码形式存放 <ul>\n<li>用8位二进制码表示1位BCD码.即高4位为0，低4位为有效位 </li>\n<li>每个存储单元存放1位BCD </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ASCII码 <ul>\n<li>西文字符编码：将每个字母、数字、标点、控制符用1Byte二进制码表示 </li>\n<li>标准ASCII的有效位：7bit，最高位默认为0 </li>\n</ul>\n</li>\n<li>ASCII码的奇偶校验 <ul>\n<li>奇校验：加上校验位后编码中“1”的个数为奇数。</li>\n<li>偶校验：加上校验位后编码中“1”的个数为偶数。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第六讲-数及其运算\"><a href=\"#第六讲-数及其运算\" class=\"headerlink\" title=\"第六讲 数及其运算\"></a>第六讲 数及其运算</h2><ul>\n<li>定点数</li>\n<li>浮点数 <ul>\n<li>小数点的位置可以左右移动的数</li>\n<li>规格化浮点数：尾数部分用纯小数表示，即小数点右边第1位不为0 </li>\n</ul>\n</li>\n<li>无符号数</li>\n<li>有符号数：用最高位表示符号，其余是数值，0正，1负<ul>\n<li>原码：最高位为符号位，其余为真值部分<ul>\n<li>[X]原=符号位+|绝对值| </li>\n<li>有[+0]和[-0]之分</li>\n</ul>\n</li>\n<li>反码：<ul>\n<li>若X&gt;0 ，则 [X]反 = [X]原 </li>\n<li>若X&lt;0， 则 [X]反 = 对应原码的符号位不变，数值部分按位求反。</li>\n<li>有[+0]和[-0]之分</li>\n</ul>\n</li>\n<li>补码：<ul>\n<li>若X&gt;0， 则 [X]补 = [X]反= [X]原</li>\n<li>若X&lt;0， 则 [X]补 = [X]反+1 </li>\n<li>没有[+0]和[-0]之分</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>无符号整数的表示范围(n表示字长)： 0 ≤ X ≤ 2^n - 1</li>\n<li>有符号整数的表示范围： <ul>\n<li>原码和反码： -（2^(n-1) -1） ≤ X ≤ 2^(n-1) -1 </li>\n<li>补码： -2^(n-1) ≤ X ≤ 2^(n-1) -1 </li>\n<li>对8位二进制数：<ul>\n<li>原码： -127 ～+127</li>\n<li>反码： -127 ～+127</li>\n<li>补码： -128 ～+127 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第七讲-基本逻辑运算和逻辑门\"><a href=\"#第七讲-基本逻辑运算和逻辑门\" class=\"headerlink\" title=\"第七讲 基本逻辑运算和逻辑门\"></a>第七讲 基本逻辑运算和逻辑门</h2><ul>\n<li>逻辑，命题，推理</li>\n<li>基本逻辑运算：与或非</li>\n<li>逻辑运算是按位进行的运算，低位运算结果对高位运算不产生影响 </li>\n<li>算术运算是两个数之间的运算，低位运算结果将对高位运算产生影响</li>\n</ul>\n<h2 id=\"第八讲-基本逻辑运算及其门电路\"><a href=\"#第八讲-基本逻辑运算及其门电路\" class=\"headerlink\" title=\"第八讲 基本逻辑运算及其门电路\"></a>第八讲 基本逻辑运算及其门电路</h2><ul>\n<li>与非，或非，异或，同或</li>\n</ul>\n<h1 id=\"第二章-微处理器与总线\"><a href=\"#第二章-微处理器与总线\" class=\"headerlink\" title=\"第二章 微处理器与总线\"></a>第二章 微处理器与总线</h1><h2 id=\"第九讲-8088-8086微处理器\"><a href=\"#第九讲-8088-8086微处理器\" class=\"headerlink\" title=\"第九讲 8088/8086微处理器\"></a>第九讲 8088/8086微处理器</h2><ul>\n<li>8088/8086 CPU的特点 <ul>\n<li>采用并行流水线工作方式<ul>\n<li>通过设置指令预取队列实现</li>\n</ul>\n</li>\n<li>对内存空间实行分段管理<ul>\n<li>将内存分为4个段并设置地址段寄存器，以实现对1MB空间的寻址</li>\n</ul>\n</li>\n<li>支持协处理器</li>\n</ul>\n</li>\n<li>8088/8086可工作于两种模式下 <ul>\n<li>最小模式：单处理器模式，所有控制信号由微处理器产生<ul>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200605180344.png\"></li>\n</ul>\n</li>\n<li>最大模式：最大模式为多处理器模式，部分控制信号由外部总线控制器产生 <ul>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200605180420.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十讲-8088的主要引线及其内部结构\"><a href=\"#第十讲-8088的主要引线及其内部结构\" class=\"headerlink\" title=\"第十讲 8088的主要引线及其内部结构\"></a>第十讲 8088的主要引线及其内部结构</h2><ul>\n<li>8088最小模式下的主要引脚信号<ul>\n<li>完成一次访问内存或接口所需要的主要信号</li>\n<li>与外部同步控制信号</li>\n<li>中断请求和响应信号</li>\n<li>总线保持和响应信号<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200605180737.png\"></li>\n</ul>\n</li>\n<li>主要控制信号<ul>\n<li>WR：  写信号；</li>\n<li>RD：  读信号；</li>\n<li>IO/M：为“0”表示访问内存，为“1”表示访问接口；</li>\n<li>DEN： 低电平有效时，允许进行读/写操作；</li>\n<li>DT/R：数据收发器的传送方向控制；</li>\n<li>ALE：  地址锁存信号；</li>\n<li>RESET：复位信号。 </li>\n</ul>\n</li>\n<li>中断请求和响应信号<ul>\n<li>INTR：可屏蔽中断请求输入端</li>\n<li>NMI： 非屏蔽中断请求输入端 </li>\n<li>INTA：中断响应输出端 </li>\n</ul>\n</li>\n<li>总线保持信号<ul>\n<li>HOLD：总线保持请求信号输入端。当CPU以外的其他设备要求占用总线时，通过该引脚向CPU发出请求。</li>\n<li>HLDA：总线保持响应信号输出端。CPU对HOLD信号的响应信号。 </li>\n</ul>\n</li>\n<li>微处理器读取一条指令的控制过程<ul>\n<li>1.发出读取数据所在的目标地址<ul>\n<li>内存储器单元地址</li>\n<li>I/O接口地址 </li>\n</ul>\n</li>\n<li>2.发出读控制信号</li>\n<li>3.送出传输的数据 </li>\n</ul>\n</li>\n<li>地址线和数据线：<ul>\n<li>20位地址信号(20根地址线)–》可产生2^20=1M个编码 </li>\n<li>8位数据信号(8位数据线)–》可同时传输8bit二进制码 </li>\n</ul>\n</li>\n<li>8088内部结构：<ul>\n<li>执行单元EU<ul>\n<li>构成：运算器，8个通用寄存器，1个标志寄存器，EU部分控制电路</li>\n<li>功能：指令译码，指令执行，暂存中间运算结果，保存运算结果特征 </li>\n</ul>\n</li>\n<li>总线接口单元BIU<ul>\n<li>功能：</li>\n<li>从内存中取指令到指令预取队列，指令预取队列是并行流水线工作的基础</li>\n<li>负责与内存或输入/输出接口之间的数据传送</li>\n<li>在执行转移程序时，BIU使指令预取队列复位，从指定的新地址取指令，并立即传给执行单元执行。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指令预取队列的存在使EU和BIU两个部分可同时进行工作 </li>\n<li>8088和8086CPU引线功能比较 <ul>\n<li>数据总线宽度不同：8088的外部总线宽度是8位，8086为16位。 </li>\n<li>访问存储器和输入输出控制信号含义不同：8088——IO/M=0表示访问内存；8086——IO/M=1表示访问内存。 </li>\n<li>其他部分引线功能的区别 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十一讲-8088CPU内部寄存器\"><a href=\"#第十一讲-8088CPU内部寄存器\" class=\"headerlink\" title=\"第十一讲 8088CPU内部寄存器\"></a>第十一讲 8088CPU内部寄存器</h2><ul>\n<li>含14个16位寄存器，按功能可分为三类： <ul>\n<li>8个通用寄存器<ul>\n<li>数据寄存器（AX，BX，CX，DX）</li>\n<li>地址指针寄存器（SP，BP）</li>\n<li>变址寄存器（SI，DI） </li>\n</ul>\n</li>\n<li>4个段寄存器</li>\n<li>2个控制寄存器  </li>\n</ul>\n</li>\n<li>通用寄存器：<ul>\n<li>数据寄存器：8088/8086含4个16位数据寄存器，它们又可分为8个8位寄存器，即： <ul>\n<li>AX——-AH，AL：累加器，所有I/O指令都通过AX与接口传送信息，中间运算结果也多放于AX中； </li>\n<li>BX——-BH，BL：基址寄存器,在间接寻址中用于存放基地址</li>\n<li>CX——-CH，CL：计数寄存器,用于在循环或串操作指令中存放计数值</li>\n<li>DX——-DH，DL：数据寄存器,在间接寻址的I/O指令中存放I/O端口地址；在32位乘除法运算时，存放高16位数。 </li>\n</ul>\n</li>\n<li>地址指针寄存器:<ul>\n<li>SP：堆栈指针寄存器，其内容为栈顶的偏移地址 </li>\n<li>BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址。 </li>\n</ul>\n</li>\n<li>变址寄存器 <ul>\n<li>SI：源变址寄存器</li>\n<li>DI：目标变址寄存器</li>\n<li>变址寄存器在指令中常用于存放数据在内存中的地址。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>BX与BP在应用上的区别 <ul>\n<li>作为通用寄存器，二者均可用于存放数据；</li>\n<li>作为基址寄存器，用BX表示所寻找的数据在数据段；用BP 则表示数据在堆栈段。 </li>\n</ul>\n</li>\n<li>段寄存器:<ul>\n<li>作用:用于存放相应逻辑段的段基地址</li>\n<li>8086/8088内存中逻辑段的类型<ul>\n<li>代码段: 存放指令代码</li>\n<li>数据段: 存放操作的数据</li>\n<li>附加段: 存放附加的操作的数据</li>\n<li>堆栈段: 存放暂时不用但需保存的数据。 </li>\n</ul>\n</li>\n<li>CS:代码段寄存器，存放代码段的段基地址。</li>\n<li>DS:数据段寄存器，存放数据段的段基地址。</li>\n<li>ES:附加段寄存器，存放附加段的段基地址。</li>\n<li>SS:堆栈段寄存器，存放堆栈段的段基地址 </li>\n<li>段寄存器的值表明相应逻辑段在内存中的位置 </li>\n</ul>\n</li>\n<li>控制寄存器：<ul>\n<li>指令指针控制寄存器IP</li>\n<li>状态标志寄存器FLAGS<ul>\n<li>状态标志位：<ul>\n<li>CF:进位标志位。加(减)法运算时，若最高位有进(借)位则CF=1</li>\n<li>OF:溢出标志位。当算术运算的结果超出了有符号数的可表达范围时，OF=l</li>\n<li>ZF:零标志位。当运算结果为零时ZF=1</li>\n<li>SF:符号标志位。当运算结果的最高位为1时，SF=l</li>\n<li>PF:奇偶标志位。运算结果的低8位中“1”的个数为偶数时PF=l</li>\n<li>AF:辅助进位标志位。加(减)操作中，若Bit3(D3)向Bit4(D4)有进位(借位)， AF=1</li>\n</ul>\n</li>\n<li>控制标志位：<ul>\n<li>TF:单步陷阱标志位，也叫跟踪标志位。TF=1时，使CPU处于单步执行指令的工作方式。</li>\n<li>IF:中断允许标志位。IF=1时，CPU可以响应中断请求。</li>\n<li>DF:方向标志位。在数据串操作时确定操作的方向。 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十二讲-实模式下的存储器寻址\"><a href=\"#第十二讲-实模式下的存储器寻址\" class=\"headerlink\" title=\"第十二讲 实模式下的存储器寻址\"></a>第十二讲 实模式下的存储器寻址</h2><ul>\n<li>存储单位地址及其内容表示<ul>\n<li>若X表示某个单元地址，则[X]表示X单元的内容</li>\n<li>例如：[0004H]=34H代表34存放在4号单元，而[0004H]=1234H，代表34存放在4号单元，12存放在5号单元</li>\n</ul>\n</li>\n<li>字的存储<ul>\n<li>占连续两个字节（16位）</li>\n<li>低对低，高对高</li>\n<li>用低位地址来表示字的地址</li>\n</ul>\n</li>\n<li>规则存放，非规则存放<ul>\n<li>8088：数据总线8位，每次传送1个字节</li>\n<li>8086：数据总线16位<ul>\n<li>字：16位，规则字，以偶地址开始存放</li>\n<li>字节： 高8位传送奇地址，低8位传送偶地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内存储器管理<ul>\n<li>8088CPU是16位体系结构的微处理器</li>\n<li>可以同时处理16位二进制码</li>\n<li>8088CPU需要管理1MB内存</li>\n</ul>\n</li>\n<li>分段技术<ul>\n<li>分为若干个逻辑段，取内地址，用16位表示，每段最大64KB</li>\n<li>对段首地址（物理地址）规定，段首地址低4位为0，例如：00000H,00010H,FFFF0H</li>\n<li>段地址：段的起始地址的高16位</li>\n<li>偏移地址：段内相对于段的起始地址的偏移量（字节数）</li>\n</ul>\n</li>\n<li>实地址模式下的存储器地址变换<ul>\n<li>内存物理地址由段基地址和偏移地址组成</li>\n<li>物理地址=段基地址×16+偏移地址</li>\n</ul>\n</li>\n<li>内存地址变换<ul>\n<li>内存单元编址<ul>\n<li>段（基）地址</li>\n<li>段内地址（相对地址/偏移地址）</li>\n</ul>\n</li>\n<li>存储器的编址<ul>\n<li>段（基）地址</li>\n<li>相对地址（偏移地址）</li>\n<li>逻辑段的起始地址称为段首，段首的偏移地址0000H</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>段寄存器：<ul>\n<li>作用：用于存放相应逻辑段的段基地址</li>\n<li>8086/8088内存中逻辑段的类型<ul>\n<li>代码段==&gt;CS（代码段寄存器）<ul>\n<li>CS×16+IP</li>\n</ul>\n</li>\n<li>数据段==&gt;DS（数据段寄存器）<ul>\n<li>DS×16+偏移地址</li>\n</ul>\n</li>\n<li>附加段==&gt;ES（附加段寄存器）<ul>\n<li>ES×16+偏移地址</li>\n</ul>\n</li>\n<li>堆栈段==&gt;SS（堆栈段寄存器）<ul>\n<li>SS×16+SP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>8086/8088内存中每类逻辑段的数量最多64K个</li>\n</ul>\n</li>\n<li>逻辑段与逻辑地址<ul>\n<li>内存的分段式逻辑分段，不是物理段</li>\n<li>两个逻辑段可以完全重合或部分重合</li>\n</ul>\n</li>\n<li>堆栈及堆栈段的使用<ul>\n<li>堆栈： <ul>\n<li>内存中一个特殊区域，用于存放暂时不用或需要保护的数据。</li>\n<li>常用于响应中断或子程序调用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626171551.png\"></p>\n<h2 id=\"第十三讲-8088-系统总线\"><a href=\"#第十三讲-8088-系统总线\" class=\"headerlink\" title=\"第十三讲 8088 系统总线\"></a>第十三讲 8088 系统总线</h2><ul>\n<li>总线时序<ul>\n<li>CPU工作时序<ul>\n<li>CPU各引脚信号在时间上的关系</li>\n</ul>\n</li>\n<li>总线周期<ul>\n<li>CPU完成一次访问内存（或接口）操作所需要的时间</li>\n<li>8086的基本总线周期为4个时钟周期，每个时钟周期间隔称为一个T状态（8086/8088：5MHz时钟信号，时钟周期T=200ns）<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626181818.png\"></li>\n<li>T1 状态：BIU将RAM或I/O地址放在地址/数据复用             总线（AD）上。</li>\n<li>T2 状态：   <ul>\n<li>读总线周期： A/D总线为接收数据做准备。改变线路的方向。</li>\n<li>写总线周期： A/D总线上形成待写的数据，且保持到总线周期的结束(T4)。</li>\n</ul>\n</li>\n<li>T3, T4:对于读或写总线周期，AD总线上均为数据。</li>\n<li>Tw: 当RAM或I/O接口速度不够时，T3与 T4 之间可插入等待状态 Tw 。</li>\n<li>Ti : 当BIU无访问操作数和取指令的任务时，8086不执行总线操作，总线周期处于空闲状态 Ti 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总线：<ul>\n<li>按层次结构分类：<ul>\n<li>CPU总线</li>\n<li>系统总线</li>\n<li>外部总线</li>\n</ul>\n</li>\n<li>按传送信息的类别分类：<ul>\n<li>地址总线</li>\n<li>数据总线</li>\n<li>控制总线</li>\n</ul>\n</li>\n<li>按总线在微机系统的位置分类：<ul>\n<li>片内总线</li>\n<li>片间总线</li>\n<li>系统总线</li>\n<li>通信总线</li>\n</ul>\n</li>\n<li>总线的基本功能<ul>\n<li>数据传送</li>\n<li>仲裁控制</li>\n<li>出错处理</li>\n<li>总线驱动</li>\n</ul>\n</li>\n<li>总线的主要性能指标<ul>\n<li>总线带宽（B/S）<ul>\n<li>单位时间内总线上可传送的数据量</li>\n<li>总线带宽=位宽×工作频率</li>\n</ul>\n</li>\n<li>总线位宽（bit）<ul>\n<li>能同时传送的数据位数</li>\n</ul>\n</li>\n<li>总线的工作频率（MHz）<ul>\n<li>总线带宽=（位宽/8）×（工作频率/每个存储周期的时钟数）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>引脚信号设计特点<ul>\n<li>分时复用，如引脚AD0-AD15<ul>\n<li>如何实现：增加地址锁存器</li>\n<li>8282三位锁存器</li>\n<li>8286八位数据收发器</li>\n</ul>\n</li>\n<li>两种工作模式复用<ul>\n<li>最大模式</li>\n<li>最小模式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"第三章-指令系统概述\"><a href=\"#第三章-指令系统概述\" class=\"headerlink\" title=\"第三章 指令系统概述\"></a>第三章 指令系统概述</h1><h2 id=\"第十四讲-8088-8086指令系统\"><a href=\"#第十四讲-8088-8086指令系统\" class=\"headerlink\" title=\"第十四讲 8088/8086指令系统\"></a>第十四讲 8088/8086指令系统</h2><ul>\n<li>指令：控制计算机完成某种操作的命令</li>\n<li>指令系统：处理器所能识别的所有指令的集合</li>\n<li>指令的兼容性：同一系列机的指令都是兼容的</li>\n<li>一条指令应包含的信息：<ul>\n<li>运算数据的来源</li>\n<li>运算结果的去向</li>\n<li>执行的操作</li>\n</ul>\n</li>\n<li>指令格式<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626182906.png\"></li>\n<li>指令中的操作数<ul>\n<li>立即数：参加操作的数据本身，可以是8位或16位，只能作为源操作数，无法作为目标操作数<ul>\n<li><code>MOV AX, 1234H</code></li>\n</ul>\n</li>\n<li>寄存器：数据存放地址<ul>\n<li><code>MOV AX, BX</code></li>\n</ul>\n</li>\n<li>存储器：数据存放地址<ul>\n<li>参加运算的数存放在存储器的某一个或两个单元中</li>\n<li>表现形式： [操作数在内存中的偏移地址]</li>\n<li><code>MOV AL, [1200H]</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十五讲-指令的寻址方式\"><a href=\"#第十五讲-指令的寻址方式\" class=\"headerlink\" title=\"第十五讲 指令的寻址方式\"></a>第十五讲 指令的寻址方式</h2><ul>\n<li><p>操作数可能的来源或运算结果可能的去处：</p>\n<ul>\n<li>由指令直接给出</li>\n<li>寄存器</li>\n<li>内存单元</li>\n</ul>\n</li>\n<li><p>寻找操作数所在地址的方法可以有三种大类型：</p>\n<ul>\n<li>指令直接给出的方式</li>\n<li>存放于寄存器中的寻址方式</li>\n<li>存放于存储器中的寻址方式</li>\n</ul>\n</li>\n<li><p>1.直接寻址：</p>\n<ul>\n<li>指令中直接给出操作数的偏移地址</li>\n<li>直接寻址方式下，操作数默认为在数据段，但允许段重设，即由指令给出所在逻辑段。 </li>\n<li><code>MOV AX，ES：[1200H]</code>  ES：段重设符</li>\n</ul>\n</li>\n<li><p>2.寄存器间接寻址</p>\n<ul>\n<li>操作数存放在内存中，数据在内存中的偏移地址为方括号中通用寄存器的内容</li>\n<li>仅有4个通用寄存器可用于存放数据的偏移地址，<code>BX</code>，<code>BP</code>，<code>SI</code>，<code>DI</code><ul>\n<li>若使用<code>BX</code>,<code>SI</code>,<code>DI</code>，则操作数在数据段<code>DS</code>中<ul>\n<li>物理地址=DS×16+{BX/SI/DI}</li>\n</ul>\n</li>\n<li>若使用<code>BP</code>，则操作数在堆栈段<code>SS</code>中<ul>\n<li>物理地址=SS×16+BP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>间接寻址的一般格式：[ 间址寄存器 ] </li>\n<li>例： <code>MOV AX，[BX]</code></li>\n<li>可以段重设</li>\n</ul>\n</li>\n<li><p>3.寄存器相对寻址</p>\n<ul>\n<li>操作数的偏移地址为寄存器的内容加上一个位移量</li>\n<li>相对寻址主要用于一维数组的操作</li>\n<li><code>MOV AX，[BX+DATA]</code></li>\n</ul>\n</li>\n<li><p>4.基址、变址寻址</p>\n<ul>\n<li>操作数的偏移地址为<ul>\n<li>一个基址寄存器的内容 + 一个变址寄存器的内容；</li>\n</ul>\n</li>\n<li>操作数的<strong>段地址由选择的基址寄存器决定</strong><ul>\n<li>基址寄存器为<code>BX</code>，默认在数据段<code>DS</code></li>\n<li>基址寄存器为<code>BP</code>，默认在堆栈段<code>SS</code></li>\n</ul>\n</li>\n<li>基址变址寻址方式与相对寻址方式一样，主要用于一维数组操作。 </li>\n</ul>\n</li>\n<li><p>5.基址、变址、相对寻址</p>\n<ul>\n<li>操作数的偏移地址为：<ul>\n<li>基址寄存器内容+变址寄存器内容+位移量</li>\n</ul>\n</li>\n<li>操作数的段地址由选择的基址寄存器决定。</li>\n<li>基址变址相对寻址方式主要用于二维表格操作。</li>\n<li>例如：<code>MOV AL, [BP][DI]5</code>==&gt;也可以表示为<code>[BP+DI+5]</code></li>\n</ul>\n</li>\n<li><p>6.隐含寻址</p>\n<ul>\n<li>指令中隐含了一个或两个操作数的地址，即操作数在默认的地址中。</li>\n<li>例：<ul>\n<li><code>MUL BL</code></li>\n</ul>\n</li>\n<li>指令执行：<ul>\n<li><code>AL×BL--&gt;AX</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>I/O端口寻址方式</p>\n<ul>\n<li>直接端口寻址<ul>\n<li>由指令提供一个8位端数（0-255）</li>\n</ul>\n</li>\n<li>间接端口寻址<ul>\n<li>由DX寄存器给出，寻址64KB</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626201755.png\"></p>\n<h2 id=\"第十六讲-数据传送指令\"><a href=\"#第十六讲-数据传送指令\" class=\"headerlink\" title=\"第十六讲 数据传送指令\"></a>第十六讲 数据传送指令</h2><ul>\n<li>8086指令系统从功能上包括六大类：<ul>\n<li>数据传送</li>\n<li>算术运算</li>\n<li>逻辑运算和移位</li>\n<li>串操作</li>\n<li>程序控制</li>\n<li>处理器控制</li>\n</ul>\n</li>\n<li>数据传送类指令<ul>\n<li>1.通用数据传送指令<ul>\n<li>一般数据传送指令<ul>\n<li><code>MOV</code></li>\n<li>格式：<code>MOV dest,src</code></li>\n<li>操作：<code>src-&gt;dest</code></li>\n<li>例子：<code>MOV AL, BL</code></li>\n<li>注意点：两操作数字长必须相同；两操作数不允许同时为存储器操作数；两操作数不允许同时为段寄存器；在源操作数是立即数时，目标操作数不能是段寄存器；IP和CS不作为目标操作数，FLAGS一般也不作为操作数在指令中出现。 </li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626203308.png\"></li>\n</ul>\n</li>\n<li>堆栈操作指令<ul>\n<li>先进后出，以字为单位</li>\n<li>压栈：<code>PUSH OPRD</code> 16位寄存器或存储器两单元</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626204137.png\"></li>\n<li>出栈：<code>POP OPRD</code></li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626204453.png\"></li>\n<li>指令的操作数必须是16位；操作数可以是寄存器或存储器两单元，但不能是立即数；不能从栈顶弹出一个字给CS；PUSH和POP指令在程序中一般成对出现；PUSH指令的操作方向是从<code>高地址向低地址</code>，而POP指令的操作正好相反。 </li>\n<li>堆栈指针寄存器SP指向栈顶位置</li>\n</ul>\n</li>\n<li>交换指令<ul>\n<li>格式：<code>XCHG REG，MEM/REG</code></li>\n<li>注：两操作数必须有一个是寄存器操作数;不允许使用段寄存器。</li>\n<li>例：<code>XCHG AX, BX</code>,<code>XCHG [2000], CL</code></li>\n</ul>\n</li>\n<li>查表转换指令<ul>\n<li>格式：<code>XLAT</code></li>\n<li>说明：用BX的内容代表表格首地址，AL内容为表内位移量，BX+AL得到要查找元素的偏移地址</li>\n<li>操作：将BX+AL所指单元的内容送AL（将BX为首地址的,偏移地址为AL的内容送给AL。）</li>\n</ul>\n</li>\n<li>字位扩展指令 <ul>\n<li>将符号数的符号位扩展到高位；</li>\n<li>指令为零操作数指令，采用隐含寻址，隐含的操作数为AX及AX，DX</li>\n<li>无符号数的扩展规则为在高位补0</li>\n<li>字节到字：<code>CBW</code>，将AL内容扩展到AX ，若AL最高位=1，则执行后AH=FFH，若AL最高位=0，则执行后AH=00H 。AL不变（即将AL的符号位移至AH）<ul>\n<li>CBW属符号扩展指令，它可以把8位扩展到16位，扩展前后两数的真值不变，主要用于数据类型不同时用符号扩展指令可以使得数据类型相同。</li>\n</ul>\n</li>\n<li>字到双字：<code>CWD</code>，将AX内容扩展到DX AX ，若AX最高位=1，则执行后DX=FFFFH，若AX最高位=0，则执行后DX=0000H<ul>\n<li>CWD的作用是将带符号的16位整数（AX）转为32位的带符号位的整数(DX:AX),例如：AX=0xFFFE, 转为32位带符号位的整数时，DX=0xFFFF,AX=0XFFFE.又例如：AX=0x0002,转为带符号位的整数时DX=0x0000,AX=0x0002.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.输入输出指令<ul>\n<li>从端口地址读入数据到累加器/将累加器的值输出到端口中 </li>\n<li>指令格式：<ul>\n<li>输入指令： <code>IN acc，PORT</code></li>\n<li>输出指令 ：<code>OUT PORT，acc</code></li>\n</ul>\n</li>\n<li>根据端口地址码的长度，指令具有两种不同的端口地址表现形式：直接寻址，间接寻址</li>\n</ul>\n</li>\n<li>3.地址传送指令<ul>\n<li><code>LEA</code>取偏移地址指令<ul>\n<li>将变量的16位偏移地址写入到目标寄存器</li>\n<li><code>LEA REG,SRC</code></li>\n</ul>\n</li>\n<li><code>LDS</code>指令<ul>\n<li><code>LDS</code>（Load pointer using DS）的一般格式：</li>\n<li><code>LDS 通用寄存器，存储器操作数(32位)</code></li>\n</ul>\n</li>\n<li><code>LES</code>指令<ul>\n<li><code>LDS</code>和<code>LES</code>均用于将一个32位的远地址指针写入到目标寄存器。</li>\n<li><code>LES</code>（Load pointer using ES）的一般格式：</li>\n<li><code>LES 通用寄存器，存储器操作数(32位)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>4.标志传送指令<ul>\n<li>隐含操作数AH,将FLAGS的低8位装入AH <ul>\n<li><code>LAHF</code>（Load AH from Flags）</li>\n<li><code>SAHF</code>（Store AH into Flags）</li>\n</ul>\n</li>\n<li>隐含操作数FLAGS<ul>\n<li><code>PUSHF</code>（Push flags onto stack）</li>\n<li><code>POPF</code>（Pop flags off stack）</li>\n</ul>\n</li>\n<li>除标志传送指令外，其它指令的执行对标志位不产生影响</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"第四章-算术运算，逻辑运算与移位操作指令\"><a href=\"#第四章-算术运算，逻辑运算与移位操作指令\" class=\"headerlink\" title=\"第四章 算术运算，逻辑运算与移位操作指令\"></a>第四章 算术运算，逻辑运算与移位操作指令</h1><h2 id=\"第十七讲-算术运算类指令\"><a href=\"#第十七讲-算术运算类指令\" class=\"headerlink\" title=\"第十七讲 算术运算类指令\"></a>第十七讲 算术运算类指令</h2><ul>\n<li>加法运算指令<ul>\n<li>1.<code>ADD</code>加法指令<ul>\n<li>格式：<code>ADD OPRD1，OPRD2</code></li>\n<li>操作：<code>OPRD1+OPRD2--&gt;OPRD1</code></li>\n<li>ADD指令的执行对全部6个状态标志位都产生影响</li>\n</ul>\n</li>\n<li>2.<code>ADC</code>带进位的加法指令<ul>\n<li><code> OPRD1+OPRD2+CF--&gt;OPRD1</code></li>\n</ul>\n</li>\n<li>3.<code>INC</code>加1指令<ul>\n<li>格式：<code>INC OPRD</code></li>\n<li>操作：<code>OPRD+1--&gt;OPRD</code></li>\n<li>常用于在程序中修改地址指针,OPRD不能是段寄存器,不能是立即数，除CF外，影响其他标志位</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>减法运算指令<ul>\n<li>1.普通减法指令<code>SUB</code><ul>\n<li>格式：<code>SUB OPRD1，OPRD2</code></li>\n<li>操作：<code>OPRD1- OPRD2--&gt;OPRD1</code></li>\n<li>对标志位的影响与ADD指令同</li>\n</ul>\n</li>\n<li>2.考虑借位的减法指令<code>SBB</code><ul>\n<li>操作：<code>OPRD1- OPRD2- CF--&gt;OPRD1</code></li>\n</ul>\n</li>\n<li>3.减1指令<code>DEC</code><ul>\n<li>格式：<code>DEC OPRD</code></li>\n<li>操作：<code>OPRD - 1--&gt;OPRD</code></li>\n<li>除了不影响CF外，影响其他标志位</li>\n</ul>\n</li>\n<li>4.比较指令<code>CMP</code><ul>\n<li>格式：    <code>CMP OPRD1，OPRD2</code></li>\n<li>操作：<code>OPRD1- OPRD2</code></li>\n<li>指令执行的结果不影响目标操作数，仅影响标志位！</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626210751.png\"></li>\n</ul>\n</li>\n<li>5.求补指令<code>NEG</code><ul>\n<li><code>NEG OPRD</code></li>\n<li>操作：<code>0-OPRD--&gt;OPRD</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>乘法指令<ul>\n<li>乘法指令采用隐含寻址，隐含的是存放被乘数的累加器AL或AX及存放结果的AX，DX； </li>\n<li>1.无符号的乘法指令MUL<ul>\n<li><code>MUL OPRD</code>不能是立即数和段寄存器</li>\n<li>操作：<ul>\n<li>OPRD为字节数<code>AL×OPRD--&gt;AX</code></li>\n<li>OPRD为16位数<code>AX×OPRD--&gt;DX,AX</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.带符号的乘法指令IMUL <ul>\n<li>格式：<code>IMUL OPRD</code></li>\n<li>指令格式及对操作数的要求与MUL指令相同。</li>\n<li>指令执行原理：<ul>\n<li>① 将两个操作数取补码（对负数按位取反加1，正数不变）；</li>\n<li>② 做乘法运算；</li>\n<li>③ 将乘积按位取反加1。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>除法指令<ul>\n<li>1.无符号除法指令<ul>\n<li>格式： <code>DIV OPRD</code></li>\n<li>操作：<ul>\n<li>操作数是字节(8位)：<code>AX/OPRD</code>,商–&gt;AL,余数–&gt;AH</li>\n<li>操作数是字(16位)：<code>DX,AX/OPRD</code>,商–&gt;AX,余数–&gt;DX</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.有符号除法指令<ul>\n<li>格式： <code>IDIV OPRD</code></li>\n<li>指令格式及对操作数的要求与DIV指令相同。</li>\n</ul>\n</li>\n<li>注：<ul>\n<li>余数符号与被除数相同</li>\n<li>范围<ul>\n<li>双字/字：商范围 -32768到+32767</li>\n<li>字/字节：商范围 -128到+127</li>\n<li>超过范围按除数为0处理，产生0号中断<br>算术运算指令的执行大多对状态标志位会产生影响</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十八讲-逻辑运算指令\"><a href=\"#第十八讲-逻辑运算指令\" class=\"headerlink\" title=\"第十八讲 逻辑运算指令\"></a>第十八讲 逻辑运算指令</h2><ul>\n<li>逻辑运算指令<ul>\n<li>对操作数的要求：<ul>\n<li>大多与MOV指令相同。</li>\n<li>“非”运算指令要求操作数不能是立即数；</li>\n</ul>\n</li>\n<li>对标志位的影响<ul>\n<li>除“非”运算指令，其余指令的执行都会影响除<code>AF</code>外的5个状态标志；</li>\n<li>无论执行结果如何，都会使标志位<code>OF=CF=0</code>。</li>\n<li>“非”运算指令的执行不影响标志位。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>1.”与”指令<ul>\n<li>格式：<code>AND OPRD1，OPRD2</code></li>\n<li>操作：两操作数相“与”，结果送目标地址。<code>(OPRD1)∧(OPRD2)--&gt;(OPRD1)</code></li>\n<li>CF=0,OF=0,SF,ZF,PF有影响，对AF无影响</li>\n</ul>\n</li>\n<li>2.”或”指令<ul>\n<li>格式：<code>OR OPRD1，OPRD2</code></li>\n<li>操作：两操作数相“或”，结果送目标地址 </li>\n</ul>\n</li>\n<li>3.”非”指令<ul>\n<li>格式：<code>NOT OPRD</code></li>\n<li>操作：操作数按位取反再送回原地址</li>\n</ul>\n</li>\n<li>4.”异或”指令<ul>\n<li>格式：<code>XOR OPRD1，OPRD2</code></li>\n<li>操作：两操作数相“异或”，结果送目标地址 </li>\n</ul>\n</li>\n<li>5.”测试”指令<ul>\n<li>格式：<code>TEST OPRD1，OPRD2</code></li>\n<li>操作：执行“与”运算，但运算的结果不送回目标地址。</li>\n<li>应用：常用于测试某些位的状态 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十九讲-移位操作指令\"><a href=\"#第十九讲-移位操作指令\" class=\"headerlink\" title=\"第十九讲 移位操作指令\"></a>第十九讲 移位操作指令</h2><ul>\n<li>移位操作指令<ul>\n<li>控制二进制位向左或向右移动的指令<ul>\n<li>非循环移位指令</li>\n<li>循环移位指令</li>\n</ul>\n</li>\n<li>移动移动1位时由指令直接给出；移动两位及以上时，移位次数必须由CL指定</li>\n</ul>\n</li>\n<li>1.非循环移位指令<ul>\n<li>逻辑左移<code>SHL</code><ul>\n<li>格式： <code>SHL OPR,CNT</code></li>\n<li>注：<ul>\n<li>OPR不能是立即数和段寄存器操作数</li>\n<li>CNT移位次数，若为1，直接写在指令中，若为几，必须先写入CL中</li>\n<li>对CF，OP，PF,ZF，SF有影响，对AF无意义</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>算术左移<code>SAL</code><ul>\n<li>格式：<code>SAL OPR,CNT</code></li>\n<li>操作同<code>SHL</code></li>\n</ul>\n</li>\n<li>逻辑右移<code>SHR</code><ul>\n<li>格式：<code>SHR OPR,CNT</code></li>\n</ul>\n</li>\n<li>算术右移<code>SAR</code><ul>\n<li>格式：<code>SAR OPR,CNT</code></li>\n<li>操作：左边补上符号位，和之前的符号一样</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.循环移位指令<ul>\n<li>不带进位位的循环移位<ul>\n<li>左移 <code>ROL</code><ul>\n<li>格式： <code>ROL OPR,CNT</code></li>\n</ul>\n</li>\n<li>右移 <code>ROR</code><ul>\n<li>格式： <code>ROR OPR,CNT</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>带进位位的循环移位<ul>\n<li>左移 <code>RCL</code><ul>\n<li>格式： <code>RCL OPR,CNT</code></li>\n</ul>\n</li>\n<li>右移 <code>RCR</code><ul>\n<li>格式： <code>RCR OPR,CNT</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"第五章-串操作指令\"><a href=\"#第五章-串操作指令\" class=\"headerlink\" title=\"第五章 串操作指令\"></a>第五章 串操作指令</h1><h2 id=\"第二十讲-串操作指令\"><a href=\"#第二十讲-串操作指令\" class=\"headerlink\" title=\"第二十讲 串操作指令\"></a>第二十讲 串操作指令</h2><ul>\n<li>针对数据块或字符串的操作 </li>\n<li>可实现存储器到存储器的数据传送； </li>\n<li>待操作的数据串称为源串，目标地址称为目标串。 </li>\n<li>串操作指令的操作对象是多个字节数（一串字符或数据），因此，指令的执行需要确定：<ul>\n<li>串所在的区域<ul>\n<li>源串一般存放在数据段，偏移地址由SI指定。允许段重设。</li>\n<li>目标串必须在附加段，偏移地址由DI指定</li>\n</ul>\n</li>\n<li>串的首地址（原串、目标串起始地址）</li>\n<li>串长度（大小）<ul>\n<li>串长度值由CX指定 </li>\n</ul>\n</li>\n<li>串的操作方向<ul>\n<li>由DF标志位决定。指令根据DF状态自动修改地址指针<ul>\n<li>DF=0 增地址方向 </li>\n<li>DF=1 减地址方向 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>通过增加重复前缀， 可以实现对CX值的自动修改 <ul>\n<li> 无条件重复</li>\n<li>REP<ul>\n<li>当CX≠0时，REP后的指令将继续重复执行</li>\n<li>常用于传送类指令前–》未传完则继续传送 </li>\n</ul>\n</li>\n<li>条件重复<ul>\n<li>相等（为零）重复：REPE（REPZ）</li>\n<li>CX≠0  ∩  ZF=1，则前缀后的指令将继续重复执行</li>\n<li>不相等（不为零）重复：REPNE（ REPNZ）</li>\n<li>CX≠0  ∩  ZF=0，则前缀后的指令将继续重复执行 </li>\n<li>条件前缀常用于运算类指令前，当：<ul>\n<li>1）操作未结束  AND  结果=0</li>\n<li>2）操作未结束  AND  结果≠0 使其后的指令继续重复执行。 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>串操作指令 <ul>\n<li>串传送 <code>MOVS</code> </li>\n<li>串比较 <code>CMPS</code> </li>\n<li>串扫描 <code>SCAS</code> </li>\n<li>串装入 <code>LODS</code> </li>\n<li>串送存 <code>STOS</code> </li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627102608.png\"></p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627102624.png\"></p>\n<h2 id=\"第二十一讲-串传送与串比较指令\"><a href=\"#第二十一讲-串传送与串比较指令\" class=\"headerlink\" title=\"第二十一讲 串传送与串比较指令\"></a>第二十一讲 串传送与串比较指令</h2><p>1.串传送指令</p>\n<ul>\n<li>功能：将原数据串传送到目标地址</li>\n<li>格式：<ul>\n<li><code>MOVS OPRD1，OPRD2</code></li>\n<li><code>MOVSB</code>,按字节传送</li>\n<li><code>MOVSW</code>，按字传送</li>\n</ul>\n</li>\n<li>串传送指令常与无条件重复前缀连用</li>\n</ul>\n<p>2.串比较指令</p>\n<ul>\n<li>功能：用于实现两个数据串的比较</li>\n<li>操作：<ul>\n<li>目标串-源串，结果不写回目标地址</li>\n<li>常与条件重复前缀连用</li>\n</ul>\n</li>\n<li>格式：<ul>\n<li><code>CMPS OPRD1，OPRD2</code></li>\n<li><code>CMPSB</code></li>\n<li><code>CMPSW</code></li>\n</ul>\n</li>\n<li>前缀的操作对标志位不影响</li>\n</ul>\n<h2 id=\"第二十二讲-串扫描指令\"><a href=\"#第二十二讲-串扫描指令\" class=\"headerlink\" title=\"第二十二讲 串扫描指令\"></a>第二十二讲 串扫描指令</h2><ul>\n<li><p>格式：</p>\n<ul>\n<li><code>SCAS OPRD</code></li>\n<li><code>SCASB</code></li>\n<li><code>SCASW</code></li>\n</ul>\n</li>\n<li><p>执行与CMPS指令相似的操作，区别是：这里的源操作数是AX或AL</p>\n</li>\n<li><p>串扫描指令应用例：</p>\n<ul>\n<li>在ES段中从2000H单元开始存放了10个字符，寻找其中有无字符“A”。若有则记下搜索次数，将搜索次数写入到DATA1单元，并将存放“A”的地址写入DATA2单元。</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627103549.png\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十三讲-串装入与串存储指令\"><a href=\"#第二十三讲-串装入与串存储指令\" class=\"headerlink\" title=\"第二十三讲 串装入与串存储指令\"></a>第二十三讲 串装入与串存储指令</h2><p>1.串装入指令</p>\n<ul>\n<li>格式：<ul>\n<li><code>LODS OPRD</code></li>\n<li><code>LODSB</code></li>\n<li><code>LODSW</code></li>\n</ul>\n</li>\n<li>操作：<ul>\n<li>对字节：AL  [DS:SI]</li>\n<li>对  字：AX  [DS:SI]</li>\n</ul>\n</li>\n</ul>\n<p>2.串存储指令</p>\n<ul>\n<li><p>格式：</p>\n<ul>\n<li><code>STOS OPRD</code></li>\n<li><code>STOSB</code></li>\n<li><code>STOSW</code></li>\n</ul>\n</li>\n<li><p>操作：</p>\n<ul>\n<li>对字节： AL  [ES:DI]</li>\n<li>对  字： AX  [ES:DI]</li>\n</ul>\n</li>\n<li><p>串操作指令应用注意事项:</p>\n<ul>\n<li>需要定义附加段<ul>\n<li>目标操作数必须在附加段</li>\n</ul>\n</li>\n<li>需要设置数据的操作方向<ul>\n<li>确定DF的状态</li>\n</ul>\n</li>\n<li>源串和目标串指针分别为SI和DI</li>\n<li>串长度值必须由CX给出</li>\n<li>注意重复前缀的使用方法<ul>\n<li>传送类指令前加无条件重复前缀</li>\n<li>串比较类指令前加条件重复前缀，但前缀不影响ZF状态 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"第六章-程序与处理器控制指令\"><a href=\"#第六章-程序与处理器控制指令\" class=\"headerlink\" title=\"第六章 程序与处理器控制指令\"></a>第六章 程序与处理器控制指令</h1><h2 id=\"第二十四讲-程序控制指令\"><a href=\"#第二十四讲-程序控制指令\" class=\"headerlink\" title=\"第二十四讲 程序控制指令\"></a>第二十四讲 程序控制指令</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627104125.png\"></p>\n<ul>\n<li>程序控制类指令<ul>\n<li>转移指令<ul>\n<li>通过修改指令的偏移地址或段地址及偏移地址实现程序的转移</li>\n<li>无条件转移指令–&gt;无条件转移到目标地址<ul>\n<li><code>JMP OPRD</code></li>\n<li>段内直接转移<ul>\n<li>当偏移量为8位时，称为段内直接短跳转<ul>\n<li>格式：<code>JMP (SHORT) 标号</code></li>\n<li>操作：<code>(IP)&lt;--disp8+(IP)</code></li>\n</ul>\n</li>\n<li>当偏移量为8位时，称为段内直接近跳转<ul>\n<li>格式：<code>JMP (NEAR PTR) 标号</code></li>\n<li>操作：<code>(IP)&lt;--disp16+(IP)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>段内间接转移<ul>\n<li><code>JMP BP</code><ul>\n<li>转向(SS):(BP)</li>\n</ul>\n</li>\n<li><code>JMP BX</code><ul>\n<li>转向(CS):(BX)</li>\n</ul>\n</li>\n<li><code>JMP (WORD PTR) [BX][DI]</code><ul>\n<li>转向(CS):(BX)+(DI)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>段间直接转移<ul>\n<li><code>JMP (FAR PTR) 标号</code></li>\n<li>执行该指令时，将把标号所在的段的值送CS，将标号在所属段内的偏移量送IP，从而形成新的转移地址CS:IP</li>\n</ul>\n</li>\n<li>段间间接转移<ul>\n<li><code>JMP DWORD PTR [BX]</code></li>\n<li>中间的<code>DWORD PTR</code>不能省略，表示存储器双字操作数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>条件转移指令–&gt;当具备一定条件时转移到目标地址<ul>\n<li><code>JC/JNC</code><ul>\n<li>判断CF的状态。常用于两个无符号数大小比较</li>\n</ul>\n</li>\n<li><code>JZ/JNZ</code><ul>\n<li>判断ZF的状态。常用于循环体的结束判断</li>\n</ul>\n</li>\n<li><code>JO/JNO</code><ul>\n<li>判断OF的状态。常用于有符号数溢出的判断</li>\n</ul>\n</li>\n<li><code>JP/JNP</code><ul>\n<li>判断PF的状态。用于判断运算结果低8位中1的个数是否为偶数</li>\n</ul>\n</li>\n<li><code>JS /JNS</code><ul>\n<li>判断SF的状态。常用于判断数的性质 </li>\n</ul>\n</li>\n<li><code>JA/JAE/JB/JBE</code><ul>\n<li>判断CF或CF+ZF的状态。常用于无符号数大小的比较</li>\n</ul>\n</li>\n<li><code>JG/JGE/JL/JLE</code><ul>\n<li>判断SF+OF或SF+OF+ZF的状态。常用于有符号数大小的比较</li>\n</ul>\n</li>\n<li><code>JCXZ</code><ul>\n<li>可根据指令执行后CX的结果实现转移<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200829201509.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>循环控制<ul>\n<li><code>LOOP</code><ul>\n<li>条件：CX≠0</li>\n</ul>\n</li>\n<li><code>LOOPZ</code><ul>\n<li>条件：CX≠0，且ZF=1</li>\n</ul>\n</li>\n<li><code>LOOPNZ</code><ul>\n<li>条件：CX≠0，且ZF=0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>过程调用<ul>\n<li>用于调用一个子过程，必须保护返回地址 </li>\n<li>调用指令的执行过程<ul>\n<li>① 保护断点：将调用指令的下一条指令的地址（断点）压入堆栈</li>\n<li>② 获取子过程的入口地址：子过程第1条指令的偏移地址</li>\n<li>③ 执行子过程：功能实现，参数的保存及恢复</li>\n<li>④ 恢复断点，返回原程序：将断点偏移地址由堆栈弹出 </li>\n</ul>\n</li>\n<li>段内调用：被调用程序与调用程序在同一代码段<ul>\n<li><code>CALL NEAR PROCC</code></li>\n</ul>\n</li>\n<li>段间调用:子过程与原调用程序不在同一代码段</li>\n<li>返回指令:<ul>\n<li>功能：从堆栈中弹出断点地址，返回原程序</li>\n<li>格式：<code>RET</code></li>\n<li>子程序的最后一条指令必须是RET</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>中断控制<ul>\n<li>中断的概念:某种异常或随机事件使处理器暂时停止正在运行的程序，转去执行一段特殊处理程序，并在处理结束后返回原程序被中断处继续执行的过程。</li>\n<li>中断指令：引起CPU产生一次中断的指令 <ul>\n<li>格式：<code>INT n</code></li>\n<li>说明： nх4</li>\n</ul>\n</li>\n<li>中断指令的执行过程<ul>\n<li>① 将FLAGS压入堆栈；</li>\n<li>② 将INT指令的下一条指令的CS、IP压栈；</li>\n<li>③ 由n×4得到存放中断向量的地址；</li>\n<li>④ 将中断向量（中断服务程序入口地址）送CS和IP寄存器；</li>\n<li>⑤ 转入中断服务程序</li>\n</ul>\n</li>\n<li>中断返回指令:<ul>\n<li>格式：<code>IRET</code></li>\n<li>中断服务程序的最后一条指令，负责：恢复断点;恢复标志寄存器内容</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十五讲-处理器控制指令\"><a href=\"#第二十五讲-处理器控制指令\" class=\"headerlink\" title=\"第二十五讲 处理器控制指令\"></a>第二十五讲 处理器控制指令</h2><ul>\n<li>这类指令用来对CPU进行控制，如修改标志寄存器，使CPU暂停，使CPU与外部设备同步等。<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627113916.png\"></li>\n</ul>\n<h1 id=\"第七章-汇编语言\"><a href=\"#第七章-汇编语言\" class=\"headerlink\" title=\"第七章 汇编语言\"></a>第七章 汇编语言</h1><h2 id=\"第二十六讲-汇编语言程序设计\"><a href=\"#第二十六讲-汇编语言程序设计\" class=\"headerlink\" title=\"第二十六讲 汇编语言程序设计\"></a>第二十六讲 汇编语言程序设计</h2><ol>\n<li>汇编语言源程序与汇编程序<br>（1）汇编语言源程序：用助记符编写<br>（2）汇编程序：源程序的编译程序</li>\n<li>汇编语言程序设计与执行过程<br>（1）输入汇编语言源程序：源文件.ASM<br>（2）汇编MASM：目标文件.OBJ<br>（3）链接LINK：可执行文件.EXE<br>（4）调试TD：最终程序</li>\n<li>汇编语言语句类型和格式<br>（1）语句类型：指令性语句，指示性语句<br>（2）语句格式：<br>指令性语句：<code>[标号：] [前缀] 助记符 [操作数]，[操作数] [ ；注释] </code><br>指示性语句格式： <code>[名字] 伪指令助记符 操作数 [，操作数，…] [ ；注释] </code></li>\n<li>汇编语言语句中的操作数<br>(1)寄存器<br>(2)存储器单元<br>(3)常量:（数字/字符串）<br>(4)变量或标号<br>(5)表达式 ：算术运算；逻辑运算；关系运算；取值运算（<code>OFFSET</code>,<code>SEG</code>）和属性运算(<code>PTR</code>)；其它运算 </li>\n</ol>\n<h2 id=\"第二十七讲-数据定义伪代码\"><a href=\"#第二十七讲-数据定义伪代码\" class=\"headerlink\" title=\"第二十七讲 数据定义伪代码\"></a>第二十七讲 数据定义伪代码</h2><ol>\n<li>数据定义伪指令<br>（1）用于定义数据区中变量的类型及其所占内存空间大小<br>（2）DB（Define Byte）:定义的变量为字节型<br>（3）DW （Define Word） :定义的变量为字类型<br>（4）DD （Define Double Word） :定义的变量为双字型<br>（5）DQ （Define Quadword） :定义的变量为4字型<br>（6）DT （Define Tenbytes） :定义的变量为10字节型</li>\n<li>重复操作符<br>（1）当同样的操作数重复多次时，可以使用重复操作符<br>（2）作用：为一个数据区的各单元设置相同的初值<br>（3）格式：[变量名] 伪指令助记符 n DUP（初值 [,初值,… ] ）<br>（4）例：<code>M1 DB 10 DUP（0）</code></li>\n<li>“？”的作用<br>（1）表示随机值，用于预留存储空间<br>（2）例：<code>MEM1 DB 34H，’A’，？</code>，例：<code>DW 20 DUP（？）</code></li>\n<li>调整偏移量伪指令<br>（1）规定程序或变量在逻辑段中的起始地址<br>（2）格式：<code>ORG 表达式</code><br>（3）例：<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA <span class=\"meta\">SEGMENT</span></span><br><span class=\"line\">ORG <span class=\"number\">1200H</span></span><br><span class=\"line\">BUFF <span class=\"built_in\">DB</span> <span class=\"number\">1</span>,<span class=\"number\">2</span></span><br><span class=\"line\">DATA ENDS </span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"第二十八讲-符号与段定义相关伪指令\"><a href=\"#第二十八讲-符号与段定义相关伪指令\" class=\"headerlink\" title=\"第二十八讲 符号与段定义相关伪指令\"></a>第二十八讲 符号与段定义相关伪指令</h2><ol>\n<li>符号定义伪指令<br>（1）将表达式的值赋给一个名字。当源程序中需多次引用某一表达式时，可以利用EQU伪指令，用一个符号代替表达式，以便于程序维护。<br>（2）格式：<code>符号名 EQU 表达式</code><br>（3）操作：用符号名取代后边的表达式，不可重新定义<br>（4）例：<code>CONSTANT EQU 100 </code></li>\n<li>段定义伪指令<br>（1）在汇编语言源程序中定义逻辑段<br>说明逻辑段的起始和结束<br>说明不同程序模块中同类逻辑段之间的联系形态<br>（2）格式：<code>段名 SEGMENT [定位类型] [组合类型] [’类别’] </code></li>\n<li>设定段寄存器伪指令<br>（1）说明所定义逻辑段的性质<br>（2）格式：<code>ASSUME 段寄存器名:段名[，段寄存器名:段名，…] </code></li>\n<li>结束伪指令<br>（1）表示源程序结束<br>（2）格式：<code>END [标号] </code></li>\n</ol>\n<h2 id=\"第二十九讲-其他伪指令\"><a href=\"#第二十九讲-其他伪指令\" class=\"headerlink\" title=\"第二十九讲 其他伪指令\"></a>第二十九讲 其他伪指令</h2><ol>\n<li>过程定义伪指令<br>（1）用于定义一个过程体<br>（2）格式：<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">过程名 PROC [ <span class=\"built_in\">NEAR</span> / <span class=\"built_in\">FAR</span> ]</span><br><span class=\"line\">┇</span><br><span class=\"line\"><span class=\"keyword\">RET</span></span><br><span class=\"line\">过程名 ENDP</span><br></pre></td></tr></table></figure>\n（3）<img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627120345.png\"></li>\n<li>宏命令伪指令<br>（1）宏：源程序中由汇编程序识别的具有独立功能的一段程序代码<br>（2）当源程序中需要多次使用同一个程序段时，可以将该程序段定义为一个宏<br>（3）格式：<code>宏命令名 MACRO &lt;形式参数&gt;</code><br>（4）<img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627120517.png\"></li>\n</ol>\n<h2 id=\"第三十讲-系统功能调用\"><a href=\"#第三十讲-系统功能调用\" class=\"headerlink\" title=\"第三十讲 系统功能调用\"></a>第三十讲 系统功能调用</h2><ol>\n<li>BIOS、DOS功能调用<br>（1）BIOS：驻留在ROM中的基本输入/输出系统<br>加电自检，装入引导，主要I/O设备处理程序及接口控制<br>（2）DOS：磁盘操作系统<br>DOS功能/BIOS功能调用是调用系统内核子程序<br>（3）BIOS、DOS功能调用：DOS功能与BIOS功能均通过中断方式调用，DOS和BIOS中断均可能影响AX</li>\n<li>DOS软中断<br>（1）DOS中断包括：设备管理，目录管理，文件管理，其它用中断类型码区分<br>（2）DOS软中断：类型码为21H </li>\n<li>单字符输入<br>（1）调用方法：<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">MOV</span> <span class=\"number\">AH</span>，<span class=\"number\">01</span></span><br><span class=\"line\"><span class=\"keyword\">INT</span> <span class=\"number\">21H</span></span><br></pre></td></tr></table></figure>\n（2）输入的字符在AL中 </li>\n<li>字符串输入<br>（1）接收由键盘输入一串字符<br>（2）输入的字符串存储在内存指导区域中<br>（3）用户自定义缓冲区格式：<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627121105.png\"></li>\n<li>单字符显示输出<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627121240.png\"></li>\n<li>字符串显示输出<br>AH 功能号09H<br>DS：DX 待输出字符串的偏移地址<br>INT 21H</li>\n<li>返回操作系统（DOS）功能<br>（1）功能号：4CH<br>（2）调用格式：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV AH，4CH</span><br><span class=\"line\">INT 21H</span><br></pre></td></tr></table></figure>\n（3）功能：程序执行完该2条语句后能正常返回OS;常位于程序结尾处</li>\n</ol>\n<h1 id=\"第八章-半导体存储器\"><a href=\"#第八章-半导体存储器\" class=\"headerlink\" title=\"第八章 半导体存储器\"></a>第八章 半导体存储器</h1><h2 id=\"第三十一讲-半导体存储器概述\"><a href=\"#第三十一讲-半导体存储器概述\" class=\"headerlink\" title=\"第三十一讲 半导体存储器概述\"></a>第三十一讲 半导体存储器概述</h2><ol>\n<li>半导体存储器<br>（1）由能够表示二进制数“0”和“1”的，具有记忆功能的半导体器件组成<br>（2）能存放一位二进制数的半导体器件称为一个存储元<br>（3）若干存储元构成一个存储单元</li>\n<li>半导体存储器的分类</li>\n</ol>\n<ul>\n<li>内存储器：<ul>\n<li>随机存取存储器（RAM）<ul>\n<li>静态存储器（SRAM）</li>\n<li>动态存储器（DRAM）</li>\n</ul>\n</li>\n<li>只读存储器（ROM）<ul>\n<li>掩模ROM</li>\n<li>一次性可写ROM</li>\n<li>可读写ROM<ul>\n<li>EPROM</li>\n<li>EEPROM</li>\n<li>PROM</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>半导体存储器的主要技术指标<br>（1）存储容量：存储单元个数×每单元的二进制数位数<br>存储容量=2^m×N<br>（m：芯片地址线根数）<br>（N：芯片数据线根数）<br>（2）存取时间：实现一次读/写所需要的时间<br>（3）存取周期：连续启动两次独立的存储器操作所需间隔的最小时间<br>（4）可靠性，功耗</li>\n</ol>\n<h2 id=\"第三十二讲-微机中的存储器\"><a href=\"#第三十二讲-微机中的存储器\" class=\"headerlink\" title=\"第三十二讲 微机中的存储器\"></a>第三十二讲 微机中的存储器</h2><ol>\n<li>微机中的存储器<br>（1）内存储器<br>主内存<br>高速缓冲存储器<br>（2）外存储器<br>联机外存<br>脱机外存<br>（3）虚拟存储器<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627143039.png\"></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">内存</th>\n<th align=\"center\">外存</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">速度</td>\n<td align=\"center\">快</td>\n<td align=\"center\">慢</td>\n</tr>\n<tr>\n<td align=\"center\">容量</td>\n<td align=\"center\">小</td>\n<td align=\"center\">大</td>\n</tr>\n<tr>\n<td align=\"center\">单位容量价格</td>\n<td align=\"center\">高</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">制造材料</td>\n<td align=\"center\">半导体</td>\n<td align=\"center\">磁性材料</td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li><p>微机中的存储系统主要有：<br>（1）Cache存储器系统<br>（2）虚拟存储器系统</p>\n</li>\n<li><p>随机存取存储器<br>（1）特点：可以随机读或写操作；掉电后存储内容即丢失<br>（2）类型：静态随机存取存储器（SRAM）；动态随机存取存储器（DRAM）</p>\n</li>\n</ol>\n<h2 id=\"第三十三讲-存储单元的编址\"><a href=\"#第三十三讲-存储单元的编址\" class=\"headerlink\" title=\"第三十三讲 存储单元的编址\"></a>第三十三讲 存储单元的编址</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627143427.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627143454.png\"></p>\n<ol>\n<li>地址译码电路<br>（1）单译码结构<br>（2）双译码结构<br>（3）3-8译码器（741S138）</li>\n</ol>\n<h2 id=\"第三十四讲-存储器扩展技术\"><a href=\"#第三十四讲-存储器扩展技术\" class=\"headerlink\" title=\"第三十四讲 存储器扩展技术\"></a>第三十四讲 存储器扩展技术</h2><ol>\n<li>存储器扩展：用已有的存储器芯片构造一个需要的存储空间<br>（1）用多片存储芯片构成一个需要的内存空间；<br>（2）各存储器芯片在整个内存中占据不同的地址范围；<br>（3）任一时刻仅有一片（或一组）被选中。<br>（4）存储器芯片的存储容量等于：单元数×每单元的位数 </li>\n<li>存储器扩展方法<br>（1）位扩展–》扩展字长<br>（2）字扩展–》扩展单元数<br>（3）字位扩展–》既扩展字长也扩展单元数</li>\n</ol>\n<h1 id=\"第九章-输入输出与中断技术\"><a href=\"#第九章-输入输出与中断技术\" class=\"headerlink\" title=\"第九章 输入输出与中断技术\"></a>第九章 输入输出与中断技术</h1><h2 id=\"第三十五讲-输入输出技术概述\"><a href=\"#第三十五讲-输入输出技术概述\" class=\"headerlink\" title=\"第三十五讲 输入输出技术概述\"></a>第三十五讲 输入输出技术概述</h2><ol>\n<li>I/O接口<br>（1）接口要解决的问题<br>速度匹配👉数据的缓冲与暂存<br>信号的驱动能力👉信号驱动<br>信号形式和电平的匹配👉信号类型转换<br>信息格式👉信号格式转换<br>时序匹配（定时关系）<br>总线隔离👉三态门 </li>\n<li>I/O端口及其编址<br>（1）端口：接口电路中用于缓存数据及控制信息的部件<br>（2）分类：数据端口，控制端口，状态端口<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627144642.png\"><br>（3）I/0端口编址：为确保CPU能够访问到每个不同的端口<br>（4）寻址端口的方法：</li>\n</ol>\n<ul>\n<li>先找到端口所在的接口电路芯片</li>\n<li>再在该芯片上找具体访问的端口<ul>\n<li>若接口中仅有一个端口，则找到芯片即找到端口</li>\n<li>若接口中有多个端口，则找到芯片后需再找端口<br>（5）每个端口地址=片选地址（高位地址）+片内地址 </li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li> I/O地址译码<br>（1）目的：确定端口的地址<br>（2）参加译码的信号：<br><code>#IOR，#IOW，高位地址信号</code><br>（3）对端口读/写信号的产生条件</li>\n</ol>\n<ul>\n<li><code>IO/#M=1</code></li>\n<li><code>#RD=0 #IOR=0</code></li>\n<li><code>#WR=0 #IOW=0</code><br>（4）当接口只有一个端口时：无片内地址，全部地址信号均为高位地址（可全部参与译码），译码输出直接选择该端口；<br>（5）当接口具有多个端口时：则16位地址线的高位参与译码（决定接口的基地址），而低位则用于确定要访问哪一个端口</li>\n</ul>\n<h2 id=\"第三十六讲-简单接口芯片\"><a href=\"#第三十六讲-简单接口芯片\" class=\"headerlink\" title=\"第三十六讲 简单接口芯片\"></a>第三十六讲 简单接口芯片</h2><ol>\n<li> 接口的分类及特点<br>（1）按传输信息的方向分类：<br>输入接口<br>输出接口<br>（2）按传输信息的类型分类：<br>数字接口<br>模拟接口<br>（3）按传输信息的方式分类：<br>并行接口<br>串行接口</li>\n<li>接口特点<br>（1）输入接口：<br>要求对数据具有控制能力<br>常用三态门实现<br>（2）输出接口：<br>要求对数据具有锁存能力<br>常用锁存器实现</li>\n</ol>\n<h2 id=\"第三十七讲-基本输入输出方法\"><a href=\"#第三十七讲-基本输入输出方法\" class=\"headerlink\" title=\"第三十七讲 基本输入输出方法\"></a>第三十七讲 基本输入输出方法</h2><ol>\n<li>基本输入/输出方法<br>（1）无条件传送：要求外设总是处于准备好状态<br>优点：软件及接口硬件简单<br>缺点：只适用于简单外设，适应范围较窄<br>（2）查询式传送：仅当条件满足时才能进行数据传送；每满足一次条件只能进行一次数据传送。<br>适用场合：外设并不总是准备好；对传送速率和效率要求不高<br>工作条件：外设应提供设备状态信息；接口应具备状态端口<br>（3）中断方式传送<br>特点：外设在需要时向CPU提出请求，CPU再去为它服务。服务结束后或在外设不需要时，CPU可执行自己的程序。<br>优点：CPU效率高，实时性好，速度快。<br>缺点：程序编制相对较为复杂。<br>（4）直接存储器存取(DMA) ：<br>特点：<br>①外设直接与存储器进行数据交换 ，CPU不再担当数据传输的中介者；<br>②总线由DMA控制器（DMAC）进行控制（CPU要放弃总线控制权），内存/外设的地址和读写控制信号均由DMAC提供。<br>③DMA传送方式有单元传送方式，快传送方式，请求传送方式<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627145513.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627145541.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627145557.png\"></li>\n</ol>\n<h3 id=\"DMA控制器8237A\"><a href=\"#DMA控制器8237A\" class=\"headerlink\" title=\"DMA控制器8237A\"></a>DMA控制器8237A</h3><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200907143459.png\"></p>\n<h2 id=\"第三十八讲-中断技术\"><a href=\"#第三十八讲-中断技术\" class=\"headerlink\" title=\"第三十八讲 中断技术\"></a>第三十八讲 中断技术</h2><ol>\n<li>中断的基本概念<br>（1）CPU执行程序时，由于发生了某种随机的事件(外部或内部)，<br>引起CPU暂时中断正在运行的程序，转去执行一段特殊的服务<br>程序，以处理该事件，该事件处理完后又返回被中断的程序<br>继续执行，这一过程称为中断。<br>（2）引入中断的原因<br>提高对外设请求的响应实时性。<br>提高了CPU的利用率<br>避免了CPU不断检测外设状态的过程<br>（3）中断类型<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627145857.png\"></li>\n</ol>\n<h1 id=\"第十章-可编程数字接口电路\"><a href=\"#第十章-可编程数字接口电路\" class=\"headerlink\" title=\"第十章 可编程数字接口电路\"></a>第十章 可编程数字接口电路</h1><h2 id=\"可编程定时计数器8253\"><a href=\"#可编程定时计数器8253\" class=\"headerlink\" title=\"可编程定时计数器8253\"></a>可编程定时计数器8253</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/8253-1.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8253-2.PNG\"></p>\n<h2 id=\"可编程并行接口8255\"><a href=\"#可编程并行接口8255\" class=\"headerlink\" title=\"可编程并行接口8255\"></a>可编程并行接口8255</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/8255-1.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8255-2.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8255-3.PNG\"></p>\n<h2 id=\"可编程中断控制器8259\"><a href=\"#可编程中断控制器8259\" class=\"headerlink\" title=\"可编程中断控制器8259\"></a>可编程中断控制器8259</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-1.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-2.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-3.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-4.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-5.PNG\"></p>\n<h1 id=\"第十一章-模拟接口电路\"><a href=\"#第十一章-模拟接口电路\" class=\"headerlink\" title=\"第十一章 模拟接口电路\"></a>第十一章 模拟接口电路</h1><h2 id=\"模拟量的输入输出\"><a href=\"#模拟量的输入输出\" class=\"headerlink\" title=\"模拟量的输入输出\"></a>模拟量的输入输出</h2><p>D： （Digital） 数字量<br>A： （Analog） 模拟量<br>采样和量化</p>\n<h2 id=\"D-A转换器和A-D转换器\"><a href=\"#D-A转换器和A-D转换器\" class=\"headerlink\" title=\"D/A转换器和A/D转换器\"></a>D/A转换器和A/D转换器</h2><ol>\n<li>主要参数<br>（1）分辨率<br>输入的二进制数每+1/-1个最低有效位LSB，使输出变化的程度 , 1LSB = 1/(2^n-1)<br>[n：D/A转换器的字长]<br>（2）转换时间<br>（3）精度<br>（4）线性度</li>\n<li>D/A转换器与微处理器的接口方法<br>（1）接口任务:解决数据锁存，缓冲问题<br>（2）特点：控制信号，无专门数据传送间隔时间，调节数据宽度<br>（3）接口电路结构：通用并行接口或直连<br>（4）D/A：数字量转换为模拟量</li>\n</ol>\n<h2 id=\"D-A转换器（DAC0832）NS\"><a href=\"#D-A转换器（DAC0832）NS\" class=\"headerlink\" title=\"D/A转换器（DAC0832）NS\"></a>D/A转换器（DAC0832）NS</h2><ol>\n<li>三种工作方式：直通方式，单缓冲方式，双缓冲方式</li>\n<li>8位寄存器，T型电阻网络，电流型输出，不可编程</li>\n<li>主要引脚功能：D7-D0，ILE，CS，WR1，WR2，XFER（低电平有效）</li>\n<li>内部结构：<br>（1）8位输入寄存器<br>（2）8位DAC寄存器<br>（3）8位D/A转换器<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200907141224.png\"></li>\n</ol>\n<h2 id=\"A-D转换器（ADC0809）\"><a href=\"#A-D转换器（ADC0809）\" class=\"headerlink\" title=\"A/D转换器（ADC0809）\"></a>A/D转换器（ADC0809）</h2><p>1.特点</p>\n<ul>\n<li>8通道（8路）输入</li>\n<li>8位字长</li>\n<li>逐位逼近型</li>\n<li>转换时间100us</li>\n<li>内置三态输出缓冲器</li>\n</ul>\n<p>2.主要引脚功能</p>\n<ul>\n<li>D7-D0：输出数据线，三态</li>\n<li>IN0-IN7：8通道模拟输入</li>\n<li>ADDC,ADDB,ADDA通道地址选择</li>\n<li>Start：启动变换</li>\n<li>ALE：通道地址锁存</li>\n<li>EOC：转换结束状态输出</li>\n<li>OE：输出允许</li>\n<li>CLK：工作时钟</li>\n</ul>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ol>\n<li>控制信号<br>（1）M/IO=1,CPU对存储器操作，M/IO=0,CPU对I/O操作<br>（2）DT/R=1,CPU→【内存/（I/O）】，DT/R=0，外部→CPU<br>（3）8086，RD，WR低电平有效</li>\n<li>ADC0809<br>（1）EOC发出中断请求<br>（2）CPU查询EOC状态</li>\n<li>D/A和A/D<br>（1）主要参数：分辨率，转换时间，精度</li>\n<li>数据传输方式（输入输出控制方式）<br>（1）程序控制方式<br> (1.1)无条件传送<br> (1.2)有条件传送（查询）<br>（2）中断控制方式<br>（3）DMA<br> （3.1）DMA传送方式：单元传送，块传送，请求传送<br> （3.2）DMAC，8237A<br> （3.3）DMA方式写，外设到存储器<br> （3.4）8237占用8个输入输出端口<br> （3.5）DMA控制方式中需要用到的一对联络信号是HLDA/HRQ</li>\n<li>串行接口<br>（1）串行接口中，并行数据和串行数据的转换通过移位寄存器实现<br>（2）RS-232是串行通信标准</li>\n<li>片选控制方式，全译码，部分译码，线译码</li>\n<li>I/O接口有独立编址和统一编址方式</li>\n<li>复位后段寄存器的初值为：CS=FFFFH，DS=0000H，SS=0000H，ES=0000H,其他寄存器的初值都是0，特别是CS=FFFFH，IP=0000H，因此复位后CPU从FFFF0H开始执行程序</li>\n<li>奇地址存储体和系统数据总线高8位相连，用BHE=0作为选通信号；偶地址存储体和系统数据总线低8位相连，用A0=0作为连通信号</li>\n<li>对准字，从偶地址开始存放字数据的存放方式（传一次，A0和BHE都有效），非对准字，从奇地址开始存放字数据的存放方式（传两次，先奇BHE后偶A0）</li>\n<li>寻址隐含约定：<br>（1）直接寻址，DS<br>（2）寄存器寻址：DS←BX/SI/DI；SS←BP<br>（3）基址变址寻址：DS←BX+SI/DI ； SS：BP+SI/DI<br>（4）堆栈：SS←SP<br>（5）取指令：CS←IP</li>\n</ol>\n","more":"<h1 id=\"第一章-微型计算机基础概论\"><a href=\"#第一章-微型计算机基础概论\" class=\"headerlink\" title=\"第一章 微型计算机基础概论\"></a>第一章 微型计算机基础概论</h1><h2 id=\"第一讲-关于\"><a href=\"#第一讲-关于\" class=\"headerlink\" title=\"第一讲 关于\"></a>第一讲 关于</h2><ul>\n<li>计算机的主要应用：数值计算，信息处理，过程控制</li>\n<li>微机原理与接口技术包括：数值信息表示，微型机基本原理，汇编程序设计，半导体存储器及其接口设计，输入输出技术</li>\n</ul>\n<h2 id=\"第二讲-微型计算机系统组成\"><a href=\"#第二讲-微型计算机系统组成\" class=\"headerlink\" title=\"第二讲 微型计算机系统组成\"></a>第二讲 微型计算机系统组成</h2><ul>\n<li>计算机系统：<ul>\n<li>硬件系统<ul>\n<li>主机系统：CPU，存储器，输入输出接口，总线</li>\n<li>外部设备</li>\n</ul>\n</li>\n<li>软件系统</li>\n</ul>\n</li>\n<li>能够与CPU直接进行信息交换的部件属于主机系统，不能够与CPU直接进行信息交换的部件属于外部设备</li>\n<li>CPU<ul>\n<li>微处理器简称CPU，是计算机的核心</li>\n<li>主要包括：运算器，控制器，寄存器组</li>\n</ul>\n</li>\n<li>存储器：<ul>\n<li>计算机中的记忆装置。用于存放计算机工作过程中需要操作的数据和程序</li>\n<li>内存储器 ：<ul>\n<li>存取速度较快，容量相对较小</li>\n<li>内存按单元组织，每单元都对应一个惟一的地址 </li>\n<li>每个内存单元中存放1Byte数据【每8位0或1称 为1字节（Byte）】</li>\n<li>内存单元个数称为内存容量</li>\n<li>按工作方式分类：随机存取存储器（RAM），只读存储器（ROM） </li>\n</ul>\n</li>\n<li>外存储器 <ul>\n<li>联机外存：硬磁盘 </li>\n<li>脱机外存：各种移动存储设备</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>输入/输出接口 <ul>\n<li>接口是CPU与外部设备间的桥梁</li>\n<li>主要功能：<ul>\n<li>数据缓冲寄存；</li>\n<li>信号电平或类型的转换；</li>\n<li>实现主机与外设间的运行匹配。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总线 <ul>\n<li>是一组导线和相关的控制、驱动电路的集合。</li>\n<li>是计算机系统各部件之间传输地址、数据和控制信息的通道 </li>\n<li>地址总线（AB） 数据总线（DB） 控制总线（CB） </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第三讲-微机工作过程\"><a href=\"#第三讲-微机工作过程\" class=\"headerlink\" title=\"第三讲 微机工作过程\"></a>第三讲 微机工作过程</h2><ul>\n<li>计算机的工作就是按照一定的顺序，一条条地执行指令</li>\n<li>指令： 由人向计算机发出的、能够为计算机所识别的命令 </li>\n<li>过程：<strong>取指令</strong>-&gt;<strong>分析指令</strong>-&gt;读取操作数-&gt;<strong>执行指令</strong>-&gt;存放结果 </li>\n<li>顺序执行： 一条指令执行完了再执行下一条指令。 <ul>\n<li>执行时间=取指令+分析指令+执行指令 </li>\n<li>设：三个部分的执行时间均为Δt，则：执行n条指令时间T0为：  </li>\n<li>T0=3nΔt </li>\n</ul>\n</li>\n<li>并行执行： 同时执行两条或多条指令。 <ul>\n<li>仅第1条指令需要3 Δt时间，之后每经过1 Δt，就有一条指令执行结束</li>\n<li>执行时间： T =3Δt +（ n-1）Δt </li>\n</ul>\n</li>\n<li>并行： 更高的效率，更高的复杂度 </li>\n<li>相对于顺序执行方式，指令并行执行的优势用加速比S表示： <ul>\n<li>S=顺序执行花费的时间/并行执行花费的时间 </li>\n<li>例： 3n Δt /（3Δt +（ n-1）Δt) =3n/（2+n） </li>\n</ul>\n</li>\n<li>冯 • 诺依曼计算机的工作原理: 存储程序工作原理,结构特点:运算器为核心 </li>\n<li>冯 • 诺依曼机的工作过程 <ul>\n<li>取一条指令的工作过程： <ul>\n<li>① 将指令所在地址赋给程序计数器PC； </li>\n<li>② PC内容送到地址寄存器AR，PC自动加1； </li>\n<li>③ 把AR的内容通过地址总线送至内存储器，经地址译码器译码，选中相应单元。 </li>\n<li>④ CPU的控制器发出读命令。 </li>\n<li>⑤ 在读命令控制下，把所选中单元的内容（即指令操作码）读到数据总线 DB。 </li>\n<li>⑥ 把读出的内容经数据总线送到数据寄存器DR。 </li>\n<li>⑦ 指令译码:数据寄存器DR将它送到指令寄存器IR，然后再送到指令译码器ID </li>\n</ul>\n</li>\n<li>特点： <ul>\n<li>程序存储，共享数据，顺序执行 </li>\n<li>属于顺序处理机，适合于确定的算法和数值数据的处理。</li>\n</ul>\n</li>\n<li>不足： <ul>\n<li>与存储器间有大量数据交互，对总线要求很高；</li>\n<li>执行顺序由程序决定，对大型复杂任务较困难；</li>\n<li>以运算器为核心，处理效率较低；</li>\n<li>由PC控制执行顺序，难以进行真正的并行处理。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>哈佛结构 <ul>\n<li>指令和数据分别存放在两个独立的存储器模块中； </li>\n<li>CPU与存储器间指令和数据的传送分别采用两组独立的总线；</li>\n<li>可以在一个机器周期内同时获得指令操作码和操作数。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第四讲-常用数制\"><a href=\"#第四讲-常用数制\" class=\"headerlink\" title=\"第四讲 常用数制\"></a>第四讲 常用数制</h2><ul>\n<li>计算机中的常用计数制：十进制 ，二进制数 ，十六进制数 ，八进制数 </li>\n</ul>\n<h2 id=\"第五讲-编码\"><a href=\"#第五讲-编码\" class=\"headerlink\" title=\"第五讲 编码\"></a>第五讲 编码</h2><ul>\n<li>编码：<ul>\n<li>信息从一种形式或格式转换为另一种形式的过程</li>\n<li>用代码来表示各种信息，以便于计算机处理。 </li>\n</ul>\n</li>\n<li>需要编码的信息种类：数值，字符，声音，图形，图像 </li>\n<li>所有需要由计算机处理的信息，都需要编码，使所有信息都以二进制码形式表示</li>\n<li>计算机中的编码 <ul>\n<li>数值编码：<ul>\n<li>二进制码</li>\n<li>BCD码 </li>\n</ul>\n</li>\n<li>西文字符编码<ul>\n<li>ASCII码 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>BCD（Binary Coded Decimal）码 <ul>\n<li>用二进制表示的十进制数</li>\n<li>特点： <ul>\n<li>保留十进制的权，数字用0和1表示。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>8421BCD编码： <ul>\n<li>用4位二进制码表示1位十进制数，每4位之间有一个空格 </li>\n<li>1010—1111是非法BCD码</li>\n<li>（0001 0001 .0010 0101）BCD    =11 .25    =（1011 .01）B </li>\n</ul>\n</li>\n<li>BCD码在计算机中的存储方式 <ul>\n<li>以压缩BCD码形式存放：<ul>\n<li>用4位二进制码表示1位BCD码</li>\n<li>一个存储单元中存放2位BCD数</li>\n</ul>\n</li>\n<li>以扩展BCD码形式存放 <ul>\n<li>用8位二进制码表示1位BCD码.即高4位为0，低4位为有效位 </li>\n<li>每个存储单元存放1位BCD </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ASCII码 <ul>\n<li>西文字符编码：将每个字母、数字、标点、控制符用1Byte二进制码表示 </li>\n<li>标准ASCII的有效位：7bit，最高位默认为0 </li>\n</ul>\n</li>\n<li>ASCII码的奇偶校验 <ul>\n<li>奇校验：加上校验位后编码中“1”的个数为奇数。</li>\n<li>偶校验：加上校验位后编码中“1”的个数为偶数。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第六讲-数及其运算\"><a href=\"#第六讲-数及其运算\" class=\"headerlink\" title=\"第六讲 数及其运算\"></a>第六讲 数及其运算</h2><ul>\n<li>定点数</li>\n<li>浮点数 <ul>\n<li>小数点的位置可以左右移动的数</li>\n<li>规格化浮点数：尾数部分用纯小数表示，即小数点右边第1位不为0 </li>\n</ul>\n</li>\n<li>无符号数</li>\n<li>有符号数：用最高位表示符号，其余是数值，0正，1负<ul>\n<li>原码：最高位为符号位，其余为真值部分<ul>\n<li>[X]原=符号位+|绝对值| </li>\n<li>有[+0]和[-0]之分</li>\n</ul>\n</li>\n<li>反码：<ul>\n<li>若X&gt;0 ，则 [X]反 = [X]原 </li>\n<li>若X&lt;0， 则 [X]反 = 对应原码的符号位不变，数值部分按位求反。</li>\n<li>有[+0]和[-0]之分</li>\n</ul>\n</li>\n<li>补码：<ul>\n<li>若X&gt;0， 则 [X]补 = [X]反= [X]原</li>\n<li>若X&lt;0， 则 [X]补 = [X]反+1 </li>\n<li>没有[+0]和[-0]之分</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>无符号整数的表示范围(n表示字长)： 0 ≤ X ≤ 2^n - 1</li>\n<li>有符号整数的表示范围： <ul>\n<li>原码和反码： -（2^(n-1) -1） ≤ X ≤ 2^(n-1) -1 </li>\n<li>补码： -2^(n-1) ≤ X ≤ 2^(n-1) -1 </li>\n<li>对8位二进制数：<ul>\n<li>原码： -127 ～+127</li>\n<li>反码： -127 ～+127</li>\n<li>补码： -128 ～+127 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第七讲-基本逻辑运算和逻辑门\"><a href=\"#第七讲-基本逻辑运算和逻辑门\" class=\"headerlink\" title=\"第七讲 基本逻辑运算和逻辑门\"></a>第七讲 基本逻辑运算和逻辑门</h2><ul>\n<li>逻辑，命题，推理</li>\n<li>基本逻辑运算：与或非</li>\n<li>逻辑运算是按位进行的运算，低位运算结果对高位运算不产生影响 </li>\n<li>算术运算是两个数之间的运算，低位运算结果将对高位运算产生影响</li>\n</ul>\n<h2 id=\"第八讲-基本逻辑运算及其门电路\"><a href=\"#第八讲-基本逻辑运算及其门电路\" class=\"headerlink\" title=\"第八讲 基本逻辑运算及其门电路\"></a>第八讲 基本逻辑运算及其门电路</h2><ul>\n<li>与非，或非，异或，同或</li>\n</ul>\n<h1 id=\"第二章-微处理器与总线\"><a href=\"#第二章-微处理器与总线\" class=\"headerlink\" title=\"第二章 微处理器与总线\"></a>第二章 微处理器与总线</h1><h2 id=\"第九讲-8088-8086微处理器\"><a href=\"#第九讲-8088-8086微处理器\" class=\"headerlink\" title=\"第九讲 8088/8086微处理器\"></a>第九讲 8088/8086微处理器</h2><ul>\n<li>8088/8086 CPU的特点 <ul>\n<li>采用并行流水线工作方式<ul>\n<li>通过设置指令预取队列实现</li>\n</ul>\n</li>\n<li>对内存空间实行分段管理<ul>\n<li>将内存分为4个段并设置地址段寄存器，以实现对1MB空间的寻址</li>\n</ul>\n</li>\n<li>支持协处理器</li>\n</ul>\n</li>\n<li>8088/8086可工作于两种模式下 <ul>\n<li>最小模式：单处理器模式，所有控制信号由微处理器产生<ul>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200605180344.png\"></li>\n</ul>\n</li>\n<li>最大模式：最大模式为多处理器模式，部分控制信号由外部总线控制器产生 <ul>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200605180420.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十讲-8088的主要引线及其内部结构\"><a href=\"#第十讲-8088的主要引线及其内部结构\" class=\"headerlink\" title=\"第十讲 8088的主要引线及其内部结构\"></a>第十讲 8088的主要引线及其内部结构</h2><ul>\n<li>8088最小模式下的主要引脚信号<ul>\n<li>完成一次访问内存或接口所需要的主要信号</li>\n<li>与外部同步控制信号</li>\n<li>中断请求和响应信号</li>\n<li>总线保持和响应信号<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200605180737.png\"></li>\n</ul>\n</li>\n<li>主要控制信号<ul>\n<li>WR：  写信号；</li>\n<li>RD：  读信号；</li>\n<li>IO/M：为“0”表示访问内存，为“1”表示访问接口；</li>\n<li>DEN： 低电平有效时，允许进行读/写操作；</li>\n<li>DT/R：数据收发器的传送方向控制；</li>\n<li>ALE：  地址锁存信号；</li>\n<li>RESET：复位信号。 </li>\n</ul>\n</li>\n<li>中断请求和响应信号<ul>\n<li>INTR：可屏蔽中断请求输入端</li>\n<li>NMI： 非屏蔽中断请求输入端 </li>\n<li>INTA：中断响应输出端 </li>\n</ul>\n</li>\n<li>总线保持信号<ul>\n<li>HOLD：总线保持请求信号输入端。当CPU以外的其他设备要求占用总线时，通过该引脚向CPU发出请求。</li>\n<li>HLDA：总线保持响应信号输出端。CPU对HOLD信号的响应信号。 </li>\n</ul>\n</li>\n<li>微处理器读取一条指令的控制过程<ul>\n<li>1.发出读取数据所在的目标地址<ul>\n<li>内存储器单元地址</li>\n<li>I/O接口地址 </li>\n</ul>\n</li>\n<li>2.发出读控制信号</li>\n<li>3.送出传输的数据 </li>\n</ul>\n</li>\n<li>地址线和数据线：<ul>\n<li>20位地址信号(20根地址线)–》可产生2^20=1M个编码 </li>\n<li>8位数据信号(8位数据线)–》可同时传输8bit二进制码 </li>\n</ul>\n</li>\n<li>8088内部结构：<ul>\n<li>执行单元EU<ul>\n<li>构成：运算器，8个通用寄存器，1个标志寄存器，EU部分控制电路</li>\n<li>功能：指令译码，指令执行，暂存中间运算结果，保存运算结果特征 </li>\n</ul>\n</li>\n<li>总线接口单元BIU<ul>\n<li>功能：</li>\n<li>从内存中取指令到指令预取队列，指令预取队列是并行流水线工作的基础</li>\n<li>负责与内存或输入/输出接口之间的数据传送</li>\n<li>在执行转移程序时，BIU使指令预取队列复位，从指定的新地址取指令，并立即传给执行单元执行。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指令预取队列的存在使EU和BIU两个部分可同时进行工作 </li>\n<li>8088和8086CPU引线功能比较 <ul>\n<li>数据总线宽度不同：8088的外部总线宽度是8位，8086为16位。 </li>\n<li>访问存储器和输入输出控制信号含义不同：8088——IO/M=0表示访问内存；8086——IO/M=1表示访问内存。 </li>\n<li>其他部分引线功能的区别 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十一讲-8088CPU内部寄存器\"><a href=\"#第十一讲-8088CPU内部寄存器\" class=\"headerlink\" title=\"第十一讲 8088CPU内部寄存器\"></a>第十一讲 8088CPU内部寄存器</h2><ul>\n<li>含14个16位寄存器，按功能可分为三类： <ul>\n<li>8个通用寄存器<ul>\n<li>数据寄存器（AX，BX，CX，DX）</li>\n<li>地址指针寄存器（SP，BP）</li>\n<li>变址寄存器（SI，DI） </li>\n</ul>\n</li>\n<li>4个段寄存器</li>\n<li>2个控制寄存器  </li>\n</ul>\n</li>\n<li>通用寄存器：<ul>\n<li>数据寄存器：8088/8086含4个16位数据寄存器，它们又可分为8个8位寄存器，即： <ul>\n<li>AX——-AH，AL：累加器，所有I/O指令都通过AX与接口传送信息，中间运算结果也多放于AX中； </li>\n<li>BX——-BH，BL：基址寄存器,在间接寻址中用于存放基地址</li>\n<li>CX——-CH，CL：计数寄存器,用于在循环或串操作指令中存放计数值</li>\n<li>DX——-DH，DL：数据寄存器,在间接寻址的I/O指令中存放I/O端口地址；在32位乘除法运算时，存放高16位数。 </li>\n</ul>\n</li>\n<li>地址指针寄存器:<ul>\n<li>SP：堆栈指针寄存器，其内容为栈顶的偏移地址 </li>\n<li>BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址。 </li>\n</ul>\n</li>\n<li>变址寄存器 <ul>\n<li>SI：源变址寄存器</li>\n<li>DI：目标变址寄存器</li>\n<li>变址寄存器在指令中常用于存放数据在内存中的地址。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>BX与BP在应用上的区别 <ul>\n<li>作为通用寄存器，二者均可用于存放数据；</li>\n<li>作为基址寄存器，用BX表示所寻找的数据在数据段；用BP 则表示数据在堆栈段。 </li>\n</ul>\n</li>\n<li>段寄存器:<ul>\n<li>作用:用于存放相应逻辑段的段基地址</li>\n<li>8086/8088内存中逻辑段的类型<ul>\n<li>代码段: 存放指令代码</li>\n<li>数据段: 存放操作的数据</li>\n<li>附加段: 存放附加的操作的数据</li>\n<li>堆栈段: 存放暂时不用但需保存的数据。 </li>\n</ul>\n</li>\n<li>CS:代码段寄存器，存放代码段的段基地址。</li>\n<li>DS:数据段寄存器，存放数据段的段基地址。</li>\n<li>ES:附加段寄存器，存放附加段的段基地址。</li>\n<li>SS:堆栈段寄存器，存放堆栈段的段基地址 </li>\n<li>段寄存器的值表明相应逻辑段在内存中的位置 </li>\n</ul>\n</li>\n<li>控制寄存器：<ul>\n<li>指令指针控制寄存器IP</li>\n<li>状态标志寄存器FLAGS<ul>\n<li>状态标志位：<ul>\n<li>CF:进位标志位。加(减)法运算时，若最高位有进(借)位则CF=1</li>\n<li>OF:溢出标志位。当算术运算的结果超出了有符号数的可表达范围时，OF=l</li>\n<li>ZF:零标志位。当运算结果为零时ZF=1</li>\n<li>SF:符号标志位。当运算结果的最高位为1时，SF=l</li>\n<li>PF:奇偶标志位。运算结果的低8位中“1”的个数为偶数时PF=l</li>\n<li>AF:辅助进位标志位。加(减)操作中，若Bit3(D3)向Bit4(D4)有进位(借位)， AF=1</li>\n</ul>\n</li>\n<li>控制标志位：<ul>\n<li>TF:单步陷阱标志位，也叫跟踪标志位。TF=1时，使CPU处于单步执行指令的工作方式。</li>\n<li>IF:中断允许标志位。IF=1时，CPU可以响应中断请求。</li>\n<li>DF:方向标志位。在数据串操作时确定操作的方向。 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十二讲-实模式下的存储器寻址\"><a href=\"#第十二讲-实模式下的存储器寻址\" class=\"headerlink\" title=\"第十二讲 实模式下的存储器寻址\"></a>第十二讲 实模式下的存储器寻址</h2><ul>\n<li>存储单位地址及其内容表示<ul>\n<li>若X表示某个单元地址，则[X]表示X单元的内容</li>\n<li>例如：[0004H]=34H代表34存放在4号单元，而[0004H]=1234H，代表34存放在4号单元，12存放在5号单元</li>\n</ul>\n</li>\n<li>字的存储<ul>\n<li>占连续两个字节（16位）</li>\n<li>低对低，高对高</li>\n<li>用低位地址来表示字的地址</li>\n</ul>\n</li>\n<li>规则存放，非规则存放<ul>\n<li>8088：数据总线8位，每次传送1个字节</li>\n<li>8086：数据总线16位<ul>\n<li>字：16位，规则字，以偶地址开始存放</li>\n<li>字节： 高8位传送奇地址，低8位传送偶地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内存储器管理<ul>\n<li>8088CPU是16位体系结构的微处理器</li>\n<li>可以同时处理16位二进制码</li>\n<li>8088CPU需要管理1MB内存</li>\n</ul>\n</li>\n<li>分段技术<ul>\n<li>分为若干个逻辑段，取内地址，用16位表示，每段最大64KB</li>\n<li>对段首地址（物理地址）规定，段首地址低4位为0，例如：00000H,00010H,FFFF0H</li>\n<li>段地址：段的起始地址的高16位</li>\n<li>偏移地址：段内相对于段的起始地址的偏移量（字节数）</li>\n</ul>\n</li>\n<li>实地址模式下的存储器地址变换<ul>\n<li>内存物理地址由段基地址和偏移地址组成</li>\n<li>物理地址=段基地址×16+偏移地址</li>\n</ul>\n</li>\n<li>内存地址变换<ul>\n<li>内存单元编址<ul>\n<li>段（基）地址</li>\n<li>段内地址（相对地址/偏移地址）</li>\n</ul>\n</li>\n<li>存储器的编址<ul>\n<li>段（基）地址</li>\n<li>相对地址（偏移地址）</li>\n<li>逻辑段的起始地址称为段首，段首的偏移地址0000H</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>段寄存器：<ul>\n<li>作用：用于存放相应逻辑段的段基地址</li>\n<li>8086/8088内存中逻辑段的类型<ul>\n<li>代码段==&gt;CS（代码段寄存器）<ul>\n<li>CS×16+IP</li>\n</ul>\n</li>\n<li>数据段==&gt;DS（数据段寄存器）<ul>\n<li>DS×16+偏移地址</li>\n</ul>\n</li>\n<li>附加段==&gt;ES（附加段寄存器）<ul>\n<li>ES×16+偏移地址</li>\n</ul>\n</li>\n<li>堆栈段==&gt;SS（堆栈段寄存器）<ul>\n<li>SS×16+SP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>8086/8088内存中每类逻辑段的数量最多64K个</li>\n</ul>\n</li>\n<li>逻辑段与逻辑地址<ul>\n<li>内存的分段式逻辑分段，不是物理段</li>\n<li>两个逻辑段可以完全重合或部分重合</li>\n</ul>\n</li>\n<li>堆栈及堆栈段的使用<ul>\n<li>堆栈： <ul>\n<li>内存中一个特殊区域，用于存放暂时不用或需要保护的数据。</li>\n<li>常用于响应中断或子程序调用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626171551.png\"></p>\n<h2 id=\"第十三讲-8088-系统总线\"><a href=\"#第十三讲-8088-系统总线\" class=\"headerlink\" title=\"第十三讲 8088 系统总线\"></a>第十三讲 8088 系统总线</h2><ul>\n<li>总线时序<ul>\n<li>CPU工作时序<ul>\n<li>CPU各引脚信号在时间上的关系</li>\n</ul>\n</li>\n<li>总线周期<ul>\n<li>CPU完成一次访问内存（或接口）操作所需要的时间</li>\n<li>8086的基本总线周期为4个时钟周期，每个时钟周期间隔称为一个T状态（8086/8088：5MHz时钟信号，时钟周期T=200ns）<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626181818.png\"></li>\n<li>T1 状态：BIU将RAM或I/O地址放在地址/数据复用             总线（AD）上。</li>\n<li>T2 状态：   <ul>\n<li>读总线周期： A/D总线为接收数据做准备。改变线路的方向。</li>\n<li>写总线周期： A/D总线上形成待写的数据，且保持到总线周期的结束(T4)。</li>\n</ul>\n</li>\n<li>T3, T4:对于读或写总线周期，AD总线上均为数据。</li>\n<li>Tw: 当RAM或I/O接口速度不够时，T3与 T4 之间可插入等待状态 Tw 。</li>\n<li>Ti : 当BIU无访问操作数和取指令的任务时，8086不执行总线操作，总线周期处于空闲状态 Ti 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总线：<ul>\n<li>按层次结构分类：<ul>\n<li>CPU总线</li>\n<li>系统总线</li>\n<li>外部总线</li>\n</ul>\n</li>\n<li>按传送信息的类别分类：<ul>\n<li>地址总线</li>\n<li>数据总线</li>\n<li>控制总线</li>\n</ul>\n</li>\n<li>按总线在微机系统的位置分类：<ul>\n<li>片内总线</li>\n<li>片间总线</li>\n<li>系统总线</li>\n<li>通信总线</li>\n</ul>\n</li>\n<li>总线的基本功能<ul>\n<li>数据传送</li>\n<li>仲裁控制</li>\n<li>出错处理</li>\n<li>总线驱动</li>\n</ul>\n</li>\n<li>总线的主要性能指标<ul>\n<li>总线带宽（B/S）<ul>\n<li>单位时间内总线上可传送的数据量</li>\n<li>总线带宽=位宽×工作频率</li>\n</ul>\n</li>\n<li>总线位宽（bit）<ul>\n<li>能同时传送的数据位数</li>\n</ul>\n</li>\n<li>总线的工作频率（MHz）<ul>\n<li>总线带宽=（位宽/8）×（工作频率/每个存储周期的时钟数）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>引脚信号设计特点<ul>\n<li>分时复用，如引脚AD0-AD15<ul>\n<li>如何实现：增加地址锁存器</li>\n<li>8282三位锁存器</li>\n<li>8286八位数据收发器</li>\n</ul>\n</li>\n<li>两种工作模式复用<ul>\n<li>最大模式</li>\n<li>最小模式</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"第三章-指令系统概述\"><a href=\"#第三章-指令系统概述\" class=\"headerlink\" title=\"第三章 指令系统概述\"></a>第三章 指令系统概述</h1><h2 id=\"第十四讲-8088-8086指令系统\"><a href=\"#第十四讲-8088-8086指令系统\" class=\"headerlink\" title=\"第十四讲 8088/8086指令系统\"></a>第十四讲 8088/8086指令系统</h2><ul>\n<li>指令：控制计算机完成某种操作的命令</li>\n<li>指令系统：处理器所能识别的所有指令的集合</li>\n<li>指令的兼容性：同一系列机的指令都是兼容的</li>\n<li>一条指令应包含的信息：<ul>\n<li>运算数据的来源</li>\n<li>运算结果的去向</li>\n<li>执行的操作</li>\n</ul>\n</li>\n<li>指令格式<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626182906.png\"></li>\n<li>指令中的操作数<ul>\n<li>立即数：参加操作的数据本身，可以是8位或16位，只能作为源操作数，无法作为目标操作数<ul>\n<li><code>MOV AX, 1234H</code></li>\n</ul>\n</li>\n<li>寄存器：数据存放地址<ul>\n<li><code>MOV AX, BX</code></li>\n</ul>\n</li>\n<li>存储器：数据存放地址<ul>\n<li>参加运算的数存放在存储器的某一个或两个单元中</li>\n<li>表现形式： [操作数在内存中的偏移地址]</li>\n<li><code>MOV AL, [1200H]</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十五讲-指令的寻址方式\"><a href=\"#第十五讲-指令的寻址方式\" class=\"headerlink\" title=\"第十五讲 指令的寻址方式\"></a>第十五讲 指令的寻址方式</h2><ul>\n<li><p>操作数可能的来源或运算结果可能的去处：</p>\n<ul>\n<li>由指令直接给出</li>\n<li>寄存器</li>\n<li>内存单元</li>\n</ul>\n</li>\n<li><p>寻找操作数所在地址的方法可以有三种大类型：</p>\n<ul>\n<li>指令直接给出的方式</li>\n<li>存放于寄存器中的寻址方式</li>\n<li>存放于存储器中的寻址方式</li>\n</ul>\n</li>\n<li><p>1.直接寻址：</p>\n<ul>\n<li>指令中直接给出操作数的偏移地址</li>\n<li>直接寻址方式下，操作数默认为在数据段，但允许段重设，即由指令给出所在逻辑段。 </li>\n<li><code>MOV AX，ES：[1200H]</code>  ES：段重设符</li>\n</ul>\n</li>\n<li><p>2.寄存器间接寻址</p>\n<ul>\n<li>操作数存放在内存中，数据在内存中的偏移地址为方括号中通用寄存器的内容</li>\n<li>仅有4个通用寄存器可用于存放数据的偏移地址，<code>BX</code>，<code>BP</code>，<code>SI</code>，<code>DI</code><ul>\n<li>若使用<code>BX</code>,<code>SI</code>,<code>DI</code>，则操作数在数据段<code>DS</code>中<ul>\n<li>物理地址=DS×16+{BX/SI/DI}</li>\n</ul>\n</li>\n<li>若使用<code>BP</code>，则操作数在堆栈段<code>SS</code>中<ul>\n<li>物理地址=SS×16+BP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>间接寻址的一般格式：[ 间址寄存器 ] </li>\n<li>例： <code>MOV AX，[BX]</code></li>\n<li>可以段重设</li>\n</ul>\n</li>\n<li><p>3.寄存器相对寻址</p>\n<ul>\n<li>操作数的偏移地址为寄存器的内容加上一个位移量</li>\n<li>相对寻址主要用于一维数组的操作</li>\n<li><code>MOV AX，[BX+DATA]</code></li>\n</ul>\n</li>\n<li><p>4.基址、变址寻址</p>\n<ul>\n<li>操作数的偏移地址为<ul>\n<li>一个基址寄存器的内容 + 一个变址寄存器的内容；</li>\n</ul>\n</li>\n<li>操作数的<strong>段地址由选择的基址寄存器决定</strong><ul>\n<li>基址寄存器为<code>BX</code>，默认在数据段<code>DS</code></li>\n<li>基址寄存器为<code>BP</code>，默认在堆栈段<code>SS</code></li>\n</ul>\n</li>\n<li>基址变址寻址方式与相对寻址方式一样，主要用于一维数组操作。 </li>\n</ul>\n</li>\n<li><p>5.基址、变址、相对寻址</p>\n<ul>\n<li>操作数的偏移地址为：<ul>\n<li>基址寄存器内容+变址寄存器内容+位移量</li>\n</ul>\n</li>\n<li>操作数的段地址由选择的基址寄存器决定。</li>\n<li>基址变址相对寻址方式主要用于二维表格操作。</li>\n<li>例如：<code>MOV AL, [BP][DI]5</code>==&gt;也可以表示为<code>[BP+DI+5]</code></li>\n</ul>\n</li>\n<li><p>6.隐含寻址</p>\n<ul>\n<li>指令中隐含了一个或两个操作数的地址，即操作数在默认的地址中。</li>\n<li>例：<ul>\n<li><code>MUL BL</code></li>\n</ul>\n</li>\n<li>指令执行：<ul>\n<li><code>AL×BL--&gt;AX</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>I/O端口寻址方式</p>\n<ul>\n<li>直接端口寻址<ul>\n<li>由指令提供一个8位端数（0-255）</li>\n</ul>\n</li>\n<li>间接端口寻址<ul>\n<li>由DX寄存器给出，寻址64KB</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626201755.png\"></p>\n<h2 id=\"第十六讲-数据传送指令\"><a href=\"#第十六讲-数据传送指令\" class=\"headerlink\" title=\"第十六讲 数据传送指令\"></a>第十六讲 数据传送指令</h2><ul>\n<li>8086指令系统从功能上包括六大类：<ul>\n<li>数据传送</li>\n<li>算术运算</li>\n<li>逻辑运算和移位</li>\n<li>串操作</li>\n<li>程序控制</li>\n<li>处理器控制</li>\n</ul>\n</li>\n<li>数据传送类指令<ul>\n<li>1.通用数据传送指令<ul>\n<li>一般数据传送指令<ul>\n<li><code>MOV</code></li>\n<li>格式：<code>MOV dest,src</code></li>\n<li>操作：<code>src-&gt;dest</code></li>\n<li>例子：<code>MOV AL, BL</code></li>\n<li>注意点：两操作数字长必须相同；两操作数不允许同时为存储器操作数；两操作数不允许同时为段寄存器；在源操作数是立即数时，目标操作数不能是段寄存器；IP和CS不作为目标操作数，FLAGS一般也不作为操作数在指令中出现。 </li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626203308.png\"></li>\n</ul>\n</li>\n<li>堆栈操作指令<ul>\n<li>先进后出，以字为单位</li>\n<li>压栈：<code>PUSH OPRD</code> 16位寄存器或存储器两单元</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626204137.png\"></li>\n<li>出栈：<code>POP OPRD</code></li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626204453.png\"></li>\n<li>指令的操作数必须是16位；操作数可以是寄存器或存储器两单元，但不能是立即数；不能从栈顶弹出一个字给CS；PUSH和POP指令在程序中一般成对出现；PUSH指令的操作方向是从<code>高地址向低地址</code>，而POP指令的操作正好相反。 </li>\n<li>堆栈指针寄存器SP指向栈顶位置</li>\n</ul>\n</li>\n<li>交换指令<ul>\n<li>格式：<code>XCHG REG，MEM/REG</code></li>\n<li>注：两操作数必须有一个是寄存器操作数;不允许使用段寄存器。</li>\n<li>例：<code>XCHG AX, BX</code>,<code>XCHG [2000], CL</code></li>\n</ul>\n</li>\n<li>查表转换指令<ul>\n<li>格式：<code>XLAT</code></li>\n<li>说明：用BX的内容代表表格首地址，AL内容为表内位移量，BX+AL得到要查找元素的偏移地址</li>\n<li>操作：将BX+AL所指单元的内容送AL（将BX为首地址的,偏移地址为AL的内容送给AL。）</li>\n</ul>\n</li>\n<li>字位扩展指令 <ul>\n<li>将符号数的符号位扩展到高位；</li>\n<li>指令为零操作数指令，采用隐含寻址，隐含的操作数为AX及AX，DX</li>\n<li>无符号数的扩展规则为在高位补0</li>\n<li>字节到字：<code>CBW</code>，将AL内容扩展到AX ，若AL最高位=1，则执行后AH=FFH，若AL最高位=0，则执行后AH=00H 。AL不变（即将AL的符号位移至AH）<ul>\n<li>CBW属符号扩展指令，它可以把8位扩展到16位，扩展前后两数的真值不变，主要用于数据类型不同时用符号扩展指令可以使得数据类型相同。</li>\n</ul>\n</li>\n<li>字到双字：<code>CWD</code>，将AX内容扩展到DX AX ，若AX最高位=1，则执行后DX=FFFFH，若AX最高位=0，则执行后DX=0000H<ul>\n<li>CWD的作用是将带符号的16位整数（AX）转为32位的带符号位的整数(DX:AX),例如：AX=0xFFFE, 转为32位带符号位的整数时，DX=0xFFFF,AX=0XFFFE.又例如：AX=0x0002,转为带符号位的整数时DX=0x0000,AX=0x0002.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.输入输出指令<ul>\n<li>从端口地址读入数据到累加器/将累加器的值输出到端口中 </li>\n<li>指令格式：<ul>\n<li>输入指令： <code>IN acc，PORT</code></li>\n<li>输出指令 ：<code>OUT PORT，acc</code></li>\n</ul>\n</li>\n<li>根据端口地址码的长度，指令具有两种不同的端口地址表现形式：直接寻址，间接寻址</li>\n</ul>\n</li>\n<li>3.地址传送指令<ul>\n<li><code>LEA</code>取偏移地址指令<ul>\n<li>将变量的16位偏移地址写入到目标寄存器</li>\n<li><code>LEA REG,SRC</code></li>\n</ul>\n</li>\n<li><code>LDS</code>指令<ul>\n<li><code>LDS</code>（Load pointer using DS）的一般格式：</li>\n<li><code>LDS 通用寄存器，存储器操作数(32位)</code></li>\n</ul>\n</li>\n<li><code>LES</code>指令<ul>\n<li><code>LDS</code>和<code>LES</code>均用于将一个32位的远地址指针写入到目标寄存器。</li>\n<li><code>LES</code>（Load pointer using ES）的一般格式：</li>\n<li><code>LES 通用寄存器，存储器操作数(32位)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>4.标志传送指令<ul>\n<li>隐含操作数AH,将FLAGS的低8位装入AH <ul>\n<li><code>LAHF</code>（Load AH from Flags）</li>\n<li><code>SAHF</code>（Store AH into Flags）</li>\n</ul>\n</li>\n<li>隐含操作数FLAGS<ul>\n<li><code>PUSHF</code>（Push flags onto stack）</li>\n<li><code>POPF</code>（Pop flags off stack）</li>\n</ul>\n</li>\n<li>除标志传送指令外，其它指令的执行对标志位不产生影响</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"第四章-算术运算，逻辑运算与移位操作指令\"><a href=\"#第四章-算术运算，逻辑运算与移位操作指令\" class=\"headerlink\" title=\"第四章 算术运算，逻辑运算与移位操作指令\"></a>第四章 算术运算，逻辑运算与移位操作指令</h1><h2 id=\"第十七讲-算术运算类指令\"><a href=\"#第十七讲-算术运算类指令\" class=\"headerlink\" title=\"第十七讲 算术运算类指令\"></a>第十七讲 算术运算类指令</h2><ul>\n<li>加法运算指令<ul>\n<li>1.<code>ADD</code>加法指令<ul>\n<li>格式：<code>ADD OPRD1，OPRD2</code></li>\n<li>操作：<code>OPRD1+OPRD2--&gt;OPRD1</code></li>\n<li>ADD指令的执行对全部6个状态标志位都产生影响</li>\n</ul>\n</li>\n<li>2.<code>ADC</code>带进位的加法指令<ul>\n<li><code> OPRD1+OPRD2+CF--&gt;OPRD1</code></li>\n</ul>\n</li>\n<li>3.<code>INC</code>加1指令<ul>\n<li>格式：<code>INC OPRD</code></li>\n<li>操作：<code>OPRD+1--&gt;OPRD</code></li>\n<li>常用于在程序中修改地址指针,OPRD不能是段寄存器,不能是立即数，除CF外，影响其他标志位</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>减法运算指令<ul>\n<li>1.普通减法指令<code>SUB</code><ul>\n<li>格式：<code>SUB OPRD1，OPRD2</code></li>\n<li>操作：<code>OPRD1- OPRD2--&gt;OPRD1</code></li>\n<li>对标志位的影响与ADD指令同</li>\n</ul>\n</li>\n<li>2.考虑借位的减法指令<code>SBB</code><ul>\n<li>操作：<code>OPRD1- OPRD2- CF--&gt;OPRD1</code></li>\n</ul>\n</li>\n<li>3.减1指令<code>DEC</code><ul>\n<li>格式：<code>DEC OPRD</code></li>\n<li>操作：<code>OPRD - 1--&gt;OPRD</code></li>\n<li>除了不影响CF外，影响其他标志位</li>\n</ul>\n</li>\n<li>4.比较指令<code>CMP</code><ul>\n<li>格式：    <code>CMP OPRD1，OPRD2</code></li>\n<li>操作：<code>OPRD1- OPRD2</code></li>\n<li>指令执行的结果不影响目标操作数，仅影响标志位！</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200626210751.png\"></li>\n</ul>\n</li>\n<li>5.求补指令<code>NEG</code><ul>\n<li><code>NEG OPRD</code></li>\n<li>操作：<code>0-OPRD--&gt;OPRD</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>乘法指令<ul>\n<li>乘法指令采用隐含寻址，隐含的是存放被乘数的累加器AL或AX及存放结果的AX，DX； </li>\n<li>1.无符号的乘法指令MUL<ul>\n<li><code>MUL OPRD</code>不能是立即数和段寄存器</li>\n<li>操作：<ul>\n<li>OPRD为字节数<code>AL×OPRD--&gt;AX</code></li>\n<li>OPRD为16位数<code>AX×OPRD--&gt;DX,AX</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.带符号的乘法指令IMUL <ul>\n<li>格式：<code>IMUL OPRD</code></li>\n<li>指令格式及对操作数的要求与MUL指令相同。</li>\n<li>指令执行原理：<ul>\n<li>① 将两个操作数取补码（对负数按位取反加1，正数不变）；</li>\n<li>② 做乘法运算；</li>\n<li>③ 将乘积按位取反加1。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>除法指令<ul>\n<li>1.无符号除法指令<ul>\n<li>格式： <code>DIV OPRD</code></li>\n<li>操作：<ul>\n<li>操作数是字节(8位)：<code>AX/OPRD</code>,商–&gt;AL,余数–&gt;AH</li>\n<li>操作数是字(16位)：<code>DX,AX/OPRD</code>,商–&gt;AX,余数–&gt;DX</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.有符号除法指令<ul>\n<li>格式： <code>IDIV OPRD</code></li>\n<li>指令格式及对操作数的要求与DIV指令相同。</li>\n</ul>\n</li>\n<li>注：<ul>\n<li>余数符号与被除数相同</li>\n<li>范围<ul>\n<li>双字/字：商范围 -32768到+32767</li>\n<li>字/字节：商范围 -128到+127</li>\n<li>超过范围按除数为0处理，产生0号中断<br>算术运算指令的执行大多对状态标志位会产生影响</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十八讲-逻辑运算指令\"><a href=\"#第十八讲-逻辑运算指令\" class=\"headerlink\" title=\"第十八讲 逻辑运算指令\"></a>第十八讲 逻辑运算指令</h2><ul>\n<li>逻辑运算指令<ul>\n<li>对操作数的要求：<ul>\n<li>大多与MOV指令相同。</li>\n<li>“非”运算指令要求操作数不能是立即数；</li>\n</ul>\n</li>\n<li>对标志位的影响<ul>\n<li>除“非”运算指令，其余指令的执行都会影响除<code>AF</code>外的5个状态标志；</li>\n<li>无论执行结果如何，都会使标志位<code>OF=CF=0</code>。</li>\n<li>“非”运算指令的执行不影响标志位。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>1.”与”指令<ul>\n<li>格式：<code>AND OPRD1，OPRD2</code></li>\n<li>操作：两操作数相“与”，结果送目标地址。<code>(OPRD1)∧(OPRD2)--&gt;(OPRD1)</code></li>\n<li>CF=0,OF=0,SF,ZF,PF有影响，对AF无影响</li>\n</ul>\n</li>\n<li>2.”或”指令<ul>\n<li>格式：<code>OR OPRD1，OPRD2</code></li>\n<li>操作：两操作数相“或”，结果送目标地址 </li>\n</ul>\n</li>\n<li>3.”非”指令<ul>\n<li>格式：<code>NOT OPRD</code></li>\n<li>操作：操作数按位取反再送回原地址</li>\n</ul>\n</li>\n<li>4.”异或”指令<ul>\n<li>格式：<code>XOR OPRD1，OPRD2</code></li>\n<li>操作：两操作数相“异或”，结果送目标地址 </li>\n</ul>\n</li>\n<li>5.”测试”指令<ul>\n<li>格式：<code>TEST OPRD1，OPRD2</code></li>\n<li>操作：执行“与”运算，但运算的结果不送回目标地址。</li>\n<li>应用：常用于测试某些位的状态 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十九讲-移位操作指令\"><a href=\"#第十九讲-移位操作指令\" class=\"headerlink\" title=\"第十九讲 移位操作指令\"></a>第十九讲 移位操作指令</h2><ul>\n<li>移位操作指令<ul>\n<li>控制二进制位向左或向右移动的指令<ul>\n<li>非循环移位指令</li>\n<li>循环移位指令</li>\n</ul>\n</li>\n<li>移动移动1位时由指令直接给出；移动两位及以上时，移位次数必须由CL指定</li>\n</ul>\n</li>\n<li>1.非循环移位指令<ul>\n<li>逻辑左移<code>SHL</code><ul>\n<li>格式： <code>SHL OPR,CNT</code></li>\n<li>注：<ul>\n<li>OPR不能是立即数和段寄存器操作数</li>\n<li>CNT移位次数，若为1，直接写在指令中，若为几，必须先写入CL中</li>\n<li>对CF，OP，PF,ZF，SF有影响，对AF无意义</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>算术左移<code>SAL</code><ul>\n<li>格式：<code>SAL OPR,CNT</code></li>\n<li>操作同<code>SHL</code></li>\n</ul>\n</li>\n<li>逻辑右移<code>SHR</code><ul>\n<li>格式：<code>SHR OPR,CNT</code></li>\n</ul>\n</li>\n<li>算术右移<code>SAR</code><ul>\n<li>格式：<code>SAR OPR,CNT</code></li>\n<li>操作：左边补上符号位，和之前的符号一样</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2.循环移位指令<ul>\n<li>不带进位位的循环移位<ul>\n<li>左移 <code>ROL</code><ul>\n<li>格式： <code>ROL OPR,CNT</code></li>\n</ul>\n</li>\n<li>右移 <code>ROR</code><ul>\n<li>格式： <code>ROR OPR,CNT</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>带进位位的循环移位<ul>\n<li>左移 <code>RCL</code><ul>\n<li>格式： <code>RCL OPR,CNT</code></li>\n</ul>\n</li>\n<li>右移 <code>RCR</code><ul>\n<li>格式： <code>RCR OPR,CNT</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"第五章-串操作指令\"><a href=\"#第五章-串操作指令\" class=\"headerlink\" title=\"第五章 串操作指令\"></a>第五章 串操作指令</h1><h2 id=\"第二十讲-串操作指令\"><a href=\"#第二十讲-串操作指令\" class=\"headerlink\" title=\"第二十讲 串操作指令\"></a>第二十讲 串操作指令</h2><ul>\n<li>针对数据块或字符串的操作 </li>\n<li>可实现存储器到存储器的数据传送； </li>\n<li>待操作的数据串称为源串，目标地址称为目标串。 </li>\n<li>串操作指令的操作对象是多个字节数（一串字符或数据），因此，指令的执行需要确定：<ul>\n<li>串所在的区域<ul>\n<li>源串一般存放在数据段，偏移地址由SI指定。允许段重设。</li>\n<li>目标串必须在附加段，偏移地址由DI指定</li>\n</ul>\n</li>\n<li>串的首地址（原串、目标串起始地址）</li>\n<li>串长度（大小）<ul>\n<li>串长度值由CX指定 </li>\n</ul>\n</li>\n<li>串的操作方向<ul>\n<li>由DF标志位决定。指令根据DF状态自动修改地址指针<ul>\n<li>DF=0 增地址方向 </li>\n<li>DF=1 减地址方向 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>通过增加重复前缀， 可以实现对CX值的自动修改 <ul>\n<li> 无条件重复</li>\n<li>REP<ul>\n<li>当CX≠0时，REP后的指令将继续重复执行</li>\n<li>常用于传送类指令前–》未传完则继续传送 </li>\n</ul>\n</li>\n<li>条件重复<ul>\n<li>相等（为零）重复：REPE（REPZ）</li>\n<li>CX≠0  ∩  ZF=1，则前缀后的指令将继续重复执行</li>\n<li>不相等（不为零）重复：REPNE（ REPNZ）</li>\n<li>CX≠0  ∩  ZF=0，则前缀后的指令将继续重复执行 </li>\n<li>条件前缀常用于运算类指令前，当：<ul>\n<li>1）操作未结束  AND  结果=0</li>\n<li>2）操作未结束  AND  结果≠0 使其后的指令继续重复执行。 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>串操作指令 <ul>\n<li>串传送 <code>MOVS</code> </li>\n<li>串比较 <code>CMPS</code> </li>\n<li>串扫描 <code>SCAS</code> </li>\n<li>串装入 <code>LODS</code> </li>\n<li>串送存 <code>STOS</code> </li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627102608.png\"></p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627102624.png\"></p>\n<h2 id=\"第二十一讲-串传送与串比较指令\"><a href=\"#第二十一讲-串传送与串比较指令\" class=\"headerlink\" title=\"第二十一讲 串传送与串比较指令\"></a>第二十一讲 串传送与串比较指令</h2><p>1.串传送指令</p>\n<ul>\n<li>功能：将原数据串传送到目标地址</li>\n<li>格式：<ul>\n<li><code>MOVS OPRD1，OPRD2</code></li>\n<li><code>MOVSB</code>,按字节传送</li>\n<li><code>MOVSW</code>，按字传送</li>\n</ul>\n</li>\n<li>串传送指令常与无条件重复前缀连用</li>\n</ul>\n<p>2.串比较指令</p>\n<ul>\n<li>功能：用于实现两个数据串的比较</li>\n<li>操作：<ul>\n<li>目标串-源串，结果不写回目标地址</li>\n<li>常与条件重复前缀连用</li>\n</ul>\n</li>\n<li>格式：<ul>\n<li><code>CMPS OPRD1，OPRD2</code></li>\n<li><code>CMPSB</code></li>\n<li><code>CMPSW</code></li>\n</ul>\n</li>\n<li>前缀的操作对标志位不影响</li>\n</ul>\n<h2 id=\"第二十二讲-串扫描指令\"><a href=\"#第二十二讲-串扫描指令\" class=\"headerlink\" title=\"第二十二讲 串扫描指令\"></a>第二十二讲 串扫描指令</h2><ul>\n<li><p>格式：</p>\n<ul>\n<li><code>SCAS OPRD</code></li>\n<li><code>SCASB</code></li>\n<li><code>SCASW</code></li>\n</ul>\n</li>\n<li><p>执行与CMPS指令相似的操作，区别是：这里的源操作数是AX或AL</p>\n</li>\n<li><p>串扫描指令应用例：</p>\n<ul>\n<li>在ES段中从2000H单元开始存放了10个字符，寻找其中有无字符“A”。若有则记下搜索次数，将搜索次数写入到DATA1单元，并将存放“A”的地址写入DATA2单元。</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627103549.png\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十三讲-串装入与串存储指令\"><a href=\"#第二十三讲-串装入与串存储指令\" class=\"headerlink\" title=\"第二十三讲 串装入与串存储指令\"></a>第二十三讲 串装入与串存储指令</h2><p>1.串装入指令</p>\n<ul>\n<li>格式：<ul>\n<li><code>LODS OPRD</code></li>\n<li><code>LODSB</code></li>\n<li><code>LODSW</code></li>\n</ul>\n</li>\n<li>操作：<ul>\n<li>对字节：AL  [DS:SI]</li>\n<li>对  字：AX  [DS:SI]</li>\n</ul>\n</li>\n</ul>\n<p>2.串存储指令</p>\n<ul>\n<li><p>格式：</p>\n<ul>\n<li><code>STOS OPRD</code></li>\n<li><code>STOSB</code></li>\n<li><code>STOSW</code></li>\n</ul>\n</li>\n<li><p>操作：</p>\n<ul>\n<li>对字节： AL  [ES:DI]</li>\n<li>对  字： AX  [ES:DI]</li>\n</ul>\n</li>\n<li><p>串操作指令应用注意事项:</p>\n<ul>\n<li>需要定义附加段<ul>\n<li>目标操作数必须在附加段</li>\n</ul>\n</li>\n<li>需要设置数据的操作方向<ul>\n<li>确定DF的状态</li>\n</ul>\n</li>\n<li>源串和目标串指针分别为SI和DI</li>\n<li>串长度值必须由CX给出</li>\n<li>注意重复前缀的使用方法<ul>\n<li>传送类指令前加无条件重复前缀</li>\n<li>串比较类指令前加条件重复前缀，但前缀不影响ZF状态 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"第六章-程序与处理器控制指令\"><a href=\"#第六章-程序与处理器控制指令\" class=\"headerlink\" title=\"第六章 程序与处理器控制指令\"></a>第六章 程序与处理器控制指令</h1><h2 id=\"第二十四讲-程序控制指令\"><a href=\"#第二十四讲-程序控制指令\" class=\"headerlink\" title=\"第二十四讲 程序控制指令\"></a>第二十四讲 程序控制指令</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627104125.png\"></p>\n<ul>\n<li>程序控制类指令<ul>\n<li>转移指令<ul>\n<li>通过修改指令的偏移地址或段地址及偏移地址实现程序的转移</li>\n<li>无条件转移指令–&gt;无条件转移到目标地址<ul>\n<li><code>JMP OPRD</code></li>\n<li>段内直接转移<ul>\n<li>当偏移量为8位时，称为段内直接短跳转<ul>\n<li>格式：<code>JMP (SHORT) 标号</code></li>\n<li>操作：<code>(IP)&lt;--disp8+(IP)</code></li>\n</ul>\n</li>\n<li>当偏移量为8位时，称为段内直接近跳转<ul>\n<li>格式：<code>JMP (NEAR PTR) 标号</code></li>\n<li>操作：<code>(IP)&lt;--disp16+(IP)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>段内间接转移<ul>\n<li><code>JMP BP</code><ul>\n<li>转向(SS):(BP)</li>\n</ul>\n</li>\n<li><code>JMP BX</code><ul>\n<li>转向(CS):(BX)</li>\n</ul>\n</li>\n<li><code>JMP (WORD PTR) [BX][DI]</code><ul>\n<li>转向(CS):(BX)+(DI)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>段间直接转移<ul>\n<li><code>JMP (FAR PTR) 标号</code></li>\n<li>执行该指令时，将把标号所在的段的值送CS，将标号在所属段内的偏移量送IP，从而形成新的转移地址CS:IP</li>\n</ul>\n</li>\n<li>段间间接转移<ul>\n<li><code>JMP DWORD PTR [BX]</code></li>\n<li>中间的<code>DWORD PTR</code>不能省略，表示存储器双字操作数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>条件转移指令–&gt;当具备一定条件时转移到目标地址<ul>\n<li><code>JC/JNC</code><ul>\n<li>判断CF的状态。常用于两个无符号数大小比较</li>\n</ul>\n</li>\n<li><code>JZ/JNZ</code><ul>\n<li>判断ZF的状态。常用于循环体的结束判断</li>\n</ul>\n</li>\n<li><code>JO/JNO</code><ul>\n<li>判断OF的状态。常用于有符号数溢出的判断</li>\n</ul>\n</li>\n<li><code>JP/JNP</code><ul>\n<li>判断PF的状态。用于判断运算结果低8位中1的个数是否为偶数</li>\n</ul>\n</li>\n<li><code>JS /JNS</code><ul>\n<li>判断SF的状态。常用于判断数的性质 </li>\n</ul>\n</li>\n<li><code>JA/JAE/JB/JBE</code><ul>\n<li>判断CF或CF+ZF的状态。常用于无符号数大小的比较</li>\n</ul>\n</li>\n<li><code>JG/JGE/JL/JLE</code><ul>\n<li>判断SF+OF或SF+OF+ZF的状态。常用于有符号数大小的比较</li>\n</ul>\n</li>\n<li><code>JCXZ</code><ul>\n<li>可根据指令执行后CX的结果实现转移<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200829201509.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>循环控制<ul>\n<li><code>LOOP</code><ul>\n<li>条件：CX≠0</li>\n</ul>\n</li>\n<li><code>LOOPZ</code><ul>\n<li>条件：CX≠0，且ZF=1</li>\n</ul>\n</li>\n<li><code>LOOPNZ</code><ul>\n<li>条件：CX≠0，且ZF=0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>过程调用<ul>\n<li>用于调用一个子过程，必须保护返回地址 </li>\n<li>调用指令的执行过程<ul>\n<li>① 保护断点：将调用指令的下一条指令的地址（断点）压入堆栈</li>\n<li>② 获取子过程的入口地址：子过程第1条指令的偏移地址</li>\n<li>③ 执行子过程：功能实现，参数的保存及恢复</li>\n<li>④ 恢复断点，返回原程序：将断点偏移地址由堆栈弹出 </li>\n</ul>\n</li>\n<li>段内调用：被调用程序与调用程序在同一代码段<ul>\n<li><code>CALL NEAR PROCC</code></li>\n</ul>\n</li>\n<li>段间调用:子过程与原调用程序不在同一代码段</li>\n<li>返回指令:<ul>\n<li>功能：从堆栈中弹出断点地址，返回原程序</li>\n<li>格式：<code>RET</code></li>\n<li>子程序的最后一条指令必须是RET</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>中断控制<ul>\n<li>中断的概念:某种异常或随机事件使处理器暂时停止正在运行的程序，转去执行一段特殊处理程序，并在处理结束后返回原程序被中断处继续执行的过程。</li>\n<li>中断指令：引起CPU产生一次中断的指令 <ul>\n<li>格式：<code>INT n</code></li>\n<li>说明： nх4</li>\n</ul>\n</li>\n<li>中断指令的执行过程<ul>\n<li>① 将FLAGS压入堆栈；</li>\n<li>② 将INT指令的下一条指令的CS、IP压栈；</li>\n<li>③ 由n×4得到存放中断向量的地址；</li>\n<li>④ 将中断向量（中断服务程序入口地址）送CS和IP寄存器；</li>\n<li>⑤ 转入中断服务程序</li>\n</ul>\n</li>\n<li>中断返回指令:<ul>\n<li>格式：<code>IRET</code></li>\n<li>中断服务程序的最后一条指令，负责：恢复断点;恢复标志寄存器内容</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十五讲-处理器控制指令\"><a href=\"#第二十五讲-处理器控制指令\" class=\"headerlink\" title=\"第二十五讲 处理器控制指令\"></a>第二十五讲 处理器控制指令</h2><ul>\n<li>这类指令用来对CPU进行控制，如修改标志寄存器，使CPU暂停，使CPU与外部设备同步等。<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627113916.png\"></li>\n</ul>\n<h1 id=\"第七章-汇编语言\"><a href=\"#第七章-汇编语言\" class=\"headerlink\" title=\"第七章 汇编语言\"></a>第七章 汇编语言</h1><h2 id=\"第二十六讲-汇编语言程序设计\"><a href=\"#第二十六讲-汇编语言程序设计\" class=\"headerlink\" title=\"第二十六讲 汇编语言程序设计\"></a>第二十六讲 汇编语言程序设计</h2><ol>\n<li>汇编语言源程序与汇编程序<br>（1）汇编语言源程序：用助记符编写<br>（2）汇编程序：源程序的编译程序</li>\n<li>汇编语言程序设计与执行过程<br>（1）输入汇编语言源程序：源文件.ASM<br>（2）汇编MASM：目标文件.OBJ<br>（3）链接LINK：可执行文件.EXE<br>（4）调试TD：最终程序</li>\n<li>汇编语言语句类型和格式<br>（1）语句类型：指令性语句，指示性语句<br>（2）语句格式：<br>指令性语句：<code>[标号：] [前缀] 助记符 [操作数]，[操作数] [ ；注释] </code><br>指示性语句格式： <code>[名字] 伪指令助记符 操作数 [，操作数，…] [ ；注释] </code></li>\n<li>汇编语言语句中的操作数<br>(1)寄存器<br>(2)存储器单元<br>(3)常量:（数字/字符串）<br>(4)变量或标号<br>(5)表达式 ：算术运算；逻辑运算；关系运算；取值运算（<code>OFFSET</code>,<code>SEG</code>）和属性运算(<code>PTR</code>)；其它运算 </li>\n</ol>\n<h2 id=\"第二十七讲-数据定义伪代码\"><a href=\"#第二十七讲-数据定义伪代码\" class=\"headerlink\" title=\"第二十七讲 数据定义伪代码\"></a>第二十七讲 数据定义伪代码</h2><ol>\n<li>数据定义伪指令<br>（1）用于定义数据区中变量的类型及其所占内存空间大小<br>（2）DB（Define Byte）:定义的变量为字节型<br>（3）DW （Define Word） :定义的变量为字类型<br>（4）DD （Define Double Word） :定义的变量为双字型<br>（5）DQ （Define Quadword） :定义的变量为4字型<br>（6）DT （Define Tenbytes） :定义的变量为10字节型</li>\n<li>重复操作符<br>（1）当同样的操作数重复多次时，可以使用重复操作符<br>（2）作用：为一个数据区的各单元设置相同的初值<br>（3）格式：[变量名] 伪指令助记符 n DUP（初值 [,初值,… ] ）<br>（4）例：<code>M1 DB 10 DUP（0）</code></li>\n<li>“？”的作用<br>（1）表示随机值，用于预留存储空间<br>（2）例：<code>MEM1 DB 34H，’A’，？</code>，例：<code>DW 20 DUP（？）</code></li>\n<li>调整偏移量伪指令<br>（1）规定程序或变量在逻辑段中的起始地址<br>（2）格式：<code>ORG 表达式</code><br>（3）例：<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATA <span class=\"meta\">SEGMENT</span></span><br><span class=\"line\">ORG <span class=\"number\">1200H</span></span><br><span class=\"line\">BUFF <span class=\"built_in\">DB</span> <span class=\"number\">1</span>,<span class=\"number\">2</span></span><br><span class=\"line\">DATA ENDS </span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"第二十八讲-符号与段定义相关伪指令\"><a href=\"#第二十八讲-符号与段定义相关伪指令\" class=\"headerlink\" title=\"第二十八讲 符号与段定义相关伪指令\"></a>第二十八讲 符号与段定义相关伪指令</h2><ol>\n<li>符号定义伪指令<br>（1）将表达式的值赋给一个名字。当源程序中需多次引用某一表达式时，可以利用EQU伪指令，用一个符号代替表达式，以便于程序维护。<br>（2）格式：<code>符号名 EQU 表达式</code><br>（3）操作：用符号名取代后边的表达式，不可重新定义<br>（4）例：<code>CONSTANT EQU 100 </code></li>\n<li>段定义伪指令<br>（1）在汇编语言源程序中定义逻辑段<br>说明逻辑段的起始和结束<br>说明不同程序模块中同类逻辑段之间的联系形态<br>（2）格式：<code>段名 SEGMENT [定位类型] [组合类型] [’类别’] </code></li>\n<li>设定段寄存器伪指令<br>（1）说明所定义逻辑段的性质<br>（2）格式：<code>ASSUME 段寄存器名:段名[，段寄存器名:段名，…] </code></li>\n<li>结束伪指令<br>（1）表示源程序结束<br>（2）格式：<code>END [标号] </code></li>\n</ol>\n<h2 id=\"第二十九讲-其他伪指令\"><a href=\"#第二十九讲-其他伪指令\" class=\"headerlink\" title=\"第二十九讲 其他伪指令\"></a>第二十九讲 其他伪指令</h2><ol>\n<li>过程定义伪指令<br>（1）用于定义一个过程体<br>（2）格式：<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">过程名 PROC [ <span class=\"built_in\">NEAR</span> / <span class=\"built_in\">FAR</span> ]</span><br><span class=\"line\">┇</span><br><span class=\"line\"><span class=\"keyword\">RET</span></span><br><span class=\"line\">过程名 ENDP</span><br></pre></td></tr></table></figure>\n（3）<img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627120345.png\"></li>\n<li>宏命令伪指令<br>（1）宏：源程序中由汇编程序识别的具有独立功能的一段程序代码<br>（2）当源程序中需要多次使用同一个程序段时，可以将该程序段定义为一个宏<br>（3）格式：<code>宏命令名 MACRO &lt;形式参数&gt;</code><br>（4）<img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627120517.png\"></li>\n</ol>\n<h2 id=\"第三十讲-系统功能调用\"><a href=\"#第三十讲-系统功能调用\" class=\"headerlink\" title=\"第三十讲 系统功能调用\"></a>第三十讲 系统功能调用</h2><ol>\n<li>BIOS、DOS功能调用<br>（1）BIOS：驻留在ROM中的基本输入/输出系统<br>加电自检，装入引导，主要I/O设备处理程序及接口控制<br>（2）DOS：磁盘操作系统<br>DOS功能/BIOS功能调用是调用系统内核子程序<br>（3）BIOS、DOS功能调用：DOS功能与BIOS功能均通过中断方式调用，DOS和BIOS中断均可能影响AX</li>\n<li>DOS软中断<br>（1）DOS中断包括：设备管理，目录管理，文件管理，其它用中断类型码区分<br>（2）DOS软中断：类型码为21H </li>\n<li>单字符输入<br>（1）调用方法：<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">MOV</span> <span class=\"number\">AH</span>，<span class=\"number\">01</span></span><br><span class=\"line\"><span class=\"keyword\">INT</span> <span class=\"number\">21H</span></span><br></pre></td></tr></table></figure>\n（2）输入的字符在AL中 </li>\n<li>字符串输入<br>（1）接收由键盘输入一串字符<br>（2）输入的字符串存储在内存指导区域中<br>（3）用户自定义缓冲区格式：<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627121105.png\"></li>\n<li>单字符显示输出<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627121240.png\"></li>\n<li>字符串显示输出<br>AH 功能号09H<br>DS：DX 待输出字符串的偏移地址<br>INT 21H</li>\n<li>返回操作系统（DOS）功能<br>（1）功能号：4CH<br>（2）调用格式：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV AH，4CH</span><br><span class=\"line\">INT 21H</span><br></pre></td></tr></table></figure>\n（3）功能：程序执行完该2条语句后能正常返回OS;常位于程序结尾处</li>\n</ol>\n<h1 id=\"第八章-半导体存储器\"><a href=\"#第八章-半导体存储器\" class=\"headerlink\" title=\"第八章 半导体存储器\"></a>第八章 半导体存储器</h1><h2 id=\"第三十一讲-半导体存储器概述\"><a href=\"#第三十一讲-半导体存储器概述\" class=\"headerlink\" title=\"第三十一讲 半导体存储器概述\"></a>第三十一讲 半导体存储器概述</h2><ol>\n<li>半导体存储器<br>（1）由能够表示二进制数“0”和“1”的，具有记忆功能的半导体器件组成<br>（2）能存放一位二进制数的半导体器件称为一个存储元<br>（3）若干存储元构成一个存储单元</li>\n<li>半导体存储器的分类</li>\n</ol>\n<ul>\n<li>内存储器：<ul>\n<li>随机存取存储器（RAM）<ul>\n<li>静态存储器（SRAM）</li>\n<li>动态存储器（DRAM）</li>\n</ul>\n</li>\n<li>只读存储器（ROM）<ul>\n<li>掩模ROM</li>\n<li>一次性可写ROM</li>\n<li>可读写ROM<ul>\n<li>EPROM</li>\n<li>EEPROM</li>\n<li>PROM</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>半导体存储器的主要技术指标<br>（1）存储容量：存储单元个数×每单元的二进制数位数<br>存储容量=2^m×N<br>（m：芯片地址线根数）<br>（N：芯片数据线根数）<br>（2）存取时间：实现一次读/写所需要的时间<br>（3）存取周期：连续启动两次独立的存储器操作所需间隔的最小时间<br>（4）可靠性，功耗</li>\n</ol>\n<h2 id=\"第三十二讲-微机中的存储器\"><a href=\"#第三十二讲-微机中的存储器\" class=\"headerlink\" title=\"第三十二讲 微机中的存储器\"></a>第三十二讲 微机中的存储器</h2><ol>\n<li>微机中的存储器<br>（1）内存储器<br>主内存<br>高速缓冲存储器<br>（2）外存储器<br>联机外存<br>脱机外存<br>（3）虚拟存储器<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627143039.png\"></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">内存</th>\n<th align=\"center\">外存</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">速度</td>\n<td align=\"center\">快</td>\n<td align=\"center\">慢</td>\n</tr>\n<tr>\n<td align=\"center\">容量</td>\n<td align=\"center\">小</td>\n<td align=\"center\">大</td>\n</tr>\n<tr>\n<td align=\"center\">单位容量价格</td>\n<td align=\"center\">高</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">制造材料</td>\n<td align=\"center\">半导体</td>\n<td align=\"center\">磁性材料</td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li><p>微机中的存储系统主要有：<br>（1）Cache存储器系统<br>（2）虚拟存储器系统</p>\n</li>\n<li><p>随机存取存储器<br>（1）特点：可以随机读或写操作；掉电后存储内容即丢失<br>（2）类型：静态随机存取存储器（SRAM）；动态随机存取存储器（DRAM）</p>\n</li>\n</ol>\n<h2 id=\"第三十三讲-存储单元的编址\"><a href=\"#第三十三讲-存储单元的编址\" class=\"headerlink\" title=\"第三十三讲 存储单元的编址\"></a>第三十三讲 存储单元的编址</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627143427.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627143454.png\"></p>\n<ol>\n<li>地址译码电路<br>（1）单译码结构<br>（2）双译码结构<br>（3）3-8译码器（741S138）</li>\n</ol>\n<h2 id=\"第三十四讲-存储器扩展技术\"><a href=\"#第三十四讲-存储器扩展技术\" class=\"headerlink\" title=\"第三十四讲 存储器扩展技术\"></a>第三十四讲 存储器扩展技术</h2><ol>\n<li>存储器扩展：用已有的存储器芯片构造一个需要的存储空间<br>（1）用多片存储芯片构成一个需要的内存空间；<br>（2）各存储器芯片在整个内存中占据不同的地址范围；<br>（3）任一时刻仅有一片（或一组）被选中。<br>（4）存储器芯片的存储容量等于：单元数×每单元的位数 </li>\n<li>存储器扩展方法<br>（1）位扩展–》扩展字长<br>（2）字扩展–》扩展单元数<br>（3）字位扩展–》既扩展字长也扩展单元数</li>\n</ol>\n<h1 id=\"第九章-输入输出与中断技术\"><a href=\"#第九章-输入输出与中断技术\" class=\"headerlink\" title=\"第九章 输入输出与中断技术\"></a>第九章 输入输出与中断技术</h1><h2 id=\"第三十五讲-输入输出技术概述\"><a href=\"#第三十五讲-输入输出技术概述\" class=\"headerlink\" title=\"第三十五讲 输入输出技术概述\"></a>第三十五讲 输入输出技术概述</h2><ol>\n<li>I/O接口<br>（1）接口要解决的问题<br>速度匹配👉数据的缓冲与暂存<br>信号的驱动能力👉信号驱动<br>信号形式和电平的匹配👉信号类型转换<br>信息格式👉信号格式转换<br>时序匹配（定时关系）<br>总线隔离👉三态门 </li>\n<li>I/O端口及其编址<br>（1）端口：接口电路中用于缓存数据及控制信息的部件<br>（2）分类：数据端口，控制端口，状态端口<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627144642.png\"><br>（3）I/0端口编址：为确保CPU能够访问到每个不同的端口<br>（4）寻址端口的方法：</li>\n</ol>\n<ul>\n<li>先找到端口所在的接口电路芯片</li>\n<li>再在该芯片上找具体访问的端口<ul>\n<li>若接口中仅有一个端口，则找到芯片即找到端口</li>\n<li>若接口中有多个端口，则找到芯片后需再找端口<br>（5）每个端口地址=片选地址（高位地址）+片内地址 </li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li> I/O地址译码<br>（1）目的：确定端口的地址<br>（2）参加译码的信号：<br><code>#IOR，#IOW，高位地址信号</code><br>（3）对端口读/写信号的产生条件</li>\n</ol>\n<ul>\n<li><code>IO/#M=1</code></li>\n<li><code>#RD=0 #IOR=0</code></li>\n<li><code>#WR=0 #IOW=0</code><br>（4）当接口只有一个端口时：无片内地址，全部地址信号均为高位地址（可全部参与译码），译码输出直接选择该端口；<br>（5）当接口具有多个端口时：则16位地址线的高位参与译码（决定接口的基地址），而低位则用于确定要访问哪一个端口</li>\n</ul>\n<h2 id=\"第三十六讲-简单接口芯片\"><a href=\"#第三十六讲-简单接口芯片\" class=\"headerlink\" title=\"第三十六讲 简单接口芯片\"></a>第三十六讲 简单接口芯片</h2><ol>\n<li> 接口的分类及特点<br>（1）按传输信息的方向分类：<br>输入接口<br>输出接口<br>（2）按传输信息的类型分类：<br>数字接口<br>模拟接口<br>（3）按传输信息的方式分类：<br>并行接口<br>串行接口</li>\n<li>接口特点<br>（1）输入接口：<br>要求对数据具有控制能力<br>常用三态门实现<br>（2）输出接口：<br>要求对数据具有锁存能力<br>常用锁存器实现</li>\n</ol>\n<h2 id=\"第三十七讲-基本输入输出方法\"><a href=\"#第三十七讲-基本输入输出方法\" class=\"headerlink\" title=\"第三十七讲 基本输入输出方法\"></a>第三十七讲 基本输入输出方法</h2><ol>\n<li>基本输入/输出方法<br>（1）无条件传送：要求外设总是处于准备好状态<br>优点：软件及接口硬件简单<br>缺点：只适用于简单外设，适应范围较窄<br>（2）查询式传送：仅当条件满足时才能进行数据传送；每满足一次条件只能进行一次数据传送。<br>适用场合：外设并不总是准备好；对传送速率和效率要求不高<br>工作条件：外设应提供设备状态信息；接口应具备状态端口<br>（3）中断方式传送<br>特点：外设在需要时向CPU提出请求，CPU再去为它服务。服务结束后或在外设不需要时，CPU可执行自己的程序。<br>优点：CPU效率高，实时性好，速度快。<br>缺点：程序编制相对较为复杂。<br>（4）直接存储器存取(DMA) ：<br>特点：<br>①外设直接与存储器进行数据交换 ，CPU不再担当数据传输的中介者；<br>②总线由DMA控制器（DMAC）进行控制（CPU要放弃总线控制权），内存/外设的地址和读写控制信号均由DMAC提供。<br>③DMA传送方式有单元传送方式，快传送方式，请求传送方式<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627145513.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627145541.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627145557.png\"></li>\n</ol>\n<h3 id=\"DMA控制器8237A\"><a href=\"#DMA控制器8237A\" class=\"headerlink\" title=\"DMA控制器8237A\"></a>DMA控制器8237A</h3><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200907143459.png\"></p>\n<h2 id=\"第三十八讲-中断技术\"><a href=\"#第三十八讲-中断技术\" class=\"headerlink\" title=\"第三十八讲 中断技术\"></a>第三十八讲 中断技术</h2><ol>\n<li>中断的基本概念<br>（1）CPU执行程序时，由于发生了某种随机的事件(外部或内部)，<br>引起CPU暂时中断正在运行的程序，转去执行一段特殊的服务<br>程序，以处理该事件，该事件处理完后又返回被中断的程序<br>继续执行，这一过程称为中断。<br>（2）引入中断的原因<br>提高对外设请求的响应实时性。<br>提高了CPU的利用率<br>避免了CPU不断检测外设状态的过程<br>（3）中断类型<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200627145857.png\"></li>\n</ol>\n<h1 id=\"第十章-可编程数字接口电路\"><a href=\"#第十章-可编程数字接口电路\" class=\"headerlink\" title=\"第十章 可编程数字接口电路\"></a>第十章 可编程数字接口电路</h1><h2 id=\"可编程定时计数器8253\"><a href=\"#可编程定时计数器8253\" class=\"headerlink\" title=\"可编程定时计数器8253\"></a>可编程定时计数器8253</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/8253-1.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8253-2.PNG\"></p>\n<h2 id=\"可编程并行接口8255\"><a href=\"#可编程并行接口8255\" class=\"headerlink\" title=\"可编程并行接口8255\"></a>可编程并行接口8255</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/8255-1.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8255-2.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8255-3.PNG\"></p>\n<h2 id=\"可编程中断控制器8259\"><a href=\"#可编程中断控制器8259\" class=\"headerlink\" title=\"可编程中断控制器8259\"></a>可编程中断控制器8259</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-1.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-2.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-3.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-4.PNG\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8259-5.PNG\"></p>\n<h1 id=\"第十一章-模拟接口电路\"><a href=\"#第十一章-模拟接口电路\" class=\"headerlink\" title=\"第十一章 模拟接口电路\"></a>第十一章 模拟接口电路</h1><h2 id=\"模拟量的输入输出\"><a href=\"#模拟量的输入输出\" class=\"headerlink\" title=\"模拟量的输入输出\"></a>模拟量的输入输出</h2><p>D： （Digital） 数字量<br>A： （Analog） 模拟量<br>采样和量化</p>\n<h2 id=\"D-A转换器和A-D转换器\"><a href=\"#D-A转换器和A-D转换器\" class=\"headerlink\" title=\"D/A转换器和A/D转换器\"></a>D/A转换器和A/D转换器</h2><ol>\n<li>主要参数<br>（1）分辨率<br>输入的二进制数每+1/-1个最低有效位LSB，使输出变化的程度 , 1LSB = 1/(2^n-1)<br>[n：D/A转换器的字长]<br>（2）转换时间<br>（3）精度<br>（4）线性度</li>\n<li>D/A转换器与微处理器的接口方法<br>（1）接口任务:解决数据锁存，缓冲问题<br>（2）特点：控制信号，无专门数据传送间隔时间，调节数据宽度<br>（3）接口电路结构：通用并行接口或直连<br>（4）D/A：数字量转换为模拟量</li>\n</ol>\n<h2 id=\"D-A转换器（DAC0832）NS\"><a href=\"#D-A转换器（DAC0832）NS\" class=\"headerlink\" title=\"D/A转换器（DAC0832）NS\"></a>D/A转换器（DAC0832）NS</h2><ol>\n<li>三种工作方式：直通方式，单缓冲方式，双缓冲方式</li>\n<li>8位寄存器，T型电阻网络，电流型输出，不可编程</li>\n<li>主要引脚功能：D7-D0，ILE，CS，WR1，WR2，XFER（低电平有效）</li>\n<li>内部结构：<br>（1）8位输入寄存器<br>（2）8位DAC寄存器<br>（3）8位D/A转换器<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200907141224.png\"></li>\n</ol>\n<h2 id=\"A-D转换器（ADC0809）\"><a href=\"#A-D转换器（ADC0809）\" class=\"headerlink\" title=\"A/D转换器（ADC0809）\"></a>A/D转换器（ADC0809）</h2><p>1.特点</p>\n<ul>\n<li>8通道（8路）输入</li>\n<li>8位字长</li>\n<li>逐位逼近型</li>\n<li>转换时间100us</li>\n<li>内置三态输出缓冲器</li>\n</ul>\n<p>2.主要引脚功能</p>\n<ul>\n<li>D7-D0：输出数据线，三态</li>\n<li>IN0-IN7：8通道模拟输入</li>\n<li>ADDC,ADDB,ADDA通道地址选择</li>\n<li>Start：启动变换</li>\n<li>ALE：通道地址锁存</li>\n<li>EOC：转换结束状态输出</li>\n<li>OE：输出允许</li>\n<li>CLK：工作时钟</li>\n</ul>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ol>\n<li>控制信号<br>（1）M/IO=1,CPU对存储器操作，M/IO=0,CPU对I/O操作<br>（2）DT/R=1,CPU→【内存/（I/O）】，DT/R=0，外部→CPU<br>（3）8086，RD，WR低电平有效</li>\n<li>ADC0809<br>（1）EOC发出中断请求<br>（2）CPU查询EOC状态</li>\n<li>D/A和A/D<br>（1）主要参数：分辨率，转换时间，精度</li>\n<li>数据传输方式（输入输出控制方式）<br>（1）程序控制方式<br> (1.1)无条件传送<br> (1.2)有条件传送（查询）<br>（2）中断控制方式<br>（3）DMA<br> （3.1）DMA传送方式：单元传送，块传送，请求传送<br> （3.2）DMAC，8237A<br> （3.3）DMA方式写，外设到存储器<br> （3.4）8237占用8个输入输出端口<br> （3.5）DMA控制方式中需要用到的一对联络信号是HLDA/HRQ</li>\n<li>串行接口<br>（1）串行接口中，并行数据和串行数据的转换通过移位寄存器实现<br>（2）RS-232是串行通信标准</li>\n<li>片选控制方式，全译码，部分译码，线译码</li>\n<li>I/O接口有独立编址和统一编址方式</li>\n<li>复位后段寄存器的初值为：CS=FFFFH，DS=0000H，SS=0000H，ES=0000H,其他寄存器的初值都是0，特别是CS=FFFFH，IP=0000H，因此复位后CPU从FFFF0H开始执行程序</li>\n<li>奇地址存储体和系统数据总线高8位相连，用BHE=0作为选通信号；偶地址存储体和系统数据总线低8位相连，用A0=0作为连通信号</li>\n<li>对准字，从偶地址开始存放字数据的存放方式（传一次，A0和BHE都有效），非对准字，从奇地址开始存放字数据的存放方式（传两次，先奇BHE后偶A0）</li>\n<li>寻址隐含约定：<br>（1）直接寻址，DS<br>（2）寄存器寻址：DS←BX/SI/DI；SS←BP<br>（3）基址变址寻址：DS←BX+SI/DI ； SS：BP+SI/DI<br>（4）堆栈：SS←SP<br>（5）取指令：CS←IP</li>\n</ol>","categories":[{"name":"学习笔记","path":"api/categories/学习笔记.json"}],"tags":[{"name":"大学课程","path":"api/tags/大学课程.json"},{"name":"微机原理","path":"api/tags/微机原理.json"}]}