{"title":"目标检测 | ATSS，正负样本的选择决定检测性能","slug":"人工智能-ATSS论文笔记","date":"2022-06-29T06:47:13.000Z","updated":"2022-06-29T06:47:13.000Z","comments":true,"path":"api/articles/人工智能-ATSS论文笔记.json","excerpt":null,"covers":["https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220308201514.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102454.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102531.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102948.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311103001.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311103116.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311110826.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311111137.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220629153201.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220629153202.png","https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311111508.png"],"content":"<h1 id=\"1-论文信息\"><a href=\"#1-论文信息\" class=\"headerlink\" title=\"1. 论文信息\"></a>1. 论文信息</h1><p>论文标题：<code>《Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection》</code></p>\n<blockquote>\n<p>论文发表：<code>CVPR2020</code><br>论文链接：<a href=\"https://openaccess.thecvf.com/content_CVPR_2020/papers/Zhang_Bridging_the_Gap_Between_Anchor-Based_and_Anchor-Free_Detection_via_Adaptive_CVPR_2020_paper.pdf\">https://openaccess.thecvf.com</a><br>论文代码：<a href=\"https://github.com/sfzhang15/ATSS\">https://github.com/sfzhang15/ATSS</a></p>\n</blockquote>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220308201514.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@inproceedings&#123;zhang2020bridging,</span><br><span class=\"line\">  title=&#123;Bridging the gap between anchor-based and anchor-free detection via adaptive training sample selection&#125;,</span><br><span class=\"line\">  author=&#123;Zhang, Shifeng and Chi, Cheng and Yao, Yongqiang and Lei, Zhen and Li, Stan Z&#125;,</span><br><span class=\"line\">  booktitle=&#123;Proceedings of the IEEE/CVF conference on computer vision and pattern recognition&#125;,</span><br><span class=\"line\">  pages=&#123;9759--9768&#125;,</span><br><span class=\"line\">  year=&#123;2020&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-归纳总结\"><a href=\"#2-归纳总结\" class=\"headerlink\" title=\"2. 归纳总结\"></a>2. 归纳总结</h1><table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">标签</td>\n<td align=\"center\">#正负样本 #目标检测</td>\n</tr>\n<tr>\n<td align=\"center\">数据集</td>\n<td align=\"center\"><code>MSCOCO</code></td>\n</tr>\n<tr>\n<td align=\"center\">目的</td>\n<td align=\"center\">通过实验发现<code>Anchor-Base</code>和<code>Anchor-Free</code>的区别在于正负样本定义，并提出了<code>ATSS</code></td>\n</tr>\n<tr>\n<td align=\"center\">方法</td>\n<td align=\"center\">使用IoU的均值和标准差作为判断正负样本的自适应<code>IoU</code>阈值</td>\n</tr>\n</tbody></table>\n<h1 id=\"3-问题背景\"><a href=\"#3-问题背景\" class=\"headerlink\" title=\"3. 问题背景\"></a>3. 问题背景</h1><p>论文指出单阶段<code>Anchor-Based</code>和<code>Center-Based Anchor-Free</code>检测算法的性能差异主要来自于<code>正负样本的选择策略不同</code>，基于此问题，作者提出了ATSS(Adaptive Training Sample Selection)方法，该方法能够自动根据真实框（GT）的相关统计特征自适应地选择合适的样本，进而提升模型性能…</p>\n<h1 id=\"4-主要工作\"><a href=\"#4-主要工作\" class=\"headerlink\" title=\"4. 主要工作\"></a>4. 主要工作</h1><ul>\n<li>指出<code>Anchor-Free</code>和<code>Anchor-Based</code>方法的根本差异主要来源于正负样本的选择;</li>\n<li>提出<code>ATSS</code>( <code>Adaptive Training Sample Selection</code>)方法来根据对象的统计特征自动选择正负样本;</li>\n<li>证明每个位置设定多个<code>anchor</code>是无用的操作;</li>\n<li>不引入其它额外的开销，在<code>MS COCO</code>上达到<code>SOTA</code>;</li>\n</ul>\n<h2 id=\"4-1-Anchor-Based和Anchor-Free的区别分析\"><a href=\"#4-1-Anchor-Based和Anchor-Free的区别分析\" class=\"headerlink\" title=\"4.1 Anchor-Based和Anchor-Free的区别分析\"></a>4.1 <code>Anchor-Based</code>和<code>Anchor-Free</code>的区别分析</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102454.png\"></p>\n<p>由于<code>FCOS</code>是基于<code>point</code>进行预测，故可以认为就是一个像素位置有一个<code>anchor</code>，为了公平对比，将<code>RetinaNet</code>的<code>anchor</code>也设置为1个(<code>#A=1</code>),将<code>FCOS</code>的训练策略移动到<code>RetinaNet</code>上面，可以发现性能依然是<code>RetinaNet</code>低于fcos 0.8mAP。 排除这个因素后，现在两个算法的区别是：</p>\n<ul>\n<li>1.<strong>正负样本定义；</strong><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102531.png\"></li>\n<li>2.<strong>回归分支中从<code>point</code>回归还是从<code>anchor</code>回归；</strong>从<code>point</code>回归就是指的每个点预测距离4条边的距离模式，而从<code>anchor</code>回归是指的<code>RetinaNet</code>那种基于<code>anchor</code>偏移量回归的模式。<img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102948.png\"></li>\n</ul>\n<p>但作者通过实验分析可以知道回归分支中从point回归还是从anchor回归对最终影响很小，反而是正负样本定义对结果影响最大。</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311103001.png\"></p>\n<h2 id=\"4-2-ATSS\"><a href=\"#4-2-ATSS\" class=\"headerlink\" title=\"4.2 ATSS\"></a>4.2 ATSS</h2><p>算法流程如下：<br><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311103116.png\"></p>\n<p>论文提出ATSS方法，该方法根据目标的相关统计特征自动进行正负样本的选择，具体逻辑如算法1所示。对于每个GT box  <code>g</code>，首先在每个特征层找到中心点最近的<code>k</code>个候选anchor boxes(非预测结果)，计算候选box与GT间的IoU $U_g$，计算IoU的均值$m_g$和标准差$v_g$，得到IoU阈值$t_g=m_g+v_g$，最后选择阈值大于$t_g$的box作为最后的输出。如果anchor box对应多个GT，则选择IoU最大的GT。</p>\n<p>均值$m_g$表示预设的anchor与GT的匹配程度，均值高则应当提高阈值来调整正样本，均值低则应当降低阈值来调整正样本。标准差$v_g$表示适合GT的FPN层数，标准差高则表示高质量的anchor box集中在一个层中，应将阈值加上标准差来过滤其他层的anchor box，低则表示多个层都适合该GT，将阈值加上标准差来选择合适的层的anchor box，均值和标准差结合作为IoU阈值能够很好地自动选择对应的特征层上合适的anchor box;</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311110826.png\"></p>\n<p>根据统计原理，大约16%的anchor box会落在$[m_g+v_g,1]$，尽管候选框的IoU不是标准正态分布，但统计下来每个GT大约有0.2×kL个正样本，与其大小和长宽比无关，而RetinaNet和FCOS则是偏向大目标有更多的正样本，导致训练不公平；其中ATSS仅有一个超参数k，并且实验表明ATSS的性能对k不敏感，参数<code>k</code>在区间$[7,17]$几乎是一样的，过大的设置会到导致过多的低质量候选anchor，而过小的设置则会导致过少的正样本，而且统计结果也不稳定。总体而言，参数<code>k</code>是相对鲁棒的，所以ATSS几乎是hyperparameter-free的。</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311111137.png\"></p>\n<p>将ATSS应用到RetinaNet和FCOS上测试效果：</p>\n<ul>\n<li>将RetinaNet中的正负样本替换为ATSS，AP提升了2.9%，这样的性能提升几乎是没有任何额外消耗的</li>\n<li>在FCOS上的应用主要用两种：lite版本采用ATSS的思想，从选取GT内的anchor point改为选取每层离GT最近的top-$k$个候选anchor point，提升了0.8%AP；full版本将FCOS的<code>anchor point</code>改为长宽为$8S$的<code>anchor box</code>来根据ATSS选择正负样本，但仍然使用原始的回归方法，提升了1.4%AP。两种方法找到的<code>anchor point</code>在空间位置上大致相同，但是在<code>FPN</code>层上的选择不太一样。从结果来看，自适应的选择方法比固定的方法更有效。</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220629153201.png\"></p>\n<p>论文还补充测试了不同anchor数下的性能，并且其实验结果证明，在每个位置设定多个anchor box是无用的操作，关键在于选择合适的正样本；</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220629153202.png\"></p>\n<h1 id=\"5-实验结果\"><a href=\"#5-实验结果\" class=\"headerlink\" title=\"5. 实验结果\"></a>5. 实验结果</h1><p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311111508.png\"></p>\n<h1 id=\"6-参考文献\"><a href=\"#6-参考文献\" class=\"headerlink\" title=\"6. 参考文献\"></a>6. 参考文献</h1><p><a href=\"https://zhuanlan.zhihu.com/p/115407465\">ATSS : 目标检测的自适应正负anchor选择，很扎实的trick | CVPR 2020 - 知乎 (zhihu.com)</a></p>\n","more":"<h1 id=\"1-论文信息\"><a href=\"#1-论文信息\" class=\"headerlink\" title=\"1. 论文信息\"></a>1. 论文信息</h1><p>论文标题：<code>《Bridging the Gap Between Anchor-based and Anchor-free Detection via Adaptive Training Sample Selection》</code></p>\n<blockquote>\n<p>论文发表：<code>CVPR2020</code><br>论文链接：<a href=\"https://openaccess.thecvf.com/content_CVPR_2020/papers/Zhang_Bridging_the_Gap_Between_Anchor-Based_and_Anchor-Free_Detection_via_Adaptive_CVPR_2020_paper.pdf\">https://openaccess.thecvf.com</a><br>论文代码：<a href=\"https://github.com/sfzhang15/ATSS\">https://github.com/sfzhang15/ATSS</a></p>\n</blockquote>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220308201514.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@inproceedings&#123;zhang2020bridging,</span><br><span class=\"line\">  title=&#123;Bridging the gap between anchor-based and anchor-free detection via adaptive training sample selection&#125;,</span><br><span class=\"line\">  author=&#123;Zhang, Shifeng and Chi, Cheng and Yao, Yongqiang and Lei, Zhen and Li, Stan Z&#125;,</span><br><span class=\"line\">  booktitle=&#123;Proceedings of the IEEE/CVF conference on computer vision and pattern recognition&#125;,</span><br><span class=\"line\">  pages=&#123;9759--9768&#125;,</span><br><span class=\"line\">  year=&#123;2020&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-归纳总结\"><a href=\"#2-归纳总结\" class=\"headerlink\" title=\"2. 归纳总结\"></a>2. 归纳总结</h1><table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">标签</td>\n<td align=\"center\">#正负样本 #目标检测</td>\n</tr>\n<tr>\n<td align=\"center\">数据集</td>\n<td align=\"center\"><code>MSCOCO</code></td>\n</tr>\n<tr>\n<td align=\"center\">目的</td>\n<td align=\"center\">通过实验发现<code>Anchor-Base</code>和<code>Anchor-Free</code>的区别在于正负样本定义，并提出了<code>ATSS</code></td>\n</tr>\n<tr>\n<td align=\"center\">方法</td>\n<td align=\"center\">使用IoU的均值和标准差作为判断正负样本的自适应<code>IoU</code>阈值</td>\n</tr>\n</tbody></table>\n<h1 id=\"3-问题背景\"><a href=\"#3-问题背景\" class=\"headerlink\" title=\"3. 问题背景\"></a>3. 问题背景</h1><p>论文指出单阶段<code>Anchor-Based</code>和<code>Center-Based Anchor-Free</code>检测算法的性能差异主要来自于<code>正负样本的选择策略不同</code>，基于此问题，作者提出了ATSS(Adaptive Training Sample Selection)方法，该方法能够自动根据真实框（GT）的相关统计特征自适应地选择合适的样本，进而提升模型性能…</p>\n<h1 id=\"4-主要工作\"><a href=\"#4-主要工作\" class=\"headerlink\" title=\"4. 主要工作\"></a>4. 主要工作</h1><ul>\n<li>指出<code>Anchor-Free</code>和<code>Anchor-Based</code>方法的根本差异主要来源于正负样本的选择;</li>\n<li>提出<code>ATSS</code>( <code>Adaptive Training Sample Selection</code>)方法来根据对象的统计特征自动选择正负样本;</li>\n<li>证明每个位置设定多个<code>anchor</code>是无用的操作;</li>\n<li>不引入其它额外的开销，在<code>MS COCO</code>上达到<code>SOTA</code>;</li>\n</ul>\n<h2 id=\"4-1-Anchor-Based和Anchor-Free的区别分析\"><a href=\"#4-1-Anchor-Based和Anchor-Free的区别分析\" class=\"headerlink\" title=\"4.1 Anchor-Based和Anchor-Free的区别分析\"></a>4.1 <code>Anchor-Based</code>和<code>Anchor-Free</code>的区别分析</h2><p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102454.png\"></p>\n<p>由于<code>FCOS</code>是基于<code>point</code>进行预测，故可以认为就是一个像素位置有一个<code>anchor</code>，为了公平对比，将<code>RetinaNet</code>的<code>anchor</code>也设置为1个(<code>#A=1</code>),将<code>FCOS</code>的训练策略移动到<code>RetinaNet</code>上面，可以发现性能依然是<code>RetinaNet</code>低于fcos 0.8mAP。 排除这个因素后，现在两个算法的区别是：</p>\n<ul>\n<li>1.<strong>正负样本定义；</strong><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102531.png\"></li>\n<li>2.<strong>回归分支中从<code>point</code>回归还是从<code>anchor</code>回归；</strong>从<code>point</code>回归就是指的每个点预测距离4条边的距离模式，而从<code>anchor</code>回归是指的<code>RetinaNet</code>那种基于<code>anchor</code>偏移量回归的模式。<img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311102948.png\"></li>\n</ul>\n<p>但作者通过实验分析可以知道回归分支中从point回归还是从anchor回归对最终影响很小，反而是正负样本定义对结果影响最大。</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311103001.png\"></p>\n<h2 id=\"4-2-ATSS\"><a href=\"#4-2-ATSS\" class=\"headerlink\" title=\"4.2 ATSS\"></a>4.2 ATSS</h2><p>算法流程如下：<br><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311103116.png\"></p>\n<p>论文提出ATSS方法，该方法根据目标的相关统计特征自动进行正负样本的选择，具体逻辑如算法1所示。对于每个GT box  <code>g</code>，首先在每个特征层找到中心点最近的<code>k</code>个候选anchor boxes(非预测结果)，计算候选box与GT间的IoU $U_g$，计算IoU的均值$m_g$和标准差$v_g$，得到IoU阈值$t_g=m_g+v_g$，最后选择阈值大于$t_g$的box作为最后的输出。如果anchor box对应多个GT，则选择IoU最大的GT。</p>\n<p>均值$m_g$表示预设的anchor与GT的匹配程度，均值高则应当提高阈值来调整正样本，均值低则应当降低阈值来调整正样本。标准差$v_g$表示适合GT的FPN层数，标准差高则表示高质量的anchor box集中在一个层中，应将阈值加上标准差来过滤其他层的anchor box，低则表示多个层都适合该GT，将阈值加上标准差来选择合适的层的anchor box，均值和标准差结合作为IoU阈值能够很好地自动选择对应的特征层上合适的anchor box;</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311110826.png\"></p>\n<p>根据统计原理，大约16%的anchor box会落在$[m_g+v_g,1]$，尽管候选框的IoU不是标准正态分布，但统计下来每个GT大约有0.2×kL个正样本，与其大小和长宽比无关，而RetinaNet和FCOS则是偏向大目标有更多的正样本，导致训练不公平；其中ATSS仅有一个超参数k，并且实验表明ATSS的性能对k不敏感，参数<code>k</code>在区间$[7,17]$几乎是一样的，过大的设置会到导致过多的低质量候选anchor，而过小的设置则会导致过少的正样本，而且统计结果也不稳定。总体而言，参数<code>k</code>是相对鲁棒的，所以ATSS几乎是hyperparameter-free的。</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311111137.png\"></p>\n<p>将ATSS应用到RetinaNet和FCOS上测试效果：</p>\n<ul>\n<li>将RetinaNet中的正负样本替换为ATSS，AP提升了2.9%，这样的性能提升几乎是没有任何额外消耗的</li>\n<li>在FCOS上的应用主要用两种：lite版本采用ATSS的思想，从选取GT内的anchor point改为选取每层离GT最近的top-$k$个候选anchor point，提升了0.8%AP；full版本将FCOS的<code>anchor point</code>改为长宽为$8S$的<code>anchor box</code>来根据ATSS选择正负样本，但仍然使用原始的回归方法，提升了1.4%AP。两种方法找到的<code>anchor point</code>在空间位置上大致相同，但是在<code>FPN</code>层上的选择不太一样。从结果来看，自适应的选择方法比固定的方法更有效。</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220629153201.png\"></p>\n<p>论文还补充测试了不同anchor数下的性能，并且其实验结果证明，在每个位置设定多个anchor box是无用的操作，关键在于选择合适的正样本；</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220629153202.png\"></p>\n<h1 id=\"5-实验结果\"><a href=\"#5-实验结果\" class=\"headerlink\" title=\"5. 实验结果\"></a>5. 实验结果</h1><p><img src=\"https://npm.elemecdn.com/justlovesmile-post@1.0.1/20220311111508.png\"></p>\n<h1 id=\"6-参考文献\"><a href=\"#6-参考文献\" class=\"headerlink\" title=\"6. 参考文献\"></a>6. 参考文献</h1><p><a href=\"https://zhuanlan.zhihu.com/p/115407465\">ATSS : 目标检测的自适应正负anchor选择，很扎实的trick | CVPR 2020 - 知乎 (zhihu.com)</a></p>\n","categories":[{"name":"人工智能","path":"api/categories/人工智能.json"}],"tags":[{"name":"深度学习","path":"api/tags/深度学习.json"},{"name":"论文笔记","path":"api/tags/论文笔记.json"},{"name":"目标检测","path":"api/tags/目标检测.json"}]}