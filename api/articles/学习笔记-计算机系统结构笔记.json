{"title":"大学课程 | 计算机系统结构","slug":"学习笔记-计算机系统结构笔记","date":"2020-04-13T02:33:59.000Z","updated":"2020-04-13T02:33:59.000Z","comments":true,"path":"api/articles/学习笔记-计算机系统结构笔记.json","excerpt":"大三计算机系统结构知识点总结笔记","covers":["https://npm.elemecdn.com/justlovesmile-img/GmXU9f.jpg","https://npm.elemecdn.com/justlovesmile-img/Gn93xx.jpg","https://npm.elemecdn.com/justlovesmile-img/GKobNV.png","https://npm.elemecdn.com/justlovesmile-img/GKT6KJ.png","https://npm.elemecdn.com/justlovesmile-img/GnAISJ.jpg","https://npm.elemecdn.com/justlovesmile-img/GQGiSH.jpg","https://npm.elemecdn.com/justlovesmile-img/GQT9Nq.png","https://npm.elemecdn.com/justlovesmile-img/GQHup6.png","https://npm.elemecdn.com/justlovesmile-img/GQHTE9.png","https://npm.elemecdn.com/justlovesmile-img/GQbfPI.jpg","https://npm.elemecdn.com/justlovesmile-img/GQqlod.png","https://npm.elemecdn.com/justlovesmile-img/G1iX6g.png","https://npm.elemecdn.com/justlovesmile-img/GQOgZF.png","https://npm.elemecdn.com/justlovesmile-img/G1kiVA.png","https://npm.elemecdn.com/justlovesmile-img/GQX3FJ.png","https://npm.elemecdn.com/justlovesmile-img/GQX0Te.png","https://npm.elemecdn.com/justlovesmile-img/GQj7Ue.png","https://npm.elemecdn.com/justlovesmile-img/GQzTET.png","https://npm.elemecdn.com/justlovesmile-img/GlSiPe.png","https://npm.elemecdn.com/justlovesmile-img/G1KCqK.png","https://npm.elemecdn.com/justlovesmile-img/G1MekF.png","https://npm.elemecdn.com/justlovesmile-img/1.png","https://npm.elemecdn.com/justlovesmile-img/20200415122950.png","https://npm.elemecdn.com/justlovesmile-img/20200415134043.png","https://npm.elemecdn.com/justlovesmile-img/20200826171758.png","https://npm.elemecdn.com/justlovesmile-img/20200415135441.png","https://npm.elemecdn.com/justlovesmile-img/20200415140626.png","https://npm.elemecdn.com/justlovesmile-img/Y5E%7B1ZHXC%25%5B77%7BW_5Z2%5BY%5DO.png","https://npm.elemecdn.com/justlovesmile-img/%25%7DMG%25YPJF2L0QNXJ%7DK8FC%402.png","https://npm.elemecdn.com/justlovesmile-img/%29%7DUAT%7DO7%7D%7B%25%28WNSFI%40I%25MOP.png","https://npm.elemecdn.com/justlovesmile-img/20200415142649.png","https://npm.elemecdn.com/justlovesmile-img/8K2W9S17_VYSURM8WL~%25YOQ.png"],"content":"<p>大三计算机系统结构知识点总结笔记</p>\n<span id=\"more\"></span>\n\n<h1 id=\"计算机系统结构\"><a href=\"#计算机系统结构\" class=\"headerlink\" title=\"计算机系统结构\"></a>计算机系统结构</h1><h2 id=\"第一章-计算机系统结构基础及并行性的开发\"><a href=\"#第一章-计算机系统结构基础及并行性的开发\" class=\"headerlink\" title=\"第一章 计算机系统结构基础及并行性的开发\"></a>第一章 计算机系统结构基础及并行性的开发</h2><ul>\n<li>计算机性能的高速增长受益于<ul>\n<li>电路技术的发展</li>\n<li>体系结构技术的发展</li>\n<li>其他因素(OS, Compiler 的发展)</li>\n</ul>\n</li>\n<li>80年代后，RISC技术和微处理器技术使得体系结构技术对计算机性能发展的影响越来越大</li>\n</ul>\n<blockquote>\n<p>CISC(复杂指令集)结构出现得较早。在这种结构中，新功能的增加主要靠增加新的指令，但为了保持向下兼容，就必须保持原有的指令；每条指令都有不同的操作指令码，对应不同的数据类型和位置，这样就造成了系统具有较大的指令系统和复杂的寻址技术，指令格式也很不规范。而RISC(精简指令集)结构则采用定长指令，使用流水线的方式执行指令。这种结构大量利用寄存器间的操作，大大简化了处理器的结构，优化了VLSI器件的使用效率，同时功耗较低。与CISC处理器相比，RISC处理器的突出特点是只用硬件实现最常用的指令，其他指令通过微代码软件来模拟实现，通过简短的定长指令提高并行度。这样虽然硬件设计较简单，但处理器指令的逻辑设计反而复杂了。RISC诞生之时恰逢386处理器取得了巨大的成功。在当时条件下，同样工艺水平的芯片，采用RISC架构的产品，其速度比CISC快3倍左右，这在Intel内部产生了很大的震动。最终诞生的 486处理器是第一个真正引入RISC技术的X86处理器。</p>\n</blockquote>\n<h3 id=\"1-1-计算机系统的层次结构\"><a href=\"#1-1-计算机系统的层次结构\" class=\"headerlink\" title=\"1.1 计算机系统的层次结构\"></a>1.1 计算机系统的层次结构</h3><ul>\n<li>如何从整体上认识计算机系统？<ul>\n<li>一种新的认识方法：从计算机语言的角度，将计算机系统看成按<strong>功能</strong>划分的<strong>多级层次结构</strong></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GmXU9f.jpg\" alt=\"GmXU9f.jpg\"></p>\n<ul>\n<li>M0用硬件实现，M1用微程序（固件）实现，M2到M5大多用软件实现</li>\n<li>固件：是一种具有软件功能的硬件</li>\n<li>虚拟机：由软件实现的机器。虚拟机的功能不一定全由软件实现，也可以是固件或硬件</li>\n<li><strong>选择什么样的软硬件比例</strong>，是系统结构研究的核心内容之一</li>\n<li>多层系统结构的意义和作用<ul>\n<li>推动了计算机系统结构的发展<ul>\n<li>有利于正确理解软件、硬件和固件在系统结构中的地位和作用</li>\n</ul>\n</li>\n<li>发展了多处理机系统、分布处理系统、计算机网络系统等系统结构<ul>\n<li>每级有各自的用户、实现方法和指令集，摆脱各级功能在一台机器实现</li>\n</ul>\n</li>\n<li>推动自虚拟机、多种操作系统共行等技术</li>\n</ul>\n</li>\n<li>对于使用某一级语言编程的程序员来说，只需要熟悉和遵守该级语言的使用规定。</li>\n<li>各机器级的实现采用翻译技术或解释技术，或者两者结合</li>\n<li><strong>翻译</strong>： 先用转换程序将高一级机器级上的程序<strong>整个</strong>地变换成低一级机器级上等效的程序，然后再在低一级机器级上实现的技术</li>\n<li><strong>解释</strong>： 在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级的机器级语言程序中的每条语句或指令<strong>逐条</strong>解释来实现的技术</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/Gn93xx.jpg\" alt=\"Gn93xx.jpg\"></p>\n<h3 id=\"1-2-计算机系统结构，计算机组成和计算机实现\"><a href=\"#1-2-计算机系统结构，计算机组成和计算机实现\" class=\"headerlink\" title=\"1.2 计算机系统结构，计算机组成和计算机实现\"></a>1.2 计算机系统结构，计算机组成和计算机实现</h3><h4 id=\"1-2-1-计算机系统结构的定义和内涵\"><a href=\"#1-2-1-计算机系统结构的定义和内涵\" class=\"headerlink\" title=\"1.2.1 计算机系统结构的定义和内涵\"></a>1.2.1 计算机系统结构的定义和内涵</h4><p>从计算机系统的层次结构角度来看，系统结构是对计算机系统中各级界面的定义及其上下的功能分配。计算机系统的每一级都有自己的系统结构。</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GKobNV.png\" alt=\"GKobNV.png\"></p>\n<ul>\n<li>从不同级看到的计算机属性是不同的</li>\n<li>计算机系统的层次结构具有的特征：<strong>透明性</strong></li>\n<li>透明：客观存在的事物或属性从某个角度<strong>看不到</strong><ul>\n<li>优点：可以不用管理它，简化设计</li>\n<li>缺点：看不到而无法加以控制，会带来不利</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GKT6KJ.png\" alt=\"GKT6KJ.png\"></p>\n<p>计算机系统结构也称为计算机系统的体系结构，它只是系统结构中的一部分，指的是传统机器级的系统结构。</p>\n<ul>\n<li>结论：计算机系统结构研究的是软，硬件之间的功能分配以及对传统机器级界面的确定</li>\n<li>计算机系统结构是程序员所看到的计算机的属性，即概念性结构与功能特性</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GnAISJ.jpg\" alt=\"GnAISJ.jpg\"></p>\n<blockquote>\n<p>堆栈型机器、累加器型机器和通用寄存器型机器各自有什么优缺点<br>1.堆栈型机器——CPU 中存储操作数的单元是堆栈的机器。<br>2.累加型机器——CPU 中存储操作数的单元是累加器的机器。<br>3.通用寄存器型机器——CPU 中存储操作数的单元是通用寄存器的机器。<br>CPU状态分为管态和目态，CPU的状态属于程序状态字PSW的一位，管态又称特权状态、系统态或核心态。通常，操作系统在管态下运行，CPU在管态下可以执行指令系统的全集。<br>目态又称常态或用户态，机器处于目态时，程序只能执行非特权指令。用户程序只能在目态下运行。</p>\n</blockquote>\n<h4 id=\"1-2-2-计算机组成和计算机实现的定义及内涵\"><a href=\"#1-2-2-计算机组成和计算机实现的定义及内涵\" class=\"headerlink\" title=\"1.2.2 计算机组成和计算机实现的定义及内涵\"></a>1.2.2 计算机组成和计算机实现的定义及内涵</h4><p>1.<strong>计算机组成</strong>：是指<strong>计算机系统结构的逻辑实现</strong>，包括机器级内部的数据流和控制流的组成以及逻辑设计等等<br>（1）着眼点：机器内部各事件的排序方式与控制机构，各部件的功能及各部件间的联系。<br>（2）预解决：在合理或满足要求的性能和价格的条件下，怎么最佳、最合理地把各种设备和部件组织成计算机，以实现所确定的计算机。</p>\n<ul>\n<li>计算机组成设计要确定的方面包括：<ul>\n<li>数据通路宽度（数据总线上一次并行传送的信息位数）</li>\n<li>各种操作对功能部件的共享程度</li>\n<li>专用功能部件的设置</li>\n<li>功能部件的并行性</li>\n<li>缓冲和排队技术</li>\n<li>预测技术</li>\n<li>可靠性技术</li>\n<li>控制机构的组成，等等</li>\n</ul>\n</li>\n</ul>\n<p>2.<strong>计算机实现</strong>：是计算机组成的<strong>物理实现</strong><br>（1）着眼点：器件技术（主导作用），微组装技术</p>\n<ul>\n<li>计算机实现:(是数字电路等课程主要研究的内容)<ul>\n<li>处理器、主存的物理结构</li>\n<li>器件的集成度和速度</li>\n<li>信号传输</li>\n<li>器件、模块、插件、底板的划分与连接</li>\n<li>涉及的专用器件</li>\n<li>电源、冷却、微组装技术、整机装配技术，等等</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQGiSH.jpg\" alt=\"GQGiSH.jpg\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQGwp4.png\" alt=\"GQGwp4.png\"></p>\n<ul>\n<li>系列机：CPU的机器指令和汇编指令系统相同（或绝大部分相同）</li>\n<li><strong>狭义的系统结构</strong>是<strong>组成</strong>的抽象</li>\n<li><strong>组成</strong>是<strong>实现</strong>的抽象</li>\n<li>一种体系结构可以有多种组成，一种组成可以有多种物理实现</li>\n<li><strong>计算机系统结构</strong>研究的范畴：机器/汇编指令系统，数据表示，是否采用通道方式输入/输出的确定</li>\n<li><strong>计算机组成研究</strong>的范畴：指令采用顺序，重叠，流水还是其他方式解释，数据通路宽度的确定，通道采用结合型还是独立型</li>\n<li><strong>广义</strong>的计算机体系结构定义：包括<strong>狭义的系统结构，计算机组成</strong><ul>\n<li>任务：<ul>\n<li>从程序设计者角度：软硬件的功能分配以及确定软硬件界面</li>\n<li>从计算机设计者角度：更合理地实现分配给硬件的功能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-3-计算机系统结构，组成和实现的相互影响\"><a href=\"#1-2-3-计算机系统结构，组成和实现的相互影响\" class=\"headerlink\" title=\"1.2.3 计算机系统结构，组成和实现的相互影响\"></a>1.2.3 计算机系统结构，组成和实现的相互影响</h4><ul>\n<li>计算机系统结构，组成，实现三者互不相同，但又互相影响</li>\n<li>不同的系统结构会影响到组成技术</li>\n<li>组成技术也会影响系统结构，是一种推动作用<ul>\n<li>专用部件的设置</li>\n</ul>\n</li>\n<li><strong>实现</strong>永远是结构和组成的最坚实基础</li>\n</ul>\n<h3 id=\"1-3-计算机系统的软硬件取舍，性能评测及定量设计原理\"><a href=\"#1-3-计算机系统的软硬件取舍，性能评测及定量设计原理\" class=\"headerlink\" title=\"1.3 计算机系统的软硬件取舍，性能评测及定量设计原理\"></a>1.3 计算机系统的软硬件取舍，性能评测及定量设计原理</h3><h4 id=\"1-3-1-软，硬件取舍的基本原则\"><a href=\"#1-3-1-软，硬件取舍的基本原则\" class=\"headerlink\" title=\"1.3.1 软，硬件取舍的基本原则\"></a>1.3.1 软，硬件取舍的基本原则</h4><ul>\n<li>计算机系统结构的任务：<ul>\n<li>软、硬功能分配，确定软硬界面</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>提高硬件功能比例</th>\n<th>提高软件功能比例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>提高解题速度</td>\n<td>降低解题速度</td>\n</tr>\n<tr>\n<td>减少程序所需存储空间</td>\n<td>增加程序所需存储空间</td>\n</tr>\n<tr>\n<td>增加硬件成本</td>\n<td>减少硬件成本</td>\n</tr>\n<tr>\n<td>降低软件费用</td>\n<td>增加软件费用</td>\n</tr>\n<tr>\n<td>降低硬件利用率</td>\n<td>增加系统灵活性</td>\n</tr>\n<tr>\n<td>降低系统灵活性</td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>软硬件取舍的<strong>三原则</strong>：</p>\n<ul>\n<li>在现有的硬件和器件条件下，系统要有<strong>高的性能价格比</strong>；</li>\n<li>在软硬功能分配时，要考虑到准备采用的组成和实现技术，<strong>使其不过多的限制或不合理限制各种组成、实现技术</strong>；</li>\n<li>在软硬功能分配时，除了从“硬件”角度考虑，还要从“软”的角度考虑，把为<strong>编译、OS以及高级语言的设计与实现提供更多、更好的硬件支持放在首位</strong>。</li>\n</ul>\n</li>\n<li><p>语义差距的大小实质上取决于软硬件功能的分配</p>\n</li>\n</ul>\n<h4 id=\"1-3-2-计算机系统的性能评测与定量设计原理\"><a href=\"#1-3-2-计算机系统的性能评测与定量设计原理\" class=\"headerlink\" title=\"1.3.2 计算机系统的性能评测与定量设计原理\"></a>1.3.2 计算机系统的性能评测与定量设计原理</h4><p>1.计算机系统的性能评测</p>\n<ul>\n<li>时钟频率：CPU的主频表示在CPU内数字脉冲信号震荡的速度，与CPU实际的运算能力并没有直接关系</li>\n<li>计算机系统的性能指标体现于<strong>时间</strong>和<strong>空间</strong>两个方面，在系统上程序实际运行的<strong>时间</strong>应该是衡量机器时间（速度）性能最可靠的标准</li>\n<li>机器的性能是通过采用好的硬件，系统结构以及高效的资源管理等技术来提高的</li>\n<li>计算机性能指：数据处理（数据运算（速度），数据传输（速度）），数据容量，数据质量的综合性能</li>\n<li>系统性能的测量依赖于人（计算机用户/系统管理者）的观点</li>\n<li>计算机的性能以及对系统评价的目标都指<strong>系统速度的性能</strong>，通常是用<strong>响应时间</strong>来衡量</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQT9Nq.png\" alt=\"GQT9Nq.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQTuU1.png\" alt=\"GQTuU1.png\"></p>\n<ul>\n<li><p>减少CPI是RISC思想的精华 </p>\n</li>\n<li><p>反应程序的运行速度通常引入下面一些指标</p>\n<ul>\n<li>MIPS：计算机单位时间执行的指令条数<ul>\n<li>主频越高f，平均每条指令的时钟周期数CPI越少，其MIPS越高，在一定程度反映了机器的性能</li>\n<li>MIPS很大程度的依赖指令集，它很难衡量指令系统不同机器之间的性能</li>\n<li>用于比较相同指令系统系统</li>\n<li>即使在同一台机器上，程序负荷不同，CPI也不同，MIPS也就受到影响——浮点运算、定点运算</li>\n<li>MIPS还与机器的硬件实现有关<ul>\n<li>浮点运算在硬件上实现，MIPS低，性能高</li>\n<li>浮点运算用软件实现，MIPS高，性能低</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>MFLOPS：每秒百万次浮点运算<ul>\n<li>Tflops:每秒一万亿次浮点运算</li>\n<li>1T=1024G ， 1G=1024M  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>计算机的性能通常用<strong>峰值性能</strong>和<strong>持续性能</strong>来评价</p>\n<ul>\n<li>峰值性能：理想情况下计算机系统可以获得的最高理论性能值</li>\n<li>持续性能：也称<strong>实际性能</strong>，其表示有<strong>算术性能平均值</strong>，<strong>调和性能平均值</strong>，<strong>几何性能平均值</strong></li>\n</ul>\n</li>\n<li><p>算术性能平均值</p>\n<ul>\n<li>设算术性能平均值Am是n道程序运算速度或运算时间的算术平均值</li>\n<li>以速率评价<img src=\"https://npm.elemecdn.com/justlovesmile-img/GQHup6.png\" alt=\"GQHup6.png\"></li>\n<li>Ti是第i个程序的执行时间，Ri是第i个程序的执行速率</li>\n<li>以执行时间评价<img src=\"https://npm.elemecdn.com/justlovesmile-img/GQHTE9.png\" alt=\"GQHTE9.png\"></li>\n</ul>\n</li>\n<li><p>调和性能平均值</p>\n<ul>\n<li>调和平均数又称倒数平均数，<strong>给定数据的倒数之算术平均数的倒数</strong></li>\n<li><strong>Hm的值与运行全部程序所需的时间成反比—比较准确</strong></li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQbfPI.jpg\" alt=\"GQbfPI.jpg\"></li>\n</ul>\n</li>\n<li><p>几何性能平均值</p>\n<ul>\n<li>几何平均数是n个变量值连乘积的n次方根</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQqlod.png\" alt=\"GQqlod.png\"></li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1iX6g.png\" alt=\"G1iX6g.png\"></li>\n<li>几何平均值无法给出系统性能的真实期望.</li>\n<li>几何平均值常常使用测试机和参考机之间归一化的比值</li>\n</ul>\n</li>\n<li><p><strong>调和平均数、几何平均数和算术平均数三者间，存在如下数量关系：  H≤G≤A</strong></p>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQOgZF.png\" alt=\"GQOgZF.png\"></p>\n<p>2.计算机系统的定量设计原理<br>（1）哈夫曼压缩原理</p>\n<ul>\n<li>也称关注经常性事件原则</li>\n<li>抓主要矛盾</li>\n<li>性能——功耗的折中<ul>\n<li>处理器执行两个数的加法运算，溢出不溢出情况</li>\n<li>Pentium M处理器为了降低系统功耗且同时提高计算机性能，在其译码单元引入“micro-op Fusion”概念，把原有的两个micro-op（microinstructions）合成为一个进行操作</li>\n</ul>\n</li>\n</ul>\n<p>（2）Amdahl定律</p>\n<ul>\n<li>该定律将“关注经常性事件原则”进行了量化</li>\n<li>用于确定对系统中<strong>性能瓶颈部件采取措施提高速度后</strong>能得到系统性能改进的程度，即系统加速比Sp</li>\n<li><strong>Sp定义为系统改进后的性能与未改进时的性能的比值，或者定义为系统未改进时的程序执行时间Told与改进后程序执行时间Tnew的比值</strong></li>\n<li>Sp与两个因素有关，即性能可改进比fnew和部件加速比rnew</li>\n<li>性能可改进比fnew是系统性能可改进部件占用的时间与未改进时系统总执行时间的比值<ul>\n<li>0≤fnew≤1</li>\n</ul>\n</li>\n<li>部件加速比rnew是系统性能可改进部分在改进后性能提高的比值<ul>\n<li>Rnew&gt;1</li>\n<li>Rnew=TRold/TRnew</li>\n</ul>\n</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1kiVA.png\" alt=\"G1kiVA.png\"></li>\n<li>当fnew为0时，Sp=1；当Rnew趋于无穷大时，Sp=1/(1-fnew);</li>\n<li>通过使用某种较快的执行方式所获得的性能提高，受限于该部件占用系统执行时间的百分比,它是一个悲观定律</li>\n<li>通用多核系统在扩展到8个核以上时，往往会达到一个性能降低的拐点</li>\n<li>应用本身受到串行处理模式和技术的限制。无论拥有多少个核心，它们中的许多都因等待数据进行串行处理而被闲置起来</li>\n<li>阿姆达尔定律描述的一个关键事实是它<strong>只适用于计算的一种场合</strong>，即施行并行化后计算中的顺序部分将占据执行时间的主要部分</li>\n<li>阿姆达尔定律是在<strong>固定应用规模的前提下</strong>考虑并行性增长的影响。但大多数并行计算则是<strong>固定并行性而扩展应用的规模</strong></li>\n</ul>\n<p>（3）程序访问的局部性规律</p>\n<ul>\n<li>时间局部性: 一个存储项被访问,可能很快再访问</li>\n<li>空间局部性: 存储项被访问,它的邻近项可能很快被访问</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQX3FJ.png\" alt=\"GQX3FJ.png\"></p>\n<p><strong>某一计算机用于商业外贸的事务处理，有大量的字符串操作。由于这种事务处理很普遍，有较大的市场，故而设计人员决定在下一代此类计算机的CPU中加入字符串操作的功能。经测试应用软件调查发现，字符串操作的使用占整个程序运行时间的50%，而增加此功能如用软件（如微程序）实现，则快5倍，增加CPU成本1/5倍；如果用硬件实现，则快100倍，CPU成本增加到5倍。问设计人员提出增加此功能是否恰当？是否用软件还是硬件？（设CPU成本占整机成本的1/3）</strong><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQX0Te.png\" alt=\"GQX0Te.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQXclt.png\" alt=\"GQXclt.png\"></p>\n<h4 id=\"1-3-3-计算机系统设计的主要任务和方法\"><a href=\"#1-3-3-计算机系统设计的主要任务和方法\" class=\"headerlink\" title=\"1.3.3 计算机系统设计的主要任务和方法\"></a>1.3.3 计算机系统设计的主要任务和方法</h4><p>1.计算机系统设计的主要任务</p>\n<ul>\n<li>包括系统结构，计算机组成和计算机实现的设计</li>\n</ul>\n<p>2.计算机系统的设计方法</p>\n<ul>\n<li>由上往下<ul>\n<li>先考虑如何满足用户要求，定好面对使用者的虚拟机的基本功能和环境，如指令系统、语言结构、数据类型等，然后逐级向下设计，每一级都严格考虑优化上一级来实现</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQj7Ue.png\" alt=\"GQj7Ue.png\"></li>\n</ul>\n</li>\n<li>由下往上<ul>\n<li>不考虑用户的具体需求，只根据当时拿到的器件，参照或吸收已有各种机器的特点，把微程序机器级和传统机器级分别研制出来，然后再配上适合不同应用环境的各种操作系统和各种编译程序，以满足不同方面的应用要求。</li>\n<li>优点:<ul>\n<li>有利于缩短研制周期</li>\n<li>有利于软硬件人员之间的交流</li>\n<li>软硬分配更加合理</li>\n<li>系统的性能价格比更高</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>从中间往两头</li>\n</ul>\n<h3 id=\"1-4-软件，应用，器件的发展对系统结构的影响\"><a href=\"#1-4-软件，应用，器件的发展对系统结构的影响\" class=\"headerlink\" title=\"1.4 软件，应用，器件的发展对系统结构的影响\"></a>1.4 软件，应用，器件的发展对系统结构的影响</h3><h4 id=\"1-4-1-软件的发展对系统结构的影响\"><a href=\"#1-4-1-软件的发展对系统结构的影响\" class=\"headerlink\" title=\"1.4.1 软件的发展对系统结构的影响\"></a>1.4.1 软件的发展对系统结构的影响</h4><ul>\n<li>软件的可移植：软件不用修改或只需经少量加工就能由一台机器投到另一台机器上运行，即同一软件可以应用于不同的环境</li>\n<li>软件移植的三种技术<ul>\n<li>统一高级语言：面向题目和算法，和具体结构关系不大<ul>\n<li>指一种完全通用的高级语言，为所有程序员所使用，并能在完全不同的机器之间实现程序的软件移植。</li>\n</ul>\n</li>\n<li>系列机、兼容机：具有相同结构的各种机器之间<ul>\n<li>兼容机：不同厂家生产的具有相同指令集结构的计算机</li>\n<li>系列机：CPU的机器指令和汇编指令系统相同（或绝大部分相同）</li>\n<li>软件兼容：即同一个软件可以不加修改地运行于体系结构相同的各档机器，而且它们    所获得的结果一样，差别只在于有不同的运行时间。</li>\n<li>向上(下)兼容指的是按某档机器编制的程序，不加修改的就能运行于比它高(低)档的机器。</li>\n<li>向前(后）兼容指的是按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之后(前)投入市场的机器。</li>\n<li>系列机软件兼容性必须保证做到向后兼容，力争向上兼容</li>\n</ul>\n</li>\n<li>模拟与仿真：软件在不同体系结构之间的移植<ul>\n<li>模拟<ul>\n<li>用A机的机器语言程序解释B机器语言程序，从而实现软件移植方法 宿主机 A机  虚拟机 B机</li>\n<li>为实现模拟编制的各种解释程序</li>\n</ul>\n</li>\n<li>仿真<ul>\n<li>用A机的微程序解释B机的机器语言程序，从而实现软件移植方法 宿主机 A机  目标机 B机</li>\n<li>为实现仿真编制的各种解释微程序</li>\n</ul>\n</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQzTET.png\" alt=\"GQzTET.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GlSiPe.png\" alt=\"GlSiPe.png\"></p>\n<h4 id=\"1-4-2-应用对系统结构的影响\"><a href=\"#1-4-2-应用对系统结构的影响\" class=\"headerlink\" title=\"1.4.2 应用对系统结构的影响\"></a>1.4.2 应用对系统结构的影响</h4><ul>\n<li>应用需求是促使计算机系统结构发展的最根本的动力</li>\n<li>不同的应用对计算机系统结构的设计提出了不同的要求</li>\n<li>计算机应用可归纳为：数据处理，信息处理，知识处理，智能处理</li>\n</ul>\n<h4 id=\"1-4-3-器件的发展对系统结构的影响\"><a href=\"#1-4-3-器件的发展对系统结构的影响\" class=\"headerlink\" title=\"1.4.3 器件的发展对系统结构的影响\"></a>1.4.3 器件的发展对系统结构的影响</h4><ul>\n<li><p>芯片制造的发展</p>\n</li>\n<li><p>器件的发展对系统的影响</p>\n<ul>\n<li>功能和使用方法—非用户片、现场片及用户片</li>\n<li>改变了逻辑设计的传统方法—速度、规整</li>\n<li>推动了系统结构技术的发展</li>\n<li>体系结构”下移”速度加快—并行计算</li>\n<li>促进了算法、语言和软件的发展</li>\n</ul>\n</li>\n<li><p>软件是促使计算机系统结构发展的最重要的因素</p>\n</li>\n<li><p>应用需求是促使计算机系统结构发展的最根本的动力</p>\n</li>\n<li><p>器件是促使计算机系统结构发展最活跃的因素</p>\n</li>\n<li><p>非用户片：也称通用片，其功能是由器件厂家生产时已确定的，器件的用户（即机器设计者）只能使用，不能改变器件内部功能</p>\n</li>\n<li><p>现场片：是用户根据需要可改变器件内部功能的芯片（FPGA）</p>\n</li>\n<li><p>用户片：是专门按用户要求生产的高集成度VLSI器件（ASIC）</p>\n<ul>\n<li>全用户片：是完全按用户要求设计的用户片</li>\n<li>半用户片：是基本按通用片进行生产，最后按用户要求再制作的用户片，如门阵列、门-触发器阵列等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-5-系统结构钟的并发性开发及计算机系统的分类\"><a href=\"#1-5-系统结构钟的并发性开发及计算机系统的分类\" class=\"headerlink\" title=\"1.5 系统结构钟的并发性开发及计算机系统的分类\"></a>1.5 系统结构钟的并发性开发及计算机系统的分类</h3><h4 id=\"1-5-1-并行性的概念和开发\"><a href=\"#1-5-1-并行性的概念和开发\" class=\"headerlink\" title=\"1.5.1 并行性的概念和开发\"></a>1.5.1 并行性的概念和开发</h4><p>1.并行性的含义和级别</p>\n<ul>\n<li><p><strong>并行性</strong>：解题中具有可以同时进行运算或操作的特性</p>\n</li>\n<li><p>并行性包含了同时性和并发性二重含义</p>\n<ul>\n<li><strong>同时性</strong>（Simultaneity）：两个或多个事件在<strong>同一时刻</strong>发生</li>\n<li><strong>并发性</strong>（Concurrency）：两个或多个事件在<strong>同一时间间隔内</strong>发生</li>\n</ul>\n</li>\n<li><p><strong>只要时间上有重叠就存在并行性！</strong></p>\n</li>\n<li><p>并行性的等级：</p>\n<ul>\n<li>从计算机系统中执行程序的角度（由低到高）<ul>\n<li>指令内部—一条指令内部各个微操作之间的并行</li>\n<li>指令之间—多条指令的并行执行</li>\n<li>任务或进程之间—多个任务或程序段的并行执行</li>\n<li>作业或程序之间—多个作业或多道程序的并行。</li>\n</ul>\n</li>\n<li>从处理数据的角度（由低到高）<ul>\n<li>位串字串——顺序</li>\n<li>位并字串——同时对一个字的全部位</li>\n<li>位片串字并——同时对许多字的同一位</li>\n<li>全并行——同时对许多字的全部或部分</li>\n</ul>\n</li>\n<li>从计算机信息加工的各个步骤和阶段<ul>\n<li>存储器操作并行</li>\n<li>处理器操作步骤并行</li>\n<li>处理器操作并行</li>\n<li>指令、任务、作业并行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>2.并行性开发的途径</p>\n<ul>\n<li><p><strong>时间重叠</strong></p>\n<ul>\n<li>是在并行性概念中引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。<ul>\n<li>举例：流水线</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>资源重叠</strong></p>\n<ul>\n<li>是在并行性概念中引入空间因素，通过重复设置硬件资源来提高可靠性或性能<ul>\n<li>例如：双工系统</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>资源共享</strong></p>\n<ul>\n<li>是利用<strong>软件的方法</strong>让多个用户按一定时间顺序轮流地使用同一套资源，以提高其利用率，这样也可以提高整个系统的性能<ul>\n<li>例如：网络打印机</li>\n<li>多道程序、分时OS →真正的处理机代替虚拟机→分布处理系统</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>3.计算机系统的并行性发展</p>\n<ul>\n<li>不同时间阶段，并行性发展的主要表现不同</li>\n</ul>\n<p>4.多机系统的耦合度</p>\n<ul>\n<li>多机系统：包含多处理机系统和多计算机系统<ul>\n<li>多处理机系统<ul>\n<li>是由多台处理机组成的单一计算机系统，各处理机都可有自己的控制部件，可带自己的局部存储器，能执行各自的程序</li>\n<li><strong>在逻辑上受统一的操作系统控制</strong>，体系结构可以是共享存储器，也可以是分布式存储器</li>\n</ul>\n</li>\n<li>多计算机系统<ul>\n<li>是由多台独立的计算机组成的系统，<strong>各计算机分别在逻辑上独立的操作系统控制下运行</strong>，机间可以互不通信，即使通信也只是经通道或通信线路以文件或数据集形式进行，实现多个作业的并行</li>\n<li>一般指分布式存储结构</li>\n<li>集群系统和大规模并行处理机MPP都是多计算机系统</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>耦合度</strong>：一般用耦合度反映多机系统中各机器之间物理连接的紧密程度和交叉作用能力的强弱<ul>\n<li><strong>最低耦合系统</strong>（Least Coupled System）：各种脱机系统 </li>\n<li><strong>松散耦和系统</strong>（Loosely Coupled System）：如果多台计算机通过通道或通信线路实现互连，共享某些磁带、磁盘等外围设备，以较低频带在文件或数据集一级相互作用。又称间接耦合系统</li>\n<li><strong>紧密耦合系统</strong>（Tightly Coupled System）：如果多台机器之间通过总线或高速开关互连，<strong>共享主存</strong>，并有较高的信息传输速度，可以实现数据集一级、任务级、作业级的并行。又称直接耦合系统 </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-5-2-计算机系统的分类\"><a href=\"#1-5-2-计算机系统的分类\" class=\"headerlink\" title=\"1.5.2 计算机系统的分类\"></a>1.5.2 计算机系统的分类</h4><p>1.弗林分类</p>\n<ul>\n<li>弗林分类法（Michael J,Flynn分类）：弗林提出按<strong>指令流</strong>和<strong>数据流</strong>的多倍性对计算机系统进行分类<ul>\n<li><strong>指令流</strong>：是指机器执行的<strong>指令序列</strong></li>\n<li><strong>数据流</strong>：是指指令流调用的<strong>数据序列</strong>，包括输入数据和中间结果</li>\n<li><strong>多倍性</strong>：是指在系统性能瓶颈部件上处于<strong>同一执行阶段</strong>的指令或数据的最大可能个数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1KCqK.png\" alt=\"G1KCqK.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1KQZ8.png\" alt=\"G1KQZ8.png\"></p>\n<ul>\n<li>主要缺点：  <ul>\n<li>(1)分类太粗：例如，在SIMD中包括有多种处理机，对流水线处理机的划分不明确，标量流水线为SISD，向量流水线为SIMD </li>\n<li>(2)根本问题是把两个不同等级的功能并列对待；通常，数据流受指令流控制，从而造成MISD不存在  </li>\n<li>(3)非冯计算机的分类；其他新型计算机的分类  </li>\n</ul>\n</li>\n</ul>\n<p>2.库克分类</p>\n<ul>\n<li>用<strong>指令流</strong>和<strong>执行流</strong>（Execution Stream）及其多倍性来描述计算机系统总控制器的结构特征<ul>\n<li>SISE：单处理机系统 </li>\n<li>SIME：多操作部件的处理机</li>\n<li>MISE：带指令级多道程序的单处理机</li>\n<li>MIME：多处理机 </li>\n</ul>\n</li>\n<li>缺点 <ul>\n<li>有些系统，如分布处理机等，没有总控制器  </li>\n<li>分类太粗，如SIME中包含了多种类型的处理机  </li>\n</ul>\n</li>\n</ul>\n<p>3.冯泽云分类</p>\n<ul>\n<li>提出用数据处理的并行度来定量地描述各种计算机系统特性<ul>\n<li>WSBS（字串位串） </li>\n<li>WSBP（字串位并）</li>\n<li>WPBS（字并位串）</li>\n<li>WPBP（字并位并）</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>仅考虑了数据的并行性，没有考虑指令、任务、作业的并行<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1MekF.png\" alt=\"G1MekF.png\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-6-本章小结\"><a href=\"#1-6-本章小结\" class=\"headerlink\" title=\"1.6 本章小结\"></a>1.6 本章小结</h3><ol>\n<li>重点：（1）计算机系统结构，计算机组成，计算机实现三者的定义以及包含的内容（2）有关透明性问题的判断（3）软件和硬件的功能分配原则（4）软件可移植性的途径，方法，适用场合，存在问题和对策（5）并行性的概念（6）系统结构中开发并行性的途径</li>\n<li>难点：透明性的判断与分析</li>\n</ol>\n<blockquote>\n<p>下列哪些对<strong>系统程序员</strong>是透明的?<br><strong>A、超大规模集成电路</strong><br>B、虚拟存储器<br><strong>C、Cache存储器</strong><br>D、程序状态字<br>E、“启动I/O”指令<br>F、“执行”指令<br><strong>G、指令缓冲寄存器</strong></p>\n</blockquote>\n<p>正确答案： ACG </p>\n<blockquote>\n<p>下列哪些对<strong>应用程序员</strong>是透明的?<br><strong>A、虚拟存储器</strong><br><strong>B、Cache存储器</strong><br><strong>C、程序状态字</strong><br><strong>D、“启动I/O”指令</strong><br>E、“执行”指令<br><strong>F、指令缓冲寄存器</strong></p>\n</blockquote>\n<p>正确答案： ABCDF </p>\n<blockquote>\n<p>1.系列机可将单总线改成双总线来减少公用总线的使用冲突。 【答案：√】<br>2.系列机增加新机种时,为增加寻址灵活性和缩短平均指令字长,由原等长操作码改为多种码长的扩展操作码。【答案：×】<br>3.系列机应用软件应做到向前兼容,力争向下兼容。【答案：×】<br>4.可以说向后兼容是系列机的根本特征。 【答案：√】<br>5.系列机不再是方向,因为它约束了计算机系统结构的发展。 【答案：×】<br>6.由同一厂家生产的,系统结构相同的,但组成和实现不同的所有计算机,称为兼容机。 【答案：×】 </p>\n</blockquote>\n<h2 id=\"第二章-数据表示，寻址方式与指令系统\"><a href=\"#第二章-数据表示，寻址方式与指令系统\" class=\"headerlink\" title=\"第二章 数据表示，寻址方式与指令系统\"></a>第二章 数据表示，寻址方式与指令系统</h2><h3 id=\"2-1-数据表示\"><a href=\"#2-1-数据表示\" class=\"headerlink\" title=\"2.1 数据表示\"></a>2.1 数据表示</h3><h4 id=\"2-1-1-数据表示与数据结构\"><a href=\"#2-1-1-数据表示与数据结构\" class=\"headerlink\" title=\"2.1.1 数据表示与数据结构\"></a>2.1.1 数据表示与数据结构</h4><ul>\n<li>数据表示：能由机器硬件识别和引用的<strong>数据类型</strong>，表现在它有对这种类型的数据进行操作的指令和运算部件。</li>\n<li>数据类型：<strong>不同于数据，数据类型除了指一组值的集合外，还定义了可作用于这个集合上的操作集</strong> <ul>\n<li><strong>基本数据</strong>类型</li>\n<li><strong>结构数据</strong>类型<ul>\n<li>一组由相互有关的数据元素复合而成的数据类型，这些数据元素可以是基本数据类型中的元素，也可以是结构数据类型本身中的元素。也就是说这些数据是有结构的，<strong>包括向量和数组、字符串、堆栈、队列、记录</strong>等，结构数据类型中的元素不一定都具有相同类型</li>\n</ul>\n</li>\n<li>访问指针</li>\n<li>抽象数据等类型</li>\n</ul>\n</li>\n<li>数据结构：通过软件映像，变换成机器中所具有的数据表示来实现的。<ul>\n<li>是应用中相互之间存在一种或多种特定关系的数据元素的集合。如：线性表、栈、队列、串、数组、阵列、链表、树和图等。</li>\n<li>是结构数据类型的组织方式，它反映了结构数据类型中各种数据元素或信息单元之间的结构关系 </li>\n<li>不同数据表示可以为数据结构的实现提供不同的支持。<strong>数据表示是数据结构的子集</strong></li>\n<li>数据结构和数据表示是软硬件的交界面。</li>\n</ul>\n</li>\n</ul>\n<p>图为变址操作对向量，阵列数据结构的支持：<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/1.png\"></p>\n<h4 id=\"2-1-2-高级数据表示\"><a href=\"#2-1-2-高级数据表示\" class=\"headerlink\" title=\"2.1.2 高级数据表示\"></a>2.1.2 高级数据表示</h4><p>1.自定义数据表示<br>（1）标志符数据表示</p>\n<ul>\n<li>为缩短高级语言与机器语言的语义差距，让机器中每个数据都带类型标志位</li>\n<li>| 类型标志 | 数据值 |</li>\n<li>标志符数据表示的主要优点<ul>\n<li>简化了指令系统和程序设计<ul>\n<li>减少指令种类</li>\n</ul>\n</li>\n<li>简化了编译程序<ul>\n<li>不用做复杂的映射</li>\n</ul>\n</li>\n<li>便于实现一致性校验</li>\n<li>能由硬件自动变换数据类型</li>\n<li>为软件调试和应用软件开发提供了支持</li>\n</ul>\n</li>\n<li>使用标志符数据表示可能带来如下问题<ul>\n<li>每个数据字因增设标志符，会增加程序所占的主存空间</li>\n<li>采用标志符会降低指令的执行速度<ul>\n<li>增加按标志符确定数据属性及判断操作数之间是否相容等操作，单条指令的执行速度会下降。</li>\n<li>程序的编制和调试时间的缩短，是解题总时间缩短</li>\n<li>所以，引入标志符数据表示对微观性能（机器的运算速度）不利，但对宏观性能（解题总时间）是有利的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>（2）数据描述符</p>\n<ul>\n<li><p>为了进一步减少标志符所占存储空间，对向量、数组、记录等数据，由于元素属性相同，因此就发展出数据描述符</p>\n</li>\n<li><p>描述符和数据分开，表示访问的数据是整块还是单个，地址信息等其他信息<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415122950.png\"></p>\n</li>\n<li><p>描述符方法优点：</p>\n<ul>\n<li>描述符方法实现阵列数据的索引要比用变址方法实现更方便</li>\n<li>且便于检查出程序中的阵列越界错误</li>\n<li>数据描述符方法为向量、数组数据结构的实现提供了一定的支持，有利于并简化编译中的代码生成，可以比变址法更快地形成元素地址</li>\n</ul>\n</li>\n</ul>\n<p>2.向量数组数据表示</p>\n<ul>\n<li>为向量、数组数据结构的<strong>实现和快速运算提供更好的硬件支持的方法是增设向量、数组数据表示</strong></li>\n<li>向量在内存中是连续存放在一段空间里的，换句话说，这些向量元素的地址是连续的 </li>\n<li>在标量计算机上运行时，由于没有专门的向量数据表示，因此在计算一个向量(相当于一维数组的计算)时，每取用一个数据元素，都要用到计算该元素的地址。</li>\n<li>而在向量机中，由于有了向量数据表示，就<strong>可以把一个向量用一个位串来表示出来</strong>。向量指令就是能够用一条指令对向量的全部元素进行运算的指令。 </li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415134043.png\"></p>\n<ul>\n<li>引入向量、数组数据表示优点<ul>\n<li>不只是能加快形成元素地址；</li>\n<li>便于实现把向量各元素成块预取到中央处理器；</li>\n<li>能对阵列中的每个元素又是一个子阵列的相关交叉型阵列进行处理；</li>\n<li>对稀疏矩阵能实现压缩存储、还原、运算等多种功能操作，不但节省了空间，也由于不必处理零元素而节省了时间。</li>\n</ul>\n</li>\n</ul>\n<p>3.堆栈数据表示</p>\n<ul>\n<li><p>堆栈数据结构在编译和子程序调用中很有用</p>\n</li>\n<li><p>通用寄存器型机器对堆栈数据结构支持<strong>较差</strong></p>\n<ul>\n<li>堆栈操作用的机器指令数少，功能单一，没有专门的堆栈指令</li>\n</ul>\n</li>\n<li><p>寄存器型机器的内存分配，有堆栈(Stack)空间</p>\n<ul>\n<li>堆栈置于存储器内，访问堆栈的速度低</li>\n<li>通常只用于保存子程序调用时的<strong>返回地址</strong></li>\n<li>少量用堆栈来实现程序之前的<strong>参数传递</strong></li>\n</ul>\n</li>\n<li><p>堆栈机器</p>\n<ul>\n<li>有堆栈数据表示的机器称为堆栈机器</li>\n<li>堆栈寻址方式的地址是隐含的，在指令中不必给出操作数的地址，<strong>零地址指令</strong></li>\n<li>从60年代开始，出现了一批以堆栈寻址方式为主的堆栈计算机</li>\n<li>堆栈对以下这些方面处理非常方便<ul>\n<li>表达式求值</li>\n<li>子程序调用，递归，中断嵌套</li>\n<li>块结构语言中的变量访问</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>堆栈计算机具有如下特点：<br>（1）有高速寄存器组成的硬件堆栈，并附加控制电路，让它与主存中的堆栈区在逻辑上构成整体，使堆栈的访问速度是寄存器级，容量是主存级。<br>（2）有丰富的堆栈指令且功能很强。<br>（3）支持高级语言，有利于编译程序。因为一般的算术表达式可以很容易地转化成逆波兰表达式，而逆波兰表达式能够直接形成由堆栈指令组成的程序，这样就简化了编译程序。</p>\n<ul>\n<li><strong>以主存寻址方式为主的计算机系统</strong>，在编译一个算术表达式时，要<strong>为每一个变量分配主存单元</strong>，另外，还会人为地产生一些中间变量。<strong>如何减少中间变量的个数</strong>，合理地为变量分配存储单元，是编译器的一项许多相当困难的工作。</li>\n<li><strong>以寄存器寻址方式为主的计算机系统</strong>，编译器需要决定哪些变量放在通用寄存器中，哪些变量放在主存中，<strong>以减少访问主存储器的次数</strong>。另外，也同样存在<strong>如何减少了中间变量</strong>，节省了存储空间的问题</li>\n</ul>\n<p>（4）支持程序的嵌套和递归调用，支持中断处理</p>\n<h4 id=\"2-1-3-引入数据表示的原则\"><a href=\"#2-1-3-引入数据表示的原则\" class=\"headerlink\" title=\"2.1.3 引入数据表示的原则\"></a>2.1.3 引入数据表示的原则</h4><p><strong>从根本上讲，存储器一维线性的存储结构与要求经常使用的多维离散数据结构有着很大的差距，不利于数据结构的实现。</strong></p>\n<p>一是基本数据表示不可少；<br>二是看系统的效率是否显著提高；<br>三是看引入这种数据表示后，其通用性和利用率是否提高。<br>四是也需要挖掘基本数据表示的细节问题。</p>\n<h4 id=\"2-1-4-浮点数尾数基值大小和下溢处理方法的选择\"><a href=\"#2-1-4-浮点数尾数基值大小和下溢处理方法的选择\" class=\"headerlink\" title=\"2.1.4 浮点数尾数基值大小和下溢处理方法的选择\"></a>2.1.4 浮点数尾数基值大小和下溢处理方法的选择</h4><p>1.浮点数尾数基值的选择<br>如果小数点的位置事先已有约定，不再改变，此类数称为“定点数”。<br>如果小数点的位置可变，则称为“浮点数”。<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200826171758.png\"></p>\n<p>rm ：尾数的基<br>re ：阶码的基（re =2）<br>m： 尾数长度 (注意其含义)<br>p： 阶码长度<br>【p表示数的范围大小；尾数的位数m主要影响表示值的精度】<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415135441.png\"></p>\n<ul>\n<li>浮点数表数误差产生的原因：<ul>\n<li>运算的结果</li>\n<li>十进制转化为二进制、四进制、八进制、十六进制</li>\n</ul>\n</li>\n<li>浮点数尾数基值的选择<ul>\n<li>可表示数的范围<ul>\n<li>随着rm增大，可表示的范围增大</li>\n<li>随着rm增大，可表示数的最小值rm^-1将减少</li>\n</ul>\n</li>\n<li>可表示数的个数<ul>\n<li>(2^p)×(rm^m’)×(1-(rm^(-1)) ，其中rm的增大将因<code>(1-(rm^-1))</code>增大而使可表示数的个数增多</li>\n</ul>\n</li>\n<li>可表示的精度<ul>\n<li>rm越大，数在数轴上的分布越稀，数的表示精度自然就下降</li>\n</ul>\n</li>\n<li>运算中的精度损失<ul>\n<li>尾数右移出机器字长，使有效数字丢失，但其不同于可表示数的精度，由于尾数基值rm取大后，对阶移位的机会和次数减少，又由于数的表示范围扩大，使尾数溢出需右规的机会也减少。因此，rm越大，尾数右移的机会越小，精度的损失就越小</li>\n</ul>\n</li>\n<li>运算速度<ul>\n<li>Rm增大时，由于对阶或尾数溢出需右移及规格化需左移的次数减少，运算速度可以提高</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>综上所述，尾数基值取大，会扩大浮点数的表示范围、增加可表示数的个数、减少移位次数、降低右移造成的精度损失和提高运算速度，但是会，降低数据的表示精度，数值的分布变稀</li>\n<li>规格化正尾数：<strong>正尾数小数点后第一个rm进制数位不是0的数</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">条件：非负阶，规格化，正尾数</th>\n<th align=\"center\">阶值：二进制p位，尾数：rm进制m’位</th>\n<th align=\"center\">若p=2，m=4，当rm=2（即m’=4）时</th>\n<th align=\"center\">若p=2，m=4，当rm=16（即m’=1）时</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">可表示最小尾数值</td>\n<td align=\"center\">rm^(-1)</td>\n<td align=\"center\">1/2</td>\n<td align=\"center\">1/16</td>\n</tr>\n<tr>\n<td align=\"center\">可表示最大尾数值</td>\n<td align=\"center\">1-1×rm^(-m’)</td>\n<td align=\"center\">15/16</td>\n<td align=\"center\">15/16</td>\n</tr>\n<tr>\n<td align=\"center\">最大阶值</td>\n<td align=\"center\">2^p-1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">可表示最小值</td>\n<td align=\"center\">rm^(-1)</td>\n<td align=\"center\">1/2</td>\n<td align=\"center\">1/16</td>\n</tr>\n<tr>\n<td align=\"center\">可表示最大值</td>\n<td align=\"center\">rm^(2^p-1)×(1-rm^(-m’))</td>\n<td align=\"center\">7.5</td>\n<td align=\"center\">3840</td>\n</tr>\n<tr>\n<td align=\"center\">可表示的尾数个数</td>\n<td align=\"center\">rm^(m’)×(rm-1)/rm</td>\n<td align=\"center\">8</td>\n<td align=\"center\">15</td>\n</tr>\n<tr>\n<td align=\"center\">可表示阶的个数</td>\n<td align=\"center\">2^p</td>\n<td align=\"center\">4</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">可表示数的个数</td>\n<td align=\"center\">2^p×rm^(m’)×(rm-1)/rm</td>\n<td align=\"center\">32</td>\n<td align=\"center\">60</td>\n</tr>\n</tbody></table>\n<p>2.浮点数位数的下溢处理方法<br>减少运算中的精度损失关键是要处理好运算中尾数超出字长的部分，使精度损失最小<br>（1）<strong>截断法</strong><br>方法：<strong>将尾数超出机器字长的部分去掉</strong></p>\n<ul>\n<li><p>以rm=2，m=2为例讨论最大误差</p>\n<ul>\n<li>在整数时接近于1(“11:111…1”截断成“11:”)</li>\n<li>在分数时接近于2^(-m) (“.01:111…1”截断成“.01:”)<br>总是产生负误差<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415140626.png\"></li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现简单，不增加硬件，不需要处理时间</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>最大误差较大，且平均误差大且无法调节，因而已很少使用</li>\n</ul>\n</li>\n</ul>\n<p>（2）<strong>舍入法</strong><br>在机器运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加1,(整数加0.5，分数加2-(m+1))</p>\n<ul>\n<li><p>例如：</p>\n<ul>\n<li>整数：“10:10…0”舍入成“11:” 正误差</li>\n<li>分数：“.10:01…0”舍入成“.10:” 负误差</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现简单，增加的硬件开销少，最大误差小，平均误差接近于零</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>处理速度慢，需要花费在数的附加位加1以及因此产生进位的时间，最坏情况下，需要从尾数最低位进制<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/Y5E%7B1ZHXC%25%5B77%7BW_5Z2%5BY%5DO.png\"><br>（3）<strong>恒置“1”法</strong></li>\n</ul>\n</li>\n<li><p>将机器运算的规定字长之最低位恒置“1”</p>\n</li>\n<li><p>最大误差</p>\n<ul>\n<li>整数为1（如“10:00…0”处理成“11:”）</li>\n<li>分数为2-m（如“.00:00…0”处理成“.01:”）</li>\n</ul>\n</li>\n<li><p>误差有正负</p>\n<ul>\n<li>负误差（如“.11:10…1”处理成“.11:”）</li>\n<li>正误差（如“.00:00…0”处理成“.01:”)<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/%25%7DMG%25YPJF2L0QNXJ%7DK8FC%402.png\"></li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现简单，不需要增加硬件和处里时间，平均误差趋于0</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>最大误差最大，比截断法还大（接近于1）<br>多用于中、高速机器中，由于尾数位数比微、小型机器长</li>\n</ul>\n</li>\n</ul>\n<p>（4）查表舍入法<br>取尾数p位的最后k-1位和准备舍弃的最高1位，共k位。通过ROM或PLA查表得到k-1位，作为新的尾数p位的最后k-1位<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/%29%7DUAT%7DO7%7D%7B%25%28WNSFI%40I%25MOP.png\"></p>\n<ul>\n<li><p>下溢处理表的内容</p>\n<ul>\n<li>当尾数最低k-1位为全”1“时以截断法设置处理结果</li>\n<li>其余情况采用舍入法<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415142649.png\"></li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>ROM法速度较快，平均误差可调到0</li>\n<li>避免再次右规操作</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>需要硬件配合</li>\n</ul>\n</li>\n<li><p>上述4种处理方法中，</p>\n<ul>\n<li><strong>最大误差最大</strong>的是恒置“1”法，</li>\n<li><strong>最大误差最小</strong>的是舍人法；</li>\n<li><strong>平均误差最大</strong>的是截断法；</li>\n<li><strong>平均误差可人为调节</strong>的是查表舍入法；</li>\n<li><strong>下溢处理不需要附加时间开销，即速度最快</strong>的是截断法和恒置“1”法，</li>\n<li><strong>处理速度最慢</strong>的是舍人法；</li>\n<li><strong>实现上最花费硬件</strong>的是查表舍入法，</li>\n<li><strong>最省硬件</strong>的是截断法和恒置“1”法。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-寻址方式\"><a href=\"#2-2-寻址方式\" class=\"headerlink\" title=\"2.2 寻址方式\"></a>2.2 寻址方式</h3><p>寻址方式指的是按什么方式寻找（或访问）到所需的操作数或信息的。</p>\n<h4 id=\"2-2-1-寻址方式的三种面向\"><a href=\"#2-2-1-寻址方式的三种面向\" class=\"headerlink\" title=\"2.2.1 寻址方式的三种面向\"></a>2.2.1 寻址方式的三种面向</h4><p><strong>面向主存</strong>，寻址主要访问主存，少量访问寄存器；<br><strong>面向寄存器</strong>，主要访问寄存器，少量访问主存和堆栈；<br><strong>面向堆栈</strong>，主要访问堆栈，少量访问主存或寄存器。</p>\n<h4 id=\"2-2-2-寻址方式在指令中的指明\"><a href=\"#2-2-2-寻址方式在指令中的指明\" class=\"headerlink\" title=\"2.2.2 寻址方式在指令中的指明\"></a>2.2.2 寻址方式在指令中的指明</h4><ul>\n<li>具体的寻址方式，组成原理已经讲过</li>\n<li>基本的指令格式：操作码 + 地址码</li>\n<li>寻址方式指明方法：<ul>\n<li>占用操作码的某些位指明</li>\n<li>不占操作码，在地址码设置寻址方式字段</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-3-程序在主存中的定位技术\"><a href=\"#2-2-3-程序在主存中的定位技术\" class=\"headerlink\" title=\"2.2.3 程序在主存中的定位技术\"></a>2.2.3 程序在主存中的定位技术</h4><ul>\n<li>逻辑地址与主存物理地址 <ul>\n<li>逻辑地址：程序员编写程序时使用的地址；</li>\n<li>物理地址：程序在主存中的实际地址；</li>\n</ul>\n</li>\n<li>早期——单道程序<ul>\n<li>逻辑地址和物理地址是一致的，程序和数据存放在主存中的位置是由程序员编写程序时指明的；</li>\n</ul>\n</li>\n<li>现在——多道程序<ul>\n<li>程序员已不用主存的实际地址编程，改用符号、标号名编址；</li>\n<li>由源程序中的符号名空间→目标程序的逻辑地址空间→主存中的物理地址空间 </li>\n<li>程序员事先无法知道程序装在主存中什么位置；</li>\n<li>各道程序的逻辑地址都是从0开始编制，主存物理空间地址是从0开始编址的一堆线性空间；</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>静态再定位<br>（1）在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的内存地址。重定位在程序装入时一次完成<br>（2）存在问题<br>①一道程序地址改错而导致其他程序出错；<br>②指令修改妨碍了程序的可重入。<br>③指令修改了，不利于程序定位和调试。</li>\n<li>动态再定位<br>是在程序执行期间完成的，即程序的逻辑地址在装入内存时不作任何修改，程序执行中，每取出一条指令，CPU对其译码时，如果有逻辑地址，就借助于重定位机构将其转换成绝对地址，然后执行该指令。</li>\n<li>基址寻址<br>（1）指令中给出一个形式地址（作为修改量），并给出基址寄存器号，基址寄存器内容（作为基准量）与形式地址相加得到操作数有效地址<br>（2）主要解决<br>①程序重定位；<br>②扩展有限字长指令的寻址空间<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8K2W9S17_VYSURM8WL~%25YOQ.png\"></li>\n<li>虚实地址映象表<br>地址加界法要求程序员所用编址空间不能超出实际主存空间容量。</li>\n</ol>\n<h4 id=\"2-2-4-物理主存中信息的存储分布\"><a href=\"#2-2-4-物理主存中信息的存储分布\" class=\"headerlink\" title=\"2.2.4 物理主存中信息的存储分布\"></a>2.2.4 物理主存中信息的存储分布</h4><p>目前使用最普遍的编址单位是字节编址，这是为了适应非数值计算的需要</p>\n<h3 id=\"2-3-指令系统的设计和优化\"><a href=\"#2-3-指令系统的设计和优化\" class=\"headerlink\" title=\"2.3 指令系统的设计和优化\"></a>2.3 指令系统的设计和优化</h3><h4 id=\"2-3-1-指令系统设计的基本原则\"><a href=\"#2-3-1-指令系统设计的基本原则\" class=\"headerlink\" title=\"2.3.1 指令系统设计的基本原则\"></a>2.3.1 指令系统设计的基本原则</h4><ul>\n<li>指令系统是软、硬件的主要界面</li>\n<li>指令系统的设计主要包括<strong>指令的功能</strong>（操作类型、具体操作内容）和<strong>指令格式</strong>的设计.</li>\n<li>指令设计的步骤：<ul>\n<li><strong>根据应用</strong>，初拟出指令的分类和具体的指令；</li>\n<li>试编出用该指令系统设计的各种<strong>高级语言的编译程序</strong>；</li>\n<li><strong>大量测试</strong>程序进行<strong>模拟测试</strong>，看指令系统的操作码和寻址方式效能是否都比较高；</li>\n<li><strong>将程序中高频出现的指令串复合改成一条强功能新指令</strong>，即改用硬件方式实现；而将频度很低的指令的操作改成基本的指令组成的指令串来完成，即用软件方式实现；</li>\n</ul>\n</li>\n<li>系统设计人员希望：指令码密度适中，兼容性，适应性</li>\n<li>指令的组成：<ul>\n<li>一般的指令主要由两部分组成：<strong>操作码</strong>和<strong>地址码</strong></li>\n<li>操作码主要包括两部分内容：<ul>\n<li>操作种类：加、减、乘、除、数据传送、移位、转移、输入输出</li>\n<li>操作数描述<ul>\n<li>数据的类型：定点数、浮点数、复数、字符、字符串、逻辑数、向量</li>\n<li>进位制：2进制、10进制、16进制</li>\n<li>数据字长：字、半字、双字、字节</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>地址码通常包括三部分内容：<ul>\n<li>地址：直接地址、间接地址、立即数、寄存器编号、变址寄存器编号</li>\n<li>地址的附加信息：偏移量、块长度、跳距</li>\n<li>寻址方式：直接寻址、间接寻址、立即数寻址、变址寻址、相对寻址、寄存器寻址(可能)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指令格式的优化<ul>\n<li>指令=操作码+地址码</li>\n<li>指令格式的优化：如何用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短。</li>\n<li>主要目标：<ul>\n<li>节省程序的存储空间</li>\n<li>指令格式尽量规整，便于译码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>操作码的优化表示：<ul>\n<li>操作码的三种编码方法：<ul>\n<li>固定长度：规整性好，解码简单，空间大</li>\n<li>Huffman编码：空间小，规整性不好，解码复杂。</li>\n<li>扩展编码：折衷方案，由固定长操作码与Huffman编码法相结合形成</li>\n</ul>\n</li>\n<li>改进操作码编码方式能够节省程序存储空间</li>\n</ul>\n</li>\n<li>指令字格式的优化：<ul>\n<li>只有操作码的优化，没有在地址码和寻址方式上采取措施，程序的总位数还是难以减少。</li>\n<li>如果主存按位编址，则部分指令的读取需要两个周期，是机器速度明显下降。</li>\n</ul>\n</li>\n</ul>\n","more":"<h1 id=\"计算机系统结构\"><a href=\"#计算机系统结构\" class=\"headerlink\" title=\"计算机系统结构\"></a>计算机系统结构</h1><h2 id=\"第一章-计算机系统结构基础及并行性的开发\"><a href=\"#第一章-计算机系统结构基础及并行性的开发\" class=\"headerlink\" title=\"第一章 计算机系统结构基础及并行性的开发\"></a>第一章 计算机系统结构基础及并行性的开发</h2><ul>\n<li>计算机性能的高速增长受益于<ul>\n<li>电路技术的发展</li>\n<li>体系结构技术的发展</li>\n<li>其他因素(OS, Compiler 的发展)</li>\n</ul>\n</li>\n<li>80年代后，RISC技术和微处理器技术使得体系结构技术对计算机性能发展的影响越来越大</li>\n</ul>\n<blockquote>\n<p>CISC(复杂指令集)结构出现得较早。在这种结构中，新功能的增加主要靠增加新的指令，但为了保持向下兼容，就必须保持原有的指令；每条指令都有不同的操作指令码，对应不同的数据类型和位置，这样就造成了系统具有较大的指令系统和复杂的寻址技术，指令格式也很不规范。而RISC(精简指令集)结构则采用定长指令，使用流水线的方式执行指令。这种结构大量利用寄存器间的操作，大大简化了处理器的结构，优化了VLSI器件的使用效率，同时功耗较低。与CISC处理器相比，RISC处理器的突出特点是只用硬件实现最常用的指令，其他指令通过微代码软件来模拟实现，通过简短的定长指令提高并行度。这样虽然硬件设计较简单，但处理器指令的逻辑设计反而复杂了。RISC诞生之时恰逢386处理器取得了巨大的成功。在当时条件下，同样工艺水平的芯片，采用RISC架构的产品，其速度比CISC快3倍左右，这在Intel内部产生了很大的震动。最终诞生的 486处理器是第一个真正引入RISC技术的X86处理器。</p>\n</blockquote>\n<h3 id=\"1-1-计算机系统的层次结构\"><a href=\"#1-1-计算机系统的层次结构\" class=\"headerlink\" title=\"1.1 计算机系统的层次结构\"></a>1.1 计算机系统的层次结构</h3><ul>\n<li>如何从整体上认识计算机系统？<ul>\n<li>一种新的认识方法：从计算机语言的角度，将计算机系统看成按<strong>功能</strong>划分的<strong>多级层次结构</strong></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GmXU9f.jpg\" alt=\"GmXU9f.jpg\"></p>\n<ul>\n<li>M0用硬件实现，M1用微程序（固件）实现，M2到M5大多用软件实现</li>\n<li>固件：是一种具有软件功能的硬件</li>\n<li>虚拟机：由软件实现的机器。虚拟机的功能不一定全由软件实现，也可以是固件或硬件</li>\n<li><strong>选择什么样的软硬件比例</strong>，是系统结构研究的核心内容之一</li>\n<li>多层系统结构的意义和作用<ul>\n<li>推动了计算机系统结构的发展<ul>\n<li>有利于正确理解软件、硬件和固件在系统结构中的地位和作用</li>\n</ul>\n</li>\n<li>发展了多处理机系统、分布处理系统、计算机网络系统等系统结构<ul>\n<li>每级有各自的用户、实现方法和指令集，摆脱各级功能在一台机器实现</li>\n</ul>\n</li>\n<li>推动自虚拟机、多种操作系统共行等技术</li>\n</ul>\n</li>\n<li>对于使用某一级语言编程的程序员来说，只需要熟悉和遵守该级语言的使用规定。</li>\n<li>各机器级的实现采用翻译技术或解释技术，或者两者结合</li>\n<li><strong>翻译</strong>： 先用转换程序将高一级机器级上的程序<strong>整个</strong>地变换成低一级机器级上等效的程序，然后再在低一级机器级上实现的技术</li>\n<li><strong>解释</strong>： 在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级的机器级语言程序中的每条语句或指令<strong>逐条</strong>解释来实现的技术</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/Gn93xx.jpg\" alt=\"Gn93xx.jpg\"></p>\n<h3 id=\"1-2-计算机系统结构，计算机组成和计算机实现\"><a href=\"#1-2-计算机系统结构，计算机组成和计算机实现\" class=\"headerlink\" title=\"1.2 计算机系统结构，计算机组成和计算机实现\"></a>1.2 计算机系统结构，计算机组成和计算机实现</h3><h4 id=\"1-2-1-计算机系统结构的定义和内涵\"><a href=\"#1-2-1-计算机系统结构的定义和内涵\" class=\"headerlink\" title=\"1.2.1 计算机系统结构的定义和内涵\"></a>1.2.1 计算机系统结构的定义和内涵</h4><p>从计算机系统的层次结构角度来看，系统结构是对计算机系统中各级界面的定义及其上下的功能分配。计算机系统的每一级都有自己的系统结构。</p>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GKobNV.png\" alt=\"GKobNV.png\"></p>\n<ul>\n<li>从不同级看到的计算机属性是不同的</li>\n<li>计算机系统的层次结构具有的特征：<strong>透明性</strong></li>\n<li>透明：客观存在的事物或属性从某个角度<strong>看不到</strong><ul>\n<li>优点：可以不用管理它，简化设计</li>\n<li>缺点：看不到而无法加以控制，会带来不利</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GKT6KJ.png\" alt=\"GKT6KJ.png\"></p>\n<p>计算机系统结构也称为计算机系统的体系结构，它只是系统结构中的一部分，指的是传统机器级的系统结构。</p>\n<ul>\n<li>结论：计算机系统结构研究的是软，硬件之间的功能分配以及对传统机器级界面的确定</li>\n<li>计算机系统结构是程序员所看到的计算机的属性，即概念性结构与功能特性</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GnAISJ.jpg\" alt=\"GnAISJ.jpg\"></p>\n<blockquote>\n<p>堆栈型机器、累加器型机器和通用寄存器型机器各自有什么优缺点<br>1.堆栈型机器——CPU 中存储操作数的单元是堆栈的机器。<br>2.累加型机器——CPU 中存储操作数的单元是累加器的机器。<br>3.通用寄存器型机器——CPU 中存储操作数的单元是通用寄存器的机器。<br>CPU状态分为管态和目态，CPU的状态属于程序状态字PSW的一位，管态又称特权状态、系统态或核心态。通常，操作系统在管态下运行，CPU在管态下可以执行指令系统的全集。<br>目态又称常态或用户态，机器处于目态时，程序只能执行非特权指令。用户程序只能在目态下运行。</p>\n</blockquote>\n<h4 id=\"1-2-2-计算机组成和计算机实现的定义及内涵\"><a href=\"#1-2-2-计算机组成和计算机实现的定义及内涵\" class=\"headerlink\" title=\"1.2.2 计算机组成和计算机实现的定义及内涵\"></a>1.2.2 计算机组成和计算机实现的定义及内涵</h4><p>1.<strong>计算机组成</strong>：是指<strong>计算机系统结构的逻辑实现</strong>，包括机器级内部的数据流和控制流的组成以及逻辑设计等等<br>（1）着眼点：机器内部各事件的排序方式与控制机构，各部件的功能及各部件间的联系。<br>（2）预解决：在合理或满足要求的性能和价格的条件下，怎么最佳、最合理地把各种设备和部件组织成计算机，以实现所确定的计算机。</p>\n<ul>\n<li>计算机组成设计要确定的方面包括：<ul>\n<li>数据通路宽度（数据总线上一次并行传送的信息位数）</li>\n<li>各种操作对功能部件的共享程度</li>\n<li>专用功能部件的设置</li>\n<li>功能部件的并行性</li>\n<li>缓冲和排队技术</li>\n<li>预测技术</li>\n<li>可靠性技术</li>\n<li>控制机构的组成，等等</li>\n</ul>\n</li>\n</ul>\n<p>2.<strong>计算机实现</strong>：是计算机组成的<strong>物理实现</strong><br>（1）着眼点：器件技术（主导作用），微组装技术</p>\n<ul>\n<li>计算机实现:(是数字电路等课程主要研究的内容)<ul>\n<li>处理器、主存的物理结构</li>\n<li>器件的集成度和速度</li>\n<li>信号传输</li>\n<li>器件、模块、插件、底板的划分与连接</li>\n<li>涉及的专用器件</li>\n<li>电源、冷却、微组装技术、整机装配技术，等等</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQGiSH.jpg\" alt=\"GQGiSH.jpg\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQGwp4.png\" alt=\"GQGwp4.png\"></p>\n<ul>\n<li>系列机：CPU的机器指令和汇编指令系统相同（或绝大部分相同）</li>\n<li><strong>狭义的系统结构</strong>是<strong>组成</strong>的抽象</li>\n<li><strong>组成</strong>是<strong>实现</strong>的抽象</li>\n<li>一种体系结构可以有多种组成，一种组成可以有多种物理实现</li>\n<li><strong>计算机系统结构</strong>研究的范畴：机器/汇编指令系统，数据表示，是否采用通道方式输入/输出的确定</li>\n<li><strong>计算机组成研究</strong>的范畴：指令采用顺序，重叠，流水还是其他方式解释，数据通路宽度的确定，通道采用结合型还是独立型</li>\n<li><strong>广义</strong>的计算机体系结构定义：包括<strong>狭义的系统结构，计算机组成</strong><ul>\n<li>任务：<ul>\n<li>从程序设计者角度：软硬件的功能分配以及确定软硬件界面</li>\n<li>从计算机设计者角度：更合理地实现分配给硬件的功能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-2-3-计算机系统结构，组成和实现的相互影响\"><a href=\"#1-2-3-计算机系统结构，组成和实现的相互影响\" class=\"headerlink\" title=\"1.2.3 计算机系统结构，组成和实现的相互影响\"></a>1.2.3 计算机系统结构，组成和实现的相互影响</h4><ul>\n<li>计算机系统结构，组成，实现三者互不相同，但又互相影响</li>\n<li>不同的系统结构会影响到组成技术</li>\n<li>组成技术也会影响系统结构，是一种推动作用<ul>\n<li>专用部件的设置</li>\n</ul>\n</li>\n<li><strong>实现</strong>永远是结构和组成的最坚实基础</li>\n</ul>\n<h3 id=\"1-3-计算机系统的软硬件取舍，性能评测及定量设计原理\"><a href=\"#1-3-计算机系统的软硬件取舍，性能评测及定量设计原理\" class=\"headerlink\" title=\"1.3 计算机系统的软硬件取舍，性能评测及定量设计原理\"></a>1.3 计算机系统的软硬件取舍，性能评测及定量设计原理</h3><h4 id=\"1-3-1-软，硬件取舍的基本原则\"><a href=\"#1-3-1-软，硬件取舍的基本原则\" class=\"headerlink\" title=\"1.3.1 软，硬件取舍的基本原则\"></a>1.3.1 软，硬件取舍的基本原则</h4><ul>\n<li>计算机系统结构的任务：<ul>\n<li>软、硬功能分配，确定软硬界面</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>提高硬件功能比例</th>\n<th>提高软件功能比例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>提高解题速度</td>\n<td>降低解题速度</td>\n</tr>\n<tr>\n<td>减少程序所需存储空间</td>\n<td>增加程序所需存储空间</td>\n</tr>\n<tr>\n<td>增加硬件成本</td>\n<td>减少硬件成本</td>\n</tr>\n<tr>\n<td>降低软件费用</td>\n<td>增加软件费用</td>\n</tr>\n<tr>\n<td>降低硬件利用率</td>\n<td>增加系统灵活性</td>\n</tr>\n<tr>\n<td>降低系统灵活性</td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>软硬件取舍的<strong>三原则</strong>：</p>\n<ul>\n<li>在现有的硬件和器件条件下，系统要有<strong>高的性能价格比</strong>；</li>\n<li>在软硬功能分配时，要考虑到准备采用的组成和实现技术，<strong>使其不过多的限制或不合理限制各种组成、实现技术</strong>；</li>\n<li>在软硬功能分配时，除了从“硬件”角度考虑，还要从“软”的角度考虑，把为<strong>编译、OS以及高级语言的设计与实现提供更多、更好的硬件支持放在首位</strong>。</li>\n</ul>\n</li>\n<li><p>语义差距的大小实质上取决于软硬件功能的分配</p>\n</li>\n</ul>\n<h4 id=\"1-3-2-计算机系统的性能评测与定量设计原理\"><a href=\"#1-3-2-计算机系统的性能评测与定量设计原理\" class=\"headerlink\" title=\"1.3.2 计算机系统的性能评测与定量设计原理\"></a>1.3.2 计算机系统的性能评测与定量设计原理</h4><p>1.计算机系统的性能评测</p>\n<ul>\n<li>时钟频率：CPU的主频表示在CPU内数字脉冲信号震荡的速度，与CPU实际的运算能力并没有直接关系</li>\n<li>计算机系统的性能指标体现于<strong>时间</strong>和<strong>空间</strong>两个方面，在系统上程序实际运行的<strong>时间</strong>应该是衡量机器时间（速度）性能最可靠的标准</li>\n<li>机器的性能是通过采用好的硬件，系统结构以及高效的资源管理等技术来提高的</li>\n<li>计算机性能指：数据处理（数据运算（速度），数据传输（速度）），数据容量，数据质量的综合性能</li>\n<li>系统性能的测量依赖于人（计算机用户/系统管理者）的观点</li>\n<li>计算机的性能以及对系统评价的目标都指<strong>系统速度的性能</strong>，通常是用<strong>响应时间</strong>来衡量</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQT9Nq.png\" alt=\"GQT9Nq.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQTuU1.png\" alt=\"GQTuU1.png\"></p>\n<ul>\n<li><p>减少CPI是RISC思想的精华 </p>\n</li>\n<li><p>反应程序的运行速度通常引入下面一些指标</p>\n<ul>\n<li>MIPS：计算机单位时间执行的指令条数<ul>\n<li>主频越高f，平均每条指令的时钟周期数CPI越少，其MIPS越高，在一定程度反映了机器的性能</li>\n<li>MIPS很大程度的依赖指令集，它很难衡量指令系统不同机器之间的性能</li>\n<li>用于比较相同指令系统系统</li>\n<li>即使在同一台机器上，程序负荷不同，CPI也不同，MIPS也就受到影响——浮点运算、定点运算</li>\n<li>MIPS还与机器的硬件实现有关<ul>\n<li>浮点运算在硬件上实现，MIPS低，性能高</li>\n<li>浮点运算用软件实现，MIPS高，性能低</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>MFLOPS：每秒百万次浮点运算<ul>\n<li>Tflops:每秒一万亿次浮点运算</li>\n<li>1T=1024G ， 1G=1024M  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>计算机的性能通常用<strong>峰值性能</strong>和<strong>持续性能</strong>来评价</p>\n<ul>\n<li>峰值性能：理想情况下计算机系统可以获得的最高理论性能值</li>\n<li>持续性能：也称<strong>实际性能</strong>，其表示有<strong>算术性能平均值</strong>，<strong>调和性能平均值</strong>，<strong>几何性能平均值</strong></li>\n</ul>\n</li>\n<li><p>算术性能平均值</p>\n<ul>\n<li>设算术性能平均值Am是n道程序运算速度或运算时间的算术平均值</li>\n<li>以速率评价<img src=\"https://npm.elemecdn.com/justlovesmile-img/GQHup6.png\" alt=\"GQHup6.png\"></li>\n<li>Ti是第i个程序的执行时间，Ri是第i个程序的执行速率</li>\n<li>以执行时间评价<img src=\"https://npm.elemecdn.com/justlovesmile-img/GQHTE9.png\" alt=\"GQHTE9.png\"></li>\n</ul>\n</li>\n<li><p>调和性能平均值</p>\n<ul>\n<li>调和平均数又称倒数平均数，<strong>给定数据的倒数之算术平均数的倒数</strong></li>\n<li><strong>Hm的值与运行全部程序所需的时间成反比—比较准确</strong></li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQbfPI.jpg\" alt=\"GQbfPI.jpg\"></li>\n</ul>\n</li>\n<li><p>几何性能平均值</p>\n<ul>\n<li>几何平均数是n个变量值连乘积的n次方根</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQqlod.png\" alt=\"GQqlod.png\"></li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1iX6g.png\" alt=\"G1iX6g.png\"></li>\n<li>几何平均值无法给出系统性能的真实期望.</li>\n<li>几何平均值常常使用测试机和参考机之间归一化的比值</li>\n</ul>\n</li>\n<li><p><strong>调和平均数、几何平均数和算术平均数三者间，存在如下数量关系：  H≤G≤A</strong></p>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQOgZF.png\" alt=\"GQOgZF.png\"></p>\n<p>2.计算机系统的定量设计原理<br>（1）哈夫曼压缩原理</p>\n<ul>\n<li>也称关注经常性事件原则</li>\n<li>抓主要矛盾</li>\n<li>性能——功耗的折中<ul>\n<li>处理器执行两个数的加法运算，溢出不溢出情况</li>\n<li>Pentium M处理器为了降低系统功耗且同时提高计算机性能，在其译码单元引入“micro-op Fusion”概念，把原有的两个micro-op（microinstructions）合成为一个进行操作</li>\n</ul>\n</li>\n</ul>\n<p>（2）Amdahl定律</p>\n<ul>\n<li>该定律将“关注经常性事件原则”进行了量化</li>\n<li>用于确定对系统中<strong>性能瓶颈部件采取措施提高速度后</strong>能得到系统性能改进的程度，即系统加速比Sp</li>\n<li><strong>Sp定义为系统改进后的性能与未改进时的性能的比值，或者定义为系统未改进时的程序执行时间Told与改进后程序执行时间Tnew的比值</strong></li>\n<li>Sp与两个因素有关，即性能可改进比fnew和部件加速比rnew</li>\n<li>性能可改进比fnew是系统性能可改进部件占用的时间与未改进时系统总执行时间的比值<ul>\n<li>0≤fnew≤1</li>\n</ul>\n</li>\n<li>部件加速比rnew是系统性能可改进部分在改进后性能提高的比值<ul>\n<li>Rnew&gt;1</li>\n<li>Rnew=TRold/TRnew</li>\n</ul>\n</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1kiVA.png\" alt=\"G1kiVA.png\"></li>\n<li>当fnew为0时，Sp=1；当Rnew趋于无穷大时，Sp=1/(1-fnew);</li>\n<li>通过使用某种较快的执行方式所获得的性能提高，受限于该部件占用系统执行时间的百分比,它是一个悲观定律</li>\n<li>通用多核系统在扩展到8个核以上时，往往会达到一个性能降低的拐点</li>\n<li>应用本身受到串行处理模式和技术的限制。无论拥有多少个核心，它们中的许多都因等待数据进行串行处理而被闲置起来</li>\n<li>阿姆达尔定律描述的一个关键事实是它<strong>只适用于计算的一种场合</strong>，即施行并行化后计算中的顺序部分将占据执行时间的主要部分</li>\n<li>阿姆达尔定律是在<strong>固定应用规模的前提下</strong>考虑并行性增长的影响。但大多数并行计算则是<strong>固定并行性而扩展应用的规模</strong></li>\n</ul>\n<p>（3）程序访问的局部性规律</p>\n<ul>\n<li>时间局部性: 一个存储项被访问,可能很快再访问</li>\n<li>空间局部性: 存储项被访问,它的邻近项可能很快被访问</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQX3FJ.png\" alt=\"GQX3FJ.png\"></p>\n<p><strong>某一计算机用于商业外贸的事务处理，有大量的字符串操作。由于这种事务处理很普遍，有较大的市场，故而设计人员决定在下一代此类计算机的CPU中加入字符串操作的功能。经测试应用软件调查发现，字符串操作的使用占整个程序运行时间的50%，而增加此功能如用软件（如微程序）实现，则快5倍，增加CPU成本1/5倍；如果用硬件实现，则快100倍，CPU成本增加到5倍。问设计人员提出增加此功能是否恰当？是否用软件还是硬件？（设CPU成本占整机成本的1/3）</strong><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQX0Te.png\" alt=\"GQX0Te.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQXclt.png\" alt=\"GQXclt.png\"></p>\n<h4 id=\"1-3-3-计算机系统设计的主要任务和方法\"><a href=\"#1-3-3-计算机系统设计的主要任务和方法\" class=\"headerlink\" title=\"1.3.3 计算机系统设计的主要任务和方法\"></a>1.3.3 计算机系统设计的主要任务和方法</h4><p>1.计算机系统设计的主要任务</p>\n<ul>\n<li>包括系统结构，计算机组成和计算机实现的设计</li>\n</ul>\n<p>2.计算机系统的设计方法</p>\n<ul>\n<li>由上往下<ul>\n<li>先考虑如何满足用户要求，定好面对使用者的虚拟机的基本功能和环境，如指令系统、语言结构、数据类型等，然后逐级向下设计，每一级都严格考虑优化上一级来实现</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQj7Ue.png\" alt=\"GQj7Ue.png\"></li>\n</ul>\n</li>\n<li>由下往上<ul>\n<li>不考虑用户的具体需求，只根据当时拿到的器件，参照或吸收已有各种机器的特点，把微程序机器级和传统机器级分别研制出来，然后再配上适合不同应用环境的各种操作系统和各种编译程序，以满足不同方面的应用要求。</li>\n<li>优点:<ul>\n<li>有利于缩短研制周期</li>\n<li>有利于软硬件人员之间的交流</li>\n<li>软硬分配更加合理</li>\n<li>系统的性能价格比更高</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>从中间往两头</li>\n</ul>\n<h3 id=\"1-4-软件，应用，器件的发展对系统结构的影响\"><a href=\"#1-4-软件，应用，器件的发展对系统结构的影响\" class=\"headerlink\" title=\"1.4 软件，应用，器件的发展对系统结构的影响\"></a>1.4 软件，应用，器件的发展对系统结构的影响</h3><h4 id=\"1-4-1-软件的发展对系统结构的影响\"><a href=\"#1-4-1-软件的发展对系统结构的影响\" class=\"headerlink\" title=\"1.4.1 软件的发展对系统结构的影响\"></a>1.4.1 软件的发展对系统结构的影响</h4><ul>\n<li>软件的可移植：软件不用修改或只需经少量加工就能由一台机器投到另一台机器上运行，即同一软件可以应用于不同的环境</li>\n<li>软件移植的三种技术<ul>\n<li>统一高级语言：面向题目和算法，和具体结构关系不大<ul>\n<li>指一种完全通用的高级语言，为所有程序员所使用，并能在完全不同的机器之间实现程序的软件移植。</li>\n</ul>\n</li>\n<li>系列机、兼容机：具有相同结构的各种机器之间<ul>\n<li>兼容机：不同厂家生产的具有相同指令集结构的计算机</li>\n<li>系列机：CPU的机器指令和汇编指令系统相同（或绝大部分相同）</li>\n<li>软件兼容：即同一个软件可以不加修改地运行于体系结构相同的各档机器，而且它们    所获得的结果一样，差别只在于有不同的运行时间。</li>\n<li>向上(下)兼容指的是按某档机器编制的程序，不加修改的就能运行于比它高(低)档的机器。</li>\n<li>向前(后）兼容指的是按某个时期投入市场的某种型号机器编制的程序，不加修改地就能运行于在它之后(前)投入市场的机器。</li>\n<li>系列机软件兼容性必须保证做到向后兼容，力争向上兼容</li>\n</ul>\n</li>\n<li>模拟与仿真：软件在不同体系结构之间的移植<ul>\n<li>模拟<ul>\n<li>用A机的机器语言程序解释B机器语言程序，从而实现软件移植方法 宿主机 A机  虚拟机 B机</li>\n<li>为实现模拟编制的各种解释程序</li>\n</ul>\n</li>\n<li>仿真<ul>\n<li>用A机的微程序解释B机的机器语言程序，从而实现软件移植方法 宿主机 A机  目标机 B机</li>\n<li>为实现仿真编制的各种解释微程序</li>\n</ul>\n</li>\n<li><img src=\"https://npm.elemecdn.com/justlovesmile-img/GQzTET.png\" alt=\"GQzTET.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/GlSiPe.png\" alt=\"GlSiPe.png\"></p>\n<h4 id=\"1-4-2-应用对系统结构的影响\"><a href=\"#1-4-2-应用对系统结构的影响\" class=\"headerlink\" title=\"1.4.2 应用对系统结构的影响\"></a>1.4.2 应用对系统结构的影响</h4><ul>\n<li>应用需求是促使计算机系统结构发展的最根本的动力</li>\n<li>不同的应用对计算机系统结构的设计提出了不同的要求</li>\n<li>计算机应用可归纳为：数据处理，信息处理，知识处理，智能处理</li>\n</ul>\n<h4 id=\"1-4-3-器件的发展对系统结构的影响\"><a href=\"#1-4-3-器件的发展对系统结构的影响\" class=\"headerlink\" title=\"1.4.3 器件的发展对系统结构的影响\"></a>1.4.3 器件的发展对系统结构的影响</h4><ul>\n<li><p>芯片制造的发展</p>\n</li>\n<li><p>器件的发展对系统的影响</p>\n<ul>\n<li>功能和使用方法—非用户片、现场片及用户片</li>\n<li>改变了逻辑设计的传统方法—速度、规整</li>\n<li>推动了系统结构技术的发展</li>\n<li>体系结构”下移”速度加快—并行计算</li>\n<li>促进了算法、语言和软件的发展</li>\n</ul>\n</li>\n<li><p>软件是促使计算机系统结构发展的最重要的因素</p>\n</li>\n<li><p>应用需求是促使计算机系统结构发展的最根本的动力</p>\n</li>\n<li><p>器件是促使计算机系统结构发展最活跃的因素</p>\n</li>\n<li><p>非用户片：也称通用片，其功能是由器件厂家生产时已确定的，器件的用户（即机器设计者）只能使用，不能改变器件内部功能</p>\n</li>\n<li><p>现场片：是用户根据需要可改变器件内部功能的芯片（FPGA）</p>\n</li>\n<li><p>用户片：是专门按用户要求生产的高集成度VLSI器件（ASIC）</p>\n<ul>\n<li>全用户片：是完全按用户要求设计的用户片</li>\n<li>半用户片：是基本按通用片进行生产，最后按用户要求再制作的用户片，如门阵列、门-触发器阵列等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-5-系统结构钟的并发性开发及计算机系统的分类\"><a href=\"#1-5-系统结构钟的并发性开发及计算机系统的分类\" class=\"headerlink\" title=\"1.5 系统结构钟的并发性开发及计算机系统的分类\"></a>1.5 系统结构钟的并发性开发及计算机系统的分类</h3><h4 id=\"1-5-1-并行性的概念和开发\"><a href=\"#1-5-1-并行性的概念和开发\" class=\"headerlink\" title=\"1.5.1 并行性的概念和开发\"></a>1.5.1 并行性的概念和开发</h4><p>1.并行性的含义和级别</p>\n<ul>\n<li><p><strong>并行性</strong>：解题中具有可以同时进行运算或操作的特性</p>\n</li>\n<li><p>并行性包含了同时性和并发性二重含义</p>\n<ul>\n<li><strong>同时性</strong>（Simultaneity）：两个或多个事件在<strong>同一时刻</strong>发生</li>\n<li><strong>并发性</strong>（Concurrency）：两个或多个事件在<strong>同一时间间隔内</strong>发生</li>\n</ul>\n</li>\n<li><p><strong>只要时间上有重叠就存在并行性！</strong></p>\n</li>\n<li><p>并行性的等级：</p>\n<ul>\n<li>从计算机系统中执行程序的角度（由低到高）<ul>\n<li>指令内部—一条指令内部各个微操作之间的并行</li>\n<li>指令之间—多条指令的并行执行</li>\n<li>任务或进程之间—多个任务或程序段的并行执行</li>\n<li>作业或程序之间—多个作业或多道程序的并行。</li>\n</ul>\n</li>\n<li>从处理数据的角度（由低到高）<ul>\n<li>位串字串——顺序</li>\n<li>位并字串——同时对一个字的全部位</li>\n<li>位片串字并——同时对许多字的同一位</li>\n<li>全并行——同时对许多字的全部或部分</li>\n</ul>\n</li>\n<li>从计算机信息加工的各个步骤和阶段<ul>\n<li>存储器操作并行</li>\n<li>处理器操作步骤并行</li>\n<li>处理器操作并行</li>\n<li>指令、任务、作业并行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>2.并行性开发的途径</p>\n<ul>\n<li><p><strong>时间重叠</strong></p>\n<ul>\n<li>是在并行性概念中引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。<ul>\n<li>举例：流水线</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>资源重叠</strong></p>\n<ul>\n<li>是在并行性概念中引入空间因素，通过重复设置硬件资源来提高可靠性或性能<ul>\n<li>例如：双工系统</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>资源共享</strong></p>\n<ul>\n<li>是利用<strong>软件的方法</strong>让多个用户按一定时间顺序轮流地使用同一套资源，以提高其利用率，这样也可以提高整个系统的性能<ul>\n<li>例如：网络打印机</li>\n<li>多道程序、分时OS →真正的处理机代替虚拟机→分布处理系统</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>3.计算机系统的并行性发展</p>\n<ul>\n<li>不同时间阶段，并行性发展的主要表现不同</li>\n</ul>\n<p>4.多机系统的耦合度</p>\n<ul>\n<li>多机系统：包含多处理机系统和多计算机系统<ul>\n<li>多处理机系统<ul>\n<li>是由多台处理机组成的单一计算机系统，各处理机都可有自己的控制部件，可带自己的局部存储器，能执行各自的程序</li>\n<li><strong>在逻辑上受统一的操作系统控制</strong>，体系结构可以是共享存储器，也可以是分布式存储器</li>\n</ul>\n</li>\n<li>多计算机系统<ul>\n<li>是由多台独立的计算机组成的系统，<strong>各计算机分别在逻辑上独立的操作系统控制下运行</strong>，机间可以互不通信，即使通信也只是经通道或通信线路以文件或数据集形式进行，实现多个作业的并行</li>\n<li>一般指分布式存储结构</li>\n<li>集群系统和大规模并行处理机MPP都是多计算机系统</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>耦合度</strong>：一般用耦合度反映多机系统中各机器之间物理连接的紧密程度和交叉作用能力的强弱<ul>\n<li><strong>最低耦合系统</strong>（Least Coupled System）：各种脱机系统 </li>\n<li><strong>松散耦和系统</strong>（Loosely Coupled System）：如果多台计算机通过通道或通信线路实现互连，共享某些磁带、磁盘等外围设备，以较低频带在文件或数据集一级相互作用。又称间接耦合系统</li>\n<li><strong>紧密耦合系统</strong>（Tightly Coupled System）：如果多台机器之间通过总线或高速开关互连，<strong>共享主存</strong>，并有较高的信息传输速度，可以实现数据集一级、任务级、作业级的并行。又称直接耦合系统 </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-5-2-计算机系统的分类\"><a href=\"#1-5-2-计算机系统的分类\" class=\"headerlink\" title=\"1.5.2 计算机系统的分类\"></a>1.5.2 计算机系统的分类</h4><p>1.弗林分类</p>\n<ul>\n<li>弗林分类法（Michael J,Flynn分类）：弗林提出按<strong>指令流</strong>和<strong>数据流</strong>的多倍性对计算机系统进行分类<ul>\n<li><strong>指令流</strong>：是指机器执行的<strong>指令序列</strong></li>\n<li><strong>数据流</strong>：是指指令流调用的<strong>数据序列</strong>，包括输入数据和中间结果</li>\n<li><strong>多倍性</strong>：是指在系统性能瓶颈部件上处于<strong>同一执行阶段</strong>的指令或数据的最大可能个数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1KCqK.png\" alt=\"G1KCqK.png\"><br><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1KQZ8.png\" alt=\"G1KQZ8.png\"></p>\n<ul>\n<li>主要缺点：  <ul>\n<li>(1)分类太粗：例如，在SIMD中包括有多种处理机，对流水线处理机的划分不明确，标量流水线为SISD，向量流水线为SIMD </li>\n<li>(2)根本问题是把两个不同等级的功能并列对待；通常，数据流受指令流控制，从而造成MISD不存在  </li>\n<li>(3)非冯计算机的分类；其他新型计算机的分类  </li>\n</ul>\n</li>\n</ul>\n<p>2.库克分类</p>\n<ul>\n<li>用<strong>指令流</strong>和<strong>执行流</strong>（Execution Stream）及其多倍性来描述计算机系统总控制器的结构特征<ul>\n<li>SISE：单处理机系统 </li>\n<li>SIME：多操作部件的处理机</li>\n<li>MISE：带指令级多道程序的单处理机</li>\n<li>MIME：多处理机 </li>\n</ul>\n</li>\n<li>缺点 <ul>\n<li>有些系统，如分布处理机等，没有总控制器  </li>\n<li>分类太粗，如SIME中包含了多种类型的处理机  </li>\n</ul>\n</li>\n</ul>\n<p>3.冯泽云分类</p>\n<ul>\n<li>提出用数据处理的并行度来定量地描述各种计算机系统特性<ul>\n<li>WSBS（字串位串） </li>\n<li>WSBP（字串位并）</li>\n<li>WPBS（字并位串）</li>\n<li>WPBP（字并位并）</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>仅考虑了数据的并行性，没有考虑指令、任务、作业的并行<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/G1MekF.png\" alt=\"G1MekF.png\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-6-本章小结\"><a href=\"#1-6-本章小结\" class=\"headerlink\" title=\"1.6 本章小结\"></a>1.6 本章小结</h3><ol>\n<li>重点：（1）计算机系统结构，计算机组成，计算机实现三者的定义以及包含的内容（2）有关透明性问题的判断（3）软件和硬件的功能分配原则（4）软件可移植性的途径，方法，适用场合，存在问题和对策（5）并行性的概念（6）系统结构中开发并行性的途径</li>\n<li>难点：透明性的判断与分析</li>\n</ol>\n<blockquote>\n<p>下列哪些对<strong>系统程序员</strong>是透明的?<br><strong>A、超大规模集成电路</strong><br>B、虚拟存储器<br><strong>C、Cache存储器</strong><br>D、程序状态字<br>E、“启动I/O”指令<br>F、“执行”指令<br><strong>G、指令缓冲寄存器</strong></p>\n</blockquote>\n<p>正确答案： ACG </p>\n<blockquote>\n<p>下列哪些对<strong>应用程序员</strong>是透明的?<br><strong>A、虚拟存储器</strong><br><strong>B、Cache存储器</strong><br><strong>C、程序状态字</strong><br><strong>D、“启动I/O”指令</strong><br>E、“执行”指令<br><strong>F、指令缓冲寄存器</strong></p>\n</blockquote>\n<p>正确答案： ABCDF </p>\n<blockquote>\n<p>1.系列机可将单总线改成双总线来减少公用总线的使用冲突。 【答案：√】<br>2.系列机增加新机种时,为增加寻址灵活性和缩短平均指令字长,由原等长操作码改为多种码长的扩展操作码。【答案：×】<br>3.系列机应用软件应做到向前兼容,力争向下兼容。【答案：×】<br>4.可以说向后兼容是系列机的根本特征。 【答案：√】<br>5.系列机不再是方向,因为它约束了计算机系统结构的发展。 【答案：×】<br>6.由同一厂家生产的,系统结构相同的,但组成和实现不同的所有计算机,称为兼容机。 【答案：×】 </p>\n</blockquote>\n<h2 id=\"第二章-数据表示，寻址方式与指令系统\"><a href=\"#第二章-数据表示，寻址方式与指令系统\" class=\"headerlink\" title=\"第二章 数据表示，寻址方式与指令系统\"></a>第二章 数据表示，寻址方式与指令系统</h2><h3 id=\"2-1-数据表示\"><a href=\"#2-1-数据表示\" class=\"headerlink\" title=\"2.1 数据表示\"></a>2.1 数据表示</h3><h4 id=\"2-1-1-数据表示与数据结构\"><a href=\"#2-1-1-数据表示与数据结构\" class=\"headerlink\" title=\"2.1.1 数据表示与数据结构\"></a>2.1.1 数据表示与数据结构</h4><ul>\n<li>数据表示：能由机器硬件识别和引用的<strong>数据类型</strong>，表现在它有对这种类型的数据进行操作的指令和运算部件。</li>\n<li>数据类型：<strong>不同于数据，数据类型除了指一组值的集合外，还定义了可作用于这个集合上的操作集</strong> <ul>\n<li><strong>基本数据</strong>类型</li>\n<li><strong>结构数据</strong>类型<ul>\n<li>一组由相互有关的数据元素复合而成的数据类型，这些数据元素可以是基本数据类型中的元素，也可以是结构数据类型本身中的元素。也就是说这些数据是有结构的，<strong>包括向量和数组、字符串、堆栈、队列、记录</strong>等，结构数据类型中的元素不一定都具有相同类型</li>\n</ul>\n</li>\n<li>访问指针</li>\n<li>抽象数据等类型</li>\n</ul>\n</li>\n<li>数据结构：通过软件映像，变换成机器中所具有的数据表示来实现的。<ul>\n<li>是应用中相互之间存在一种或多种特定关系的数据元素的集合。如：线性表、栈、队列、串、数组、阵列、链表、树和图等。</li>\n<li>是结构数据类型的组织方式，它反映了结构数据类型中各种数据元素或信息单元之间的结构关系 </li>\n<li>不同数据表示可以为数据结构的实现提供不同的支持。<strong>数据表示是数据结构的子集</strong></li>\n<li>数据结构和数据表示是软硬件的交界面。</li>\n</ul>\n</li>\n</ul>\n<p>图为变址操作对向量，阵列数据结构的支持：<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/1.png\"></p>\n<h4 id=\"2-1-2-高级数据表示\"><a href=\"#2-1-2-高级数据表示\" class=\"headerlink\" title=\"2.1.2 高级数据表示\"></a>2.1.2 高级数据表示</h4><p>1.自定义数据表示<br>（1）标志符数据表示</p>\n<ul>\n<li>为缩短高级语言与机器语言的语义差距，让机器中每个数据都带类型标志位</li>\n<li>| 类型标志 | 数据值 |</li>\n<li>标志符数据表示的主要优点<ul>\n<li>简化了指令系统和程序设计<ul>\n<li>减少指令种类</li>\n</ul>\n</li>\n<li>简化了编译程序<ul>\n<li>不用做复杂的映射</li>\n</ul>\n</li>\n<li>便于实现一致性校验</li>\n<li>能由硬件自动变换数据类型</li>\n<li>为软件调试和应用软件开发提供了支持</li>\n</ul>\n</li>\n<li>使用标志符数据表示可能带来如下问题<ul>\n<li>每个数据字因增设标志符，会增加程序所占的主存空间</li>\n<li>采用标志符会降低指令的执行速度<ul>\n<li>增加按标志符确定数据属性及判断操作数之间是否相容等操作，单条指令的执行速度会下降。</li>\n<li>程序的编制和调试时间的缩短，是解题总时间缩短</li>\n<li>所以，引入标志符数据表示对微观性能（机器的运算速度）不利，但对宏观性能（解题总时间）是有利的。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>（2）数据描述符</p>\n<ul>\n<li><p>为了进一步减少标志符所占存储空间，对向量、数组、记录等数据，由于元素属性相同，因此就发展出数据描述符</p>\n</li>\n<li><p>描述符和数据分开，表示访问的数据是整块还是单个，地址信息等其他信息<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415122950.png\"></p>\n</li>\n<li><p>描述符方法优点：</p>\n<ul>\n<li>描述符方法实现阵列数据的索引要比用变址方法实现更方便</li>\n<li>且便于检查出程序中的阵列越界错误</li>\n<li>数据描述符方法为向量、数组数据结构的实现提供了一定的支持，有利于并简化编译中的代码生成，可以比变址法更快地形成元素地址</li>\n</ul>\n</li>\n</ul>\n<p>2.向量数组数据表示</p>\n<ul>\n<li>为向量、数组数据结构的<strong>实现和快速运算提供更好的硬件支持的方法是增设向量、数组数据表示</strong></li>\n<li>向量在内存中是连续存放在一段空间里的，换句话说，这些向量元素的地址是连续的 </li>\n<li>在标量计算机上运行时，由于没有专门的向量数据表示，因此在计算一个向量(相当于一维数组的计算)时，每取用一个数据元素，都要用到计算该元素的地址。</li>\n<li>而在向量机中，由于有了向量数据表示，就<strong>可以把一个向量用一个位串来表示出来</strong>。向量指令就是能够用一条指令对向量的全部元素进行运算的指令。 </li>\n</ul>\n<p><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415134043.png\"></p>\n<ul>\n<li>引入向量、数组数据表示优点<ul>\n<li>不只是能加快形成元素地址；</li>\n<li>便于实现把向量各元素成块预取到中央处理器；</li>\n<li>能对阵列中的每个元素又是一个子阵列的相关交叉型阵列进行处理；</li>\n<li>对稀疏矩阵能实现压缩存储、还原、运算等多种功能操作，不但节省了空间，也由于不必处理零元素而节省了时间。</li>\n</ul>\n</li>\n</ul>\n<p>3.堆栈数据表示</p>\n<ul>\n<li><p>堆栈数据结构在编译和子程序调用中很有用</p>\n</li>\n<li><p>通用寄存器型机器对堆栈数据结构支持<strong>较差</strong></p>\n<ul>\n<li>堆栈操作用的机器指令数少，功能单一，没有专门的堆栈指令</li>\n</ul>\n</li>\n<li><p>寄存器型机器的内存分配，有堆栈(Stack)空间</p>\n<ul>\n<li>堆栈置于存储器内，访问堆栈的速度低</li>\n<li>通常只用于保存子程序调用时的<strong>返回地址</strong></li>\n<li>少量用堆栈来实现程序之前的<strong>参数传递</strong></li>\n</ul>\n</li>\n<li><p>堆栈机器</p>\n<ul>\n<li>有堆栈数据表示的机器称为堆栈机器</li>\n<li>堆栈寻址方式的地址是隐含的，在指令中不必给出操作数的地址，<strong>零地址指令</strong></li>\n<li>从60年代开始，出现了一批以堆栈寻址方式为主的堆栈计算机</li>\n<li>堆栈对以下这些方面处理非常方便<ul>\n<li>表达式求值</li>\n<li>子程序调用，递归，中断嵌套</li>\n<li>块结构语言中的变量访问</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>堆栈计算机具有如下特点：<br>（1）有高速寄存器组成的硬件堆栈，并附加控制电路，让它与主存中的堆栈区在逻辑上构成整体，使堆栈的访问速度是寄存器级，容量是主存级。<br>（2）有丰富的堆栈指令且功能很强。<br>（3）支持高级语言，有利于编译程序。因为一般的算术表达式可以很容易地转化成逆波兰表达式，而逆波兰表达式能够直接形成由堆栈指令组成的程序，这样就简化了编译程序。</p>\n<ul>\n<li><strong>以主存寻址方式为主的计算机系统</strong>，在编译一个算术表达式时，要<strong>为每一个变量分配主存单元</strong>，另外，还会人为地产生一些中间变量。<strong>如何减少中间变量的个数</strong>，合理地为变量分配存储单元，是编译器的一项许多相当困难的工作。</li>\n<li><strong>以寄存器寻址方式为主的计算机系统</strong>，编译器需要决定哪些变量放在通用寄存器中，哪些变量放在主存中，<strong>以减少访问主存储器的次数</strong>。另外，也同样存在<strong>如何减少了中间变量</strong>，节省了存储空间的问题</li>\n</ul>\n<p>（4）支持程序的嵌套和递归调用，支持中断处理</p>\n<h4 id=\"2-1-3-引入数据表示的原则\"><a href=\"#2-1-3-引入数据表示的原则\" class=\"headerlink\" title=\"2.1.3 引入数据表示的原则\"></a>2.1.3 引入数据表示的原则</h4><p><strong>从根本上讲，存储器一维线性的存储结构与要求经常使用的多维离散数据结构有着很大的差距，不利于数据结构的实现。</strong></p>\n<p>一是基本数据表示不可少；<br>二是看系统的效率是否显著提高；<br>三是看引入这种数据表示后，其通用性和利用率是否提高。<br>四是也需要挖掘基本数据表示的细节问题。</p>\n<h4 id=\"2-1-4-浮点数尾数基值大小和下溢处理方法的选择\"><a href=\"#2-1-4-浮点数尾数基值大小和下溢处理方法的选择\" class=\"headerlink\" title=\"2.1.4 浮点数尾数基值大小和下溢处理方法的选择\"></a>2.1.4 浮点数尾数基值大小和下溢处理方法的选择</h4><p>1.浮点数尾数基值的选择<br>如果小数点的位置事先已有约定，不再改变，此类数称为“定点数”。<br>如果小数点的位置可变，则称为“浮点数”。<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200826171758.png\"></p>\n<p>rm ：尾数的基<br>re ：阶码的基（re =2）<br>m： 尾数长度 (注意其含义)<br>p： 阶码长度<br>【p表示数的范围大小；尾数的位数m主要影响表示值的精度】<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415135441.png\"></p>\n<ul>\n<li>浮点数表数误差产生的原因：<ul>\n<li>运算的结果</li>\n<li>十进制转化为二进制、四进制、八进制、十六进制</li>\n</ul>\n</li>\n<li>浮点数尾数基值的选择<ul>\n<li>可表示数的范围<ul>\n<li>随着rm增大，可表示的范围增大</li>\n<li>随着rm增大，可表示数的最小值rm^-1将减少</li>\n</ul>\n</li>\n<li>可表示数的个数<ul>\n<li>(2^p)×(rm^m’)×(1-(rm^(-1)) ，其中rm的增大将因<code>(1-(rm^-1))</code>增大而使可表示数的个数增多</li>\n</ul>\n</li>\n<li>可表示的精度<ul>\n<li>rm越大，数在数轴上的分布越稀，数的表示精度自然就下降</li>\n</ul>\n</li>\n<li>运算中的精度损失<ul>\n<li>尾数右移出机器字长，使有效数字丢失，但其不同于可表示数的精度，由于尾数基值rm取大后，对阶移位的机会和次数减少，又由于数的表示范围扩大，使尾数溢出需右规的机会也减少。因此，rm越大，尾数右移的机会越小，精度的损失就越小</li>\n</ul>\n</li>\n<li>运算速度<ul>\n<li>Rm增大时，由于对阶或尾数溢出需右移及规格化需左移的次数减少，运算速度可以提高</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>综上所述，尾数基值取大，会扩大浮点数的表示范围、增加可表示数的个数、减少移位次数、降低右移造成的精度损失和提高运算速度，但是会，降低数据的表示精度，数值的分布变稀</li>\n<li>规格化正尾数：<strong>正尾数小数点后第一个rm进制数位不是0的数</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">条件：非负阶，规格化，正尾数</th>\n<th align=\"center\">阶值：二进制p位，尾数：rm进制m’位</th>\n<th align=\"center\">若p=2，m=4，当rm=2（即m’=4）时</th>\n<th align=\"center\">若p=2，m=4，当rm=16（即m’=1）时</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">可表示最小尾数值</td>\n<td align=\"center\">rm^(-1)</td>\n<td align=\"center\">1/2</td>\n<td align=\"center\">1/16</td>\n</tr>\n<tr>\n<td align=\"center\">可表示最大尾数值</td>\n<td align=\"center\">1-1×rm^(-m’)</td>\n<td align=\"center\">15/16</td>\n<td align=\"center\">15/16</td>\n</tr>\n<tr>\n<td align=\"center\">最大阶值</td>\n<td align=\"center\">2^p-1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">可表示最小值</td>\n<td align=\"center\">rm^(-1)</td>\n<td align=\"center\">1/2</td>\n<td align=\"center\">1/16</td>\n</tr>\n<tr>\n<td align=\"center\">可表示最大值</td>\n<td align=\"center\">rm^(2^p-1)×(1-rm^(-m’))</td>\n<td align=\"center\">7.5</td>\n<td align=\"center\">3840</td>\n</tr>\n<tr>\n<td align=\"center\">可表示的尾数个数</td>\n<td align=\"center\">rm^(m’)×(rm-1)/rm</td>\n<td align=\"center\">8</td>\n<td align=\"center\">15</td>\n</tr>\n<tr>\n<td align=\"center\">可表示阶的个数</td>\n<td align=\"center\">2^p</td>\n<td align=\"center\">4</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">可表示数的个数</td>\n<td align=\"center\">2^p×rm^(m’)×(rm-1)/rm</td>\n<td align=\"center\">32</td>\n<td align=\"center\">60</td>\n</tr>\n</tbody></table>\n<p>2.浮点数位数的下溢处理方法<br>减少运算中的精度损失关键是要处理好运算中尾数超出字长的部分，使精度损失最小<br>（1）<strong>截断法</strong><br>方法：<strong>将尾数超出机器字长的部分去掉</strong></p>\n<ul>\n<li><p>以rm=2，m=2为例讨论最大误差</p>\n<ul>\n<li>在整数时接近于1(“11:111…1”截断成“11:”)</li>\n<li>在分数时接近于2^(-m) (“.01:111…1”截断成“.01:”)<br>总是产生负误差<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415140626.png\"></li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现简单，不增加硬件，不需要处理时间</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>最大误差较大，且平均误差大且无法调节，因而已很少使用</li>\n</ul>\n</li>\n</ul>\n<p>（2）<strong>舍入法</strong><br>在机器运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加1,(整数加0.5，分数加2-(m+1))</p>\n<ul>\n<li><p>例如：</p>\n<ul>\n<li>整数：“10:10…0”舍入成“11:” 正误差</li>\n<li>分数：“.10:01…0”舍入成“.10:” 负误差</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现简单，增加的硬件开销少，最大误差小，平均误差接近于零</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>处理速度慢，需要花费在数的附加位加1以及因此产生进位的时间，最坏情况下，需要从尾数最低位进制<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/Y5E%7B1ZHXC%25%5B77%7BW_5Z2%5BY%5DO.png\"><br>（3）<strong>恒置“1”法</strong></li>\n</ul>\n</li>\n<li><p>将机器运算的规定字长之最低位恒置“1”</p>\n</li>\n<li><p>最大误差</p>\n<ul>\n<li>整数为1（如“10:00…0”处理成“11:”）</li>\n<li>分数为2-m（如“.00:00…0”处理成“.01:”）</li>\n</ul>\n</li>\n<li><p>误差有正负</p>\n<ul>\n<li>负误差（如“.11:10…1”处理成“.11:”）</li>\n<li>正误差（如“.00:00…0”处理成“.01:”)<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/%25%7DMG%25YPJF2L0QNXJ%7DK8FC%402.png\"></li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现简单，不需要增加硬件和处里时间，平均误差趋于0</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>最大误差最大，比截断法还大（接近于1）<br>多用于中、高速机器中，由于尾数位数比微、小型机器长</li>\n</ul>\n</li>\n</ul>\n<p>（4）查表舍入法<br>取尾数p位的最后k-1位和准备舍弃的最高1位，共k位。通过ROM或PLA查表得到k-1位，作为新的尾数p位的最后k-1位<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/%29%7DUAT%7DO7%7D%7B%25%28WNSFI%40I%25MOP.png\"></p>\n<ul>\n<li><p>下溢处理表的内容</p>\n<ul>\n<li>当尾数最低k-1位为全”1“时以截断法设置处理结果</li>\n<li>其余情况采用舍入法<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/20200415142649.png\"></li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>ROM法速度较快，平均误差可调到0</li>\n<li>避免再次右规操作</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>需要硬件配合</li>\n</ul>\n</li>\n<li><p>上述4种处理方法中，</p>\n<ul>\n<li><strong>最大误差最大</strong>的是恒置“1”法，</li>\n<li><strong>最大误差最小</strong>的是舍人法；</li>\n<li><strong>平均误差最大</strong>的是截断法；</li>\n<li><strong>平均误差可人为调节</strong>的是查表舍入法；</li>\n<li><strong>下溢处理不需要附加时间开销，即速度最快</strong>的是截断法和恒置“1”法，</li>\n<li><strong>处理速度最慢</strong>的是舍人法；</li>\n<li><strong>实现上最花费硬件</strong>的是查表舍入法，</li>\n<li><strong>最省硬件</strong>的是截断法和恒置“1”法。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-寻址方式\"><a href=\"#2-2-寻址方式\" class=\"headerlink\" title=\"2.2 寻址方式\"></a>2.2 寻址方式</h3><p>寻址方式指的是按什么方式寻找（或访问）到所需的操作数或信息的。</p>\n<h4 id=\"2-2-1-寻址方式的三种面向\"><a href=\"#2-2-1-寻址方式的三种面向\" class=\"headerlink\" title=\"2.2.1 寻址方式的三种面向\"></a>2.2.1 寻址方式的三种面向</h4><p><strong>面向主存</strong>，寻址主要访问主存，少量访问寄存器；<br><strong>面向寄存器</strong>，主要访问寄存器，少量访问主存和堆栈；<br><strong>面向堆栈</strong>，主要访问堆栈，少量访问主存或寄存器。</p>\n<h4 id=\"2-2-2-寻址方式在指令中的指明\"><a href=\"#2-2-2-寻址方式在指令中的指明\" class=\"headerlink\" title=\"2.2.2 寻址方式在指令中的指明\"></a>2.2.2 寻址方式在指令中的指明</h4><ul>\n<li>具体的寻址方式，组成原理已经讲过</li>\n<li>基本的指令格式：操作码 + 地址码</li>\n<li>寻址方式指明方法：<ul>\n<li>占用操作码的某些位指明</li>\n<li>不占操作码，在地址码设置寻址方式字段</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-3-程序在主存中的定位技术\"><a href=\"#2-2-3-程序在主存中的定位技术\" class=\"headerlink\" title=\"2.2.3 程序在主存中的定位技术\"></a>2.2.3 程序在主存中的定位技术</h4><ul>\n<li>逻辑地址与主存物理地址 <ul>\n<li>逻辑地址：程序员编写程序时使用的地址；</li>\n<li>物理地址：程序在主存中的实际地址；</li>\n</ul>\n</li>\n<li>早期——单道程序<ul>\n<li>逻辑地址和物理地址是一致的，程序和数据存放在主存中的位置是由程序员编写程序时指明的；</li>\n</ul>\n</li>\n<li>现在——多道程序<ul>\n<li>程序员已不用主存的实际地址编程，改用符号、标号名编址；</li>\n<li>由源程序中的符号名空间→目标程序的逻辑地址空间→主存中的物理地址空间 </li>\n<li>程序员事先无法知道程序装在主存中什么位置；</li>\n<li>各道程序的逻辑地址都是从0开始编制，主存物理空间地址是从0开始编址的一堆线性空间；</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>静态再定位<br>（1）在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成实际的内存地址。重定位在程序装入时一次完成<br>（2）存在问题<br>①一道程序地址改错而导致其他程序出错；<br>②指令修改妨碍了程序的可重入。<br>③指令修改了，不利于程序定位和调试。</li>\n<li>动态再定位<br>是在程序执行期间完成的，即程序的逻辑地址在装入内存时不作任何修改，程序执行中，每取出一条指令，CPU对其译码时，如果有逻辑地址，就借助于重定位机构将其转换成绝对地址，然后执行该指令。</li>\n<li>基址寻址<br>（1）指令中给出一个形式地址（作为修改量），并给出基址寄存器号，基址寄存器内容（作为基准量）与形式地址相加得到操作数有效地址<br>（2）主要解决<br>①程序重定位；<br>②扩展有限字长指令的寻址空间<br><img src=\"https://npm.elemecdn.com/justlovesmile-img/8K2W9S17_VYSURM8WL~%25YOQ.png\"></li>\n<li>虚实地址映象表<br>地址加界法要求程序员所用编址空间不能超出实际主存空间容量。</li>\n</ol>\n<h4 id=\"2-2-4-物理主存中信息的存储分布\"><a href=\"#2-2-4-物理主存中信息的存储分布\" class=\"headerlink\" title=\"2.2.4 物理主存中信息的存储分布\"></a>2.2.4 物理主存中信息的存储分布</h4><p>目前使用最普遍的编址单位是字节编址，这是为了适应非数值计算的需要</p>\n<h3 id=\"2-3-指令系统的设计和优化\"><a href=\"#2-3-指令系统的设计和优化\" class=\"headerlink\" title=\"2.3 指令系统的设计和优化\"></a>2.3 指令系统的设计和优化</h3><h4 id=\"2-3-1-指令系统设计的基本原则\"><a href=\"#2-3-1-指令系统设计的基本原则\" class=\"headerlink\" title=\"2.3.1 指令系统设计的基本原则\"></a>2.3.1 指令系统设计的基本原则</h4><ul>\n<li>指令系统是软、硬件的主要界面</li>\n<li>指令系统的设计主要包括<strong>指令的功能</strong>（操作类型、具体操作内容）和<strong>指令格式</strong>的设计.</li>\n<li>指令设计的步骤：<ul>\n<li><strong>根据应用</strong>，初拟出指令的分类和具体的指令；</li>\n<li>试编出用该指令系统设计的各种<strong>高级语言的编译程序</strong>；</li>\n<li><strong>大量测试</strong>程序进行<strong>模拟测试</strong>，看指令系统的操作码和寻址方式效能是否都比较高；</li>\n<li><strong>将程序中高频出现的指令串复合改成一条强功能新指令</strong>，即改用硬件方式实现；而将频度很低的指令的操作改成基本的指令组成的指令串来完成，即用软件方式实现；</li>\n</ul>\n</li>\n<li>系统设计人员希望：指令码密度适中，兼容性，适应性</li>\n<li>指令的组成：<ul>\n<li>一般的指令主要由两部分组成：<strong>操作码</strong>和<strong>地址码</strong></li>\n<li>操作码主要包括两部分内容：<ul>\n<li>操作种类：加、减、乘、除、数据传送、移位、转移、输入输出</li>\n<li>操作数描述<ul>\n<li>数据的类型：定点数、浮点数、复数、字符、字符串、逻辑数、向量</li>\n<li>进位制：2进制、10进制、16进制</li>\n<li>数据字长：字、半字、双字、字节</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>地址码通常包括三部分内容：<ul>\n<li>地址：直接地址、间接地址、立即数、寄存器编号、变址寄存器编号</li>\n<li>地址的附加信息：偏移量、块长度、跳距</li>\n<li>寻址方式：直接寻址、间接寻址、立即数寻址、变址寻址、相对寻址、寄存器寻址(可能)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指令格式的优化<ul>\n<li>指令=操作码+地址码</li>\n<li>指令格式的优化：如何用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短。</li>\n<li>主要目标：<ul>\n<li>节省程序的存储空间</li>\n<li>指令格式尽量规整，便于译码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>操作码的优化表示：<ul>\n<li>操作码的三种编码方法：<ul>\n<li>固定长度：规整性好，解码简单，空间大</li>\n<li>Huffman编码：空间小，规整性不好，解码复杂。</li>\n<li>扩展编码：折衷方案，由固定长操作码与Huffman编码法相结合形成</li>\n</ul>\n</li>\n<li>改进操作码编码方式能够节省程序存储空间</li>\n</ul>\n</li>\n<li>指令字格式的优化：<ul>\n<li>只有操作码的优化，没有在地址码和寻址方式上采取措施，程序的总位数还是难以减少。</li>\n<li>如果主存按位编址，则部分指令的读取需要两个周期，是机器速度明显下降。</li>\n</ul>\n</li>\n</ul>","categories":[{"name":"学习笔记","path":"api/categories/学习笔记.json"}],"tags":[{"name":"大学课程","path":"api/tags/大学课程.json"},{"name":"系统结构","path":"api/tags/系统结构.json"}]}