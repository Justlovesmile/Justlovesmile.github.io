{"title":"学习笔记 | 《算法导论》之从入门到放弃（3）","slug":"学习笔记-算法导论学习笔记3","date":"2019-10-11T13:12:48.000Z","updated":"2019-10-11T13:12:48.000Z","comments":true,"path":"api/articles/学习笔记-算法导论学习笔记3.json","excerpt":null,"covers":["https://s2.ax1x.com/2019/10/31/Ko9IoQ.md.png"],"content":"<p>算法导论打卡3，主要内容：堆排序</p>\n<h1 id=\"第六章-堆排序\"><a href=\"#第六章-堆排序\" class=\"headerlink\" title=\"第六章 堆排序\"></a>第六章 堆排序</h1><h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li>二叉堆是一个数组，它可以被看成一个近似的完全二叉树。树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。</li>\n<li>表示堆的数组A包括两个属性：A.length(通常)给出数组元素的个数，A.heap-size表示有多少个堆元素存储在该数组中。也就是说虽然A[1..A.length]可能都存有数据，但只有A[1..A.heap-size]中存放的是堆的有效元素，这里0≤A.heap-size≤A.length。树的根节点是A[1]，这样给定一个结点的下标i，我们很容易计算得到它的父结点，左孩子和右孩子的下标：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parent</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i//<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">left</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>*i</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">right</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>*i+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><img src=\"https://s2.ax1x.com/2019/10/31/Ko9IoQ.md.png\" alt=\"Ko9IoQ.md.png\"></li>\n<li>二叉堆可以分为两种形式：最大堆和最小堆。在这两种堆中，结点的值都要满足堆的性质。区别在于：<ul>\n<li>最大堆中，最大堆性质是指除了根以外的所有结点i都要满足：A[PARENT(i)]≥A[i]，即在任一子树中，该子树所包含的所有结点的值都不大于该子树根节点的值。</li>\n<li>最小堆中，最小堆性质是指除了根以外的所有结点i都要满足：A[PARENT(i)]≤A[i]</li>\n</ul>\n</li>\n<li>在堆排序算法中，我们使用最大堆。最小堆通常用于构造优先队列。</li>\n<li>如果把堆看成一棵树，我们定义一个堆中的结点的高度是该节点到叶结点最长简单路径上<code>边的数目</code>。既然一个包含n个元素的堆可以看作是一颗完全二叉树，那么该堆的高度是<code>O(lgn)</code></li>\n<li>堆结构上的一些基本操作的运行时间至多与树的高度成正比，即时间复杂度为O(lgn).</li>\n</ul>\n<h2 id=\"维护堆的性质\"><a href=\"#维护堆的性质\" class=\"headerlink\" title=\"维护堆的性质\"></a>维护堆的性质</h2><ul>\n<li>通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根结点的子树重新遵循最大堆的性质：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">A,i</span>):</span></span><br><span class=\"line\">    l,r=<span class=\"number\">2</span>*i,<span class=\"number\">2</span>*i+<span class=\"number\">1</span></span><br><span class=\"line\">    heap_size=<span class=\"built_in\">len</span>(A)-<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&lt;=heap_size <span class=\"keyword\">and</span> A[l]&gt;A[i]):</span><br><span class=\"line\">        largest=l</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        largest=i</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r&lt;=heap_size <span class=\"keyword\">and</span> A[r]&gt;A[largest]):</span><br><span class=\"line\">        largest=r</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(largest!=i):</span><br><span class=\"line\">        temp=A[i]</span><br><span class=\"line\">        A[i]=A[largest]</span><br><span class=\"line\">        A[largest]=temp</span><br><span class=\"line\">        max_heapify(A,largest)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于一个高为h的结点来说，max_heapify的时间复杂度是O(h)。</li>\n</ul>\n<h2 id=\"建堆\"><a href=\"#建堆\" class=\"headerlink\" title=\"建堆\"></a>建堆</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">\t<span class=\"comment\">#A[0]存储堆元数个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]//<span class=\"number\">2</span>+<span class=\"number\">1</span>)[::-<span class=\"number\">1</span>]:</span><br><span class=\"line\">        max_heapify(A,i)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>完整代码：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">A,i</span>):</span></span><br><span class=\"line\">    l,r=<span class=\"number\">2</span>*i,<span class=\"number\">2</span>*i+<span class=\"number\">1</span></span><br><span class=\"line\">    heap_size=A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&lt;=heap_size <span class=\"keyword\">and</span> A[l]&gt;A[i]):</span><br><span class=\"line\">        largest=l</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        largest=i</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r&lt;=heap_size <span class=\"keyword\">and</span> A[r]&gt;A[largest]):</span><br><span class=\"line\">        largest=r</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(largest!=i):</span><br><span class=\"line\">        temp=A[i]</span><br><span class=\"line\">        A[i]=A[largest]</span><br><span class=\"line\">        A[largest]=temp</span><br><span class=\"line\">        max_heapify(A,largest)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">\t<span class=\"comment\">#A[0]存储堆元数个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]//<span class=\"number\">2</span>+<span class=\"number\">1</span>)[::-<span class=\"number\">1</span>]:</span><br><span class=\"line\">        max_heapify(A,i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">\t<span class=\"comment\">#数组的第一个位置存储堆元素个数，并用于占位</span></span><br><span class=\"line\">    A=[<span class=\"number\">9</span>,<span class=\"number\">50</span>, <span class=\"number\">16</span>, <span class=\"number\">30</span>, <span class=\"number\">10</span>, <span class=\"number\">60</span>,  <span class=\"number\">90</span>,  <span class=\"number\">2</span>, <span class=\"number\">80</span>, <span class=\"number\">70</span>]</span><br><span class=\"line\">    build_max_heap(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A[i])</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"堆排序算法\"><a href=\"#堆排序算法\" class=\"headerlink\" title=\"堆排序算法\"></a>堆排序算法</h2><ul>\n<li>因为数组的最大元素总是在根结点A[1]中，通过把它与A[n]进行互换，我们可以把该元素放到正确的位置上(如从小到大排列)</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">A,i</span>):</span></span><br><span class=\"line\">    l,r=<span class=\"number\">2</span>*i,<span class=\"number\">2</span>*i+<span class=\"number\">1</span></span><br><span class=\"line\">    heap_size=A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&lt;=heap_size <span class=\"keyword\">and</span> A[l]&gt;A[i]):</span><br><span class=\"line\">        largest=l</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        largest=i</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r&lt;=heap_size <span class=\"keyword\">and</span> A[r]&gt;A[largest]):</span><br><span class=\"line\">        largest=r</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(largest!=i):</span><br><span class=\"line\">        temp=A[i]</span><br><span class=\"line\">        A[i]=A[largest]</span><br><span class=\"line\">        A[largest]=temp</span><br><span class=\"line\">        max_heapify(A,largest)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">\t<span class=\"comment\">#A[0]存储堆元数个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]//<span class=\"number\">2</span>+<span class=\"number\">1</span>)[::-<span class=\"number\">1</span>]:</span><br><span class=\"line\">        max_heapify(A,i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heapsort</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">\tbuild_max_heap(A)</span><br><span class=\"line\">\tn=A[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,n+<span class=\"number\">1</span>)[::-<span class=\"number\">1</span>]:</span><br><span class=\"line\">\t\ttemp=A[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\tA[<span class=\"number\">1</span>]=A[i]</span><br><span class=\"line\">\t\tA[i]=temp</span><br><span class=\"line\">\t\tA[<span class=\"number\">0</span>]-=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tmax_heapify(A,<span class=\"number\">1</span>)</span><br><span class=\"line\">\tA[<span class=\"number\">0</span>]=n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">\t<span class=\"comment\">#数组的第一个位置存储堆元素个数，并用于占位</span></span><br><span class=\"line\">    A=[<span class=\"number\">9</span>,<span class=\"number\">50</span>, <span class=\"number\">16</span>, <span class=\"number\">30</span>, <span class=\"number\">10</span>, <span class=\"number\">60</span>,  <span class=\"number\">90</span>,  <span class=\"number\">2</span>, <span class=\"number\">80</span>, <span class=\"number\">70</span>]</span><br><span class=\"line\">    heapsort(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A[i])</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>heapsort的时间复杂度是O(nlgn),因为每次调用build_max_heap的时间复杂度是O(n)，而n-1次调用max_heapify，每次的时间是O(lgn)。</li>\n</ul>\n<h2 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h2><ul>\n<li>优先队列是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个相关的值，称为关键字。</li>\n<li>一个最大优先队列支持以下操作：<ul>\n<li>insert(S,x)：把元素x插入集合S中。</li>\n<li>maximum(S)：返回S中具有最大关键字的元素。</li>\n<li>extract-max(S)：去掉并返回S中具有最大关键字的元素。</li>\n<li>increase-key(S,x,k)：将元素x的关键字值增加到k，这里假设k的值不小于x的原关键字值。</li>\n</ul>\n</li>\n<li>最小优先队列同理</li>\n<li>实现：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_maximum</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> A[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_extract_max</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">    heap_size=<span class=\"built_in\">len</span>(A)-<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap_size&lt;<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> IndexError(<span class=\"string\">&quot;heap underflow&quot;</span>)</span><br><span class=\"line\">    Max=A[<span class=\"number\">1</span>]</span><br><span class=\"line\">    A[<span class=\"number\">1</span>]=A[heap_size]</span><br><span class=\"line\">    heap_size-=<span class=\"number\">1</span></span><br><span class=\"line\">    max_heapify(A,<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Max</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_increase_key</span>(<span class=\"params\">A,i,key</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(key&lt;A[i]):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> Exception,<span class=\"string\">&quot;new key is small than current key&quot;</span></span><br><span class=\"line\">    A[i]=key</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&gt;<span class=\"number\">1</span> <span class=\"keyword\">and</span> A[parent[i]]&lt;A[i]):</span><br><span class=\"line\">        temp=A[i]</span><br><span class=\"line\">        A[i]=A[parent[i]]</span><br><span class=\"line\">        A[parent[i]]=temp</span><br><span class=\"line\">        i=parent[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heap_insert</span>(<span class=\"params\">A,key</span>):</span></span><br><span class=\"line\">    heap_size+=<span class=\"number\">1</span></span><br><span class=\"line\">    A[heap_size]=<span class=\"built_in\">float</span>(<span class=\"string\">&#x27;-inf&#x27;</span>)</span><br><span class=\"line\">    heap_increase_key(A,heap_size,key)</span><br></pre></td></tr></table></figure>","more":"<p>算法导论打卡3，主要内容：堆排序</p>\n<h1 id=\"第六章-堆排序\"><a href=\"#第六章-堆排序\" class=\"headerlink\" title=\"第六章 堆排序\"></a>第六章 堆排序</h1><h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li>二叉堆是一个数组，它可以被看成一个近似的完全二叉树。树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。</li>\n<li>表示堆的数组A包括两个属性：A.length(通常)给出数组元素的个数，A.heap-size表示有多少个堆元素存储在该数组中。也就是说虽然A[1..A.length]可能都存有数据，但只有A[1..A.heap-size]中存放的是堆的有效元素，这里0≤A.heap-size≤A.length。树的根节点是A[1]，这样给定一个结点的下标i，我们很容易计算得到它的父结点，左孩子和右孩子的下标：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parent</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i//<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">left</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>*i</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">right</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">2</span>*i+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><img src=\"https://s2.ax1x.com/2019/10/31/Ko9IoQ.md.png\" alt=\"Ko9IoQ.md.png\"></li>\n<li>二叉堆可以分为两种形式：最大堆和最小堆。在这两种堆中，结点的值都要满足堆的性质。区别在于：<ul>\n<li>最大堆中，最大堆性质是指除了根以外的所有结点i都要满足：A[PARENT(i)]≥A[i]，即在任一子树中，该子树所包含的所有结点的值都不大于该子树根节点的值。</li>\n<li>最小堆中，最小堆性质是指除了根以外的所有结点i都要满足：A[PARENT(i)]≤A[i]</li>\n</ul>\n</li>\n<li>在堆排序算法中，我们使用最大堆。最小堆通常用于构造优先队列。</li>\n<li>如果把堆看成一棵树，我们定义一个堆中的结点的高度是该节点到叶结点最长简单路径上<code>边的数目</code>。既然一个包含n个元素的堆可以看作是一颗完全二叉树，那么该堆的高度是<code>O(lgn)</code></li>\n<li>堆结构上的一些基本操作的运行时间至多与树的高度成正比，即时间复杂度为O(lgn).</li>\n</ul>\n<h2 id=\"维护堆的性质\"><a href=\"#维护堆的性质\" class=\"headerlink\" title=\"维护堆的性质\"></a>维护堆的性质</h2><ul>\n<li>通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根结点的子树重新遵循最大堆的性质：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">A,i</span>):</span></span><br><span class=\"line\">    l,r=<span class=\"number\">2</span>*i,<span class=\"number\">2</span>*i+<span class=\"number\">1</span></span><br><span class=\"line\">    heap_size=<span class=\"built_in\">len</span>(A)-<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&lt;=heap_size <span class=\"keyword\">and</span> A[l]&gt;A[i]):</span><br><span class=\"line\">        largest=l</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        largest=i</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r&lt;=heap_size <span class=\"keyword\">and</span> A[r]&gt;A[largest]):</span><br><span class=\"line\">        largest=r</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(largest!=i):</span><br><span class=\"line\">        temp=A[i]</span><br><span class=\"line\">        A[i]=A[largest]</span><br><span class=\"line\">        A[largest]=temp</span><br><span class=\"line\">        max_heapify(A,largest)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对于一个高为h的结点来说，max_heapify的时间复杂度是O(h)。</li>\n</ul>\n<h2 id=\"建堆\"><a href=\"#建堆\" class=\"headerlink\" title=\"建堆\"></a>建堆</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">\t<span class=\"comment\">#A[0]存储堆元数个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]//<span class=\"number\">2</span>+<span class=\"number\">1</span>)[::-<span class=\"number\">1</span>]:</span><br><span class=\"line\">        max_heapify(A,i)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>完整代码：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">A,i</span>):</span></span><br><span class=\"line\">    l,r=<span class=\"number\">2</span>*i,<span class=\"number\">2</span>*i+<span class=\"number\">1</span></span><br><span class=\"line\">    heap_size=A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&lt;=heap_size <span class=\"keyword\">and</span> A[l]&gt;A[i]):</span><br><span class=\"line\">        largest=l</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        largest=i</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r&lt;=heap_size <span class=\"keyword\">and</span> A[r]&gt;A[largest]):</span><br><span class=\"line\">        largest=r</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(largest!=i):</span><br><span class=\"line\">        temp=A[i]</span><br><span class=\"line\">        A[i]=A[largest]</span><br><span class=\"line\">        A[largest]=temp</span><br><span class=\"line\">        max_heapify(A,largest)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">\t<span class=\"comment\">#A[0]存储堆元数个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]//<span class=\"number\">2</span>+<span class=\"number\">1</span>)[::-<span class=\"number\">1</span>]:</span><br><span class=\"line\">        max_heapify(A,i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">\t<span class=\"comment\">#数组的第一个位置存储堆元素个数，并用于占位</span></span><br><span class=\"line\">    A=[<span class=\"number\">9</span>,<span class=\"number\">50</span>, <span class=\"number\">16</span>, <span class=\"number\">30</span>, <span class=\"number\">10</span>, <span class=\"number\">60</span>,  <span class=\"number\">90</span>,  <span class=\"number\">2</span>, <span class=\"number\">80</span>, <span class=\"number\">70</span>]</span><br><span class=\"line\">    build_max_heap(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A[i])</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"堆排序算法\"><a href=\"#堆排序算法\" class=\"headerlink\" title=\"堆排序算法\"></a>堆排序算法</h2><ul>\n<li>因为数组的最大元素总是在根结点A[1]中，通过把它与A[n]进行互换，我们可以把该元素放到正确的位置上(如从小到大排列)</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">A,i</span>):</span></span><br><span class=\"line\">    l,r=<span class=\"number\">2</span>*i,<span class=\"number\">2</span>*i+<span class=\"number\">1</span></span><br><span class=\"line\">    heap_size=A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&lt;=heap_size <span class=\"keyword\">and</span> A[l]&gt;A[i]):</span><br><span class=\"line\">        largest=l</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        largest=i</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r&lt;=heap_size <span class=\"keyword\">and</span> A[r]&gt;A[largest]):</span><br><span class=\"line\">        largest=r</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(largest!=i):</span><br><span class=\"line\">        temp=A[i]</span><br><span class=\"line\">        A[i]=A[largest]</span><br><span class=\"line\">        A[largest]=temp</span><br><span class=\"line\">        max_heapify(A,largest)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build_max_heap</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">\t<span class=\"comment\">#A[0]存储堆元数个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]//<span class=\"number\">2</span>+<span class=\"number\">1</span>)[::-<span class=\"number\">1</span>]:</span><br><span class=\"line\">        max_heapify(A,i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heapsort</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">\tbuild_max_heap(A)</span><br><span class=\"line\">\tn=A[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>,n+<span class=\"number\">1</span>)[::-<span class=\"number\">1</span>]:</span><br><span class=\"line\">\t\ttemp=A[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\tA[<span class=\"number\">1</span>]=A[i]</span><br><span class=\"line\">\t\tA[i]=temp</span><br><span class=\"line\">\t\tA[<span class=\"number\">0</span>]-=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tmax_heapify(A,<span class=\"number\">1</span>)</span><br><span class=\"line\">\tA[<span class=\"number\">0</span>]=n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">\t<span class=\"comment\">#数组的第一个位置存储堆元素个数，并用于占位</span></span><br><span class=\"line\">    A=[<span class=\"number\">9</span>,<span class=\"number\">50</span>, <span class=\"number\">16</span>, <span class=\"number\">30</span>, <span class=\"number\">10</span>, <span class=\"number\">60</span>,  <span class=\"number\">90</span>,  <span class=\"number\">2</span>, <span class=\"number\">80</span>, <span class=\"number\">70</span>]</span><br><span class=\"line\">    heapsort(A)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,A[<span class=\"number\">0</span>]+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A[i])</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>heapsort的时间复杂度是O(nlgn),因为每次调用build_max_heap的时间复杂度是O(n)，而n-1次调用max_heapify，每次的时间是O(lgn)。</li>\n</ul>\n<h2 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h2><ul>\n<li>优先队列是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个相关的值，称为关键字。</li>\n<li>一个最大优先队列支持以下操作：<ul>\n<li>insert(S,x)：把元素x插入集合S中。</li>\n<li>maximum(S)：返回S中具有最大关键字的元素。</li>\n<li>extract-max(S)：去掉并返回S中具有最大关键字的元素。</li>\n<li>increase-key(S,x,k)：将元素x的关键字值增加到k，这里假设k的值不小于x的原关键字值。</li>\n</ul>\n</li>\n<li>最小优先队列同理</li>\n<li>实现：</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_maximum</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> A[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_extract_max</span>(<span class=\"params\">A</span>):</span></span><br><span class=\"line\">    heap_size=<span class=\"built_in\">len</span>(A)-<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(heap_size&lt;<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> IndexError(<span class=\"string\">&quot;heap underflow&quot;</span>)</span><br><span class=\"line\">    Max=A[<span class=\"number\">1</span>]</span><br><span class=\"line\">    A[<span class=\"number\">1</span>]=A[heap_size]</span><br><span class=\"line\">    heap_size-=<span class=\"number\">1</span></span><br><span class=\"line\">    max_heapify(A,<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Max</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">heap_increase_key</span>(<span class=\"params\">A,i,key</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(key&lt;A[i]):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> Exception,<span class=\"string\">&quot;new key is small than current key&quot;</span></span><br><span class=\"line\">    A[i]=key</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&gt;<span class=\"number\">1</span> <span class=\"keyword\">and</span> A[parent[i]]&lt;A[i]):</span><br><span class=\"line\">        temp=A[i]</span><br><span class=\"line\">        A[i]=A[parent[i]]</span><br><span class=\"line\">        A[parent[i]]=temp</span><br><span class=\"line\">        i=parent[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">max_heap_insert</span>(<span class=\"params\">A,key</span>):</span></span><br><span class=\"line\">    heap_size+=<span class=\"number\">1</span></span><br><span class=\"line\">    A[heap_size]=<span class=\"built_in\">float</span>(<span class=\"string\">&#x27;-inf&#x27;</span>)</span><br><span class=\"line\">    heap_increase_key(A,heap_size,key)</span><br></pre></td></tr></table></figure>","categories":[{"name":"学习笔记","path":"api/categories/学习笔记.json"}],"tags":[{"name":"python","path":"api/tags/python.json"},{"name":"算法","path":"api/tags/算法.json"}]}