<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Justlovesmile&#39;s BLOG</title>
  <icon>https://www.gravatar.com/avatar/7637880d6fba1338ba97dd0c0ccfc1c8</icon>
  <subtitle>Writer(记录) &amp; Maker(创作) &amp; Developer(启发)</subtitle>
  <link href="https://blog.justlovesmile.top/atom.xml" rel="self"/>
  
  <link href="https://blog.justlovesmile.top/"/>
  <updated>2022-03-18T10:16:03.000Z</updated>
  <id>https://blog.justlovesmile.top/</id>
  
  <author>
    <name>Justlovesmile</name>
    <email>865717150@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习 | Detectron2使用指南</title>
    <link href="https://blog.justlovesmile.top/posts/589ec011.html"/>
    <id>https://blog.justlovesmile.top/posts/589ec011.html</id>
    <published>2022-03-18T10:16:03.000Z</published>
    <updated>2022-03-18T10:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Detectron2</code>是<code>Facebook AI Research</code>的检测和分割框架，其主要基于<code>PyTorch</code>实现，但具有更模块化设计，因此它是灵活且便于扩展的，具体简介可见<a href="https://github.com/facebookresearch/detectron2">Github库</a>和<a href="https://ai.facebook.com/blog/-detectron2-a-pytorch-based-modular-object-detection-library-/">Meta AI Blog Post</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@misc&#123;wu2019detectron2,</span><br><span class="line">  author =       &#123;Yuxin Wu and Alexander Kirillov and Francisco Massa and</span><br><span class="line"> Wan-Yen Lo and Ross Girshick&#125;,</span><br><span class="line">  title =        &#123;Detectron2&#125;,</span><br><span class="line">  howpublished = &#123;\url&#123;https://github.com/facebookresearch/detectron2&#125;&#125;,</span><br><span class="line">  year =         &#123;2019&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-Detectron2安装"><a href="#1-Detectron2安装" class="headerlink" title="1. Detectron2安装"></a>1. Detectron2安装</h1><blockquote><p>首先官方要求的环境条件如下：</p><ul><li>Linux or macOS with Python ≥ 3.6</li><li>PyTorch ≥ 1.8 and <a href="https://github.com/pytorch/vision/">torchvision</a> that matches the PyTorch installation. Install them together at <a href="https://pytorch.org/">pytorch.org</a> to make sure of this</li><li>OpenCV is optional but needed by demo and visualization</li><li> gcc &amp; g++ ≥ 5.4 are required</li><li><a href="https://ninja-build.org/">ninja</a> is optional but recommended for faster build</li><li>Cuda &amp; Cudnn</li></ul></blockquote><p>因此想要安装并使用Detectron2，需要有：</p><ul><li>环境：Python，Cuda，Cudnn，gcc&amp;g++</li><li>Python包：pytorch，torchvision，python-opencv</li><li>推荐：Anaconda</li></ul><h2 id="1-1-Linux"><a href="#1-1-Linux" class="headerlink" title="1.1 Linux"></a>1.1 Linux</h2><p>Linux安装直接按照<a href="https://detectron2.readthedocs.io/en/latest/tutorials/install.html">官方文档</a>的安装步骤即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install &#x27;git+https://github.com/facebookresearch/detectron2.git&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> (add --user <span class="keyword">if</span> you don<span class="string">&#x27;t have permission)</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Or, to install it from a local clone:</span></span></span><br><span class="line">git clone https://github.com/facebookresearch/detectron2.git</span><br><span class="line">python -m pip install -e detectron2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> On macOS, you may need to prepend the above commands with a few environment variables:</span></span></span><br><span class="line">CC=clang CXX=clang++ ARCHFLAGS=&quot;-arch x86_64&quot; python -m pip install ...</span><br></pre></td></tr></table></figure><p>如果以上安装失败，可以尝试直接安装预编译文件，同样在<a href="https://detectron2.readthedocs.io/en/latest/tutorials/install.html">官方文档有提供</a></p><h2 id="1-2-Windows"><a href="#1-2-Windows" class="headerlink" title="1.2 Windows"></a>1.2 Windows</h2><h3 id="1-2-1-VS2019-C-编译环境"><a href="#1-2-1-VS2019-C-编译环境" class="headerlink" title="1.2.1 VS2019 C++编译环境"></a>1.2.1 VS2019 C++编译环境</h3><p>Windows想要安装Detectron2，需要提前安装<strong>Microsoft Visual Studio 2019</strong>，然后选择安装“<strong>使用C++的桌面开发</strong>”，其他均默认即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20220316165420.png"></p><h3 id="1-2-2-pycocotools"><a href="#1-2-2-pycocotools" class="headerlink" title="1.2.2 pycocotools"></a>1.2.2 pycocotools</h3><p>安装方法一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/philferriere/cocoapi.git#subdirectory=PythonAPI</span><br></pre></td></tr></table></figure><p>安装方法二：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pdollar/coco.git</span><br><span class="line"></span><br><span class="line">cd coco/PythonAPI</span><br><span class="line"></span><br><span class="line">python setup.py build_ext --inplace</span><br><span class="line">python setup.py build_ext install</span><br></pre></td></tr></table></figure><p>如果安装失败（一般都会失败），尝试下载“Microsoft Visual C++ Build Tools.exe” ，官网链接：<a href="https://go.microsoft.com/fwlink/?LinkId=691126">https://go.microsoft.com/fwlink/?LinkId=691126</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20220316171845.png"></p><p>如果在安装的过程中因网络问题失败，可以使用离线包，网盘链接：<a href="https://pan.baidu.com/s/1GeJ2c8MxnZP8lAYAwQACzg">https://pan.baidu.com/s/1GeJ2c8MxnZP8lAYAwQACzg</a>，提取码<code>1114</code>。</p><h3 id="1-2-3-Detectron2"><a href="#1-2-3-Detectron2" class="headerlink" title="1.2.3 Detectron2"></a>1.2.3 Detectron2</h3><p>使用Conda（推荐！之前有过同一个包使用conda安装的好用而pip安装的不好用的经历）或者pip下载包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install cython</span><br><span class="line">conda install ninja</span><br><span class="line">conda install pywin32</span><br></pre></td></tr></table></figure><p>下载Detectron2到本地:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/facebookresearch/detectron2.git</span><br><span class="line">python -m pip install -e detectron2</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebookresearch/detectron2.git</span><br><span class="line">cd detectron2 </span><br><span class="line">python setup.py build develop</span><br></pre></td></tr></table></figure><h1 id="2-自定义数据集"><a href="#2-自定义数据集" class="headerlink" title="2.  自定义数据集"></a>2.  自定义数据集</h1><h2 id="2-1-关于COCO格式"><a href="#2-1-关于COCO格式" class="headerlink" title="2.1 关于COCO格式"></a>2.1 关于COCO格式</h2><p>Detectron2已经写好了COCO格式的数据集图像和标注的读取，因此通常减少工作量，可以自己写一个脚本将<strong>数据集转为COCO格式</strong>的标注。</p><p>COCO的文件目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-coco/</span><br><span class="line">    |-train2017/</span><br><span class="line">    |-1.jpg</span><br><span class="line">    |-2.jpg</span><br><span class="line">    |-val2017/</span><br><span class="line">    |-3.jpg</span><br><span class="line">    |-4.jpg</span><br><span class="line">    |-test2017/</span><br><span class="line">    |-5.jpg</span><br><span class="line">    |-6.jpg</span><br><span class="line">    |-annotations/</span><br><span class="line">    |-instances_train2017.json</span><br><span class="line">    |-instances_val2017.json</span><br><span class="line">    |-*.json</span><br></pre></td></tr></table></figure><p>其中标注文件（json）最为重要，其格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;info&quot;</span>: &#123;<span class="comment">//数据集信息，对于训练而言不重要</span></span><br><span class="line"><span class="attr">&quot;year&quot;</span>: int, </span><br><span class="line"><span class="attr">&quot;version&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;description&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;contributor&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;url&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;date_created&quot;</span>: datetime,</span><br><span class="line">&#125;, </span><br><span class="line"><span class="attr">&quot;images&quot;</span>: [&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: int, <span class="comment">//必要</span></span><br><span class="line"><span class="attr">&quot;width&quot;</span>: int, <span class="comment">//必要</span></span><br><span class="line"><span class="attr">&quot;height&quot;</span>: int, <span class="comment">//必要</span></span><br><span class="line"><span class="attr">&quot;file_name&quot;</span>: str, <span class="comment">//必要</span></span><br><span class="line"><span class="attr">&quot;license&quot;</span>: int,</span><br><span class="line"><span class="attr">&quot;flickr_url&quot;</span>: str,</span><br><span class="line"><span class="attr">&quot;coco_url&quot;</span>: str,</span><br><span class="line"><span class="attr">&quot;date_captured&quot;</span>: datetime, </span><br><span class="line">&#125;,&#123;...&#125;], <span class="comment">//列表</span></span><br><span class="line"><span class="attr">&quot;annotations&quot;</span>: [&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: int, <span class="comment">//标注id</span></span><br><span class="line"><span class="attr">&quot;image_id&quot;</span>: int, <span class="comment">//所属图像id</span></span><br><span class="line"><span class="attr">&quot;category_id&quot;</span>: int, <span class="comment">//类别id</span></span><br><span class="line"><span class="attr">&quot;segmentation&quot;</span>: RLE or [polygon], <span class="comment">//图像分割标注</span></span><br><span class="line"><span class="attr">&quot;area&quot;</span>: float, <span class="comment">//区域面积</span></span><br><span class="line"><span class="attr">&quot;bbox&quot;</span>: [x,y,width,height], <span class="comment">//目标框左上角坐标以及宽高</span></span><br><span class="line"><span class="attr">&quot;iscrowd&quot;</span>: <span class="number">0</span> or <span class="number">1</span>, <span class="comment">//是否密集</span></span><br><span class="line">&#125;,&#123;...&#125;], <span class="comment">//列表</span></span><br><span class="line"><span class="attr">&quot;categories&quot;</span>: [&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: int, <span class="comment">//类别序号</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span>: str, <span class="comment">//类别名称</span></span><br><span class="line"><span class="attr">&quot;supercategory&quot;</span>: str, <span class="comment">//父类别</span></span><br><span class="line">&#125;], <span class="comment">//列表</span></span><br><span class="line"><span class="attr">&quot;licenses&quot;</span>: [&#123;<span class="comment">//对于训练，不重要</span></span><br><span class="line"><span class="attr">&quot;id&quot;</span>: int, </span><br><span class="line"><span class="attr">&quot;name&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;url&quot;</span>: str,</span><br><span class="line">&#125;], <span class="comment">//列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-注册数据集"><a href="#2-2-注册数据集" class="headerlink" title="2.2 注册数据集"></a>2.2 注册数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> detectron2.data <span class="keyword">import</span> DatasetCatalog, MetadataCatalog</span><br><span class="line"><span class="keyword">from</span> detectron2.data.datasets.register_coco <span class="keyword">import</span> register_coco_instances</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DATA_ALL_CATEGORIES = [</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;airplane&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ship&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;storage tank&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;baseball diamond&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tennis court&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;basketball court&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ground track field&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;harbor&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;bridge&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;vehicle&#x27;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">DATA_SPLITS = &#123;&#125;</span><br><span class="line">DATA_SPLITS[<span class="string">&#x27;nwpu_all&#x27;</span>] = &#123;</span><br><span class="line"><span class="string">&#x27;nwpu_all_trainval&#x27;</span>: (</span><br><span class="line">os.path.join(DATA_ROOT,<span class="string">&quot;positive image set&quot;</span>),</span><br><span class="line">os.path.join(DATA_ROOT,<span class="string">&#x27;trainval.json&#x27;</span>)</span><br><span class="line">),</span><br><span class="line"><span class="string">&#x27;nwpu_all_test&#x27;</span>: (</span><br><span class="line">os.path.join(DATA_ROOT,<span class="string">&quot;positive image set&quot;</span>),</span><br><span class="line">os.path.join(DATA_ROOT,<span class="string">&#x27;test.json&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_data_all_instance_meta</span>():</span></span><br><span class="line">    thing_ids = [k[<span class="string">&quot;id&quot;</span>] <span class="keyword">for</span> k <span class="keyword">in</span> DATA_ALL_CATEGORIES]</span><br><span class="line">    thing_dataset_id_to_contiguous_id = &#123;k: i <span class="keyword">for</span> i, k <span class="keyword">in</span> <span class="built_in">enumerate</span>(thing_ids)&#125;</span><br><span class="line">    thing_classes = [k[<span class="string">&quot;name&quot;</span>] <span class="keyword">for</span> k <span class="keyword">in</span> DATA_ALL_CATEGORIES]</span><br><span class="line">    ret = &#123;</span><br><span class="line">        <span class="string">&quot;thing_dataset&quot;</span>: thing_dataset_id_to_contiguous_id,</span><br><span class="line">        <span class="string">&quot;thing_classes&quot;</span>: thing_classes,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_builtin_metadata</span>(<span class="params">dataset_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> dataset_name == <span class="string">&quot;nwpu_all&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> _get_data_instance_meta(DATA_ALL_CATEGORIES)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_all</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">for</span> dataset_name, splits_per_dataset <span class="keyword">in</span> DATA_SPLITS.items():</span><br><span class="line">        <span class="keyword">for</span> key, (image_root, json_file) <span class="keyword">in</span> splits_per_dataset.items():</span><br><span class="line">            <span class="keyword">assert</span> os.path.exists(os.path.join(root, json_file))</span><br><span class="line">            register_coco_instances(</span><br><span class="line">                key,</span><br><span class="line">                _get_builtin_metadata(dataset_name),</span><br><span class="line">                os.path.join(root, json_file) <span class="keyword">if</span> <span class="string">&quot;://&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> json_file <span class="keyword">else</span> json_file,</span><br><span class="line">                os.path.join(root, image_root),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">DATA_ROOT = <span class="string">&quot;D:/GISP/XIEMINGJIE/Code/Detection/dataset/NWPU VHR-10 dataset/&quot;</span></span><br><span class="line"></span><br><span class="line">register_all(DATA_ROOT)</span><br></pre></td></tr></table></figure><p>此时已完成<code>nwpu_all_trainval</code>以及<code>nwpu_all_test</code>数据集的注册，可以通过代码查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(DatasetCatalog.get(<span class="string">&quot;nwpu_all_trainval&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(DatasetCatalog.get(<span class="string">&quot;nwpu_all_test&quot;</span>))</span><br></pre></td></tr></table></figure><p>当然，如果不想要使用COCO格式数据集也可以自定义注册函数，可以参考<code>register_coco_instances</code>的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_coco_instances</span>(<span class="params">name, metadata, json_file, image_root</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        name (str): the name that identifies a dataset, e.g. &quot;coco_2014_train&quot;.</span></span><br><span class="line"><span class="string">        metadata (dict): extra metadata associated with this dataset.  You can</span></span><br><span class="line"><span class="string">            leave it as an empty dict.</span></span><br><span class="line"><span class="string">        json_file (str): path to the json instance annotation file.</span></span><br><span class="line"><span class="string">        image_root (str or path-like): directory which contains all the images.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(name, <span class="built_in">str</span>), name</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(json_file, (<span class="built_in">str</span>, os.PathLike)), json_file</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(image_root, (<span class="built_in">str</span>, os.PathLike)), image_root</span><br><span class="line">    <span class="comment"># 1. register a function which returns dicts</span></span><br><span class="line">    DatasetCatalog.register(name, <span class="keyword">lambda</span>: load_coco_json(json_file, image_root, name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. Optionally, add metadata about this dataset,</span></span><br><span class="line">    <span class="comment"># since they might be useful in evaluation, visualization or logging</span></span><br><span class="line">    MetadataCatalog.get(name).<span class="built_in">set</span>(</span><br><span class="line">        json_file=json_file, image_root=image_root, evaluator_type=<span class="string">&quot;coco&quot;</span>, **metadata</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>其中<code>load_coco_json</code>函数的功能是读取数据集标注文件，并以固定的形式返回，详细可见<a href="https://detectron2.readthedocs.io/en/latest/tutorials/datasets.html#register-a-dataset">官网</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load_coco_json返回的是一个列表</span></span><br><span class="line"><span class="comment"># 返回格式如下：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_coco_json</span>(<span class="params">json_file, image_root, dataset_name=<span class="literal">None</span>, extra_annotation_keys=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="comment"># read and do something</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># generate dataset_dicts like: ↓</span></span><br><span class="line">    dataset_dicts = [&#123;<span class="string">&#x27;file_name&#x27;</span>: <span class="string">&#x27;...\\images\\001.jpg&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">939</span>, <span class="string">&#x27;width&#x27;</span>: <span class="number">1356</span>, <span class="string">&#x27;image_id&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;annotations&#x27;</span>: [&#123;<span class="string">&#x27;iscrowd&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;bbox&#x27;</span>: [<span class="number">903</span>, <span class="number">57</span>, <span class="number">129</span>, <span class="number">123</span>], <span class="string">&#x27;category_id&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;bbox_mode&#x27;</span>: &lt;BoxMode.XYWH_ABS: <span class="number">1</span>&gt;&#125;]&#125;, &#123;...&#125;]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dataset_dicts</span><br></pre></td></tr></table></figure><h2 id="2-3-可视化工具"><a href="#2-3-可视化工具" class="headerlink" title="2.3 可视化工具"></a>2.3 可视化工具</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> detectron2.data <span class="keyword">import</span> MetadataCatalog</span><br><span class="line"><span class="keyword">from</span> detectron2.data <span class="keyword">import</span> detection_utils <span class="keyword">as</span> utils</span><br><span class="line"><span class="keyword">from</span> detectron2.utils.visualizer <span class="keyword">import</span> Visualizer</span><br><span class="line"></span><br><span class="line">datasets_dicts = DatasetCatalog.get(<span class="string">&quot;nwpu_all_trainval_1shot&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> random.sample(datasets_dicts, <span class="number">1</span>):</span><br><span class="line">    img = utils.read_image(data[<span class="string">&quot;file_name&quot;</span>])</span><br><span class="line">    visual = Visualizer(img, metadata=MetadataCatalog.get(<span class="string">&quot;nwpu_all_trainval&quot;</span>),scale=<span class="number">0.5</span>)</span><br><span class="line">    vis = visual.draw_dataset_dict(data)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;window&quot;</span>, vis.get_image()[:, :, ::-<span class="number">1</span>])</span><br><span class="line">    cv2.waitKey()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20220316211311.png"></p><h2 id="2-4-自定义数据增强"><a href="#2-4-自定义数据增强" class="headerlink" title="2.4 自定义数据增强"></a>2.4 自定义数据增强</h2><p>在注册了数据集之后就可以用<code>detectron2.data.build_detection_train_loader</code>和<code>detectron2.data.build_detection_test_loader</code>构建<code>Dataloader</code>，即数据集的加载方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.config <span class="keyword">import</span> get_cfg</span><br><span class="line"><span class="keyword">import</span> detectron2.data.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> detectron2.model_zoo <span class="keyword">import</span> model_zoo</span><br><span class="line"><span class="keyword">from</span> detectron2.data <span class="keyword">import</span> build_detection_train_loader</span><br><span class="line"><span class="keyword">from</span> detectron2.data <span class="keyword">import</span> DatasetMapper   <span class="comment"># the default mapper</span></span><br><span class="line"></span><br><span class="line">cfg = get_cfg()</span><br><span class="line">cfg.merge_from_file(model_zoo.get_config_file(<span class="string">&quot;COCO-Detection/retinanet_R_50_FPN_1x.yaml&quot;</span>))</span><br><span class="line">cfg.DATASETS.TRAIN = (<span class="string">&quot;nwpu_all_trainval&quot;</span>,)</span><br><span class="line"></span><br><span class="line">mapper = DatasetMapper(cfg,is_train=<span class="literal">True</span>,augmentations=[T.Resize((<span class="number">800</span>, <span class="number">800</span>))])</span><br><span class="line">train_loader = build_detection_train_loader(cfg,mapper=mapper)</span><br></pre></td></tr></table></figure><p><code>build_detection_train_loader()</code>的参数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">build_detection_train_loader(</span><br><span class="line">    dataset,</span><br><span class="line">    *,</span><br><span class="line">    mapper,</span><br><span class="line">    sampler=<span class="literal">None</span>,</span><br><span class="line">    total_batch_size,</span><br><span class="line">    aspect_ratio_grouping=<span class="literal">True</span>,</span><br><span class="line">    num_workers=<span class="number">0</span>,</span><br><span class="line">    collate_fn=<span class="literal">None</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中<code>mapper</code>对应的就是数据增强部分，默认为<code>detectron2.data.DatasetMapper</code>，<code>sampler</code>对应的采样策略部分，通常只需要关注<code>mapper</code>即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatasetMapper</span>:</span></span><br><span class="line"><span class="meta">    @configurable</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,is_train: <span class="built_in">bool</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_config</span>(<span class="params">cls, cfg, is_train: <span class="built_in">bool</span> = <span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_transform_annotations</span>(<span class="params">self, dataset_dict, transforms, image_shape</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, dataset_dict</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> dataset_dict</span><br></pre></td></tr></table></figure><p>官方给的自定义简化DataMapper：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.data <span class="keyword">import</span> detection_utils <span class="keyword">as</span> utils</span><br><span class="line"><span class="keyword">import</span> detectron2.data.transforms <span class="keyword">as</span> T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapper</span>(<span class="params">dataset_dict</span>):</span></span><br><span class="line">    dataset_dict = copy.deepcopy(dataset_dict)  <span class="comment"># it will be modified by code below</span></span><br><span class="line">    <span class="comment"># can use other ways to read image</span></span><br><span class="line">    image = utils.read_image(dataset_dict[<span class="string">&quot;file_name&quot;</span>], <span class="built_in">format</span>=<span class="string">&quot;BGR&quot;</span>)</span><br><span class="line">    <span class="comment"># &quot;Data Augmentation&quot;</span></span><br><span class="line">    auginput = T.AugInput(image)</span><br><span class="line">    transform = T.Resize((<span class="number">800</span>, <span class="number">800</span>))(auginput)</span><br><span class="line">    image = torch.from_numpy(auginput.image.transpose(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    annos = [</span><br><span class="line">        utils.transform_instance_annotations(annotation, [transform], image.shape[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">for</span> annotation <span class="keyword">in</span> dataset_dict.pop(<span class="string">&quot;annotations&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="comment"># create the format that the model expects</span></span><br><span class="line">       <span class="string">&quot;image&quot;</span>: image,</span><br><span class="line">       <span class="string">&quot;instances&quot;</span>: utils.annotations_to_instances(annos, image.shape[<span class="number">1</span>:])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">dataloader = build_detection_train_loader(cfg, mapper=mapper)</span><br></pre></td></tr></table></figure><p>因此自定义的数据增强需要满足，输入为<code>dataset_dict</code>，输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;images&quot;</span>: image_tensor,</span><br><span class="line"> <span class="string">&quot;instances&quot;</span>: utils.annotations_to_instances =&gt; Instances类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-自定义模型"><a href="#3-自定义模型" class="headerlink" title="3. 自定义模型"></a>3. 自定义模型</h1><p>Detectron2的模型是分模块的，它将目标检测模型拆分为了4个核心模块：<code>backbone</code>，<code>proposal_generator</code>，<code>roi_heads</code>以及<code>meta_arch</code>。</p><h2 id="3-1-特征提取网络（backbone）"><a href="#3-1-特征提取网络（backbone）" class="headerlink" title="3.1 特征提取网络（backbone）"></a>3.1 特征提取网络（backbone）</h2><p>在<code>detectron2.modeling.backbone</code>路径下可以看到，目前只有<code>ResNet</code>、<code>FPN</code>和<code>RegNet</code></p><p>可直接使用的<code>backbone</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build_resnet_backbone</span><br><span class="line">build_resnet_fpn_backbone</span><br><span class="line">build_retinanet_resnet_fpn_backbone</span><br></pre></td></tr></table></figure><p>官方的自定义<code>backbone</code>的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.modeling <span class="keyword">import</span> BACKBONE_REGISTRY, Backbone, ShapeSpec</span><br><span class="line"></span><br><span class="line"><span class="meta">@BACKBONE_REGISTRY.register()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyBackbone</span>(<span class="params">Backbone</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cfg, input_shape</span>):</span></span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="comment"># create your own backbone</span></span><br><span class="line">    self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">16</span>, padding=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, image</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;conv1&quot;</span>: self.conv1(image)&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output_shape</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;conv1&quot;</span>: ShapeSpec(channels=<span class="number">64</span>, stride=<span class="number">16</span>)&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-候选框生成器（proposal-generator）"><a href="#3-2-候选框生成器（proposal-generator）" class="headerlink" title="3.2 候选框生成器（proposal_generator）"></a>3.2 候选框生成器（proposal_generator）</h2><p>同样可以自定义注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PROPOSAL_GENERATOR_REGISTRY.register()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyRPN</span>(<span class="params">RPN</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args, **kwargs</span>):</span></span><br><span class="line"><span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RPN_HEAD_REGISTRY.register()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyRPNHead</span>(<span class="params">StandardRPNHead</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args, **kwargs</span>):</span></span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="3-3-检测器（roi-heads）"><a href="#3-3-检测器（roi-heads）" class="headerlink" title="3.3 检测器（roi_heads）"></a>3.3 检测器（roi_heads）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ROI_MASK_HEAD_REGISTRY.register()</span></span><br><span class="line"><span class="meta">@ROI_KEYPOINT_HEAD_REGISTRY.register()</span></span><br><span class="line"><span class="meta">@ROI_HEADS_REGISTRY.register()</span></span><br><span class="line"><span class="meta">@ROI_BOX_HEAD_REGISTRY.register()</span></span><br></pre></td></tr></table></figure><h2 id="3-4-模型框架（meta-arch）"><a href="#3-4-模型框架（meta-arch）" class="headerlink" title="3.4 模型框架（meta_arch）"></a>3.4 模型框架（meta_arch）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@META_ARCH_REGISTRY.register()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"><span class="meta">    @configurable</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_config</span>(<span class="params">cls, cfg</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_training</span>(<span class="params">self,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loss</span>(<span class="params">self,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @torch.no_grad()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">label_anchors</span>(<span class="params">self,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_inference</span>(<span class="params">self,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inference_single_image</span>(<span class="params">self,*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>具体可参考官方复现的<a href="https://github.com/facebookresearch/detectron2/tree/main/projects">projects</a></p><h1 id="4-模型训练"><a href="#4-模型训练" class="headerlink" title="4. 模型训练"></a>4. 模型训练</h1><h2 id="4-1-默认训练"><a href="#4-1-默认训练" class="headerlink" title="4.1 默认训练"></a>4.1 默认训练</h2><p>一般而言，我们可以继承使用默认的目标检测任务训练器<code>DefalutTrainer</code>，而<code>DefalutTrainer</code>又是继承自<code>TrainerBase</code>，<code>TrainerBase</code>中又使用到了<code>HookBase</code>。我的理解是<code>HookBase</code>和<code>TrainerBase</code>是将一个训练过程抽象并拆分成阶段步骤的过程，先看<code>HookBase</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookBase</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before_train</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Called before the first iteration.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after_train</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Called after the last iteration.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Called before each iteration.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Called after each iteration.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">state_dict</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>对于训练而言，它将一个完整的训练拆分成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainerBase</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._hooks: <span class="type">List</span>[HookBase] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_hooks</span>(<span class="params">self, hooks: <span class="type">List</span>[<span class="type">Optional</span>[HookBase]]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        hooks = [h <span class="keyword">for</span> h <span class="keyword">in</span> hooks <span class="keyword">if</span> h <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> hooks:</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">isinstance</span>(h, HookBase)</span><br><span class="line">            h.trainer = weakref.proxy(self)</span><br><span class="line">        self._hooks.extend(hooks)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self, start_iter: <span class="built_in">int</span>, max_iter: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.<span class="built_in">iter</span> = self.start_iter = start_iter</span><br><span class="line">        self.max_iter = max_iter</span><br><span class="line">        <span class="keyword">with</span> EventStorage(start_iter) <span class="keyword">as</span> self.storage:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.before_train()</span><br><span class="line">                <span class="keyword">for</span> self.<span class="built_in">iter</span> <span class="keyword">in</span> <span class="built_in">range</span>(start_iter, max_iter):</span><br><span class="line">                    self.before_step()</span><br><span class="line">                    self.run_step()</span><br><span class="line">                    self.after_step()</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.after_train()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before_train</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> self._hooks:</span><br><span class="line">            h.before_train()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after_train</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.storage.<span class="built_in">iter</span> = self.<span class="built_in">iter</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> self._hooks:</span><br><span class="line">            h.after_train()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.storage.<span class="built_in">iter</span> = self.<span class="built_in">iter</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> self._hooks:</span><br><span class="line">            h.before_step()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> self._hooks:</span><br><span class="line">            h.after_step()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">state_dict</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_state_dict</span>(<span class="params">self, state_dict</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>简化一点，它将一个训练过程抽象成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hook.before_train()</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">iter</span> <span class="keyword">in</span> <span class="built_in">range</span>(start_iter, max_iter):</span><br><span class="line">    hook.before_step()</span><br><span class="line">    trainer.run_step()</span><br><span class="line">    hook.after_step()</span><br><span class="line"><span class="built_in">iter</span> += <span class="number">1</span></span><br><span class="line">hook.after_train()</span><br></pre></td></tr></table></figure><p>具体到目标检测任务，<code>DefaultTrainer</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultTrainer</span>(<span class="params">TrainerBase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cfg</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_hooks</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_writers</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">cls, cfg, model, evaluators=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="comment"># a lot of</span></span><br><span class="line">    <span class="comment"># def ...(...):</span></span><br><span class="line">    <span class="comment">#     .....</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_train_loader</span>(<span class="params">cls, cfg</span>):</span></span><br><span class="line">        <span class="keyword">return</span> build_detection_train_loader(cfg)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_test_loader</span>(<span class="params">cls, cfg, dataset_name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> build_detection_test_loader(cfg, dataset_name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_evaluator</span>(<span class="params">cls, cfg, dataset_name</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="4-2-自定义训练"><a href="#4-2-自定义训练" class="headerlink" title="4.2 自定义训练"></a>4.2 自定义训练</h2><p>由于Detectron2已经将训练过程模块化，因此只需要修改对应模块即可，而一般而言，我们只需要修改数据加载和<code>evaluate</code>部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.engine <span class="keyword">import</span> DefaultTrainer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trainer</span>(<span class="params">DefaultTrainer</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_evaluator</span>(<span class="params">cls, cfg, dataset_name, output_folder=<span class="literal">None</span></span>):</span></span><br><span class="line">        evaluator_list = []</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> DatasetEvaluators(evaluator_list)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_test_loader</span>(<span class="params">cls, cfg, dataset_name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> build_detection_test_loader(cfg, dataset_name, mapper=my_mapper(cfg,<span class="string">&quot;test&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_train_loader</span>(<span class="params">cls, cfg</span>):</span></span><br><span class="line">        <span class="keyword">return</span> build_detection_train_loader(cfg, mapper=my_mapper(cfg, <span class="string">&quot;train&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="4-3-完整训练流程"><a href="#4-3-完整训练流程" class="headerlink" title="4.3 完整训练流程"></a>4.3 完整训练流程</h2><p>参考<code>tools/train_net.py</code>或者<code>tools/plain_train_net.py</code>，已经写的非常详细了👍，注意别忘了导入自己写好的注册数据集以及注册模型的文件，只要导入了就会自动注册，就可以在配置文件中使用。</p><h1 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5. 配置文件"></a>5. 配置文件</h1><p>参考<code>configs</code>文件夹下的<code>yaml</code>文件格式，，可以通过<code>__BASE__</code>继承基础配置文件，还可以直接覆盖之前的配置，如<code>retinanet_R_50_FPN_3x.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_BASE_:</span> <span class="string">&quot;../Base-RetinaNet.yaml&quot;</span></span><br><span class="line"><span class="attr">MODEL:</span></span><br><span class="line">  <span class="attr">WEIGHTS:</span> <span class="string">&quot;detectron2://ImageNetPretrained/MSRA/R-50.pkl&quot;</span></span><br><span class="line">  <span class="attr">RESNETS:</span></span><br><span class="line">    <span class="attr">DEPTH:</span> <span class="number">50</span></span><br><span class="line"><span class="attr">SOLVER:</span></span><br><span class="line">  <span class="attr">STEPS:</span> <span class="string">(210000,</span> <span class="number">250000</span><span class="string">)</span></span><br><span class="line">  <span class="attr">MAX_ITER:</span> <span class="number">270000</span></span><br></pre></td></tr></table></figure><p>查看全部配置项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.config <span class="keyword">import</span> get_cfg</span><br><span class="line">cfg = get_cfg()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cfg)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">print</span>(cfg.dump())</span><br></pre></td></tr></table></figure><p>在python文件中修改配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cfg.SOLVER.BASE_LR = <span class="number">0.001</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">cfg.merge_from_list([<span class="string">&quot;SOLVER.BASE_LR&quot;</span>, <span class="string">&quot;0.001&quot;</span>])</span><br></pre></td></tr></table></figure><p>合并多个文件中的配置项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfg.merge_from_file(<span class="string">&quot;my_cfg.yaml&quot;</span>)</span><br></pre></td></tr></table></figure><p>由于配置项本质上还是转换成了字典类型，因此可以直接从python文件导入配置，并且也提供了python格式的配置文件该怎么进行训练的示例，参考<code>tools/lazyconfig_train_net.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.py</span></span><br><span class="line">NEW_MODEL = <span class="built_in">dict</span>(NUM=<span class="number">1</span>,SIZE=<span class="built_in">dict</span>(W=<span class="number">2</span>,H=<span class="number">3</span>))</span><br><span class="line">NEW_OPT = <span class="built_in">dict</span>(NAME=<span class="string">&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line"><span class="keyword">from</span> detectron2.config <span class="keyword">import</span> LazyConfig</span><br><span class="line">cfg = LazyConfig.load(<span class="string">&quot;config.py&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> cfg.NEW_MODEL.SIZE.W==<span class="number">2</span></span><br><span class="line"><span class="comment"># cfg = LazyConfig.load(args.config_file)</span></span><br><span class="line"><span class="comment"># cfg = LazyConfig.apply_overrides(cfg, args.opts)</span></span><br></pre></td></tr></table></figure><p>并且Detectron2还提供了一个帮助创建配置字典的函数，<code>LazyCall</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> detectron2.config <span class="keyword">import</span> LazyCall <span class="keyword">as</span> L</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.backbone <span class="keyword">import</span> RegNet</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.backbone.regnet <span class="keyword">import</span> SimpleStem, ResBottleneckBlock</span><br><span class="line"></span><br><span class="line">bottom_up = L(RegNet)(</span><br><span class="line">    stem_class=SimpleStem,</span><br><span class="line">    stem_width=<span class="number">32</span>,</span><br><span class="line">    block_class=ResBottleneckBlock,</span><br><span class="line">    depth=<span class="number">23</span>,</span><br><span class="line">    w_a=<span class="number">38.65</span>,</span><br><span class="line">    w_0=<span class="number">96</span>,</span><br><span class="line">    w_m=<span class="number">2.43</span>,</span><br><span class="line">    group_width=<span class="number">40</span>,</span><br><span class="line">    norm=<span class="string">&quot;SyncBN&quot;</span>,</span><br><span class="line">    out_features=[<span class="string">&quot;s1&quot;</span>, <span class="string">&quot;s2&quot;</span>, <span class="string">&quot;s3&quot;</span>, <span class="string">&quot;s4&quot;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bottom_up)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Detectron2是Facebook AI Research的检测和分割框架，其主要基于PyTorch实现，但具有更模块化设计，因此它是灵活且便于扩展的，具体简介可见Github库和Meta AI Blog Post。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Detectron2" scheme="https://blog.justlovesmile.top/tags/Detectron2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客 | 如何让Butterfly主题导航栏居中</title>
    <link href="https://blog.justlovesmile.top/posts/56b0563d.html"/>
    <id>https://blog.justlovesmile.top/posts/56b0563d.html</id>
    <published>2022-03-15T01:25:18.000Z</published>
    <updated>2022-03-15T01:25:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有很多小伙伴留言问我ButterFly主题的<strong>导航栏是怎么居中的</strong>，说实话我的博客样式其实都是一点一点从其他博主的博客那模仿来的（如果我没记错的话，导航栏应该是看的<a href="https://blog.zhheo.com/">Heo大佬</a>的），所以样式修改的时间跨度有点长，我自己也不太清楚具体改了哪些地方，但是鉴于问的小伙伴太多，我决定把导航栏文件全部展示出来，至于CSS可以参考我的<a href="/css/justlovesmile.css">css文件</a>第168到434行（当前时间2022/3/15，不排除之后我又改了）……</p><h2 id="主题模板文件"><a href="#主题模板文件" class="headerlink" title="主题模板文件"></a>主题模板文件</h2><h3 id="index-pug"><a href="#index-pug" class="headerlink" title="index.pug"></a>index.pug</h3><p><code>themes\butterfly\layout\includes\header\index.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">if !theme.disable_top_img &amp;&amp; page.top_img !== false</span><br><span class="line">  if is_post()</span><br><span class="line">    - var top_img = page.top_img || page.cover || page.randomcover</span><br><span class="line">  else if is_page()</span><br><span class="line">    - var top_img = page.top_img || theme.default_top_img</span><br><span class="line">  else if is_tag()</span><br><span class="line">    - var top_img = theme.tag_per_img &amp;&amp; theme.tag_per_img[page.tag] </span><br><span class="line">    - top_img = top_img ? top_img : (theme.tag_img !== false ? theme.tag_img || theme.default_top_img : false)</span><br><span class="line">  else if is_category()</span><br><span class="line">    - var top_img = theme.category_per_img &amp;&amp; theme.category_per_img[page.category]</span><br><span class="line">    - top_img = top_img ? top_img : (theme.category_img !== false ? theme.category_img || theme.default_top_img : false)</span><br><span class="line">  else if is_home()</span><br><span class="line">    - var top_img = theme.index_img !== false ? theme.index_img || theme.default_top_img : false</span><br><span class="line">  else if is_archive()</span><br><span class="line">    - var top_img = theme.archive_img !== false ? theme.archive_img || theme.default_top_img : false</span><br><span class="line">  else</span><br><span class="line">    - var top_img = page.top_img || theme.default_top_img</span><br><span class="line"></span><br><span class="line">  if top_img !== false</span><br><span class="line">    - var imgSource = top_img &amp;&amp; top_img.indexOf(&#x27;/&#x27;) !== -1 ? `background-image: url(&#x27;$&#123;url_for(top_img)&#125;&#x27;)` : `background: $&#123;top_img&#125;`</span><br><span class="line">    - var bg_img = top_img ? imgSource : &#x27;&#x27;</span><br><span class="line">    - var site_title = is_archive() ? fragment_cache(&#x27;findArchivesTitle&#x27;, function()&#123;return findArchivesTitle(theme.menu);&#125;) : page.title || page.tag || page.category || config.title</span><br><span class="line">    - var isHomeClass = is_home() ? &#x27;full_page&#x27; : &#x27;not-home-page&#x27;</span><br><span class="line">    - is_post() ? isHomeClass = &#x27;post-bg&#x27; : isHomeClass</span><br><span class="line">  else</span><br><span class="line">    - var isHomeClass = &#x27;not-top-img&#x27;</span><br><span class="line">else</span><br><span class="line">  - var top_img = false</span><br><span class="line">  - var isHomeClass = &#x27;not-top-img&#x27;</span><br><span class="line"></span><br><span class="line">header#page-header(class=isHomeClass style=bg_img)</span><br><span class="line">  !=partial(&#x27;includes/header/nav&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">  if top_img !== false</span><br><span class="line">    if is_post()</span><br><span class="line">      #coverdiv.coverdiv</span><br><span class="line">        img#post-cover.cover.entered.loading(alt=&#x27;cover&#x27; src=`$&#123;top_img&#125;`)</span><br><span class="line">      include ./post-info.pug</span><br><span class="line">    else if is_home() </span><br><span class="line">      #site-info</span><br><span class="line">        h1#site-title=site_title</span><br><span class="line">        if theme.subtitle.enable</span><br><span class="line">          - var loadSubJs = true</span><br><span class="line">          #site-subtitle</span><br><span class="line">            span#subtitle</span><br><span class="line">        if(theme.social)</span><br><span class="line">          #site_social_icons</span><br><span class="line">            !=fragment_cache(&#x27;social&#x27;, function()&#123;return partial(&#x27;includes/header/social&#x27;)&#125;)</span><br><span class="line">      #scroll-down</span><br><span class="line">        i.fas.fa-angle-down.scroll-down-effects</span><br><span class="line">    else</span><br><span class="line">      #coverdiv.coverdiv</span><br><span class="line">        img#post-cover.cover.entered.loading(alt=&#x27;cover&#x27; src=`$&#123;top_img&#125;`)</span><br><span class="line">      #page-site-info</span><br><span class="line">        h1#site-title=site_title</span><br></pre></td></tr></table></figure><h3 id="nav-pug"><a href="#nav-pug" class="headerlink" title="nav.pug"></a>nav.pug</h3><p><code>themes\butterfly\layout\includes\header\nav.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">  #nav-group</span><br><span class="line">    #blog_name</span><br><span class="line">      a#site-name(href=url_for(&#x27;/&#x27;)) #[=config.author]</span><br><span class="line"></span><br><span class="line">    #menus</span><br><span class="line">      !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    #nav-right</span><br><span class="line">      if (theme.algolia_search.enable || theme.local_search.enable)</span><br><span class="line">        #search-button</span><br><span class="line">          a.nav-rightbutton.site-page.social-icon.search</span><br><span class="line">            i.fas.fa-search.fa-fw</span><br><span class="line">      #darkmode_navswitch</span><br><span class="line">        a.nav-rightbutton.site-page.darkmode_switchbutton(onclick=&quot;switchDarkMode()&quot;)</span><br><span class="line">          i.fas.fa-adjust</span><br><span class="line">      #toggle-menu</span><br><span class="line">        a.nav-rightbutton.site-page</span><br><span class="line">          i.fas.fa-bars.fa-fw</span><br></pre></td></tr></table></figure><p>上面提到的<code>switchDarkMode()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">switchDarkMode</span>(<span class="params"></span>) </span>&#123; <span class="comment">// Switch Between Light And Dark Mode</span></span><br><span class="line">      <span class="keyword">const</span> nowMode = <span class="built_in">document</span>.documentElement.getAttribute(<span class="string">&#x27;data-theme&#x27;</span>) === <span class="string">&#x27;dark&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span></span><br><span class="line">      <span class="keyword">if</span> (nowMode === <span class="string">&#x27;light&#x27;</span>) &#123;</span><br><span class="line">        activateDarkMode()</span><br><span class="line">        saveToLocal.set(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;dark&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">        GLOBAL_CONFIG.Snackbar !== <span class="literal">undefined</span> &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        activateLightMode()</span><br><span class="line">        saveToLocal.set(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">        GLOBAL_CONFIG.Snackbar !== <span class="literal">undefined</span> &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// handle some cases</span></span><br><span class="line">      <span class="keyword">typeof</span> utterancesTheme === <span class="string">&#x27;function&#x27;</span> &amp;&amp; utterancesTheme()</span><br><span class="line">      <span class="keyword">typeof</span> FB === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="built_in">window</span>.loadFBComment()</span><br><span class="line">      <span class="built_in">window</span>.DISQUS &amp;&amp; <span class="built_in">document</span>.getElementById(<span class="string">&#x27;disqus_thread&#x27;</span>).children.length &amp;&amp; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">window</span>.disqusReset(), <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>请自行F12查看，截至目前（2022/3/15）导航栏相关css样式是在<a href="/css/justlovesmile.css">/css/justlovesmile.css</a>第168到434行….</p><p>其他的之后再补充，有问题的欢迎留言提问</p>]]></content>
    
    
    <summary type="html">最近有很多小伙伴留言问我ButterFly主题的导航栏是怎么居中的，说实话我的博客样式其实都是一点一点从其他博主的博客那模仿来的，所以样式修改的时间跨度有点长，我自己也不太清楚具体改了哪些地方，但是鉴于问的小伙伴太多，我决定把导航栏文件全部展示出来......</summary>
    
    
    
    <category term="博客相关" scheme="https://blog.justlovesmile.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Hexo" scheme="https://blog.justlovesmile.top/tags/Hexo/"/>
    
    <category term="前端" scheme="https://blog.justlovesmile.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>目标检测 | RetinaNet，经典单阶段Anchor-Based目标检测模型</title>
    <link href="https://blog.justlovesmile.top/posts/bb608df3.html"/>
    <id>https://blog.justlovesmile.top/posts/bb608df3.html</id>
    <published>2022-03-14T03:26:21.000Z</published>
    <updated>2022-03-14T03:26:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Focal-Loss-for-Dense-Object-Detection"><a href="#Focal-Loss-for-Dense-Object-Detection" class="headerlink" title="Focal Loss for Dense Object Detection"></a>Focal Loss for Dense Object Detection</h1><blockquote><p>论文来源：IEEE Transactions on Pattern Analysis and Machine Intelligence 2020<br>论文链接：<a href="https://ieeexplore.ieee.org/document/8417976">Focal Loss for Dense Object Detection | IEEE Xplore</a><br>论文代码：<a href="https://github.com/facebookresearch/Detectron">https://github.com/facebookresearch/Detectron</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211119213555220.png" alt="image-20211119213555220"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@inproceedings&#123;lin2017focal,</span><br><span class="line">  title=&#123;Focal loss for dense object detection&#125;,</span><br><span class="line">  author=&#123;Lin, Tsung-Yi and Goyal, Priya and Girshick, Ross and He, Kaiming and Doll&#123;\&#x27;a&#125;r, Piotr&#125;,</span><br><span class="line">  booktitle=&#123;Proceedings of the IEEE international conference on computer vision&#125;,</span><br><span class="line">  pages=&#123;2980--2988&#125;,</span><br><span class="line">  year=&#123;2017&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><table><thead><tr><th>标签</th><th>目的</th><th>方法</th><th>总结</th></tr></thead><tbody><tr><td>#Anchor #单阶段</td><td>解决正负样本严重不均衡的问题</td><td>retinanet和focal loss</td><td>针对训练过程中的实际问题，修改损失函数以达到优化的目的</td></tr></tbody></table><h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><p>作者认为之前的单阶段检测算法精度不高的原因可能是前后景类别（正负样本）严重不均衡导致的。因此作者重新设计了一个损失：Focal Loss，其能降低可以较好分类的样本的损失权重，防止训练过程中大量的easy negatives给检测器带来的压制影响，并基于Focal Loss设计提出并训练了RetinaNet。</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>RetinaNet的结构如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120135540595.png" alt="image-20211120135540595"></p><p>主要包括三个部分：</p><ul><li>Backbone：使用了ResNet+FPN，用于生成多尺度{p3~p7}卷积特征图</li><li>Anchor：p3-p7特征图的base_size设置为$[32^2,64^2,128^2,256^2,512^2]$，在每一层特征图针对denser scale coverage，设置{${2^0,2^{1/3},2^{2/3}}$}三种不同的anchor size，比例为{1:2,1:1,2:1}，即每个位置9种Anchor。</li><li>subnets：用于分类和回归，结构相同但参数不共享的小型FCN结构</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120135222791.png" alt="image-20211120135222791"></p><h3 id="Focal-Loss"><a href="#Focal-Loss" class="headerlink" title="Focal Loss"></a>Focal Loss</h3><p>作者提到基于R-CNN模式的两阶段算法在解决训练过程中的正负样本不均衡的方法是：</p><ul><li>两阶段级联：在proposal阶段过滤掉大量负样本</li><li>启发式采样：例如固定正负样本比例（例如1:3）或者在线难样本挖掘（Online Hard Example Mining，OHEM）</li></ul><p>Focal loss的做法是设置一个sacling factor，如下图的$(1-p_t)^{\gamma}$，其可以自动的对easy example进行降权，从而使模型更关注hard example。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120135146831.png" alt="image-20211120135146831"></p><p>首先，对于二分类任务，普通的交叉熵如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120132951497.png" alt="image-20211120132951497"></p><p>如果定义$p_t$：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120133459396.png" alt="image-20211120133459396"></p><p>那么交叉熵可以写成$CE(p,y)=CE(p_t)=-log(p_t)$</p><p>有一种常见的用于解决类别不均衡的方法是添加一个权重变量$\alpha \in [0,1]$：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120133655071.png" alt="image-20211120133655071"></p><p>Focal Loss的做法是添加了一个权重变量$(1-p_t)^{\gamma}$：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120133916235.png" alt="image-20211120133916235"></p><p>因此当$p_t$趋近于1时，可以较好分类的样本被降权；而$\gamma$可以用来调节权重比率。除此之外，还可以将$\alpha$和FL损失相结合：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120134227038.png" alt="image-20211120134227038"></p><p>除此之外还有其他的Focal Loss变种形式。</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120141212266.png" alt="image-20211120141212266"></p>]]></content>
    
    
    <summary type="html">RetinaNet是He Kaiming等人在提出的一种单阶段目标检测算法，其针对现有单阶段检测模型中前后景（正负样本）类别的不平衡问题，提出了Focal Loss损失函数，用来降低大量easy negatives样本在标准交叉熵中所占权重。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文笔记" scheme="https://blog.justlovesmile.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="目标检测" scheme="https://blog.justlovesmile.top/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>目标检测 | Faster R-CNN，经典两阶段检测模型</title>
    <link href="https://blog.justlovesmile.top/posts/fc798de3.html"/>
    <id>https://blog.justlovesmile.top/posts/fc798de3.html</id>
    <published>2022-03-12T13:59:01.000Z</published>
    <updated>2022-03-12T13:59:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Faster-R-CNN-Towards-Real-Time-ObjectDetection-with-Region-Proposal-Networks"><a href="#Faster-R-CNN-Towards-Real-Time-ObjectDetection-with-Region-Proposal-Networks" class="headerlink" title="Faster R-CNN: Towards Real-Time ObjectDetection with Region Proposal Networks"></a>Faster R-CNN: Towards Real-Time ObjectDetection with Region Proposal Networks</h1><blockquote><p>论文发表：2015<br>论文链接：<a href="https://arxiv.org/abs/1506.01497">https://arxiv.org/abs/1506.01497</a><br>论文代码：<a href="https://github.com/rbgirshick/py-faster-rcnn">https://github.com/rbgirshick/py-faster-rcnn</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120141803069.png" alt="image-20211120141803069"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@article&#123;ren2015faster,</span><br><span class="line">  title=&#123;Faster r-cnn: Towards real-time object detection with region proposal networks&#125;,</span><br><span class="line">  author=&#123;Ren, Shaoqing and He, Kaiming and Girshick, Ross and Sun, Jian&#125;,</span><br><span class="line">  journal=&#123;Advances in neural information processing systems&#125;,</span><br><span class="line">  volume=&#123;28&#125;,</span><br><span class="line">  pages=&#123;91--99&#125;,</span><br><span class="line">  year=&#123;2015&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><table><thead><tr><th>标签</th><th>目的</th><th>方法</th><th>总结</th></tr></thead><tbody><tr><td>#Anchor #两阶段</td><td>-</td><td>RPN</td><td>首次提出RPN和Anchor</td></tr></tbody></table><h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><p>Faster R-CNN是在R-CNN和Fast R-CNN的基础上提出的一种两阶段目标检测算法，其主要包括：</p><ul><li>特征提取网络（Backbone）</li><li>RPN（Region Proposal Networks）</li><li>RoI Pooling（Region of Interesting Pooling）</li><li>分类回归（Classification and Regression）</li></ul><p>论文中的结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120142753845.png" alt="image-20211120142753845"></p><p>自己画的训练流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120143345989.png" alt="image-20211120143345989"></p><p>网上找的训练流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/fasterRCNN.png" alt="fasterRCNN"></p><blockquote><p>图片来自<a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing/tree/master/pytorch_object_detection/faster_rcnn">WZMIAOMIAO/deep-learning-for-image-processing (github.com)</a></p></blockquote><p>对于Backbone生成的特征图，首先输入到RPN结构中，用于生成Proposal。RPN，即区域推荐网络，对于目标检测任务而言，不仅需要对目标分类还需要对目标定位，因此Faster RCNN模型提出了Anchor机制，其中的做法是，在特征图的每个像素位置预设一组多尺度的先验框，即Anchor（作者使用了3种尺寸（128，256，512），3种比例（1:1，1:2，2:1）的Anchor，共9种）：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120143554871.png" alt="image-20211120143554871"></p><p>如果输入一张800×600的图片，经过Backbone后被下采样16倍，那么这个特征图的尺寸为$\frac{800}{16}×\frac{600}{16}=1900$个像素，那么这个特征图上需要设置1900×9=17100个Anchor。但这一步得到的Anchor肯定不可能全部当作候选区域，因此在预设了Anchor之后，为了筛选有意义的proposal，还设置了一个3×3的卷积层后接两个1×1的卷积层来预测该区域是否包含目标(cls)以及偏移量预测(reg)，如果包含目标则需要根据预测的偏移量对该Anchor进行微调。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120143818038.png" alt="image-20211120143818038"></p><p>这两个1×1的卷积层的输出维度分别为2k和4k，其中k为每个位置的Anchor数量，2代表包含目标和不包含目标的概率，4代表对目标框坐标值（x,y,w,h）的偏移量预测：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120144113585.png" alt="image-20211120144113585"></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120144227681.png" alt="image-20211120144227681"></p><p>可以根据上述公式，计算出候选区域的坐标。并且当我们得到了该区域包含目标的概率之后，我们就可以进行一个简单的筛选，按照包含目标可能性排序，只保留前2000个作为候选区域，并且对于超出图片边界的边框还需要进行一个裁剪处理。</p><p>尽管我们筛选出了2000个候选区域，但我们在计算Loss的时候并不是拿这2000个候选区域来计算，这里Faster RCNN定义了正负样本的概念，首先我们需要将特征图上的Anchor映射回原始图像，因为我们的Ground-Truth是在原始图像上标注的，RPN需要根据这个来进行学习，其次还需要了解IoU这个概念，IoU可以用来计算两个框之间的重合度，其值为两个框的交集与并集的比值。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120151522563.png" alt="image-20211120151522563"></p><p>那么我们就可以定义候选区域和ground-truth的IoU值大于0.7的为正样本，小于0.3的为负样本，其他的都不用于计算损失，然后从中分别随机抽取128个正负样本。RPN的损失函数如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120144312326.png" alt="image-20211120144312326"></p><p>RoI Pooling的作用是将 RPN 输出的大小不等的候选框缩放到统一的尺寸。具体做法是，假设需要固定候选区域为7×7大小，那么就可以将其划分为7×7个块，然后对每个块进行最大值池化，最后输出的大小就是所需要的。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120144459517.png" alt="image-20211120144459517"></p><p>这样，将所有的候选区域统一大小后，将其展平为49×1大小，通道数为256的向量，输入到两个全连接层隐藏层，最后再分别接两个输出大小为类别数以及类别数×4的全连接层。来实现对候选区域包含目标所属类别概率以及对该目标框的偏移量的预测。分类回归的损失函数和之前RPN的损失函数类似，只是分类损失不再是二分类交叉熵而是多分类交叉熵。预测框的坐标计算也和之前RPN部分的一样。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120151313142.png" alt="image-20211120151313142"></p><p>而在得到了预测目标框和类别概率之后，还需要进一步筛选，因为之前保留了2000个候选区域，而实际场景中目标数量根本达不到那么多，因此我们使用了NMS算法对重叠目标框进行去重。NMS算法的流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120151353580.png" alt="image-20211120151353580"></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120151446230.png" alt="image-20211120151446230"></p><p>首先对同一个类别所有的目标框进行排序，（这里默认之前预测的分类概率最大的类别为目标所属类别），然后从大到小依次选择一个目标框和其他剩余目标框计算IoU值，如果IoU值大于设定的阈值如0.5，就代表重叠，此时舍去得分小的目标框，否则就保留，然后依次比较之后，就能实现对重叠目标的去重处理。</p><p>论文里的实验结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120151656814.png" alt="image-20211120151656814"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/31426458">一文读懂Faster RCNN - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">Faster R-CNN是He Kaiming等人在R-CNN和Fast R-CNN的基础上提出的一种两阶段目标检测算法，其主要包括：特征提取网络（Backbone），RPN（Region Proposal Networks），RoI Pooling（Region of Interesting Pooling）以及分类回归（Classification and Regression）。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文笔记" scheme="https://blog.justlovesmile.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="目标检测" scheme="https://blog.justlovesmile.top/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 小样本学习基础概念</title>
    <link href="https://blog.justlovesmile.top/posts/d150f284.html"/>
    <id>https://blog.justlovesmile.top/posts/d150f284.html</id>
    <published>2022-01-27T02:24:38.000Z</published>
    <updated>2022-01-27T02:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小样本学习"><a href="#小样本学习" class="headerlink" title="小样本学习"></a>小样本学习</h1><p>人类非常擅长通过极少量的样本识别一个新物体，比如小孩子只需要书中的一些图片就可以认识什么是“斑马”，什么是“犀牛”。在人类的快速学习能力的启发下，研究人员希望机器学习模型在学习了一定类别的大量数据后，对于新的类别，只需要少量的样本就能快速学习，这就是 Few-shot Learning 要解决的问题。Few-shot learning (FSL) 在机器学习领域具有重大意义和挑战性，是否拥有从少量样本中学习和概括的能力，是将人工智能和人类智能进行区分的明显分界点，因为人类可以仅通过一个或几个示例就可以轻松地建立对新事物的认知，而机器学习算法通常需要成千上万个有监督样本来保证其泛化能力。</p><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><p>机器学习定义：A computer program is said to learn from experience <code>E</code> with respect to some classes of task <code>T</code> and performance measure <code>P</code> if its performance can improve with <code>E</code> on <code>T</code> measured by <code>P</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202109201329876.png" alt="image-20210920132843364"></p><p>小样本学习定义：Few-Shot Learning (FSL) is a type of machine learning problems (specified by <code>E</code>, <code>T</code> and <code>P</code>), where <code>E</code> contains only a limited number of examples with supervised information for the target <code>T</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202109201329400.png" alt="image-20210920132907931"></p><p>小样本学习（Few-shot learning），或者称为少样本学习（Low-shot learning），包含了n-shot learning，其中<code>n</code>代表样本数量，<code>n=1</code>的情况下，也被称One-shot learning，而<code>n=0</code>的情况下，被称为Zero-shot learning。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202109201348334.png" alt="image-20210920134843156"></p><p>小样本学习的主要思想是利用先验知识使其快速适用于只包含少量带有监督信息的样本的任务中。</p><h2 id="2-方法分类"><a href="#2-方法分类" class="headerlink" title="2. 方法分类"></a>2. 方法分类</h2><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202109201336741.png" alt="image-20210920133613257"></p><p>小样本学习问题的解决方法可以根据先验知识的利用方式分为三类：</p><ul><li>数据：此类方法利用先验知识来增强训练数据集或者增加样本数量（从样本量的角度）<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110051544192.png" alt="image-20211005154338367"></li><li>1.使用旋转，翻转，裁剪等方法对训练集图像增强</li><li>2.从其他数据集获取图像用于扩充训练集</li><li>3.使用GAN来生成具有相似分布的数据用于扩充训练集</li></ul></li><li>模型：此类方法利用先验知识来限制假设空间的复杂性（从模型训练的角度）<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110051544913.png" alt="image-20211005154419771"></li><li>1.多任务学习（同时进行多个相关任务训练，共享表示，以获得更好的泛化能力）与迁移学习不同（将源任务中学到的知识运用到目标任务中）<ul><li>parameter sharing：多任务间共享参数（例如最开始几层网络结构共享，最后输出层单独训练）</li><li>parameter typing：对不同任务的参数正则化处理，使其参数相似（encourages parameters of different tasks to be similar using regularization）</li></ul></li><li>2.嵌入学习（将样本映射（嵌入）到低纬度空间后，相似样本距离更近，不相似样本距离远）<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110052028366.png" alt="image-20211005202850882"></li><li>Task-Specific Embedding Model:只使用来自任务的信息学习一个定制的嵌入函数</li><li>Task-Invariant Embedding Model：将从其他充足样本中学到的信息直接利用到小样本学习任务中<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110062246351.png" alt="image-20211006224637164"></li><li>Matching Nets</li><li>Prototypical Networks(ProtoNet)</li></ul></li><li>Hybrid Embedding Model: 前两种方法的结合，使用小样本任务中的task specific信息运用到从先验知识学到的task invariant嵌入模型<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110062249691.png" alt="image-20211006224925493"></li></ul></li></ul></li><li>3.带有存储的模型，构建键值存储，并优化内存，每个新样本都可以由内存中提取出的内容的加权平均值表示（通过查询相似性），进一步限制假设空间。<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110052104077.png" alt="image-20211005202918521"></li><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110052033347.png" alt="image-20211005203314132"></li><li>优化表征（representation）</li><li>优化参数（parameter）</li></ul></li><li>4.生成模型，对于样本x在先验知识的帮助下可以估计其分布p(x)：假设x的分布可以表示为受$\theta$约束的$p(x;\theta)$，并且通常还存在潜在变量$z \sim p(z;y)$，因此$x \sim \int p(x|z;\theta)p(z;y)dz$，即在先验分布$p(z;y)$的帮助下，可以进一步缩小假设空间的大小.<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110052048660.png" alt="image-20211005204829440"></li><li>Decomposable Components：训练可分解组件模型，在不同任务间共享分解组件的信息，最后再找到分解组件的组合方式（模型层面？）</li><li>Groupwise Shared Prior：使用无监督学习将数据集分组，对于新类别，首先查询其所属组，再根据其所属组的先验概率建模（相似的任务拥有相似的先验概率）</li><li>Parameters of Inference Networks：找到最佳的$\theta$，使得最大化$p(z|x;\theta,\gamma)=\frac{p(x,z;\theta,\gamma)}{p(x;\gamma)}=\frac{p(x|z;\theta)p(z;\gamma)}{\int p(x|z;\theta)p(z;\gamma)dz}$，通常使用从数据中学到的变分分布$q(z;\delta)$来估计$p(z|x;\theta,\gamma)$。（？）</li></ul></li></ul></li><li>算法：此类方法利用先验知识在假设空间中搜索最优的假设<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110052106876.png" alt="image-20211005210608746"></li><li>1.精炼现存参数<ul><li>使用预训练模型，通过正则化进行微调<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110052115770.png" alt="image-20211005211532604"></li><li>Early-stopping</li><li>Selectively updating parameters</li><li>Updating related parts of parameters together</li><li>Using a model regression network</li></ul></li><li>聚集子任务的参数（参数层面？）<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110052109091.png" alt="image-20211005210954883"></li></ul></li><li>使用新参数微调现有参数：给模型参数扩充一个$\delta$，使其参数为$\theta={\theta_0,\delta}$，然后通过学习$\delta$来微调初始参数$\theta_0$。</li></ul></li><li>2.精炼Meta-Learned参数<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110071533336.png" alt="image-20211007153301984"></li></ul></li><li>3.学习优化器：不使用梯度下降来更新参数，而是通过学习一个优化器来输出参数的更新，即$\Delta{\theta^{i-1}}$<ul><li><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202110071540903.png" alt="image-20211007154007652"></li></ul></li></ul></li></ul><h2 id="3-小样本学习常用数据集"><a href="#3-小样本学习常用数据集" class="headerlink" title="3. 小样本学习常用数据集"></a>3. 小样本学习常用数据集</h2><p>小样本常用Benchmark图像数据集：</p><ul><li>Omniglot</li><li>Mini-Imagenet</li><li>CU-Birds</li></ul>]]></content>
    
    
    <summary type="html">在很多场景下，收集大量的有标签的数据是非常昂贵、困难、甚至不可能的，比如医疗数据、手机上用户手动标注的数据等。是否能仅利用少量带标签的数据来训练就得到一个好的模型？这已经成为机器学习的发展中一个十分重要的课题，不论是学术界还是工业界都高度关注。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="小样本学习" scheme="https://blog.justlovesmile.top/tags/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Lab | 安装、配置、插件推荐、多用户使用教程</title>
    <link href="https://blog.justlovesmile.top/posts/e05a9ab6.html"/>
    <id>https://blog.justlovesmile.top/posts/e05a9ab6.html</id>
    <published>2021-11-25T09:38:43.000Z</published>
    <updated>2021-11-25T09:38:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先相信很多使用过python的人都或多或少地了解过<code>Jupyter Notebook</code>这个应用。<code>Jupyter Notebook</code>是一个开源Web应用程序，可让用户创建和共享包含实时代码、公式、可视化和叙述文本的文档。 用途包括：数据清理和转换、数值模拟、统计建模、数据可视化、机器学习等等。</p><p>而<code>Jupyter Lab</code>则是Jupyter的下一代笔记本界面。<code>Jupyter Lab</code> 是一个基于Web的交互式开发环境，用于Jupyter notebook、代码和数据。 <code>Jupyter Lab</code> 非常灵活，可支持数据科学、科学计算和机器学习领域的广泛工作。 <code>Jupyter Lab</code> 是可扩展和模块化的,其可编写插件来添加新组件并与现有组件相集成。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211125180351537.png" alt="image-20211125180351537"></p><h1 id="Jupyter-Lab安装和配置"><a href="#Jupyter-Lab安装和配置" class="headerlink" title="Jupyter Lab安装和配置"></a>Jupyter Lab安装和配置</h1><h2 id="1-Jupyter-Lab安装"><a href="#1-Jupyter-Lab安装" class="headerlink" title="1.Jupyter Lab安装"></a>1.Jupyter Lab安装</h2><p>首先进入自己的<code>Python</code>环境或者其他<code>Conda</code>虚拟环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate XXXXXXX</span><br></pre></td></tr></table></figure><p>然后在<code>terminal</code>或者<code>cmd</code>输入安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyterlab</span><br><span class="line">//或者</span><br><span class="line">conda install -c conda-forge jupyterlab</span><br></pre></td></tr></table></figure><p>等待安装完成！</p><h2 id="2-Jupyter-Lab配置"><a href="#2-Jupyter-Lab配置" class="headerlink" title="2.Jupyter Lab配置"></a>2.Jupyter Lab配置</h2><p>使用命令创建配置文件，其会生成<code>C:\Users\用户名\.jupyter\jupyter_notebook_config.py</code>或者<code>/home/用户名/.jupyter/jupyter_notebook_config.py</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab --generate-config</span><br></pre></td></tr></table></figure><p>使用编辑器打开配置文件，在文件上方添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.ServerApp.ip = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">c.ServerApp.port = <span class="number">8000</span></span><br><span class="line">c.ServerApp.open_browser = <span class="literal">False</span></span><br><span class="line">c.ServerApp.root_dir = <span class="string">&#x27;/xxxx/xxxx/xxx&#x27;</span> </span><br><span class="line">c.ServerApp.password_required = <span class="literal">True</span></span><br><span class="line">c.ServerApp.password = <span class="string">&#x27;xxxxxxx&#x27;</span></span><br></pre></td></tr></table></figure><p>其中<code>ip</code>代表允许访问的ip，<code>*</code>代表全部，<code>port</code>用于设置端口，<code>open_browser</code>用于设置启动lab时是否打开浏览器，<code>root_dir</code>用于设置lab启动文件夹根路径，<code>password_required</code>用于设置是否需要密码，<code>password</code>用于设置（加密）密码，这个加密密码的获取方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开python或者ipython环境</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br><span class="line"><span class="comment">#Enter password: </span></span><br><span class="line"><span class="comment">#Verify password: </span></span><br><span class="line"><span class="comment">#Out[2]: &#x27;argon2:f704bjkasjdfkjasdjfkasjdkjfklmasjdfkalflakdkf&#x27;</span></span><br></pre></td></tr></table></figure><p>复制上方输出的加密密码即可。</p><p>当然也可以在<code>Terminal</code>强制设置/修改密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab password</span><br></pre></td></tr></table></figure><p>更多配置可以查看默认配置文件下方的注释！</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120214858878.png" alt="image-20211120214858878"></p><h2 id="3-Jupyter-Lab启动"><a href="#3-Jupyter-Lab启动" class="headerlink" title="3. Jupyter Lab启动"></a>3. Jupyter Lab启动</h2><p>在<code>Terminal</code>输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab -p 9090 --no-browser</span><br></pre></td></tr></table></figure><p>更多启动命名可通过<code>jupyter lab --help</code>查看，启动之后即可在浏览器输入：ip+端口 ，进行访问，如：<code>127.0.0.0:9090</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120215159090.png" alt="image-20211120215159090"></p><h2 id="4-Jupyter-Lab插件推荐"><a href="#4-Jupyter-Lab插件推荐" class="headerlink" title="4. Jupyter Lab插件推荐"></a>4. Jupyter Lab插件推荐</h2><p>首先启动Jupyter Lab，在Lab中打开菜单栏的<code>Setting</code>里的<code>Advanced Setting Editor</code>，接着找到<code>Extension Manager</code>，并在右边填入<code>&#123;&#39;enabled&#39;:true&#125;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120215625334.png" alt="image-20211120215625334"></p><p>然后即可在左边菜单栏找到插件安装符号，在里面就可以搜索插件，推荐如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211120215754890.png" alt="image-20211120215754890"></p><ul><li>theme-darcula：一个好看的主题配色</li><li>jupyterlab_go_to_definition：跳转到定义</li><li>jupyterlab_lsp：代码跳转+代码补全</li><li>还有很多如：latex，git，html，plotly，bokeh，matplotlib，drawio等等</li></ul><h2 id="5-Jupyter-Lab多用户使用"><a href="#5-Jupyter-Lab多用户使用" class="headerlink" title="5. Jupyter Lab多用户使用"></a>5. Jupyter Lab多用户使用</h2><p>复制配置文件到指定位置，例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /home/admin555/.jupyter/jupyter_notebook_config.py /指定位置/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>之后启动时，使用命令：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab --config /指定位置/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p> 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=1izx0kxkb2lzz">https://cloud.tencent.com/developer/support-plan?invite_code=1izx0kxkb2lzz</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先相信很多使用过python的人都或多或少地了解过&lt;code&gt;Jupyter Notebook&lt;/code&gt;这个应用。&lt;code&gt;Jupyter Notebook&lt;/code&gt;是一个开源Web应用程序，可让用户创建和共享包含实时代码、公式、可视化和叙述文本的文档。 用途包</summary>
      
    
    
    
    <category term="折腾记录" scheme="https://blog.justlovesmile.top/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Jupyter" scheme="https://blog.justlovesmile.top/tags/Jupyter/"/>
    
  </entry>
  
  <entry>
    <title>目标检测 | 常用数据集标注格式及生成脚本</title>
    <link href="https://blog.justlovesmile.top/posts/865c56ba.html"/>
    <id>https://blog.justlovesmile.top/posts/865c56ba.html</id>
    <published>2021-09-11T07:11:26.000Z</published>
    <updated>2021-09-11T07:11:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>目标检测是计算机视觉任务中的一个重要研究方向，其用于解决对数码图像中特定种类的可视目标实例的检测问题。目标检测作为计算机视觉的根本性问题之一，是其他诸多计算机视觉任务，例如图像描述生成，实例分割和目标跟踪的基础以及前提。而在解决此类问题时，我们常常需要使用自己的脚本或者利用标注工具生成数据集，数据集格式往往会多种多样，因此对于目标检测任务而言，为了更好地兼容训练，大多数目标检测模型框架会默认支持几种常用的数据集标注格式，常见的分别是COCO，Pascal VOC，YOLO等等。本文主要介绍上述几种数据集格式以及我写的Python脚本（一般需要根据实际情况再改改）。</p><h1 id="1-COCO"><a href="#1-COCO" class="headerlink" title="1. COCO"></a>1. COCO</h1><h2 id="1-1-COCO数据集格式"><a href="#1-1-COCO数据集格式" class="headerlink" title="1.1 COCO数据集格式"></a>1.1 COCO数据集格式</h2><p>COCO（Common Objects in COtext）数据集，是一个大规模的，适用于目标检测，图像分割，Image Captioning任务的数据集，其标注格式是最常用的几种格式之一。目前使用较多的是COCO2017数据集。其官网为<a href="https://cocodataset.org/">COCO - Common Objects in Context (cocodataset.org)</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202109111535004.png" alt="image-20210911153516753"></p><p>COCO数据集主要包含图像（jpg或者png等等）和标注文件（json），其数据集格式如下(<code>/</code>代表文件夹)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-coco/</span><br><span class="line">    |-train2017/</span><br><span class="line">    |-1.jpg</span><br><span class="line">    |-2.jpg</span><br><span class="line">    |-val2017/</span><br><span class="line">    |-3.jpg</span><br><span class="line">    |-4.jpg</span><br><span class="line">    |-test2017/</span><br><span class="line">    |-5.jpg</span><br><span class="line">    |-6.jpg</span><br><span class="line">    |-annotations/</span><br><span class="line">    |-instances_train2017.json</span><br><span class="line">    |-instances_val2017.json</span><br><span class="line">    |-*.json</span><br></pre></td></tr></table></figure><p><code>train2017</code>以及<code>val2017</code>这两个文件夹中存储的是训练集和验证集的图像，而<code>test2017</code>文件夹中存储的是测试集的信息，可以只是图像，也可以包含标注，一般是单独使用的。</p><p><code>annotations</code>文件夹中的文件就是标注文件，如果你有<code>xml</code>文件，通常需要转换成<code>json</code>格式，其格式如下（更详细的可以参考<a href="https://cocodataset.org/#format-data">官网</a>）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;info&quot;</span>: info, </span><br><span class="line"><span class="attr">&quot;images&quot;</span>: [image], <span class="comment">//列表</span></span><br><span class="line"><span class="attr">&quot;annotations&quot;</span>: [annotation], <span class="comment">//列表</span></span><br><span class="line"><span class="attr">&quot;categories&quot;</span>: [category], <span class="comment">//列表</span></span><br><span class="line"><span class="attr">&quot;licenses&quot;</span>: [license], <span class="comment">//列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>info</code>为整个数据集的信息，包括年份，版本，描述等等信息，如果只是完成训练任务，其实不太重要，如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于训练，不是那么的重要</span></span><br><span class="line">info&#123;</span><br><span class="line"><span class="attr">&quot;year&quot;</span>: int, </span><br><span class="line"><span class="attr">&quot;version&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;description&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;contributor&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;url&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;date_created&quot;</span>: datetime,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>image</code>为图像的基本信息，包括序号，宽高，文件名等等信息，其中的序号（<code>id</code>）需要和后面的<code>annotations</code>中的标注所属图片序号对应如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">image&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: int, <span class="comment">//必要</span></span><br><span class="line"><span class="attr">&quot;width&quot;</span>: int, <span class="comment">//必要</span></span><br><span class="line"><span class="attr">&quot;height&quot;</span>: int, <span class="comment">//必要</span></span><br><span class="line"><span class="attr">&quot;file_name&quot;</span>: str, <span class="comment">//必要</span></span><br><span class="line"><span class="attr">&quot;license&quot;</span>: int,</span><br><span class="line"><span class="attr">&quot;flickr_url&quot;</span>: str,</span><br><span class="line"><span class="attr">&quot;coco_url&quot;</span>: str,</span><br><span class="line"><span class="attr">&quot;date_captured&quot;</span>: datetime, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>annotation</code>是最重要的标注信息，包括序号，所属图像序号，类别序号等等信息，如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">annotation&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: int, <span class="comment">//标注id</span></span><br><span class="line"><span class="attr">&quot;image_id&quot;</span>: int, <span class="comment">//所属图像id</span></span><br><span class="line"><span class="attr">&quot;category_id&quot;</span>: int, <span class="comment">//类别id</span></span><br><span class="line"><span class="attr">&quot;segmentation&quot;</span>: RLE or [polygon], <span class="comment">//图像分割标注</span></span><br><span class="line"><span class="attr">&quot;area&quot;</span>: float, <span class="comment">//区域面积</span></span><br><span class="line"><span class="attr">&quot;bbox&quot;</span>: [x,y,width,height], <span class="comment">//目标框左上角坐标以及宽高</span></span><br><span class="line"><span class="attr">&quot;iscrowd&quot;</span>: <span class="number">0</span> or <span class="number">1</span>, <span class="comment">//是否密集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>category</code>代表类别信息，包括父类别，类别序号以及类别名称，如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">category&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: int, <span class="comment">//类别序号</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span>: str, <span class="comment">//类别名称</span></span><br><span class="line"><span class="attr">&quot;supercategory&quot;</span>: str, <span class="comment">//父类别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>license</code>代表数据集的协议许可信息，包括序号，协议名称以及链接信息，如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于训练，不重要</span></span><br><span class="line">license&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: int, </span><br><span class="line"><span class="attr">&quot;name&quot;</span>: str, </span><br><span class="line"><span class="attr">&quot;url&quot;</span>: str,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来看一个简单的示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;info&quot;</span>: &#123;略&#125;, <span class="attr">&quot;images&quot;</span>: [&#123;<span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;file_name&quot;</span>: <span class="string">&quot;1.jpg&quot;</span>, <span class="attr">&quot;height&quot;</span>: <span class="number">334</span>, <span class="attr">&quot;width&quot;</span>: <span class="number">500</span>&#125;, &#123;<span class="attr">&quot;id&quot;</span>: <span class="number">2</span>, <span class="attr">&quot;file_name&quot;</span>: <span class="string">&quot;2.jpg&quot;</span>, <span class="attr">&quot;height&quot;</span>: <span class="number">445</span>, <span class="attr">&quot;width&quot;</span>: <span class="number">556</span>&#125;], <span class="attr">&quot;annotations&quot;</span>: [&#123;<span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;area&quot;</span>: <span class="number">40448</span>, <span class="attr">&quot;iscrowd&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;image_id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;bbox&quot;</span>: [<span class="number">246</span>, <span class="number">61</span>, <span class="number">128</span>, <span class="number">316</span>], <span class="attr">&quot;category_id&quot;</span>: <span class="number">3</span>, <span class="attr">&quot;segmentation&quot;</span>: []&#125;, &#123;<span class="attr">&quot;id&quot;</span>: <span class="number">2</span>, <span class="attr">&quot;area&quot;</span>: <span class="number">40448</span>, <span class="attr">&quot;iscrowd&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;image_id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;bbox&quot;</span>: [<span class="number">246</span>, <span class="number">61</span>, <span class="number">128</span>, <span class="number">316</span>], <span class="attr">&quot;category_id&quot;</span>: <span class="number">2</span>, <span class="attr">&quot;segmentation&quot;</span>: []&#125;, &#123;<span class="attr">&quot;id&quot;</span>: <span class="number">3</span>, <span class="attr">&quot;area&quot;</span>: <span class="number">40448</span>, <span class="attr">&quot;iscrowd&quot;</span>: <span class="number">0</span>, <span class="attr">&quot;image_id&quot;</span>: <span class="number">2</span>, <span class="attr">&quot;bbox&quot;</span>: [<span class="number">246</span>, <span class="number">61</span>, <span class="number">128</span>, <span class="number">316</span>], <span class="attr">&quot;category_id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;segmentation&quot;</span>: []&#125;], <span class="attr">&quot;categories&quot;</span>: [&#123;<span class="attr">&quot;supercategory&quot;</span>: <span class="string">&quot;none&quot;</span>, <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;liner&quot;</span>&#125;,&#123;<span class="attr">&quot;supercategory&quot;</span>: <span class="string">&quot;none&quot;</span>, <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>, <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;containership&quot;</span>&#125;,&#123;<span class="attr">&quot;supercategory&quot;</span>: <span class="string">&quot;none&quot;</span>, <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>, <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;bulkcarrier&quot;</span>&#125;], <span class="attr">&quot;licenses&quot;</span>: [&#123;略&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-COCO转换脚本"><a href="#1-2-COCO转换脚本" class="headerlink" title="1.2 COCO转换脚本"></a>1.2 COCO转换脚本</h2><p><code>Python转换脚本</code>如下所示，需要准备<code>图像</code>和<code>xml</code>标注文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author    : justlovesmile</span></span><br><span class="line"><span class="comment"># @Date      : 2021/9/8 15:36</span></span><br><span class="line"><span class="keyword">import</span> os, random, json</span><br><span class="line"><span class="keyword">import</span> shutil <span class="keyword">as</span> sh</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> xmlET</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;The path (<span class="subst">&#123;path&#125;</span>) already exists.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readxml</span>(<span class="params">file</span>):</span></span><br><span class="line">    tree = xmlET.parse(file)</span><br><span class="line">    <span class="comment">#图片尺寸字段</span></span><br><span class="line">    size = tree.find(<span class="string">&#x27;size&#x27;</span>)</span><br><span class="line">    width = <span class="built_in">int</span>(size.find(<span class="string">&#x27;width&#x27;</span>).text)</span><br><span class="line">    height = <span class="built_in">int</span>(size.find(<span class="string">&#x27;height&#x27;</span>).text)</span><br><span class="line">    <span class="comment">#目标字段</span></span><br><span class="line">    objs = tree.findall(<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">    bndbox = []</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> objs:</span><br><span class="line">        label = obj.find(<span class="string">&quot;name&quot;</span>).text</span><br><span class="line">        bnd = obj.find(<span class="string">&quot;bndbox&quot;</span>)</span><br><span class="line">        xmin = <span class="built_in">int</span>(bnd.find(<span class="string">&quot;xmin&quot;</span>).text)</span><br><span class="line">        ymin = <span class="built_in">int</span>(bnd.find(<span class="string">&quot;ymin&quot;</span>).text)</span><br><span class="line">        xmax = <span class="built_in">int</span>(bnd.find(<span class="string">&quot;xmax&quot;</span>).text)</span><br><span class="line">        ymax = <span class="built_in">int</span>(bnd.find(<span class="string">&quot;ymax&quot;</span>).text)</span><br><span class="line">        bbox = [xmin, ymin, xmax, ymax, label]</span><br><span class="line">        bndbox.append(bbox)</span><br><span class="line">    <span class="keyword">return</span> [[width, height], bndbox]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tococo</span>(<span class="params">xml_root, image_root, output_root,classes=&#123;&#125;,errorId=[],train_percent=<span class="number">0.9</span></span>):</span></span><br><span class="line">    <span class="comment"># assert</span></span><br><span class="line">    <span class="keyword">assert</span> train_percent&lt;=<span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(classes)&gt;<span class="number">0</span></span><br><span class="line">    <span class="comment"># define the root path</span></span><br><span class="line">    train_root = os.path.join(output_root, <span class="string">&quot;train2017&quot;</span>)</span><br><span class="line">    val_root = os.path.join(output_root, <span class="string">&quot;val2017&quot;</span>)</span><br><span class="line">    ann_root = os.path.join(output_root, <span class="string">&quot;annotations&quot;</span>)</span><br><span class="line">    <span class="comment"># initialize train and val dict</span></span><br><span class="line">    train_content = &#123;</span><br><span class="line">        <span class="string">&quot;images&quot;</span>: [],  <span class="comment"># &#123;&quot;file_name&quot;: &quot;09780.jpg&quot;, &quot;height&quot;: 334, &quot;width&quot;: 500, &quot;id&quot;: 9780&#125;</span></span><br><span class="line">        <span class="string">&quot;annotations&quot;</span>: [],<span class="comment"># &#123;&quot;area&quot;: 40448, &quot;iscrowd&quot;: 0, &quot;image_id&quot;: 1, &quot;bbox&quot;: [246, 61, 128, 316], &quot;category_id&quot;: 5, &quot;id&quot;: 1, &quot;segmentation&quot;: []&#125;</span></span><br><span class="line">        <span class="string">&quot;categories&quot;</span>: []  <span class="comment"># &#123;&quot;supercategory&quot;: &quot;none&quot;, &quot;id&quot;: 1, &quot;name&quot;: &quot;liner&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    val_content = &#123;</span><br><span class="line">        <span class="string">&quot;images&quot;</span>: [],  <span class="comment"># &#123;&quot;file_name&quot;: &quot;09780.jpg&quot;, &quot;height&quot;: 334, &quot;width&quot;: 500, &quot;id&quot;: 9780&#125;</span></span><br><span class="line">        <span class="string">&quot;annotations&quot;</span>: [],<span class="comment"># &#123;&quot;area&quot;: 40448, &quot;iscrowd&quot;: 0, &quot;image_id&quot;: 1, &quot;bbox&quot;: [246, 61, 128, 316], &quot;category_id&quot;: 5, &quot;id&quot;: 1, &quot;segmentation&quot;: []&#125;</span></span><br><span class="line">        <span class="string">&quot;categories&quot;</span>: []  <span class="comment"># &#123;&quot;supercategory&quot;: &quot;none&quot;, &quot;id&quot;: 1, &quot;name&quot;: &quot;liner&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    train_json = <span class="string">&#x27;instances_train2017.json&#x27;</span></span><br><span class="line">    val_json = <span class="string">&#x27;instances_val2017.json&#x27;</span></span><br><span class="line">    <span class="comment"># divide the trainset and valset</span></span><br><span class="line">    images = os.listdir(image_root)</span><br><span class="line">    total_num = <span class="built_in">len</span>(images)</span><br><span class="line">    train_percent = train_percent</span><br><span class="line">    train_num = <span class="built_in">int</span>(total_num * train_percent)</span><br><span class="line">    train_file = <span class="built_in">sorted</span>(random.sample(images, train_num))</span><br><span class="line">    <span class="keyword">if</span> mkdir(output_root):</span><br><span class="line">        <span class="keyword">if</span> mkdir(train_root) <span class="keyword">and</span> mkdir(val_root) <span class="keyword">and</span> mkdir(ann_root):</span><br><span class="line">            idx1, idx2, dx1, dx2 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> tqdm(images):</span><br><span class="line">                name=os.path.splitext(os.path.basename(file))[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> errorId:</span><br><span class="line">                    res = readxml(os.path.join(xml_root, name + <span class="string">&#x27;.xml&#x27;</span>))</span><br><span class="line">                    <span class="keyword">if</span> file <span class="keyword">in</span> train_file:</span><br><span class="line">                        idx1 += <span class="number">1</span></span><br><span class="line">                        sh.copy(os.path.join(image_root, file), train_root)</span><br><span class="line">                        train_content[<span class="string">&#x27;images&#x27;</span>].append(</span><br><span class="line">                            &#123;<span class="string">&quot;file_name&quot;</span>: file, <span class="string">&quot;width&quot;</span>: res[<span class="number">0</span>][<span class="number">0</span>], <span class="string">&quot;height&quot;</span>: res[<span class="number">0</span>][<span class="number">1</span>], <span class="string">&quot;id&quot;</span>: idx1&#125;)</span><br><span class="line">                        <span class="keyword">for</span> b <span class="keyword">in</span> res[<span class="number">1</span>]:</span><br><span class="line">                            dx1 += <span class="number">1</span></span><br><span class="line">                            x = b[<span class="number">0</span>]</span><br><span class="line">                            y = b[<span class="number">1</span>]</span><br><span class="line">                            w = b[<span class="number">2</span>] - b[<span class="number">0</span>]</span><br><span class="line">                            h = b[<span class="number">3</span>] - b[<span class="number">1</span>]</span><br><span class="line">                            train_content[<span class="string">&#x27;annotations&#x27;</span>].append(</span><br><span class="line">                                &#123;<span class="string">&quot;area&quot;</span>: w * h, <span class="string">&quot;iscrowd&quot;</span>: <span class="number">0</span>, <span class="string">&quot;image_id&quot;</span>: idx1, <span class="string">&quot;bbox&quot;</span>: [x, y, w, h],</span><br><span class="line">                                 <span class="string">&quot;category_id&quot;</span>: classes[b[<span class="number">4</span>]], <span class="string">&quot;id&quot;</span>: dx1, <span class="string">&quot;segmentation&quot;</span>: []&#125;)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        idx2 += <span class="number">1</span></span><br><span class="line">                        sh.copy(os.path.join(image_root, file), val_root)</span><br><span class="line">                        val_content[<span class="string">&#x27;images&#x27;</span>].append(</span><br><span class="line">                            &#123;<span class="string">&quot;file_name&quot;</span>: file, <span class="string">&quot;width&quot;</span>: res[<span class="number">0</span>][<span class="number">0</span>], <span class="string">&quot;height&quot;</span>: res[<span class="number">0</span>][<span class="number">1</span>], <span class="string">&quot;id&quot;</span>: idx2&#125;)</span><br><span class="line">                        <span class="keyword">for</span> b <span class="keyword">in</span> res[<span class="number">1</span>]:</span><br><span class="line">                            dx2 += <span class="number">1</span></span><br><span class="line">                            x = b[<span class="number">0</span>]</span><br><span class="line">                            y = b[<span class="number">1</span>]</span><br><span class="line">                            w = b[<span class="number">2</span>] - b[<span class="number">0</span>]</span><br><span class="line">                            h = b[<span class="number">3</span>] - b[<span class="number">1</span>]</span><br><span class="line">                            val_content[<span class="string">&#x27;annotations&#x27;</span>].append(</span><br><span class="line">                                &#123;<span class="string">&quot;area&quot;</span>: w * h, <span class="string">&quot;iscrowd&quot;</span>: <span class="number">0</span>, <span class="string">&quot;image_id&quot;</span>: idx2, <span class="string">&quot;bbox&quot;</span>: [x, y, w, h],</span><br><span class="line">                                 <span class="string">&quot;category_id&quot;</span>: classes[b[<span class="number">4</span>]], <span class="string">&quot;id&quot;</span>: dx2, <span class="string">&quot;segmentation&quot;</span>: []&#125;)</span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> classes.items():</span><br><span class="line">                train_content[<span class="string">&#x27;categories&#x27;</span>].append(&#123;<span class="string">&quot;supercategory&quot;</span>: <span class="string">&quot;none&quot;</span>, <span class="string">&quot;id&quot;</span>: j, <span class="string">&quot;name&quot;</span>: i&#125;)</span><br><span class="line">                val_content[<span class="string">&#x27;categories&#x27;</span>].append(&#123;<span class="string">&quot;supercategory&quot;</span>: <span class="string">&quot;none&quot;</span>, <span class="string">&quot;id&quot;</span>: j, <span class="string">&quot;name&quot;</span>: i&#125;)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(ann_root, train_json), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                json.dump(train_content, f)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(ann_root, val_json), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                json.dump(val_content, f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number of Train Images:&quot;</span>, <span class="built_in">len</span>(os.listdir(train_root)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Number of Val Images:&quot;</span>, <span class="built_in">len</span>(os.listdir(val_root)))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    box_root = <span class="string">&quot;E:/MyProject/Dataset/hwtest/annotations&quot;</span> <span class="comment">#xml文件夹</span></span><br><span class="line">    image_root = <span class="string">&quot;E:/MyProject/Dataset/hwtest/images&quot;</span> <span class="comment">#image文件夹</span></span><br><span class="line">    output_root = <span class="string">&quot;E:/MyProject/Dataset/coco&quot;</span> <span class="comment">#输出文件夹</span></span><br><span class="line">    classes = &#123;<span class="string">&quot;liner&quot;</span>: <span class="number">0</span>,<span class="string">&quot;bulk carrier&quot;</span>: <span class="number">1</span>,<span class="string">&quot;warship&quot;</span>: <span class="number">2</span>,<span class="string">&quot;sailboat&quot;</span>: <span class="number">3</span>,<span class="string">&quot;canoe&quot;</span>: <span class="number">4</span>,<span class="string">&quot;container ship&quot;</span>: <span class="number">5</span>,<span class="string">&quot;fishing boat&quot;</span>: <span class="number">6</span>&#125; <span class="comment">#类别字典</span></span><br><span class="line">    errorId = [] <span class="comment">#脏数据id</span></span><br><span class="line">    train_percent = <span class="number">0.9</span> <span class="comment">#训练集和验证集比例</span></span><br><span class="line">    tococo(box_root, image_root, output_root,classes=classes,errorId=errorId,train_percent=train_percent)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><h1 id="2-VOC"><a href="#2-VOC" class="headerlink" title="2. VOC"></a>2. VOC</h1><h2 id="2-1-VOC数据集格式"><a href="#2-1-VOC数据集格式" class="headerlink" title="2.1 VOC数据集格式"></a>2.1 VOC数据集格式</h2><p>VOC（Visual Object Classes）数据集来源于PASCAL VOC挑战赛，其主要任务有<code>Object Classification</code> 、<code>Object Detection</code>、<code>Object Segmentation</code>、<code>Human Layout</code>、<code>Action Classification</code>。其官网为<a href="http://host.robots.ox.ac.uk/pascal/VOC/">The PASCAL Visual Object Classes Homepage (ox.ac.uk)</a>。其主要数据集有VOC2007以及VOC2012。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202109111939729.png" alt="image-20210911193933398"></p><p>VOC数据集主要包含图像（jpg或者png等等）和标注文件（xml），其数据集格式如下(<code>/</code>代表文件夹)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-VOC/</span><br><span class="line">|-JPEGImages/</span><br><span class="line">|-1.jpg</span><br><span class="line">|-2.jpg</span><br><span class="line">|-Annotations/</span><br><span class="line">|-1.xml</span><br><span class="line">|-2.xml</span><br><span class="line">|-ImageSets/</span><br><span class="line">|-Layout/</span><br><span class="line">|-*.txt</span><br><span class="line">|-Main/</span><br><span class="line">|-train.txt</span><br><span class="line">|-val.txt</span><br><span class="line">|-trainval.txt</span><br><span class="line">|-test.txt</span><br><span class="line">|-Segmentation/</span><br><span class="line">|-*.txt</span><br><span class="line">|-Action/</span><br><span class="line">|-*.txt</span><br><span class="line">|-SegmentationClass/</span><br><span class="line">|-SegmentationObject/</span><br></pre></td></tr></table></figure><p>其中对于目标检测任务而言，最常用的以及必须的文件夹包括：<code>JPEGImages</code>，<code>Annotations</code>，<code>ImageSets/Main</code>。</p><p><code>JPEGImages</code>里存放的是图像，而<code>Annotations</code>里存放的是<code>xml</code>标注文件，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;annotation&gt;</span><br><span class="line">&lt;folder&gt;VOC&lt;/folder&gt;            # 图像所在文件夹</span><br><span class="line">&lt;filename&gt;000032.jpg&lt;/filename&gt; # 图像文件名</span><br><span class="line">&lt;source&gt;                        # 图像源</span><br><span class="line">&lt;database&gt;The VOC Database&lt;/database&gt;</span><br><span class="line">&lt;annotation&gt;PASCAL VOC&lt;/annotation&gt;</span><br><span class="line">&lt;image&gt;flickr&lt;/image&gt;</span><br><span class="line">&lt;/source&gt;</span><br><span class="line">&lt;size&gt;                          # 图像尺寸信息</span><br><span class="line">&lt;width&gt;500&lt;/width&gt;    # 图像宽度</span><br><span class="line">&lt;height&gt;281&lt;/height&gt;  # 图像高度</span><br><span class="line">&lt;depth&gt;3&lt;/depth&gt;      # 图像通道数</span><br><span class="line">&lt;/size&gt;</span><br><span class="line">&lt;segmented&gt;0&lt;/segmented&gt;  # 图像是否用于分割，0代表不适用，对目标检测而言没关系</span><br><span class="line">&lt;object&gt;                  # 一个目标对象的信息</span><br><span class="line">&lt;name&gt;aeroplane&lt;/name&gt;    # 目标的类别名</span><br><span class="line">&lt;pose&gt;Frontal&lt;/pose&gt;      # 拍摄角度，若无一般为Unspecified</span><br><span class="line">&lt;truncated&gt;0&lt;/truncated&gt;  # 是否被截断，0表示完整未截断</span><br><span class="line">&lt;difficult&gt;0&lt;/difficult&gt;  # 是否难以识别，0表示不难识别</span><br><span class="line">&lt;bndbox&gt;            # 边界框信息</span><br><span class="line">&lt;xmin&gt;104&lt;/xmin&gt;  # 左上角x</span><br><span class="line">&lt;ymin&gt;78&lt;/ymin&gt;   # 左上角y</span><br><span class="line">&lt;xmax&gt;375&lt;/xmax&gt;  # 右下角x</span><br><span class="line">&lt;ymax&gt;183&lt;/ymax&gt;  # 右下角y</span><br><span class="line">&lt;/bndbox&gt;</span><br><span class="line">&lt;/object&gt;</span><br><span class="line">    # 下面是其他目标的信息，这里略掉</span><br><span class="line">&lt;object&gt;</span><br><span class="line">        其他object信息，这里省略</span><br><span class="line">&lt;/object&gt;</span><br><span class="line">&lt;/annotation&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2-VOC转换脚本"><a href="#2-2-VOC转换脚本" class="headerlink" title="2.2 VOC转换脚本"></a>2.2 VOC转换脚本</h2><p>下面这个脚本，只适用于有图像和xml文件的情况下，coco转voc格式以后有需要再写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author    : justlovesmile</span></span><br><span class="line"><span class="comment"># @Date      : 2021/9/8 21:01</span></span><br><span class="line"><span class="keyword">import</span> os,random</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> shutil <span class="keyword">as</span> sh</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.mkdir(path)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;The path (<span class="subst">&#123;path&#125;</span>) already exists.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tovoc</span>(<span class="params">xmlroot,imgroot,saveroot,errorId=[],classes=&#123;&#125;,tvp=<span class="number">1.0</span>,trp=<span class="number">0.9</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        root：数据集存放根目录</span></span><br><span class="line"><span class="string">    功能：</span></span><br><span class="line"><span class="string">        加载数据，并保存为VOC格式</span></span><br><span class="line"><span class="string">    加载后的格式：</span></span><br><span class="line"><span class="string">    VOC/</span></span><br><span class="line"><span class="string">      Annotations/</span></span><br><span class="line"><span class="string">        - **.xml</span></span><br><span class="line"><span class="string">      JPEGImages/</span></span><br><span class="line"><span class="string">        - **.jpg</span></span><br><span class="line"><span class="string">      ImageSets/</span></span><br><span class="line"><span class="string">        Main/</span></span><br><span class="line"><span class="string">          - train.txt</span></span><br><span class="line"><span class="string">          - test.txt</span></span><br><span class="line"><span class="string">          - val.txt</span></span><br><span class="line"><span class="string">          - trainval.txt</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># assert</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(classes)&gt;<span class="number">0</span></span><br><span class="line">    <span class="comment"># init path</span></span><br><span class="line">    VOC = saveroot</span><br><span class="line">    ann_path = os.path.join(VOC, <span class="string">&#x27;Annotations&#x27;</span>)</span><br><span class="line">    img_path = os.path.join(VOC,<span class="string">&#x27;JPEGImages&#x27;</span>)</span><br><span class="line">    set_path = os.path.join(VOC,<span class="string">&#x27;ImageSets&#x27;</span>)</span><br><span class="line">    txt_path = os.path.join(set_path,<span class="string">&#x27;Main&#x27;</span>)</span><br><span class="line">    <span class="comment"># mkdirs </span></span><br><span class="line">    <span class="keyword">if</span> mkdir(VOC):</span><br><span class="line">        <span class="keyword">if</span> mkdir(ann_path) <span class="keyword">and</span> mkdir(img_path) <span class="keyword">and</span> mkdir(set_path):</span><br><span class="line">            mkdir(txt_path)</span><br><span class="line"></span><br><span class="line">    images = os.listdir(imgroot)</span><br><span class="line">    list_index = <span class="built_in">range</span>(<span class="built_in">len</span>(images))</span><br><span class="line">    <span class="comment">#test and trainval set</span></span><br><span class="line">    trainval_percent = tvp</span><br><span class="line">    train_percent = trp</span><br><span class="line">    val_percent = <span class="number">1</span> - train_percent <span class="keyword">if</span> train_percent&lt;<span class="number">1</span> <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">    total_num = <span class="built_in">len</span>(images)</span><br><span class="line">    trainval_num = <span class="built_in">int</span>(total_num*trainval_percent)</span><br><span class="line">    train_num = <span class="built_in">int</span>(trainval_num*train_percent)</span><br><span class="line">    val_num = <span class="built_in">int</span>(trainval_num*val_percent) <span class="keyword">if</span> train_percent&lt;<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    trainval = random.sample(list_index,trainval_num)</span><br><span class="line">    train = random.sample(list_index,train_num)</span><br><span class="line">    val = random.sample(list_index,val_num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(list_index):</span><br><span class="line">        imgfile = images[i]</span><br><span class="line">        img_id = os.path.splitext(os.path.basename(imgfile))[<span class="number">0</span>]</span><br><span class="line">        xmlfile = img_id+<span class="string">&quot;.xml&quot;</span></span><br><span class="line">        sh.copy(os.path.join(imgroot,imgfile),os.path.join(img_path,imgfile))</span><br><span class="line">        sh.copy(os.path.join(xmlroot,xmlfile),os.path.join(ann_path,xmlfile))</span><br><span class="line">        <span class="keyword">if</span> img_id <span class="keyword">not</span> <span class="keyword">in</span> errorId:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(txt_path,<span class="string">&#x27;trainval.txt&#x27;</span>),<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(img_id+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(txt_path,<span class="string">&#x27;train.txt&#x27;</span>),<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write(img_id+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(txt_path,<span class="string">&#x27;val.txt&#x27;</span>),<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write(img_id+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> train_percent==<span class="number">1</span> <span class="keyword">and</span> i <span class="keyword">in</span> val:</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(txt_path,<span class="string">&#x27;val.txt&#x27;</span>),<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write(img_id+<span class="string">&#x27;\n&#x27;</span>)          </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(txt_path,<span class="string">&#x27;test.txt&#x27;</span>),<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(img_id+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># end</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Dataset to VOC format finished!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    box_root = <span class="string">&quot;E:/MyProject/Dataset/hwtest/annotations&quot;</span></span><br><span class="line">    image_root = <span class="string">&quot;E:/MyProject/Dataset/hwtest/images&quot;</span></span><br><span class="line">    output_root = <span class="string">&quot;E:/MyProject/Dataset/voc&quot;</span></span><br><span class="line">    classes = &#123;<span class="string">&quot;liner&quot;</span>: <span class="number">0</span>,<span class="string">&quot;bulk carrier&quot;</span>: <span class="number">1</span>,<span class="string">&quot;warship&quot;</span>: <span class="number">2</span>,<span class="string">&quot;sailboat&quot;</span>: <span class="number">3</span>,<span class="string">&quot;canoe&quot;</span>: <span class="number">4</span>,<span class="string">&quot;container ship&quot;</span>: <span class="number">5</span>,<span class="string">&quot;fishing boat&quot;</span>: <span class="number">6</span>&#125;</span><br><span class="line">    errorId = []</span><br><span class="line">    train_percent = <span class="number">0.9</span></span><br><span class="line">    tovoc(box_root,image_root,output_root,errorId,classes,trp=train_percent)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><h1 id="3-YOLO"><a href="#3-YOLO" class="headerlink" title="3. YOLO"></a>3. YOLO</h1><h2 id="3-1-YOLO数据集格式"><a href="#3-1-YOLO数据集格式" class="headerlink" title="3.1 YOLO数据集格式"></a>3.1 YOLO数据集格式</h2><p><code>YOLO</code>数据集格式的出现主要是为了训练<code>YOLO</code>模型，其文件格式没有固定的要求，因为可以通过修改模型的配置文件进行数据加载，唯一需要注意的是<code>YOLO</code>数据集的标注格式是将目标框的位置信息进行归一化处理（此处归一化指的是除以图片宽和高），如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;目标类别&#125; &#123;归一化后的目标中心点x坐标&#125; &#123;归一化后的目标中心点y坐标&#125; &#123;归一化后的目标框宽度w&#125; &#123;归一化后的目标框高度h&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-YOLO转换脚本"><a href="#3-2-YOLO转换脚本" class="headerlink" title="3.2 YOLO转换脚本"></a>3.2 YOLO转换脚本</h2><p><code>Python</code>转换脚本如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author    : justlovesmile</span></span><br><span class="line"><span class="comment"># @Date      : 2021/9/8 20:28</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> shutil <span class="keyword">as</span> sh</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> xml.etree.cElementTree <span class="keyword">as</span> et</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> et</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;The path (<span class="subst">&#123;path&#125;</span>) already exists.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xml2yolo</span>(<span class="params">xmlpath,savepath,classes=&#123;&#125;</span>):</span></span><br><span class="line">    namemap = classes</span><br><span class="line">    <span class="comment">#try:</span></span><br><span class="line">    <span class="comment">#    with open(&#x27;classes_yolo.json&#x27;,&#x27;r&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#        namemap=json.load(f)</span></span><br><span class="line">    <span class="comment">#except:</span></span><br><span class="line">    <span class="comment">#    pass</span></span><br><span class="line">    rt = et.parse(xmlpath).getroot()</span><br><span class="line">    w = <span class="built_in">int</span>(rt.find(<span class="string">&quot;size&quot;</span>).find(<span class="string">&quot;width&quot;</span>).text)</span><br><span class="line">    h = <span class="built_in">int</span>(rt.find(<span class="string">&quot;size&quot;</span>).find(<span class="string">&quot;height&quot;</span>).text)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(savepath, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> rt.findall(<span class="string">&quot;object&quot;</span>):</span><br><span class="line">            name = obj.find(<span class="string">&quot;name&quot;</span>).text</span><br><span class="line">            xmin = <span class="built_in">int</span>(obj.find(<span class="string">&quot;bndbox&quot;</span>).find(<span class="string">&quot;xmin&quot;</span>).text)</span><br><span class="line">            ymin = <span class="built_in">int</span>(obj.find(<span class="string">&quot;bndbox&quot;</span>).find(<span class="string">&quot;ymin&quot;</span>).text)</span><br><span class="line">            xmax = <span class="built_in">int</span>(obj.find(<span class="string">&quot;bndbox&quot;</span>).find(<span class="string">&quot;xmax&quot;</span>).text)</span><br><span class="line">            ymax = <span class="built_in">int</span>(obj.find(<span class="string">&quot;bndbox&quot;</span>).find(<span class="string">&quot;ymax&quot;</span>).text)</span><br><span class="line">            f.write(</span><br><span class="line">                <span class="string">f&quot;<span class="subst">&#123;namemap[name]&#125;</span> <span class="subst">&#123;(xmin+xmax)/w/<span class="number">2.</span>&#125;</span> <span class="subst">&#123;(ymin+ymax)/h/<span class="number">2.</span>&#125;</span> <span class="subst">&#123;(xmax-xmin)/w&#125;</span> <span class="subst">&#123;(ymax-ymin)/h&#125;</span>&quot;</span></span><br><span class="line">                + <span class="string">&quot;\n&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainval</span>(<span class="params">xmlroot,imgroot,saveroot,errorId=[],classes=&#123;&#125;,tvp=<span class="number">1.0</span>,trp=<span class="number">0.9</span></span>):</span></span><br><span class="line">    <span class="comment"># assert</span></span><br><span class="line">    <span class="keyword">assert</span> tvp&lt;=<span class="number">1.0</span> <span class="keyword">and</span> trp &lt;=<span class="number">1.0</span> <span class="keyword">and</span> <span class="built_in">len</span>(classes)&gt;<span class="number">0</span></span><br><span class="line">    <span class="comment"># create dirs</span></span><br><span class="line">    imglabel = [<span class="string">&#x27;images&#x27;</span>,<span class="string">&#x27;labels&#x27;</span>]</span><br><span class="line">    trainvaltest = [<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;val&#x27;</span>,<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line">    mkdir(saveroot)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> imglabel:</span><br><span class="line">        mkdir(os.path.join(saveroot,r))</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> trainvaltest:</span><br><span class="line">            mkdir(os.path.join(saveroot,r,s))</span><br><span class="line">    <span class="comment">#train / val</span></span><br><span class="line">    trainval_percent = tvp</span><br><span class="line">    train_percent = trp</span><br><span class="line">    val_percent = <span class="number">1</span> - train_percent <span class="keyword">if</span> train_percent&lt;<span class="number">1.0</span> <span class="keyword">else</span> <span class="number">0.15</span></span><br><span class="line">    </span><br><span class="line">    total_img = os.listdir(imgroot)</span><br><span class="line">    num = <span class="built_in">len</span>(total_img)</span><br><span class="line">    list_index = <span class="built_in">range</span>(num)</span><br><span class="line">    tv = <span class="built_in">int</span>(num * trainval_percent)</span><br><span class="line">    tr = <span class="built_in">int</span>(tv * train_percent)</span><br><span class="line">    va = <span class="built_in">int</span>(tv * val_percent)</span><br><span class="line">    trainval = random.sample(list_index, tv) <span class="comment"># trainset and valset</span></span><br><span class="line">    train = random.sample(trainval, tr) <span class="comment"># trainset</span></span><br><span class="line">    val = random.sample(trainval, va) <span class="comment">#valset, use it only when train_percent = 1 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;trainval_percent:<span class="subst">&#123;trainval_percent&#125;</span>,train_percent:<span class="subst">&#123;train_percent&#125;</span>,val_percent:<span class="subst">&#123;val_percent&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(list_index):</span><br><span class="line">        name = total_img[i]</span><br><span class="line">        op = os.path.join(imgroot,name)</span><br><span class="line">        file_id = os.path.splitext(os.path.basename(name))[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> file_id <span class="keyword">not</span> <span class="keyword">in</span> errorId:</span><br><span class="line">            xmlp = os.path.join(xmlroot,file_id+<span class="string">&#x27;.xml&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line">                <span class="comment"># trainset and valset</span></span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line">                    sp = os.path.join(saveroot,<span class="string">&quot;images&quot;</span>,<span class="string">&quot;train&quot;</span>,name)</span><br><span class="line">                    xml2yolo(xmlp,os.path.join(saveroot,<span class="string">&quot;labels&quot;</span>,<span class="string">&quot;train&quot;</span>,file_id+<span class="string">&#x27;.txt&#x27;</span>),classes)</span><br><span class="line">                    sh.copy(op,sp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sp = os.path.join(saveroot,<span class="string">&quot;images&quot;</span>,<span class="string">&quot;val&quot;</span>,name)</span><br><span class="line">                    xml2yolo(xmlp,os.path.join(saveroot,<span class="string">&quot;labels&quot;</span>,<span class="string">&quot;val&quot;</span>,file_id+<span class="string">&#x27;.txt&#x27;</span>),classes)</span><br><span class="line">                    sh.copy(op,sp)</span><br><span class="line">                <span class="keyword">if</span> (train_percent==<span class="number">1.0</span> <span class="keyword">and</span> i <span class="keyword">in</span> val):</span><br><span class="line">                    sp = os.path.join(saveroot,<span class="string">&quot;images&quot;</span>,<span class="string">&quot;val&quot;</span>,name)</span><br><span class="line">                    xml2yolo(xmlp,os.path.join(saveroot,<span class="string">&quot;labels&quot;</span>,<span class="string">&quot;val&quot;</span>,file_id+<span class="string">&#x27;.txt&#x27;</span>),classes)</span><br><span class="line">                    sh.copy(op,sp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># testset</span></span><br><span class="line">                sp = os.path.join(saveroot,<span class="string">&quot;images&quot;</span>,<span class="string">&quot;test&quot;</span>,name)</span><br><span class="line">                xml2yolo(xmlp,os.path.join(saveroot,<span class="string">&quot;labels&quot;</span>,<span class="string">&quot;test&quot;</span>,file_id+<span class="string">&#x27;.txt&#x27;</span>),classes)</span><br><span class="line">                sh.copy(op,sp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maketxt</span>(<span class="params"><span class="built_in">dir</span>,saveroot,filename</span>):</span></span><br><span class="line">    savetxt = os.path.join(saveroot,filename)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(savetxt,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(os.listdir(<span class="built_in">dir</span>)):</span><br><span class="line">            f.write(os.path.join(<span class="built_in">dir</span>,i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                           </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toyolo</span>(<span class="params">xmlroot,imgroot,saveroot,errorId=[],classes=&#123;&#125;,tvp=<span class="number">1</span>,train_percent=<span class="number">0.9</span></span>):</span></span><br><span class="line">    <span class="comment"># toyolo main function</span></span><br><span class="line">    trainval(xmlroot,imgroot,saveroot,errorId,classes,tvp,train_percent)</span><br><span class="line">    maketxt(os.path.join(saveroot,<span class="string">&quot;images&quot;</span>,<span class="string">&quot;train&quot;</span>),saveroot,<span class="string">&quot;train.txt&quot;</span>)</span><br><span class="line">    maketxt(os.path.join(saveroot,<span class="string">&quot;images&quot;</span>,<span class="string">&quot;val&quot;</span>),saveroot,<span class="string">&quot;val.txt&quot;</span>)</span><br><span class="line">    maketxt(os.path.join(saveroot,<span class="string">&quot;images&quot;</span>,<span class="string">&quot;test&quot;</span>),saveroot,<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Dataset to yolo format success.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    box_root = <span class="string">&quot;E:/MyProject/Dataset/hwtest/annotations&quot;</span></span><br><span class="line">    image_root = <span class="string">&quot;E:/MyProject/Dataset/hwtest/images&quot;</span></span><br><span class="line">    output_root = <span class="string">&quot;E:/MyProject/Dataset/yolo&quot;</span></span><br><span class="line">    classes = &#123;<span class="string">&quot;liner&quot;</span>: <span class="number">0</span>,<span class="string">&quot;bulk carrier&quot;</span>: <span class="number">1</span>,<span class="string">&quot;warship&quot;</span>: <span class="number">2</span>,<span class="string">&quot;sailboat&quot;</span>: <span class="number">3</span>,<span class="string">&quot;canoe&quot;</span>: <span class="number">4</span>,<span class="string">&quot;container ship&quot;</span>: <span class="number">5</span>,<span class="string">&quot;fishing boat&quot;</span>: <span class="number">6</span>&#125;</span><br><span class="line">    errorId = []</span><br><span class="line">    train_percent = <span class="number">0.9</span></span><br><span class="line">    toyolo(box_root,image_root,output_root,errorId,classes,train_percent=train_percent)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>按照此脚本，将会在输出文件夹中生成以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-yolo/</span><br><span class="line">|-images/</span><br><span class="line">|-train/</span><br><span class="line">|-1.jpg</span><br><span class="line">|-2.jpg</span><br><span class="line">|-test/</span><br><span class="line">|-3.jpg</span><br><span class="line">|-4.jpg</span><br><span class="line">|-val/</span><br><span class="line">|-5.jpg</span><br><span class="line">|-6.jpg</span><br><span class="line">|-labels/</span><br><span class="line">|-train/</span><br><span class="line">|-1.txt</span><br><span class="line">|-2.txt</span><br><span class="line">|-test/</span><br><span class="line">|-3.txt</span><br><span class="line">|-4.txt</span><br><span class="line">|-val/</span><br><span class="line">|-5.txt</span><br><span class="line">|-6.txt</span><br><span class="line">|-train.txt</span><br><span class="line">|-test.txt</span><br><span class="line">|-val.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">目标检测是计算机视觉任务中的一个重要研究方向，是计算机视觉的根本性问题之一，是其他诸多计算机视觉任务的基础以及前提。本文主要介绍了目标检测数据集的几种标注格式和转换代码。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="目标检测" scheme="https://blog.justlovesmile.top/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    <category term="python" scheme="https://blog.justlovesmile.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客 | 动态分类标签条，自动获取全站分类与标签进行展示</title>
    <link href="https://blog.justlovesmile.top/posts/2bfb1caa.html"/>
    <id>https://blog.justlovesmile.top/posts/2bfb1caa.html</id>
    <published>2021-08-14T13:10:23.000Z</published>
    <updated>2021-08-14T13:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>本文是对Heo博主写的<a href="https://blog.zhheo.com/p/bc61964d.html">Butterfly魔改：动态分类条，可以根据页面变化而改变的分类列表展示方式</a>文章的补充，增加了动态标签条，并且可以自动获取全站分类和标签名称。</p><h1 id="2-预览"><a href="#2-预览" class="headerlink" title="2. 预览"></a>2. 预览</h1><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202108142116064.png" alt="image-20210814211626863"></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202108142121159.png" alt="image-20210814212127747"></p><h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h1><h2 id="3-1-新建PUG文件"><a href="#3-1-新建PUG文件" class="headerlink" title="3.1 新建PUG文件"></a>3.1 新建PUG文件</h2><p>首先是分类条，在<code>themes/butterfly/layout/includes/</code>处新建文件<code>categoryBar.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#category-bar</span><br><span class="line">  .category-bar-items#category-bar-items</span><br><span class="line">    !=getarray_bar(&quot;category&quot;)</span><br><span class="line">  a.category-bar-more(href=&quot;/categories/&quot;) 更多</span><br></pre></td></tr></table></figure><p>其次是标签条，在<code>themes/butterfly/layout/includes/</code>处新建文件<code>tagBar.pug</code>，因为样式一样，所以没有更改id和class名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#category-bar</span><br><span class="line">  .category-bar-items#category-bar-items</span><br><span class="line">    !=getarray_bar(&quot;tag&quot;)</span><br><span class="line">  a.category-bar-more(href=&quot;/tags/&quot;) 更多</span><br></pre></td></tr></table></figure><h2 id="3-2-新建Hexo辅助函数"><a href="#3-2-新建Hexo辅助函数" class="headerlink" title="3.2 新建Hexo辅助函数"></a>3.2 新建Hexo辅助函数</h2><p>在<code>theme/butterfly/scripts/helpers/</code>中创建<code>get_arrays.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">hexo.extend.helper.register(<span class="string">&#x27;getarray_bar&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">types</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!types) &#123;</span><br><span class="line">    types = <span class="string">&quot;category&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> categoriesBar = <span class="function"><span class="keyword">function</span> (<span class="params">categories</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!categories || !categories.length) <span class="keyword">return</span> <span class="string">``</span></span><br><span class="line">    <span class="keyword">const</span> categoryArr = []</span><br><span class="line">    hexo.locals.get(<span class="string">&#x27;categories&#x27;</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">category</span>) </span>&#123;</span><br><span class="line">      categoryArr.push(&#123; <span class="attr">name</span>: category.name, <span class="attr">value</span>: category.length &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    categoryArr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> b.value - a.value &#125;)</span><br><span class="line">    <span class="keyword">let</span> strCategoriesBar = <span class="string">``</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; categories.length; i++) &#123;</span><br><span class="line">      strTemp=<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;category-bar-item&quot; id=&quot;<span class="subst">$&#123;categoryArr[i].name&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a href=&quot;/categories/<span class="subst">$&#123;categoryArr[i].name&#125;</span>/&quot;&gt;<span class="subst">$&#123;categoryArr[i].name&#125;</span>&lt;/a&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;`</span></span><br><span class="line">      strCategoriesBar+=strTemp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strCategoriesBar</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tagsBar = <span class="function"><span class="keyword">function</span>(<span class="params">tags</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tags || !tags.length) <span class="keyword">return</span> <span class="string">``</span></span><br><span class="line">    <span class="keyword">const</span> tagArr = []</span><br><span class="line">    hexo.locals.get(<span class="string">&#x27;tags&#x27;</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</span><br><span class="line">      tagArr.push(&#123; <span class="attr">name</span>: tag.name, <span class="attr">value</span>: tag.length &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    tagArr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> b.value - a.value &#125;)</span><br><span class="line">    <span class="keyword">let</span> strTagsBar = <span class="string">``</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tags.length; i++) &#123;</span><br><span class="line">      strTemp=<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;category-bar-item&quot; id=&quot;<span class="subst">$&#123;tagArr[i].name&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a href=&quot;/tags/<span class="subst">$&#123;tagArr[i].name&#125;</span>/&quot;&gt;<span class="subst">$&#123;tagArr[i].name&#125;</span>&lt;/a&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;`</span></span><br><span class="line">      strTagsBar+=strTemp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strTagsBar</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (types == <span class="string">&quot;category&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> categoriesBar(<span class="built_in">this</span>.site.categories)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (types == <span class="string">&quot;tag&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> tagsBar(<span class="built_in">this</span>.site.tags)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-3-引用模块"><a href="#3-3-引用模块" class="headerlink" title="3.3 引用模块"></a>3.3 引用模块</h2><p>在需要的位置引用该模块，例如：</p><p>在分类页面引用：找到<code>theme/butterfly/layout/category.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  if theme.category_ui == &#x27;index&#x27;</span><br><span class="line">    include ./includes/mixins/post-ui.pug</span><br><span class="line">    #recent-posts.recent-posts.category_ui   </span><br><span class="line">      +postUI</span><br><span class="line">      include includes/pagination.pug    </span><br><span class="line">  else</span><br><span class="line">    include ./includes/mixins/article-sort.pug</span><br><span class="line">    #category</span><br><span class="line">+      .category-in-bar</span><br><span class="line">+        .category-in-bar-tips</span><br><span class="line">+          i.fa-fw.fas.fa-folder-open</span><br><span class="line">+        include includes/categoryBar.pug</span><br><span class="line">      .article-sort-title= _p(&#x27;page.category&#x27;) + &#x27; - &#x27; + page.category</span><br><span class="line">      +articleSort(page.posts)</span><br><span class="line">      include includes/pagination.pug</span><br></pre></td></tr></table></figure><p>在标签页引用：找到<code>theme/butterfly/layout/tag.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  if theme.tag_ui == &#x27;index&#x27;</span><br><span class="line">    include ./includes/mixins/post-ui.pug</span><br><span class="line">    #recent-posts.recent-posts</span><br><span class="line">      +postUI</span><br><span class="line">      include includes/pagination.pug</span><br><span class="line">  else</span><br><span class="line">    include ./includes/mixins/article-sort.pug</span><br><span class="line">    #tag</span><br><span class="line">+      .category-in-bar</span><br><span class="line">+        .category-in-bar-tips</span><br><span class="line">+          i.fa-fw.fas.fa-tags</span><br><span class="line">+        include includes/tagBar.pug</span><br><span class="line">      .article-sort-title= _p(&#x27;page.tag&#x27;) + &#x27; - &#x27; + page.tag</span><br><span class="line">      +articleSort(page.posts)</span><br><span class="line">      include includes/pagination.pug</span><br></pre></td></tr></table></figure><h1 id="4-引入js和css文件"><a href="#4-引入js和css文件" class="headerlink" title="4. 引入js和css文件"></a>4. 引入js和css文件</h1><p>这一部分和Heo博主的教程<a href="https://blog.zhheo.com/p/bc61964d.html">Butterfly魔改：动态分类条，可以根据页面变化而改变的分类列表展示方式 | 张洪Heo (zhheo.com)</a>一致。</p><p>不过如果添加了标签条，js文件需要增加一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标签条</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tagsBarActive</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> urlinfo = <span class="built_in">window</span>.location.pathname;</span><br><span class="line">  urlinfo = <span class="built_in">decodeURIComponent</span>(urlinfo)</span><br><span class="line">  <span class="comment">//console.log(urlinfo);</span></span><br><span class="line">  <span class="comment">//判断是否是首页</span></span><br><span class="line">  <span class="keyword">if</span> (urlinfo == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#tags-bar&#x27;</span>))&#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">&#x27;首页&#x27;</span>).classList.add(<span class="string">&quot;select&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 验证是否是分类链接</span></span><br><span class="line">    <span class="keyword">var</span> pattern = <span class="regexp">/\/tags\/.*?\//</span>;</span><br><span class="line">    <span class="keyword">var</span> patbool = pattern.test(urlinfo);</span><br><span class="line">    <span class="comment">//console.log(patbool);</span></span><br><span class="line">    <span class="comment">// 获取当前的标签</span></span><br><span class="line">    <span class="keyword">if</span> (patbool) &#123;</span><br><span class="line">      <span class="keyword">var</span> valuegroup = urlinfo.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">      <span class="comment">//console.log(valuegroup[2]);</span></span><br><span class="line">      <span class="comment">// 获取当前分类</span></span><br><span class="line">      <span class="keyword">var</span> nowTag = valuegroup[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#category-bar&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(nowTag).classList.add(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">tagsBarActive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h1&gt;&lt;p&gt;本文是对Heo博主写的&lt;a href=&quot;https://blog.zhheo.com/p/bc61964d.html&quot;&gt;</summary>
      
    
    
    
    <category term="博客相关" scheme="https://blog.justlovesmile.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Hexo" scheme="https://blog.justlovesmile.top/tags/Hexo/"/>
    
    <category term="前端" scheme="https://blog.justlovesmile.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客 | 如何让你的博客拥有星空背景和流星特效</title>
    <link href="https://blog.justlovesmile.top/posts/6a260bf6.html"/>
    <id>https://blog.justlovesmile.top/posts/6a260bf6.html</id>
    <published>2021-08-12T09:41:33.000Z</published>
    <updated>2021-08-12T09:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近很多小伙伴留言想要<code>星空和流星特效</code>，于是写了这篇文章准备介绍如何部署。</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202108121834269.gif"></p></blockquote><h2 id="1-插入Canvas标签"><a href="#1-插入Canvas标签" class="headerlink" title="1. 插入Canvas标签"></a>1. 插入Canvas标签</h2><p>首先打开Butterfly主题的<code>_config.yml</code>文件或者使用HTML直接插入，找到配置文件对应的<code>inject</code>部分，插入<code>&lt;canvas id=&quot;universe&quot;&gt;&lt;/canvas&gt;</code></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202108121759902.png" alt="image-20210812175952760"></p><h2 id="2-创建JS文件"><a href="#2-创建JS文件" class="headerlink" title="2. 创建JS文件"></a>2. 创建JS文件</h2><p>在<code>butterfly/source/js/</code>创建一个<code>universe.js</code>文件，或者添加到自己的<code>js</code>文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dark</span>(<span class="params"></span>) </span>&#123;<span class="built_in">window</span>.requestAnimationFrame=<span class="built_in">window</span>.requestAnimationFrame||<span class="built_in">window</span>.mozRequestAnimationFrame||<span class="built_in">window</span>.webkitRequestAnimationFrame||<span class="built_in">window</span>.msRequestAnimationFrame;<span class="keyword">var</span> n,e,i,h,t=<span class="number">.05</span>,s=<span class="built_in">document</span>.getElementById(<span class="string">&quot;universe&quot;</span>),o=!<span class="number">0</span>,a=<span class="string">&quot;180,184,240&quot;</span>,r=<span class="string">&quot;226,225,142&quot;</span>,d=<span class="string">&quot;226,225,224&quot;</span>,c=[];<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;n=<span class="built_in">window</span>.innerWidth,e=<span class="built_in">window</span>.innerHeight,i=<span class="number">.216</span>*n,s.setAttribute(<span class="string">&quot;width&quot;</span>,n),s.setAttribute(<span class="string">&quot;height&quot;</span>,e)&#125;<span class="function"><span class="keyword">function</span> <span class="title">u</span>(<span class="params"></span>)</span>&#123;h.clearRect(<span class="number">0</span>,<span class="number">0</span>,n,e);<span class="keyword">for</span>(<span class="keyword">var</span> t=c.length,i=<span class="number">0</span>;i&lt;t;i++)&#123;<span class="keyword">var</span> s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>)</span>&#123;<span class="built_in">this</span>.reset=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">this</span>.giant=m(<span class="number">3</span>),<span class="built_in">this</span>.comet=!<span class="built_in">this</span>.giant&amp;&amp;!o&amp;&amp;m(<span class="number">10</span>),<span class="built_in">this</span>.x=l(<span class="number">0</span>,n-<span class="number">10</span>),<span class="built_in">this</span>.y=l(<span class="number">0</span>,e),<span class="built_in">this</span>.r=l(<span class="number">1.1</span>,<span class="number">2.6</span>),<span class="built_in">this</span>.dx=l(t,<span class="number">6</span>*t)+(<span class="built_in">this</span>.comet+<span class="number">1</span>-<span class="number">1</span>)*t*l(<span class="number">50</span>,<span class="number">120</span>)+<span class="number">2</span>*t,<span class="built_in">this</span>.dy=-l(t,<span class="number">6</span>*t)-(<span class="built_in">this</span>.comet+<span class="number">1</span>-<span class="number">1</span>)*t*l(<span class="number">50</span>,<span class="number">120</span>),<span class="built_in">this</span>.fadingOut=<span class="literal">null</span>,<span class="built_in">this</span>.fadingIn=!<span class="number">0</span>,<span class="built_in">this</span>.opacity=<span class="number">0</span>,<span class="built_in">this</span>.opacityTresh=l(<span class="number">.2</span>,<span class="number">1</span>-<span class="number">.4</span>*(<span class="built_in">this</span>.comet+<span class="number">1</span>-<span class="number">1</span>)),<span class="built_in">this</span>.do=l(<span class="number">5e-4</span>,<span class="number">.002</span>)+<span class="number">.001</span>*(<span class="built_in">this</span>.comet+<span class="number">1</span>-<span class="number">1</span>)&#125;,<span class="built_in">this</span>.fadeIn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">this</span>.fadingIn&amp;&amp;(<span class="built_in">this</span>.fadingIn=!(<span class="built_in">this</span>.opacity&gt;<span class="built_in">this</span>.opacityTresh),<span class="built_in">this</span>.opacity+=<span class="built_in">this</span>.do)&#125;,<span class="built_in">this</span>.fadeOut=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">this</span>.fadingOut&amp;&amp;(<span class="built_in">this</span>.fadingOut=!(<span class="built_in">this</span>.opacity&lt;<span class="number">0</span>),<span class="built_in">this</span>.opacity-=<span class="built_in">this</span>.do/<span class="number">2</span>,(<span class="built_in">this</span>.x&gt;n||<span class="built_in">this</span>.y&lt;<span class="number">0</span>)&amp;&amp;(<span class="built_in">this</span>.fadingOut=!<span class="number">1</span>,<span class="built_in">this</span>.reset()))&#125;,<span class="built_in">this</span>.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">if</span>(h.beginPath(),<span class="built_in">this</span>.giant)h.fillStyle=<span class="string">&quot;rgba(&quot;</span>+a+<span class="string">&quot;,&quot;</span>+<span class="built_in">this</span>.opacity+<span class="string">&quot;)&quot;</span>,h.arc(<span class="built_in">this</span>.x,<span class="built_in">this</span>.y,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">1</span>);<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.comet)&#123;h.fillStyle=<span class="string">&quot;rgba(&quot;</span>+d+<span class="string">&quot;,&quot;</span>+<span class="built_in">this</span>.opacity+<span class="string">&quot;)&quot;</span>,h.arc(<span class="built_in">this</span>.x,<span class="built_in">this</span>.y,<span class="number">1.5</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">1</span>);<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;<span class="number">30</span>;t++)h.fillStyle=<span class="string">&quot;rgba(&quot;</span>+d+<span class="string">&quot;,&quot;</span>+(<span class="built_in">this</span>.opacity-<span class="built_in">this</span>.opacity/<span class="number">20</span>*t)+<span class="string">&quot;)&quot;</span>,h.rect(<span class="built_in">this</span>.x-<span class="built_in">this</span>.dx/<span class="number">4</span>*t,<span class="built_in">this</span>.y-<span class="built_in">this</span>.dy/<span class="number">4</span>*t-<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),h.fill()&#125;<span class="keyword">else</span> h.fillStyle=<span class="string">&quot;rgba(&quot;</span>+r+<span class="string">&quot;,&quot;</span>+<span class="built_in">this</span>.opacity+<span class="string">&quot;)&quot;</span>,h.rect(<span class="built_in">this</span>.x,<span class="built_in">this</span>.y,<span class="built_in">this</span>.r,<span class="built_in">this</span>.r);h.closePath(),h.fill()&#125;,<span class="built_in">this</span>.move=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">this</span>.x+=<span class="built_in">this</span>.dx,<span class="built_in">this</span>.y+=<span class="built_in">this</span>.dy,!<span class="number">1</span>===<span class="built_in">this</span>.fadingOut&amp;&amp;<span class="built_in">this</span>.reset(),(<span class="built_in">this</span>.x&gt;n-n/<span class="number">4</span>||<span class="built_in">this</span>.y&lt;<span class="number">0</span>)&amp;&amp;(<span class="built_in">this</span>.fadingOut=!<span class="number">0</span>)&#125;,<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;o=!<span class="number">1</span>&#125;,<span class="number">50</span>)&#125;<span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params">t</span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="number">1e3</span>*<span class="built_in">Math</span>.random())+<span class="number">1</span>&lt;<span class="number">10</span>*t&#125;<span class="function"><span class="keyword">function</span> <span class="title">l</span>(<span class="params">t,i</span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">Math</span>.random()*(i-t)+t&#125;f(),<span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>,f,!<span class="number">1</span>),<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;h=s.getContext(<span class="string">&quot;2d&quot;</span>);<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;i;t++)c[t]=<span class="keyword">new</span> y,c[t].reset();u()&#125;(),<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;<span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;html&#x27;</span>)[<span class="number">0</span>].getAttribute(<span class="string">&#x27;data-theme&#x27;</span>)==<span class="string">&#x27;dark&#x27;</span>&amp;&amp;u(),<span class="built_in">window</span>.requestAnimationFrame(t)&#125;()&#125;;</span><br><span class="line">dark()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/202108121822274.png" alt="image-20210812182203080"></p><p>代码的这一部分要求<code>data-theme</code>也就是主题为<code>dark</code>暗色主题，因此仅在暗色主题生效，随后将<code>js</code>文件添加到配置文件的<code>inject</code>处或者其他需要的位置。</p><h2 id="3-CSS样式"><a href="#3-CSS样式" class="headerlink" title="3. CSS样式"></a>3. CSS样式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 背景宇宙星光  */</span></span><br><span class="line"><span class="selector-id">#universe</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">最近很多小伙伴留言想要`星空和流星特效`，于是写了这篇文章准备介绍如何部署。本文主要以Butterfly主题为例进行介绍。</summary>
    
    
    
    <category term="博客相关" scheme="https://blog.justlovesmile.top/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Hexo" scheme="https://blog.justlovesmile.top/tags/Hexo/"/>
    
    <category term="前端" scheme="https://blog.justlovesmile.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>iOS快捷指令 | iPicGo，随时随地用手机上传图片到图床</title>
    <link href="https://blog.justlovesmile.top/posts/223c1a0c.html"/>
    <id>https://blog.justlovesmile.top/posts/223c1a0c.html</id>
    <published>2021-03-26T05:48:49.000Z</published>
    <updated>2021-03-26T05:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS快捷指令版PicGo"><a href="#iOS快捷指令版PicGo" class="headerlink" title="iOS快捷指令版PicGo"></a>iOS快捷指令版PicGo</h1><blockquote><p>功能：<strong>上传手机图片到Github，并将其在jsdelivr的CDN图片链接复制到剪切板。</strong></p><p>当然我主要是为了方便发图片链接到<a href="/essay/">哔哔</a>😀。哔哔来自<a href="https://immmmm.com/bb-by-wechat-pro/">木木木木木</a>，iOS<a href="https://www.icloud.com/shortcuts/8e9e01fd2fc14124b1a7cf43a5ea64bd">哔哔发射</a>捷径来自<a href="https://blog.zhheo.com/p/27be0e44.html">Heo</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210326105717.png" alt="image-20210326105717200"></p><h2 id="1-申请github的personal-access-token"><a href="#1-申请github的personal-access-token" class="headerlink" title="1. 申请github的personal access token"></a>1. 申请github的personal access token</h2><p>点击Settings-Developer settings-Personal access tokens-Generate new token-取个名字勾选repo-复制token（!!!）即可获得token</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210326132347.png" alt="image-20210326132347250"></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210326132516.png" alt="image-20210326132516102"></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210326132545.png" alt="image-20210326132545789"></p><h2 id="2-使用iOS-的iPicGo捷径"><a href="#2-使用iOS-的iPicGo捷径" class="headerlink" title="2. 使用iOS 的iPicGo捷径"></a>2. 使用iOS 的iPicGo捷径</h2><p>使用手机Safari浏览器打开<a href="https://www.icloud.com/shortcuts/7c950e63f0ff4533b125253705e18f7c">快捷指令链接</a>，修改第一块<code>词典</code>里面的参数。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210326130845.png" alt="06B2762F01E8C962472455EBA7B39F19"></p><p>其中参数如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;name&#x27;: github的用户名,</span><br><span class="line">    &#x27;repo&#x27;: github图床的仓库名,</span><br><span class="line">    &#x27;path&#x27;: 你想要上传的子路径名，例如：image或者image/pic，首尾无斜杠,</span><br><span class="line">    &#x27;token&#x27;: 申请到的github personal access token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中path部分默认是有子路径的，因为我有😀，所以没有增加判断…可以自行修改url链接，如下图所示URL部分：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210326131817.png" alt="image-20210326131817492"></p><p>修改完成后即可实现手机图片上传到github的功能。</p><h2 id="3-使用iPicGo和哔哔发射"><a href="#3-使用iPicGo和哔哔发射" class="headerlink" title="3. 使用iPicGo和哔哔发射"></a>3. 使用iPicGo和哔哔发射</h2><p>所以现在，我就可以先使用iPicGo捷径上传到github图床，然后捷径会自动返回图片链接到剪切板，再打开哔哔发射，粘贴图片链接，就可以方便哔哔了。当然，木木大佬的哔哔点啥公众号也可以发图片😂。</p><p>Gif演示：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210326134511.gif" alt="20201105174303"></p><style>    img{max-height: 450px;}</style>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS快捷指令版PicGo&quot;&gt;&lt;a href=&quot;#iOS快捷指令版PicGo&quot; class=&quot;headerlink&quot; title=&quot;iOS快捷指令版PicGo&quot;&gt;&lt;/a&gt;iOS快捷指令版PicGo&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;功能：&lt;strong&gt;上传</summary>
      
    
    
    
    <category term="折腾记录" scheme="https://blog.justlovesmile.top/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="iOS" scheme="https://blog.justlovesmile.top/tags/iOS/"/>
    
    <category term="捷径" scheme="https://blog.justlovesmile.top/tags/%E6%8D%B7%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | GAN，什么是生成对抗网络</title>
    <link href="https://blog.justlovesmile.top/posts/6a054795.html"/>
    <id>https://blog.justlovesmile.top/posts/6a054795.html</id>
    <published>2021-03-03T02:43:37.000Z</published>
    <updated>2021-03-03T02:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAN学习笔记"><a href="#GAN学习笔记" class="headerlink" title="GAN学习笔记"></a>GAN学习笔记</h1><h2 id="1-GAN原理"><a href="#1-GAN原理" class="headerlink" title="1. GAN原理"></a>1. GAN原理</h2><p>论文链接：<a href="https://arxiv.org/abs/1406.2661">Generative Adversarial Networks</a></p><blockquote><p>生成式对抗网络(GAN, Generative Adversarial Networks)是一种深度学习模型，是近年来复杂分布上无监督学习最具前景的方法之一。模型通过框架中（至少）两个模块：生成模型（Generative Model）和判别模型（Discriminative Model）的互相博弈学习产生相当好的输出。原始 GAN 理论中，并不要求 G 和 D 都是神经网络，只需要是能拟合相应生成和判别的函数即可。但实用中一般均使用深度神经网络作为 G 和 D 。一个优秀的GAN应用需要有良好的训练方法，否则可能由于神经网络模型的自由性而导致输出不理想。<br>Ian J. Goodfellow等人于2014年10月在<a href="https://arxiv.org/abs/1406.2661">Generative Adversarial Networks</a>中提出了一个通过对抗过程估计生成模型的新框架。框架中同时训练两个模型：捕获数据分布的生成模型G，和估计样本来自训练数据的概率的判别模型D。G的训练程序是将D错误的概率最大化。这个框架对应一个最大值集下限的双方对抗游戏。可以证明在任意函数G和D的空间中，存在唯一的解决方案，使得G重现训练数据分布，而D=0.5。在G和D由多层感知器定义的情况下，整个系统可以用反向传播进行训练。在训练或生成样本期间，不需要任何马尔科夫链或展开的近似推理网络。实验通过对生成的样品的定性和定量评估证明了本框架的潜力。<br>  —- 摘自<a href="https://baike.baidu.com/item/Gan/22181905?fr=aladdin">百度百科</a></p></blockquote><p>GAN是由两部分组成的，第一部分是生成，第二部分是对抗。简单来说，就是有一个生成网络G和一个判别网络D，通过训练让两个网络相互竞争，生成网络G接受一个随机噪声z来生成假的数据G(z)，对抗网络D通过判别器去判别真伪概率，最后希望生成器G生成的数据能够以假乱真。在最理想的状态下，D(G(z)) = 0.5。</p><p>以上原理的数学公式为：</p><p>$$ min_{G}max_{D}V(D,G) = \mathbb{E} _ {x \sim p_{data}(x)} [\log D(x)] + \mathbb{E} _ {z \sim p_{z}(z) [\log (1-D(G(z)))]} $$</p><p>式子中，x表示真实数据，z表示噪声，G(z)表示G网络根据z生成的数据，D(x)表示D网络判断真实数据是否为真的概率，因此D(x)接近1越好。而D(G(z))代表D网络判断G网络生成的虚假数据是真实的概率。<br>因此，对于D网络(辨别器)：</p><ul><li>如果x来自$P_{data}$，那么D(x)要越大越好，可以用$\log(D(x)) \uparrow$表示。</li><li>如果x来自于$P_{generator}$，那么D(G(z))越小越好，进而表示为$\log[1−D(G(z))] \uparrow$。</li><li>因此需要最大化$max_D$<br>对于G网络(生成器)：</li><li>$D(G(z))$越大越好，进而表示为log[1−D(G(z))]↓</li><li>因此需要最小化$min_{G}$。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210223180633.png"></p><p>第一步我们训练D，D是希望V(D,G)越大越好，所以是加上梯度(ascending)。第二步训练G时，V(D,G)越小越好，所以是减去梯度(descending)。整个训练过程交替进行。</p><h2 id="2-GAN实例"><a href="#2-GAN实例" class="headerlink" title="2. GAN实例"></a>2. GAN实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn,optim</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">transforms = tfs.Compose([</span><br><span class="line">    tfs.Resize((<span class="number">32</span>,<span class="number">32</span>)),</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    <span class="comment">#tfs.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">flat_img = <span class="number">32</span>*<span class="number">32</span>*<span class="number">3</span></span><br><span class="line">noise_dim = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;1.jpg&#x27;</span>)</span><br><span class="line">real_img = transforms(img)</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">2</span>)</span><br><span class="line">fake_img = torch.rand(<span class="number">1</span>,noise_dim)</span><br><span class="line"></span><br><span class="line">plt.imshow(np.transpose(real_img.numpy(),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)))</span><br><span class="line"><span class="comment">#print(real_img)</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210224172221.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.linear = nn.Sequential(</span><br><span class="line">            nn.Linear(flat_img, <span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">2048</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">2048</span>, <span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid() <span class="comment">#sigmoid常用于二分类问题</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, img</span>):</span></span><br><span class="line">        img = img.view(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        out = self.linear(img)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.linear = nn.Sequential(</span><br><span class="line">            nn.Linear(noise_dim, <span class="number">1024</span>),</span><br><span class="line">            nn.LeakyReLU(),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">2048</span>),</span><br><span class="line">            nn.LeakyReLU(),</span><br><span class="line">            nn.Linear(<span class="number">2048</span>, flat_img)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, latent_space</span>):</span></span><br><span class="line">        latent_space = latent_space.view(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        out = self.linear(latent_space)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">device = <span class="string">&#x27;cuda:0&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">discr = Discriminator().to(device)</span><br><span class="line">gen = Generator().to(device)</span><br><span class="line"></span><br><span class="line">opt_d = optim.SGD(discr.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">opt_g = optim.SGD(gen.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">epochs = <span class="number">200</span></span><br><span class="line">discr_e = <span class="number">4</span></span><br><span class="line">gen_e = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#whole model training starts here</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line"></span><br><span class="line">    <span class="comment">#discriminator training</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(discr_e):</span><br><span class="line">        out_d1 = discr(real_img.to(device))</span><br><span class="line">        <span class="comment">#loss for real image</span></span><br><span class="line">        loss_d1 = criterion(out_d1, torch.ones((<span class="number">1</span>, <span class="number">1</span>)).to(device))</span><br><span class="line"></span><br><span class="line">        out_d2 = gen(fake_img.to(device)).detach()</span><br><span class="line">        <span class="comment">#loss for fake image</span></span><br><span class="line">        loss_d2 = criterion(discr(out_d2.to(device)), torch.zeros((<span class="number">1</span>, <span class="number">1</span>)).to(device))</span><br><span class="line"></span><br><span class="line">        opt_d.zero_grad()</span><br><span class="line">        loss_d = loss_d1+loss_d2</span><br><span class="line">        loss_d.backward()</span><br><span class="line">        opt_d.step()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#generator training</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gen_e):</span><br><span class="line">        out_g = gen(fake_img.to(device))</span><br><span class="line">        <span class="comment">#Binary cross entropy loss</span></span><br><span class="line">        loss_g = criterion(discr(out_g.to(device)), torch.ones(<span class="number">1</span>, <span class="number">1</span>).to(device))</span><br><span class="line">        <span class="comment">#Loss function in the GAN paper</span></span><br><span class="line">        <span class="comment">#[log(1 - D(G(z)))]</span></span><br><span class="line">        <span class="comment">#loss_g = torch.log(torch.ones(1, 1).to(device) - (discr(out_g.to(device))))</span></span><br><span class="line">        </span><br><span class="line">        opt_g.zero_grad()</span><br><span class="line">        loss_g.backward()</span><br><span class="line">        opt_g.step()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (epoch+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch[&#123;&#125;/&#123;&#125;],d_loss:&#123;:.6f&#125;,g_loss:&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(epoch+<span class="number">1</span>,epochs,loss_d.data.item(),loss_g.data.item()))</span><br><span class="line"></span><br><span class="line">out=gen(fake_img.to(device)).detach()</span><br><span class="line">out_score=discr(out_g.to(device))</span><br><span class="line">loss = criterion(out_score, torch.ones(<span class="number">1</span>, <span class="number">1</span>).to(device))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;score:&quot;</span>,out_score.item(),<span class="string">&quot;loss:&quot;</span>,loss.item())</span><br><span class="line"></span><br><span class="line">out=out.reshape((<span class="number">3</span>,<span class="number">32</span>,<span class="number">32</span>)).cpu()</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(out)</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;fake&#x27;</span>)</span><br><span class="line">plt.imshow(np.transpose(out.numpy(),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;real&#x27;</span>)</span><br><span class="line">plt.imshow(np.transpose(real_img.numpy(),(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210224183510.png"></p><h2 id="3-DCGAN原理"><a href="#3-DCGAN原理" class="headerlink" title="3. DCGAN原理"></a>3. DCGAN原理</h2><p><a href="https://arxiv.org/pdf/1511.06434.pdf">https://arxiv.org/pdf/1511.06434.pdf</a></p><p>DCGAN的原理和GAN是一样的。只不过DCGANs体系结构有所改变：</p><ul><li>使用指定步长的卷积层代替池化层</li><li>在生成器和鉴别器中使用batch norm。</li><li>移除全连接层，以实现更深层次的体系结构，减少参数。</li><li>在生成器中使用ReLU激活，但输出使用Tanh。</li><li>在鉴别器中使用LeakyReLU激活</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210224183753.png"></p><p>DCGAN中提到了网络的训练细节：</p><ul><li>使用Adam算法更新参数，betas=(0.5, 0.999)；</li><li>batch size选为128；</li><li>权重使用正太分布，均值为0，标准差为0.02；</li><li>学习率0.0002。</li></ul><h2 id="4-DCGAN实例"><a href="#4-DCGAN实例" class="headerlink" title="4. DCGAN实例"></a>4. DCGAN实例</h2><p>生成动漫头像，数据集来自<a href="https://www.kaggle.com/soumikrakshit/anime-faces">https://www.kaggle.com/soumikrakshit/anime-faces</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> torch,torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, utils</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">avatar_img_path = <span class="string">&quot;E:/python/dataset/anime face/data&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">trans = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">noise_dim = <span class="number">100</span></span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">beta1=<span class="number">0.5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#自定义数据集</span></span><br><span class="line"><span class="string">file_train=[]</span></span><br><span class="line"><span class="string">for image_name in tqdm(os.listdir(avatar_img_path)):</span></span><br><span class="line"><span class="string">    file_train.append(os.path.join(avatar_img_path,image_name))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def default_loader(path):</span></span><br><span class="line"><span class="string">    img = imageio.imread(path)</span></span><br><span class="line"><span class="string">    img = img/255</span></span><br><span class="line"><span class="string">    img = trans(img)</span></span><br><span class="line"><span class="string">    return img</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class trainset(Dataset):</span></span><br><span class="line"><span class="string">    def __init__(self, loader=default_loader):</span></span><br><span class="line"><span class="string">    #定义好 image 的路径</span></span><br><span class="line"><span class="string">        self.images = file_train</span></span><br><span class="line"><span class="string">        self.target = 0</span></span><br><span class="line"><span class="string">        self.loader = loader</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __getitem__(self, index):</span></span><br><span class="line"><span class="string">        fn = self.images[index]</span></span><br><span class="line"><span class="string">        img = self.loader(fn)</span></span><br><span class="line"><span class="string">        target = self.target</span></span><br><span class="line"><span class="string">        return img,target</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    def __len__(self):</span></span><br><span class="line"><span class="string">        return len(self.images)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">img_dataset=torchvision.datasets.ImageFolder(<span class="string">&quot;E:/python/dataset/anime face&quot;</span>, transform=trans)</span><br><span class="line"><span class="comment">#img_dataset=trainset()</span></span><br><span class="line">img_dataloader=DataLoader(img_dataset,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#print(img_dataset)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, z_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Generator,self).__init__()</span><br><span class="line">        self.z_dim = z_dim</span><br><span class="line">        self.generator = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(self.z_dim,<span class="number">512</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(num_features=<span class="number">512</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">512</span>,<span class="number">256</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(num_features=<span class="number">256</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">256</span>,<span class="number">128</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(num_features=<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">128</span>,<span class="number">64</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(num_features=<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">64</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line">        self.weight_init()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.generator.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.ConvTranspose2d):</span><br><span class="line">                nn.init.normal_(m.weight.data, <span class="number">0</span>, <span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                nn.init.normal_(m.weight.data, <span class="number">0</span>, <span class="number">0.02</span>)</span><br><span class="line">                nn.init.constant_(m.bias.data, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.generator(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param image_size: tuple (3, h, w)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(Discriminator,self).__init__()</span><br><span class="line">        self.discriminator = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">64</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(num_features=<span class="number">64</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(num_features=<span class="number">128</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(num_features=<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>,<span class="number">512</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(num_features=<span class="number">512</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">512</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,bias=<span class="literal">False</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line">        self.weight_init()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight_init</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.discriminator.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.ConvTranspose2d):</span><br><span class="line">                nn.init.normal_(m.weight.data, <span class="number">0</span>, <span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                nn.init.normal_(m.weight.data, <span class="number">0</span>, <span class="number">0.02</span>)</span><br><span class="line">                nn.init.constant_(m.bias.data, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.discriminator(x)</span><br><span class="line">        out = out.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">generator = Generator(noise_dim).to(device)</span><br><span class="line">discriminator = Discriminator().to(device)</span><br><span class="line"></span><br><span class="line">bce_loss = nn.BCELoss()</span><br><span class="line"><span class="comment">#optimizer_D = torch.optim.Adam(discriminator.parameters(), lr=0.0002, betas=(beta1, 0.999))</span></span><br><span class="line">optimizer_D = torch.optim.Adam(discriminator.parameters(), lr=<span class="number">0.00005</span>, betas=(beta1, <span class="number">0.999</span>))</span><br><span class="line">optimizer_G = torch.optim.Adam(generator.parameters(), lr=<span class="number">0.0002</span>, betas=(beta1, <span class="number">0.999</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">epochs=<span class="number">20</span></span><br><span class="line"></span><br><span class="line">fixed_z=torch.randn(batch_size,noise_dim,<span class="number">1</span>,<span class="number">1</span>,device=device)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="keyword">for</span> step,(image,_) <span class="keyword">in</span> <span class="built_in">enumerate</span>(img_dataloader):</span><br><span class="line">        batch_size=image.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#=====训练辨别器====</span></span><br><span class="line">        optimizer_D.zero_grad()</span><br><span class="line">        <span class="comment"># 计算判别器对真实样本给出为真的概率</span></span><br><span class="line">        d_out_real = discriminator(image.<span class="built_in">type</span>(torch.FloatTensor).to(device))</span><br><span class="line">        real_loss = bce_loss(d_out_real, torch.ones(size=(batch_size, <span class="number">1</span>)).to(device))</span><br><span class="line">        real_scores = d_out_real</span><br><span class="line">        <span class="comment">#real_loss.backward()</span></span><br><span class="line">        <span class="comment"># 计算判别器对假样本给出为真的概率</span></span><br><span class="line">        noise = torch.randn(batch_size,noise_dim,<span class="number">1</span>,<span class="number">1</span>,device=device)</span><br><span class="line">        fake_img = generator(noise)</span><br><span class="line">        d_out_fake = discriminator(fake_img.detach())</span><br><span class="line">        fake_loss = bce_loss(d_out_fake, torch.zeros(size=(batch_size, <span class="number">1</span>)).to(device))</span><br><span class="line">        fake_scores = d_out_fake</span><br><span class="line">        <span class="comment">#fake_loss.backward()</span></span><br><span class="line">        <span class="comment"># 更新判别器参数</span></span><br><span class="line">        d_loss = (real_loss + fake_loss)/<span class="number">2</span></span><br><span class="line">        d_loss.backward()</span><br><span class="line">        optimizer_D.step()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#=====训练生成器====</span></span><br><span class="line">        optimizer_G.zero_grad()</span><br><span class="line">        <span class="comment"># 计算判别器对伪造样本的输出的为真样本的概率值</span></span><br><span class="line">        d_out_fake = discriminator(fake_img)</span><br><span class="line">        <span class="comment"># 计算生成器伪造样本不被认为是真的损失</span></span><br><span class="line">        g_loss = bce_loss(d_out_fake, torch.ones(size=(batch_size, <span class="number">1</span>)).to(device))</span><br><span class="line">        <span class="comment"># 更新生成器</span></span><br><span class="line">        g_loss.backward()</span><br><span class="line">        optimizer_G.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># #################################################</span></span><br><span class="line">        <span class="comment"># 4：打印损失，保存图片</span></span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">200</span> == <span class="number">0</span>:</span><br><span class="line">            generator.<span class="built_in">eval</span>()</span><br><span class="line">            fixed_image = generator(fixed_z)</span><br><span class="line">            generator.train()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[epoch: &#123;&#125;/&#123;&#125;], [iter: &#123;&#125;], [G loss: &#123;:.3f&#125;], [D loss: &#123;:.3f&#125;], [R Score: &#123;:.3f&#125;], [F Score: &#123;:.3f&#125;]&quot;</span>.<span class="built_in">format</span>(epoch+<span class="number">1</span>,epochs,step, g_loss.item(), d_loss.item(),real_scores.data.mean(), fake_scores.data.mean()))</span><br><span class="line">            utils.save_image(fixed_image.detach(), <span class="built_in">str</span>(epoch+<span class="number">1</span>)+<span class="string">&quot;fake.jpg&quot;</span>,normalize=<span class="literal">True</span>)</span><br><span class="line">            utils.save_image(image,<span class="built_in">str</span>(epoch+<span class="number">1</span>)+<span class="string">&quot;real.jpg&quot;</span>,normalize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>结果如下：<br>    [epoch: 1/20], [iter: 0], [G loss: 0.699], [D loss: 0.694], [R Score: 0.499], [F Score: 0.500]<br>    [epoch: 1/20], [iter: 200], [G loss: 0.803], [D loss: 0.715], [R Score: 0.512], [F Score: 0.529]<br>    [epoch: 1/20], [iter: 400], [G loss: 0.734], [D loss: 0.692], [R Score: 0.492], [F Score: 0.491]<br>    [epoch: 1/20], [iter: 600], [G loss: 0.730], [D loss: 0.693], [R Score: 0.496], [F Score: 0.496]<br>    [epoch: 1/20], [iter: 800], [G loss: 0.748], [D loss: 0.686], [R Score: 0.500], [F Score: 0.492]<br>    [epoch: 1/20], [iter: 1000], [G loss: 0.745], [D loss: 0.680], [R Score: 0.514], [F Score: 0.499]<br>    [epoch: 1/20], [iter: 1200], [G loss: 0.715], [D loss: 0.701], [R Score: 0.527], [F Score: 0.532]<br>    [epoch: 2/20], [iter: 0], [G loss: 0.762], [D loss: 0.679], [R Score: 0.524], [F Score: 0.508]<br>    [epoch: 2/20], [iter: 200], [G loss: 0.815], [D loss: 0.686], [R Score: 0.507], [F Score: 0.498]<br>    [epoch: 2/20], [iter: 400], [G loss: 0.836], [D loss: 0.665], [R Score: 0.509], [F Score: 0.479]<br>    [epoch: 2/20], [iter: 600], [G loss: 0.759], [D loss: 0.694], [R Score: 0.523], [F Score: 0.520]<br>    [epoch: 2/20], [iter: 800], [G loss: 0.973], [D loss: 0.646], [R Score: 0.551], [F Score: 0.499]<br>    [epoch: 2/20], [iter: 1000], [G loss: 0.926], [D loss: 0.671], [R Score: 0.531], [F Score: 0.495]<br>    [epoch: 2/20], [iter: 1200], [G loss: 1.100], [D loss: 0.582], [R Score: 0.497], [F Score: 0.362]</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210225180739.png"></p><p>第7个epoch：<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210226103604.jpg"></p><p>batch_size以及其他参数可自行调整。</p><h2 id="5-WGAN原理"><a href="#5-WGAN原理" class="headerlink" title="5. WGAN原理"></a>5. WGAN原理</h2><p>论文：<a href="https://arxiv.org/pdf/1701.07875.pdf">Wasserstein GAN</a><br><a href="https://arxiv.org/abs/1701.04862">Towards Principled Methods for Training Generative Adversarial Networks</a></p><p>总所周知，GAN的训练存在很多问题和挑战：</p><ul><li>训练困难，需要精心设计模型结构，协调G和D的训练程度</li><li>G和D的损失函数无法指示训练过程，缺乏一个有意义的指标和生成图片的质量相关联</li><li>模式崩坏（mode collapse），生成的图片虽然看起来像是真的，但是缺乏多样性</li></ul><p>WGAN相比较于传统的GAN，做了如下修改：</p><ul><li>D最后一层去掉sigmoid</li><li>G和D的loss不取log</li><li>每次更新D的参数后，将其绝对值截断到不超过一个固定常数c</li><li>不要用基于动量的优化算法（包括momentum和Adam），推荐RMSProp，SGD也行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210303105435.png"></p><p>G的损失函数原本为$\mathbb{E} _ {z \sim p _ z}[\log(1-D(G(z)))]$ ，其导致的结果是，如果D训练得太好，G将学习不到有效的梯度。但是，如果D训练得不够好，G也学习不到有效的梯度。<br>因此以上损失函数导致GAN训练特别不稳定，需要小心协调G和D的训练程度。</p><blockquote><p>WGAN参考资料：<br><a href="https://zhuanlan.zhihu.com/p/44169714">https://zhuanlan.zhihu.com/p/44169714</a><br><a href="https://www.cnblogs.com/Allen-rg/p/10305125.html">https://www.cnblogs.com/Allen-rg/p/10305125.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">2014年，arXiv上面刊载了一篇关于生成对抗网络的文章，名为《Generative Adversarial Nets》，作者是深度学习领域的大牛Ian J. Goodfellow。本文主要记录博主对于GAN及其基础变种的学习笔记，主要包括GAN，DCGAN的原理和实例，以及WGAN的基础原理。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GAN" scheme="https://blog.justlovesmile.top/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | Wasserstein距离</title>
    <link href="https://blog.justlovesmile.top/posts/ebe3a70b.html"/>
    <id>https://blog.justlovesmile.top/posts/ebe3a70b.html</id>
    <published>2021-01-31T07:14:05.000Z</published>
    <updated>2021-01-31T07:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wasserstein-距离"><a href="#Wasserstein-距离" class="headerlink" title="Wasserstein 距离"></a>Wasserstein 距离</h1><p>对于绝大多数的机器学习问题，尤其是预测问题和隐变量模型（<code>latent factor model</code>）中，学习到数据集背后所服从的分布往往是模型所要解决的最终问题。在变分推断（<code>variational inference</code>）等领域中，往往会先从一个简单的分布引入，比如高斯分布或者多项式分布等；希望由这个简单的分布模型能不断学习进而逼近最终想要的、符合数据背后规律的分布，注意这时候的分布往往可能在形状上与初始假设的分布有所差异。</p><h2 id="KL散度和JS散度"><a href="#KL散度和JS散度" class="headerlink" title="KL散度和JS散度"></a>KL散度和JS散度</h2><p>在学习Wasserstein距离，首先回顾在机器学习算法中，衡量两个分布相似程度的指标常常是KL散度（<code>Kullback-Leibler Divergence</code>）以及JS散度 （<code>Jensen-Shannon Divergence</code>）。</p><h3 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h3><p>KL散度描述的是，评价训练所得的概率分布p与目标分布q之间的距离，可以表示为：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210131104040.png" alt="image-20210131104033253"></p><p>机器学习的算法最终的目的是缩小 $D _ {KL}$ 的值，可以看到当 $p(x)==q(x)$ 的时候，KL散度处处为0，达到最优结果。 但同时必须注意的是，由于KL散度中，对数项中$p(x)$与$q(x)$相对位置的关系，决定了KL散度其实是非对称的，即 $D_{KL}(p||q) \neq D_{KL}(q||p)$ .从物理学参考系的角度可以直观感受出，如果要想评价两个物体（分布）的相似程度，相似程度的值（比如KL散度）应该不能因为选取的参考目标（目标分布）的不同而改变。</p><h3 id="JS散度"><a href="#JS散度" class="headerlink" title="JS散度"></a>JS散度</h3><p>既然KL散度不具备对称性，那么依然从参考系的角度出发，那我们直接把所有参考系下计算的距离平均即可（在本文环境下只有目标分布和预测分布两个参考系）。这样便是JS散度的思想，具体的定义为:</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210131104625.png" alt="image-20210131104625712"></p><p>因而JS散度便有了对称性，并且形式上更为平滑，更适合作为最后最大似然的函数，这点在生成对抗网络（GAN）的损失函数取得了不错的成绩。</p><h2 id="Wasserstein距离"><a href="#Wasserstein距离" class="headerlink" title="Wasserstein距离"></a>Wasserstein距离</h2><p>Wasserstein距离也叫做推土机距离（Earth Mover’s distance），这也是由于它的推导过程可以很形象的用挖土填土来解释，这也是因为该距离定义中由一个分布转变为另一个分布所需要的代价和挖土填土的过程十分相似。考虑两个离散的分布P和Q:</p><ul><li><p>P1 = 3, P2 = 2, P3 = 1, P4 = 4</p></li><li><p>Q1 = 1, Q2 = 2, Q3 = 4, Q4 = 3</p></li></ul><p>为了让两个分布相同，我们一个个变量地观察，</p><ul><li>为了让P1和Q1相同，我们需要P1把手头上的3分2到P2去，这样P1和Q1都等于1，此时P2=4，其他数保持不变，这个过程是不是非常像挖掉P1的土填到P2上</li><li>为了让P2和Q2相同，我们也要做类似的挖土填土工作，但注意，此时P2手头上由P1填的2，因此现在P2是4，但是Q2依然是2，因而P2也要挖2分土给P3，保持和Q2一样。</li><li>P3和Q3也是一样，但此时P3为3，Q3为4，因为我们只能先挖土再填土，因此要Q3挖1分土给Q4，这样P4和Q4也能够一样。</li></ul><p>每一步的代价计算公式为$\delta_{i+1} = \delta_{i} + P_{i} -Q_i$，第0步我们规定为0，故有</p><ul><li><p>$\delta_{0} = 0$</p></li><li><p>$\delta_{1} = 0+3-1 = 2$</p></li><li><p>$\delta_{2} = 2+2-2 = 2$</p></li><li><p>$\delta_{3} = 2+1-4 = -1$</p></li><li><p>$\delta_{4} = -1+4-3 = 0$</p><p>所以最终的总代价，也即Wasserstein距离则为$W=\sum_i |\delta_i|=5$</p></li></ul><p>该挖土填土的过程可以由下图表示:(图片来源：<a href="https://lilianweng.github.io/lil-log/2017/08/20/from-GAN-to-WGAN.html#kullbackleibler-and-jensenshannon-divergence">From GAN to WGAN</a>)</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210131105502.jpeg" alt="img"></p><p>由离散情况理解了距离计算以后，针对一般的<strong>连续分布</strong>，Wasserstein距离则变成如下形式:</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20210131105656.png" alt="image-20210131105656319"></p><p>其中<code>inf</code>指代最大下界，$S(p_r,p_g)$表示的是分布$p_r$和$p_g$中所有可能的联合分布，每一个联合分布$\gamma \in S(p_r,p_g)$都是之前提到的“土”，用于刻画连续空间中分布间转换的代价，更具体而言，$\gamma(x,y)$刻画从x点转移到y点从而让x，y服从相同分布所需要的“土”的百分比。因此$\gamma$的边缘分布可以表示为$\sum_x \gamma(x,y)=p_g(y),\sum_y \gamma(x,y)=p_r(x)$</p><p>当我们将x作为我们的起始点，y作为我们要逼近的终点时，挖土填土的总量即为$\gamma(x,y)$，也即上文离散情况下计算的代价$\delta$，而点与点之间的距离则为||x-y||，因而总代价为$\sum_{x,y} \gamma(x,y)||x-y||$,总代价最后可以使用EM等方法求得最小值。</p><h3 id="为什么Wasserstein距离优于KL和JS散度"><a href="#为什么Wasserstein距离优于KL和JS散度" class="headerlink" title="为什么Wasserstein距离优于KL和JS散度"></a>为什么Wasserstein距离优于KL和JS散度</h3><p>P,Q两个分布完全重合，此时这三种距离度量方式均为0。可以看出KL散度在两个分布完全没有任何交集的时候会得出无穷的结果，而JS散度则会有突然的阶跃，并且在0点出不可微，只有Wasserstein距离能够提供更为平滑的结果用于梯度下降法的参数更新。不过值得一提的是，目前主流的分布距离度量依然是KL散度，这是由于KL散度的计算方式简单，计算成本较Wasserstein低，但近年来Wasserstein距离的近似<code>Sinkhorn distance</code>以及其他加快距离计算方法的论文也在不断涌现.</p><blockquote><p>转自：<a href="https://zhuanlan.zhihu.com/p/84617531">https://zhuanlan.zhihu.com/p/84617531</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Wasserstein-距离&quot;&gt;&lt;a href=&quot;#Wasserstein-距离&quot; class=&quot;headerlink&quot; title=&quot;Wasserstein 距离&quot;&gt;&lt;/a&gt;Wasserstein 距离&lt;/h1&gt;&lt;p&gt;对于绝大多数的机器学习问题，尤其是预测问题和</summary>
      
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="损失函数" scheme="https://blog.justlovesmile.top/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 论文笔记（Lifelong Zero-Shot Learning）</title>
    <link href="https://blog.justlovesmile.top/posts/f6289062.html"/>
    <id>https://blog.justlovesmile.top/posts/f6289062.html</id>
    <published>2021-01-08T09:40:56.000Z</published>
    <updated>2021-01-08T09:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lifelong-Zero-Shot-Learning-论文翻译"><a href="#Lifelong-Zero-Shot-Learning-论文翻译" class="headerlink" title="Lifelong Zero-Shot Learning(论文翻译)"></a>Lifelong Zero-Shot Learning(论文翻译)</h1><p><strong>终身零样本学习</strong></p><p>作者：<strong>Kun Wei, Cheng Deng, Xu Yang</strong></p><p><a href="https://www.ijcai.org/Proceedings/2020/0077.pdf">https://www.ijcai.org/Proceedings/2020/0077.pdf</a></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>零样本学习(Zero-Shot Learning, ZSL)解决了一些测试类别在训练集中从未出现的问题。现有的零样本学习方法是被设计用来从一个固定的训练集中学习的，不具备对多种训练集的知识进行捕获和积累的能力，因此不适合许多现实生活中的应用。在本文中，我们提出了一种新的零样本学习方法，称为终身零样本学习(Lifelong Zero-Shot Learning，LZSL)，其目的是在多种数据集的学习过程中积累知识，并对所有训练数据集的从未出现的类别进行识别。此外，我们提出了一种革新的方法用来实现终身零样本学习，有效地缓解了连续训练过程中的灾难性遗忘。针对包含不同语义嵌入的数据集，我们利用变分自动编码器实现统一的语义表示。然后，在微调整个模型时，我们利用选择性再训练策略来保留先前任务的训练权重，并避免负迁移。最后，利用知识蒸馏，将之前的训练阶段的知识转移到当前阶段。我们还设计了终身零样本学习评估协议和高要求的基准。在这些基准上的大量实验表明，当现有的零样本学习方法失败时，我们的方法有效地解决了零样本学习问题。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>在最近几年，零样本学习在计算机视觉和机器学习社区中获得了越来越多的关注。与在训练阶段要求所有类别都有足够的样本的传统的分类任务不同，零样本学习的目标是识别在训练阶段从未出现过的新的类别的样本。在流行的零样本学习方法中，学习模型只在单个数据集的可见类上进行训练，然后在同一数据集的不可见类上进行测试，该数据集的可见类和不可见类是不相交的。然而，在许多现实世界的应用中，识别系统需要具有从获得的训练数据中不断学习的能力，并以终身的方式改进系统。</p><p>为了满足这一要求，我们提出了一种更实用的零样本学习方法，称为终身零样本学习(Lifelong Zero-Shot Learning,LZSL)，它要求模型积累不同数据集的知识，并对所有面向数据集的未出现的类别进行识别。如图1所示，该模型在多个学习阶段进行训练，每个阶段都包含来自新数据集的图像和语义嵌入。这些数据集的语义嵌入是多样而复杂的，例如，这些数据集的属性列表是不同的。在完成所有训练阶段后，模型将对所有数据集上的可见的和不可见的测试图像进行评估。</p><p>主流的零样本学习方法旨在学习图像之间的映射和相应的语义嵌入。这些方法根据分类空间可分为三种类型，即视觉空间、语义空间和常见嵌入空间。除此之外，还有一些零样本学习方法通过训练生成模型来获取不可见的类别的特征。然后，利用可见类别的视觉特征和生成的不可见类别的视觉特征训练分类器。这些方法将零样本学习任务转换为监督学习任务。然而，这些方法不能有效地处理终身零样本学习问题，因为它们缺乏在没有排查的情况下从之前训练的任务中积累知识的机制。</p><p>为了解决上述问题，实现终身零样本学习，我们提出了一种将统一语义嵌入、选择性再训练和知识蒸馏策略无缝集成的新方法。选择交叉和分布对齐变分自编码器(Cross and Distribution Aligned VAE, CACD-VAE)作为基础模型，训练VAEs [Kingma and Welling, 2013]分别对视觉嵌入和语义嵌入的特征进行编码和解码，并使用学习到的潜在特征训练一个零样本学习分类器。为了使CACD-VAE具备终身学习的能力，我们首先利用训练后的VAEs在每个训练阶段获得统一的语义嵌入。利用统一的语义嵌入，分别学习和固定不同任务的潜在空间。为了保证视觉特征能够准确地投射到固定的潜在空间中，利用选择性再训练策略提高了不同任务的分类空间之间的相似性，也避免了在获取新任务知识过程中的负迁移。此外，知识蒸馏被用来将知识从之前的任务转移到当前任务。大量的实验表明，当其他最先进的零样本学习方法无效时，我们的方法可以有效地从之前学习的任务中积累知识并缓解灾难性遗忘。我们的方法的贡献总结如下:</p><ul><li><p>据我们所知，我们是第一个提出并解决终身零样本学习问题的。我们以一种新颖的方式设计了终身零样本学习的基准和评估协议。</p></li><li><p>针对不同数据集的异构语义嵌入的挑战，我们采用了可以固定相应任务的潜在空间的VAEs算法去获得统一的语义嵌入。</p></li><li><p>利用选择性再训练提高不同数据集的分类空间之间的相似性，并通过知识蒸馏损失来监督，规范了知识从之前的任务向当前任务转移的过程。</p></li><li><p>在提出的基准上的大量的实验结果证明了我们提出的方法的有效性，它显著优于最先进的零样本学习方法。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201230132259.png" alt="1"></p><p>图1:终身零样本学习的概述。当新任务到来时，模型按顺序学习新任务，从所有面临的任务中积累知识。将先前任务中的知识转移到当前任务中，可以有效地对不同数据集的不可见的类别进行分类。</p><h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><h3 id="2-1-零样本学习"><a href="#2-1-零样本学习" class="headerlink" title="2.1 零样本学习"></a>2.1 零样本学习</h3><p>零样本学习已经成为一个热门的研究课题，其目标是在没有任何标记的训练数据的情况下识别不可见的类别。此外，零样本学习是迁移学习的一个子问题，其重点是将知识从可见的类别转移到不可见的类别。在测试阶段，测试样本从视觉空间中获取，而我们只在语义空间中进行不可见的类别的语义嵌入。因此，零样本学习方法的主流方法是构建视觉空间与语义空间的连接。典型的方法是学习将视觉特征和语义特征映射到一个共同的嵌入空间的函数，在这个空间中视觉特征和语义特征的嵌入是匹配的。最近，生成对抗网络(GANs)被提出并成功引入到零样本学习问题中。生成零样本学习方法的任务是根据语义特征生成不可见的类别的视觉特征，将零样本学习转换为传统的监督分类任务。例如，f-CLSWGAN是利用conditional Wasserstein GANs提出的，它生成了差别性的不可见的视觉特征。基于f-CLSWGAN, Cycle-WGAN 重建正则化的目的是，保留转移过程中的类别的不同特征。</p><p>然而，上述所有方法都仅在单个数据集上进行训练，因为顺序学习各种数据集的能力有限。据我们所知，我们是第一个提出并解决终身零样本学习问题的。</p><h3 id="2-2-终身学习"><a href="#2-2-终身学习" class="headerlink" title="2.2 终身学习"></a>2.2 终身学习</h3><p>终身学习(Lifelong Learning)是一种学习模式，它要求模型拥有从一系列任务中进行学习，并能将从之前任务中获得的知识转移到后续任务中的能力。终身学习的关键挑战是灾难性遗忘，即当新任务到来时，被训练的模型会忘记之前任务中得到的知识。有很多终身学习的方法被提出，主要分为三部分，即，存储之前任务的训练样本，新任务到来时的正则化参数更新，以及使用额外的生成模型来重现之前任务的训练样本的记忆重现。</p><p>与传统的终身学习问题不同的是，在流行的终身学习分类问题中，传统的终身学习问题的训练和测试的类别是相同的，而在终身零样本学习中，这些是不相交的。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201230132412.png" alt="2"></p><p>图2:我们提出的在$t^{th}$训练阶段上方法框架，该框架由两个VAEs和一个在$(t−1)^{th}$训练阶段训练过的视觉模态编码器组成。给定一张图像,视觉特征提取器可以捕获它的视觉特征$x^t$,映射到的潜在空间作为$\mu^t_v$和$\sum^t_v$。同时，相应的语义嵌入$c^t$映射到潜在的空间作为$\mu^t_a$和$\sum ^ t _ a$。 为了实现潜在的分布对齐，在训练阶段将潜在分布之间的Wasserstein距离($L _ {DA}$)最小化。然后，利用交叉对齐损失( $L _ {CA}$ )，通过交叉模态重构，来保证潜在分布的对齐。此外，我们利用知识蒸馏( $L _ {KD}$ )将之前任务中获得的知识转移到当前任务中。</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><p>针对终身零样本学习问题，我们提出终身零样本学习方法，将终身学习和零样本学习无缝结合。我们的方法框架如图2所示。首先，我们利用VAEs实现不同数据集的统一语义嵌入;然后，我们采用选择性再训练策略逼近不同数据集的分类空间，避免负迁移。最后，我们采用知识蒸馏的方法，将先前任务中的知识转移到当前任务中。</p><h3 id="3-1-问题公式"><a href="#3-1-问题公式" class="headerlink" title="3.1 问题公式"></a>3.1 问题公式</h3><p>在第$t^{th}$个训练阶段，给出一个数据集$S^t = {(x^t, y^t, c^t)|x^t \in X^t, y^t \in Y^t_s, c^t \in C^t }$， 其由一个预训练卷积神经网络(CNN)提取的图像特征$x^t$、可见的类别$Y^t_s$的标签$y^t$和对应类别的语义嵌入$c^t$组成。此外，还有一个可获得的数据集$U^t= {(u^t, c^t_u) | u^t \in Y^t_u, c^t_u \in C^t }$，该数据集包含集合$Y^t_u$中的不可见的类别的标签$u^t$和不可见的类别的语义嵌入$c^t_u$。对于最现实和最具挑战性的广义零学习(Generalized Zero-Learning, GZSL)，其目标是学习一个分类器$f^t_{GZSL}: X^t \rightarrow Y^t_s\cup Y^t_u$。然而，我们的方法主要集中在通过顺序训练不同的数据集来学习一个生成模型，然后针对不同的数据集构造几个分类器。</p><h3 id="3-2-背景-交叉分布对齐变分自编码器-CACD-VAE"><a href="#3-2-背景-交叉分布对齐变分自编码器-CACD-VAE" class="headerlink" title="3.2 背景: 交叉分布对齐变分自编码器(CACD-VAE)"></a>3.2 背景: 交叉分布对齐变分自编码器(CACD-VAE)</h3><p>本文首先介绍了一种最先进的零样本学习方法–交叉分布对齐变分自编码器 (CADA-VAE)，它是我们方法的基本模型。它的目标是搜索一个共同的分类空间，其中嵌入的语义特征和视觉特征是一致的。该模型包含两个VAEs，一个用于语义特征，另一个用于视觉特征，每个都包含一个编码器和一个解码器。每个VAE的目标函数是给定样本的边际似然的变分下界，它可以表述为:</p><p>$$ L = \mathbb{E} _ {q_{\phi} (z|x)}\left[\log p_{\phi} (x|z)\right] - \lambda D_{KL}(q_{\phi} (z|x)||p_{\theta} (z)),  (1) $$</p><p>其中，第一项为重构损失，第二项为解开的<code>Kullback-Leibler散度</code>，对推理模型$q(z|x)$和$p(z)$进行规则化。此外，$\lambda$被用来加权KL-散度。编码器预测$\mu$和$\sum$，所以有$q_{\phi}(z | x) = N(\mu, \sum)$，并且通过应用重新参数化技巧获取一个潜在的向量$z$。编码器被用于将特征投影到公共空间，并且解码器用于重建原始数据。<br>整个模型的VAE损失是两个VAE基本损失的总和:</p><p>$$ L_{VAE} = L_{VAE}^a + L_{VAE}^v,  (2) $$</p><p>其中$L_{VAE}^a$和$L_{VAE}^v$分别表示语义模态和视觉模态的VAE损失。此外，针对语义空间和视觉空间的嵌入在公共空间中的匹配问题，该模型对潜在分布进行了精确对齐，需要一个交叉重建准则来保证。因此，我们设计并应用了交叉对齐损失(CA)和分布对齐损失(DA)。</p><p>交叉对齐损失使来自另一个模态的重构特征与原始模态特征相似。交叉对齐损失为:</p><p>$$ L_{CA} = \left| c-D_a(E_v(x)) \right| + \left|x-D_v(E_a(x))\right|,  (3) $$</p><p>其中，$c$、$D_a$和$E_a$是语义模态的特征、解码器和编码器，$x$、$D_v$和$E_v$是视觉模态的特征、解码器和编码器。</p><p>利用分布对齐损失最小化语义模态的潜在高斯分布与视觉模态的之间的Wasserstein距离，使语义空间和视觉空间的隐性嵌入相匹配。<br>距离表示为:</p><p>$$ L_{DA} = (||\mu_a - \mu_v||_2^2 + ||\sum^{\frac{1}{2}}_a-\sum_a^{frac{1}{2}}||^2_Frobenius)^{frac{1}{2}} ,  (4) $$</p><p>其中$\mu_a$和$\sum_a$通过编码器$E_a$预测,而$µ_v$和$\sum_v$通过编码器$E_v$预测。<br>目标函数可以表示为:</p><p>$$ L_{CACD - VAE} = L_{VAE} + \gamma L_{CA} + \delta L_{DA}, (5)  $$</p><p>其中，$\gamma$ 和 $\delta$ 是交叉对齐和分布对齐损失的超参数，用于权衡这些损失。</p><h3 id="3-3-统一的语义嵌入"><a href="#3-3-统一的语义嵌入" class="headerlink" title="3.3 统一的语义嵌入"></a>3.3 统一的语义嵌入</h3><p>由于不同数据集的属性数量和种类不同，首先需要解决的挑战是不同数据集的语义嵌入是多种多样和复杂的。为了解决这一问题，我们尝试寻找不同数据集的统一语义嵌入。在训练$t^{th}$任务之后,语义嵌入$c^t$被预测为通过$E^t_a$映射的$\mu^t_a$和$\sum^t_a$。隐向量z是采用再参数化的技巧生成的,其过程是从点数据生成各种隐向量的过程。生成的隐向量可以作为最终分类器的训练数据，其中包含了对应类的判别信息。在此基础上,我们替换原始语义嵌入$c^t$和$\mu^t_a$,$\sum_a^t$,从一个点数据到两个点数据,数据可被视为更具代表性的语义映射。在训练完所有任务后，我们可以利用这些新的语义嵌入再现所有数据集的隐向量，并训练更强健的分类器。</p><h3 id="3-4-选择性再训练"><a href="#3-4-选择性再训练" class="headerlink" title="3.4 选择性再训练"></a>3.4 选择性再训练</h3><p>对于这项新任务，一种自然的方法是对整个模型进行微调。然而，对整个模型进行微调会改变先前任务的权重，导致神经网络的灾难性遗忘。因此，我们采用选择性再训练策略对整个模型进行微调。当获得统一的语义嵌入时，不同数据集的分类空间是固定的，这也是之前任务的潜在空间。因此,模型是从视觉空间到分类空间的投影,是视觉模态的编码器$E_v^t$。我们表示$W^t$作为$E^t_v$和$W^t_l$的参数，被表示为l层的参数，而l层的数量是L。当一个新的任务到达时，我们首先冻结参数$W^{t - 1}_l$，并对模型进行微调，以获得$L - 1$层之间输出单元$o_t$和隐藏单元的连接。然后，我们可以选择在训练过程中受影响的所有单位和权重，并保持与输出单位无关的部分不变。选择操作可以看作是对模型进行初始化，保证优化的方向是保护前一个任务的分类空间。最后，我们只对选定的权值进行微调，记为$W_S^t$。算法1描述了选择性再训练的过程。</p><table><thead><tr><th><strong>算法1</strong> 选择性再训练的过程</th></tr></thead><tbody><tr><td>输入：数据集$S^t$，之前的参数$W^{t-1}$</td></tr><tr><td>输出：选择参数$W_s^t$</td></tr><tr><td>1: 冻结参数$W^{t-1}_L$，$S^t={o_t}$</td></tr><tr><td>2: 微调网络</td></tr><tr><td>3: $\text{for l = L,…,l do}$</td></tr><tr><td>4: 添加神经元$i$到$S^t$，如果存在一些神经元$j \in S$，且$W_{l,ij}^{t-1}≠0$</td></tr><tr><td>5: $\text{end for}$</td></tr><tr><td>6: 微调选择的参数$W^t_S$</td></tr></tbody></table><h3 id="3-5-知识蒸馏"><a href="#3-5-知识蒸馏" class="headerlink" title="3.5 知识蒸馏"></a>3.5 知识蒸馏</h3><p>通过选择性再训练，选择性神经元发生变化并且其他神经元被冻结，但不能保证整个模型的优化方向，即激励模型保持之前任务的知识。为了将知识从之前的任务中转移到当前任务中，我们采用了知识蒸馏策略。当$t^{th}$任务到达时，我们希望在相同输入$x^t$的情况下，$E^t_v$的输出与$E^{t−1}_v$的输出相似，这样可以保证$t^{th}$任务和$(t-1)^{th}$任务的分类空间近似。在顺序训练所有数据集后,当$E_v^t$输入相同的图像特征$x^t$时，最后的$e_v$有能力预测相似的$\mu^t_v$和$\sum^t_v$。蒸馏损失记为:</p><p>$$ L_{KD} = ||\mu_v^t - \widehat{\mu _v^t}||_1 + ||\sum_v^t - \widehat{\sum_v^t}||_1 ,  (6) $$</p><p>其中$\mu_v^t$和$\sum_v^t$通过$E^t_v$预测，而$\widehat{\mu_v^t}$和$\widehat{\sum_v^t}$通过$E^{t-1}_v$。</p><p>当$t&gt;1$时，目标函数表示为：</p><p>$$L = L_{CACD-VAE} +\beta L_{KD},  (7) $$</p><p>其中$\beta$为加权知识蒸馏损失的超参数，设为1。</p><h3 id="3-6-训练和推理"><a href="#3-6-训练和推理" class="headerlink" title="3.6 训练和推理"></a>3.6 训练和推理</h3><p>在训练中，我们对数据集进行顺序训练，并保存所有类别的统一语义嵌入。<br>在VAEs的训练阶段结束后，我们利用保存的语义嵌入再现所有类的隐向量。隐向量的生成过程对每个可见类别重复$n_s$次，对每个不可见类别重复$n_u$次。$n_s$和$n_u$分别设置为200和400。这些隐向量包含了这些类别的判别信息。利用不同数据集的隐向量分别训练<code>softmax分类器</code>。</p><p>在测试阶段，通过视觉模态$E_v$编码器将被测试可见类和不可见类的视觉特征投影为隐向量。然后将测试特征输入到训练好的分类器，得到不同数据集的分类结果。</p><table><thead><tr><th>数据集</th><th>语义维度</th><th>图像</th><th>可见类</th><th>不可见类</th></tr></thead><tbody><tr><td>APY</td><td>64</td><td>15339</td><td>20</td><td>12</td></tr><tr><td>AWA1</td><td>85</td><td>30475</td><td>40</td><td>10</td></tr><tr><td>CUB</td><td>312</td><td>11788</td><td>150</td><td>50</td></tr><tr><td>SUN</td><td>102</td><td>14340</td><td>645</td><td>72</td></tr></tbody></table><p>表1：实验使用的数据集及其统计信息。</p><h2 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h2><p>在本节中，我们将详细介绍所涉及的数据集、评估指标和实现细节。然后，我们将呈现几个最先进的竞争对手以及我们的方法的实验结果。最后，消融研究将证明我们所提出方法的有效性。</p><h3 id="4-1-基准和评估标准"><a href="#4-1-基准和评估标准" class="headerlink" title="4.1 基准和评估标准"></a>4.1 基准和评估标准</h3><p>我们在四个数据集上评估我们的方法: <code>Attribute Pascal</code>和<code>Yahoo数据集(aPY)</code>，<code>Animals with Attributes 1 (AW A1)</code>，<code>Caltech-UCSD-Birds 200-2011数据集(CUB)</code>和<code>SUN Attribute数据集(SUN)</code>。数据集统计如表1所示。对于所有数据集，我们使用预先训练的101层的<code>ResNet</code>提取2048维视觉特征。训练数据集的顺序为<code>aPY</code>, <code>AWA1</code>, <code>CUB</code>和<code>SUN</code>，都是按字母顺序排列的。</p><p>遵循广义零样本学习方法，我们对终身零样本学习采用相同的评价指标:</p><ul><li><p>u：是对每类带有预测标签集的不可见类别的测试图像进行分类的平均准确率，用于衡量识别不可见类的能力。</p></li><li><p>s：是对每类带有预测标签集的可见类的测试图像进行分类的平均准确率，用于衡量识别增量可见类的能力。</p></li><li><p>H：u和s的调和均值，公式为：$H=\frac{2×u×s}{u+s}$。</p></li></ul><p>我们任务中最重要的指标是，H平衡u和s指标之间的性能。对所有数据集进行训练后，对三个度量的所有结果进行测量。</p><h3 id="4-2-实施细则"><a href="#4-2-实施细则" class="headerlink" title="4.2 实施细则"></a>4.2 实施细则</h3><p>所有的编码器和解码器都是多层感知机，有一个隐藏层。我们使用了1560个隐藏单元作为图像特征编码器，1660个作为解码器。编码器和解码器的属性分别有1450个和660个隐藏单元。$\delta$从第6个epoch到第22个epoch以每轮0.54的速率增加，而$\gamma$从第21个epoch到第75个epoch以每个epoch按0.044的速率增加。KL散度的权重$\lambda$以每个epoch按照0.0026的速率增加，直到第90个epoch。此外，我们使用L1距离作为重构误差，得到了比L2更好的结果。</p><p>对于每个数据集，epoch的数量设置为100，批处理大小(batch size)设置为50。VAEs学习率设置为0.00015，分类器学习率设置为0.001。另外，我们的方法是用<code>PyTorch</code>实现的，并通过<code>ADAM</code>优化器进行优化。</p><h3 id="4-3-与现存基准程序的比较"><a href="#4-3-与现存基准程序的比较" class="headerlink" title="4.3 与现存基准程序的比较"></a>4.3 与现存基准程序的比较</h3><p><strong>基线模型</strong>。由于之前没有关于终身零样本学习的研究，我们将结合了CACD-VAE与传统的终身学习方法的基线进行比较。<br>(a) 顺序微调(SFT): 当一个新任务按顺序到达时，模型被微调，该模型的参数从在前一个任务训练或微调的模型进行初始化。<br>(b) L2正则化(L2): 在每个任务t上，$W_t$初始化为$W_{t−1}$，在$W_t$和$W_{t−1}$之间持续进行L2正则化训练。<br>(C) L1正则化(L1): 在每个任务t上，$W_t$初始化为$W_{t−1}$，在$W_t$和$W_{t−1}$之间持续进行L1正则化训练。</p><p><strong>结果和分析</strong>。表2总结了在四个基准数据集上的所有的对比方法以及我们的方法在三个评价指标下的结果。对于GZSL指标上的零样本学习方法，H是评价零样本学习方法性能最重要的指标，它平衡了u和s指标的性能。</p><p>表2中的“Base”表示模型在没有任何终身策略的情况下按顺序训练，“Original”表示分别训练数据集的模型。显然，我们可以发现Base的结果获得了之前数据集的最差性能，当新任务到来时，这些数据集不具备积累之前数据集的知识的能力。此外，采用顺序微调策略的模型比不采用该策略的模型的结果更差，这表明了零样本学习中存在灾难性遗忘问题。</p><p>与其他基准相比，我们的方法在前三个数据集中获得了三个评价指标的最佳性能。在<code>aPY数据集</code>上，我们的模型的u达到了29.11%，s达到了43.29%和H达到了34.81%，其中u提升了2.69%，s提升了13.50%，并且H提升了6.80%。在<code>AWA1数据集</code>上，我们的模型的u达到了51.17%，s达到了63.66%和H达到了56.73%，其中u提升了1.53%,s提升了4.59%，并且H提升了3.14%。在<code>CUB数据集</code>上，我们的模型的u达到了38.82%,s达到了45.81%和H达到了42.03%，其中u提升了3.29%,s提升了11.07%，并且H提升了7.68%。尽管我们的方法没有在SUN数据集上获得最好的结果，但是与其他数据集的改进相比，结果只下降了很少，这是因为我们的方法更好地平衡了从之前任务积累知识的能力以及当前任务获取知识的能力。我们还计算了这些方法在四个数据集上的平均H值。Base、SFT、L1、L2以及我们方法的平均H值分别为10.2%、36.73%、38.03%、36.73%和42.48%，平均H值提高了4.45%。综上所述，我们的方法在之前任务和当前任务中获得了均衡的性能，并且明显优于基线程序。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201230134611.png" alt="3"></p><h3 id="4-4-消融研究"><a href="#4-4-消融研究" class="headerlink" title="4.4 消融研究"></a>4.4 消融研究</h3><p>我们进行了两组消融实验来研究我们方法的有效性。</p><p>表3显示了添加了不同模块的基本模型的结果。基本模型为使用了连续微调训练策略的CACD-VAE。在基础模型的基础上，加入知识蒸馏模块和选择性再训练模块，分别用“KD”和“SR”表示。如表3所示，知识蒸馏和选择性再训练都可以提高前三个数据集的性能。加入“KD”的改进表明知识蒸馏可以将前一个任务的知识转移到当前任务中，在一定程度上缓解了灾难性遗忘的不利影响。此外，添加“SR”的改进表明选择性再训练可以保留之前任务中受影响的权重，避免负迁移，因为没有被选择的神经元不会受到再训练过程的影响。当添加所有模块时，我们的方法表现得最好。</p><p>我们做了一个实验来讨论数字$n_s$和$n_u$重放的影响，其平均H结果如图3所示。<br>当$n_s$和$n_u$被设置为200和400时，可以获得最佳性能。显然，我们可以注意到一个现象：在平均H达到峰值性能之前，平均H随着$n_s$和$n_u$的增加而增加。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201230134705.png" alt="4"></p><p>图3:不同$n_s$和$n_u$超参数下的平均H结果。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>据我们所知，本文是第一个尝试介绍和解决终身零样本学习的。首先，我们采用VAEs方法获得统一的语义嵌入，从而弥补了不同数据集语义嵌入之间的差距。然后，利用选择性再训练策略，在很大程度上保留前一训练阶段构造的投影。最后，我们从之前的任务中提炼出知识，并转移到当前的训练阶段。实验结果表明，该方法在4个基准数据集上性能均明显优于以往的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lifelong-Zero-Shot-Learning-论文翻译&quot;&gt;&lt;a href=&quot;#Lifelong-Zero-Shot-Learning-论文翻译&quot; class=&quot;headerlink&quot; title=&quot;Lifelong Zero-Shot Learning(</summary>
      
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文笔记" scheme="https://blog.justlovesmile.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="小样本学习" scheme="https://blog.justlovesmile.top/tags/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 什么是知识图谱</title>
    <link href="https://blog.justlovesmile.top/posts/ba289ad3.html"/>
    <id>https://blog.justlovesmile.top/posts/ba289ad3.html</id>
    <published>2020-12-23T11:34:42.000Z</published>
    <updated>2020-12-23T11:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是知识图谱"><a href="#什么是知识图谱" class="headerlink" title="什么是知识图谱"></a>什么是知识图谱</h1><h2 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a>1. 来源</h2><p>2012年5月17日，<strong>Google</strong>正式提出了<strong>知识图谱</strong>（Knowledge Graph）的概念，其初衷是为了优化搜索引擎返回的结果，增强用户搜索质量及体验。</p><p>实际上，知识图谱并不是一个全新的概念，早在 2006 年就有文献提出了语义网（Semantic Network）的概念，呼吁推广、完善使用本体模型来形式化表达数据中的隐含语义，RDF（resource description framework，资源描述框架）模式和 OWL（Web ontology language，万维网本体语言）就是基于上述目的产生的。用电子科技大学徐增林教授的论文原文来说：</p><p>知识图谱技术的出现正是基于以上相关研究，是对语义网标准与技术的一次扬弃与升华。</p><p>目前，随着智能信息服务应用的不断发展，知识图谱已广泛应用于智能搜索，智能问答，个性化推荐等领域。</p><h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p><strong>知识图谱</strong>，本质上，是一种揭示<strong>实体</strong>之间<strong>关系</strong>的语义网络。</p><p>看一张简单的知识图谱：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201223193032.jpg" alt="img"></p><p>如图所示，你可以看到，如果两个节点之间存在关系，他们就会被一条无向边连接在一起，那么这个节点，我们就称为<strong>实体</strong>（Entity），它们之间的这条边，我们就称为<strong>关系</strong>（Relationship）。</p><p>如果你看过网络综艺《奇葩说》第五季第17期：你是否支持全人类一秒知识共享，你也许会被辩手陈铭的辩论印象深刻。他在节目中区分了信息和知识两个概念：</p><p>信息是指外部的客观事实。举例：这里有一瓶水，它现在是7°。</p><p>知识是对外部客观规律的归纳和总结。举例：水在零度的时候会结冰。</p><p>“客观规律的归纳和总结” 似乎有些难以实现。Quora 上有另一种经典的解读，区分 “信息” 和 “知识” 。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201223193045.jpg" alt="img"></p><p>这样我们就很容易理解，在信息的基础上，建立实体之间的联系，就能行成 “知识”，或者称为叫事实（Fact）更为合适。换句话说，知识图谱是由一条条知识组成，每条知识表示为一个SPO<strong>三元组</strong>(Subject-Predicate-Object)。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201223193127.png" alt="img"></p><p>知识图谱实际上就是如此工作的。曾经知识图谱非常流行<strong>自顶向下</strong>(top-down)的构建方式。自顶向下指的是先为知识图谱定义好本体与数据模式，再将实体加入到知识库。该构建方式需要利用一些现有的结构化知识库作为其基础知识库，例如 Freebase 项目就是采用这种方式，它的绝大部分数据是从维基百科中得到的。</p><p>然而目前，大多数知识图谱都采用<strong>自底向上</strong>(bottom-up)的构建方式。自底向上指的是从一些开放链接数据（也就是 “信息”）中提取出实体，选择其中置信度较高的加入到知识库，再构建实体与实体之间的联系。</p><h2 id="3-数据类型和存储方式"><a href="#3-数据类型和存储方式" class="headerlink" title="3. 数据类型和存储方式"></a>3. 数据类型和存储方式</h2><p>知识图谱的原始数据类型一般来说有三类（也是互联网上的三类原始数据）：</p><ul><li><p>结构化数据（Structed Data）：如关系数据库</p></li><li><p>半结构化数据（Semi-Structed Data）：如XML、JSON、百科</p></li><li><p>非结构化数据（UnStructed Data）：如图片、音频、视频、文本</p></li></ul><p>如何存储上面这三类数据类型呢？一般有两种选择，一个是通过RDF（资源描述框架）这样的规范存储格式来进行存储，还有一种方法，就是使用图数据库来进行存储，常用的有Neo4j等。</p><h2 id="4-体系架构"><a href="#4-体系架构" class="headerlink" title="4. 体系架构"></a>4. 体系架构</h2><p>知识图谱的架构主要包括自身的<strong>逻辑结构</strong>以及<strong>体系架构</strong>。</p><p>知识图谱在<strong>逻辑结构</strong>上可分为<strong>模式层</strong>与<strong>数据层</strong>两个层次，<strong>数据层</strong>主要是由一系列的事实组成，而知识将以事实为单位进行存储。如果用（实体1，关系，实体2）、（实体、属性，属性值）这样的三元组来表达事实，可选择图数据库作为存储介质，例如开源的 Neo4j、Twitter 的 FlockDB、JanusGraph 等。<strong>模式层</strong>构建在数据层之上，主要是通过本体库来规范数据层的一系列事实表达。本体是结构化知识库的概念模板，通过本体库而形成的知识库不仅层次结构较强，并且冗余程度较小。</p><p>知识图谱的<strong>体系架构</strong>是指其构建模式的结构，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201223193136.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201223193143.jpg" alt="img"></p><p>大规模知识库的构建与应用需要多种智能信息处理技术的支持。通过知识抽取技术，可以从一些公开的半结构化、非结构化的数据中提取出实体、关系、属性等知识要素。通过知识融合，可消除实体、关系、属性等指称项与事实对象之间的歧义，形成高质量的知识库。知识推理则是在已有的知识库基础上进一步挖掘隐含的知识，从而丰富、扩展知识库。分布式的知识表示形成的综合向量对知识库的构建、推理、融合以及应用均具有重要的意义。</p><h2 id="5-知识抽取"><a href="#5-知识抽取" class="headerlink" title="5. 知识抽取"></a>5. 知识抽取</h2><p>知识抽取主要是面向开放的链接数据，通过自动化的技术抽取出可用的知识单元，知识单元主要包括实体(概念的外延)、关系以及属性3个知识要素，并以此为基础，形成一系列高质量的事实表达，为上层模式层的构建奠定基础。知识抽取有三个主要工作：</p><ul><li><p><strong>实体抽取</strong>：在技术上，更多称为 NER（named entity recognition，命名实体识别），指的是从原始语料中自动识别出命名实体。由于实体是知识图谱中的最基本元素，其抽取的完整性、准确、召回率等将直接影响到知识库的质量。因此，实体抽取是知识抽取中最为基础与关键的一步；</p></li><li><p><strong>关系抽取</strong>：目标是解决实体间语义链接的问题，早期的关系抽取主要是通过人工构造语义规则以及模板的方法识别实体关系。随后，实体间的关系模型逐渐替代了人工预定义的语法与规则。</p></li><li><p><strong>属性抽取</strong>：属性抽取主要是针对实体而言的，通过属性可形成对实体的完整勾画。由于实体的属性可以看成是实体与属性值之间的一种名称性关系，因此可以将实体属性的抽取问题转换为关系抽取问题。</p></li></ul><h2 id="6-知识表示"><a href="#6-知识表示" class="headerlink" title="6. 知识表示"></a>6. 知识表示</h2><p>近年来，以深度学习为代表的表示学习技术取得了重要的进展，可以将实体的语义信息表示为稠密低维实值向量，进而在低维空间中高效计算实体、关系及其之间的复杂语义关联，对知识库的构建、推理、融合以及应用均具有重要的意义。</p><h2 id="7-知识融合"><a href="#7-知识融合" class="headerlink" title="7. 知识融合"></a>7. 知识融合</h2><p>由于知识图谱中的知识来源广泛，存在知识质量良莠不齐、来自不同数据源的知识重复、知识间的关联不够明确等问题，所以必须要进行知识的融合。知识融合是高层次的知识组织，使来自不同知识源的知识在同一框架规范下进行异构数据整合、消歧、加工、推理验证、更新等步骤，达到数据、信息、方法、经验以及人的思想的融合，形成高质量的知识库。知识融合包括两部分内容：<strong>实体链接</strong>，<strong>知识合并</strong>。</p><ul><li><p><strong>实体链接</strong>：是指对于从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作。</p></li><li><p><strong>知识合并</strong>：常见的知识合并需求有两个，一个是合并外部知识库，另一个是合并关系数据库。</p></li></ul><h2 id="8-知识加工"><a href="#8-知识加工" class="headerlink" title="8. 知识加工"></a>8. 知识加工</h2><p>事实本身并不等于知识。要想最终获得结构化，网络化的知识体系，还需要经历知识加工的过程。<strong>知识加工</strong>主要包括三方面内容：<strong>本体构建</strong>、<strong>知识推理</strong>和<strong>质量评估</strong>。</p><h2 id="9-知识更新"><a href="#9-知识更新" class="headerlink" title="9. 知识更新"></a>9. 知识更新</h2><p>从逻辑上看，知识库的更新包括<strong>概念层的更新</strong>和<strong>数据层的更新</strong>。</p><ul><li><p><strong>概念层的更新</strong>是指新增数据后获得了新的概念，需要自动将新的概念添加到知识库的概念层中。</p></li><li><p><strong>数据层的更新</strong>主要是新增或更新实体、关系、属性值，对数据层进行更新需要考虑数据源的可靠性、数据的一致性（是否存在矛盾或冗杂等问题）等可靠数据源，并选择在各数据源中出现频率高的事实和属性加入知识库。</p></li></ul><p>知识图谱的内容更新有两种方式：</p><ul><li><p> <strong>全面更新</strong>：指以更新后的全部数据为输入，从零开始构建知识图谱。这种方法比较简单，但资源消耗大，而且需要耗费大量人力资源进行系统维护；</p></li><li><p> <strong>增量更新</strong>：以当前新增数据为输入，向现有知识图谱中添加新增知识。这种方式资源消耗小，但目前仍需要大量人工干预（定义规则等），因此实施起来十分困难。</p></li></ul><h2 id="10-知识图谱应用"><a href="#10-知识图谱应用" class="headerlink" title="10.   知识图谱应用"></a>10.   知识图谱应用</h2><p>知识图谱为互联网上海量、异构、动态的大数据表达、组织、管理以及利用提供了一种更为有效的方式，使得网络的智能化水平更高，更加接近于人类的认知思维。</p><p><strong>智能搜索，智能问答，社交网络，个性化推荐，情报分析，反欺诈</strong>等等</p><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11.   总结"></a>11.   总结</h2><p>从技术来说，知识图谱的难点在于 NLP，因为我们需要机器能够理解海量的文字信息。但在工程上，我们面临更多的问题，来源于知识的获取，知识的融合。搜索领域能做的越来越好，是因为有成千上万（成百万上亿）的用户，用户在查询的过程中，实际也在优化搜索结果，这也是为什么百度的英文搜索不可能超过 Google，因为没有那么多英文用户。知识图谱也是同样的道理，如果将用户的行为应用在知识图谱的更新上，才能走的更远。</p><p>知识图谱肯定不是人工智能的最终答案，但知识图谱这种综合各项计算机技术的应用方向，一定是人工智能未来的形式之一。</p><h2 id="12-参考资料"><a href="#12-参考资料" class="headerlink" title="12.   参考资料"></a>12.   参考资料</h2><p><a href="https://www.cnblogs.com/huangyc/p/10043749.html">https://www.cnblogs.com/huangyc/p/10043749.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/71128505">https://zhuanlan.zhihu.com/p/71128505</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是知识图谱&quot;&gt;&lt;a href=&quot;#什么是知识图谱&quot; class=&quot;headerlink&quot; title=&quot;什么是知识图谱&quot;&gt;&lt;/a&gt;什么是知识图谱&lt;/h1&gt;&lt;h2 id=&quot;1-来源&quot;&gt;&lt;a href=&quot;#1-来源&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="知识图谱" scheme="https://blog.justlovesmile.top/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 交叉熵损失函数</title>
    <link href="https://blog.justlovesmile.top/posts/fdbf585c.html"/>
    <id>https://blog.justlovesmile.top/posts/fdbf585c.html</id>
    <published>2020-12-11T14:48:21.000Z</published>
    <updated>2020-12-11T14:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cross-Entropy-Error-Function"><a href="#Cross-Entropy-Error-Function" class="headerlink" title="Cross Entropy Error Function"></a>Cross Entropy Error Function</h1><p>交叉熵损失函数</p><h2 id="一，信息量"><a href="#一，信息量" class="headerlink" title="一，信息量"></a>一，信息量</h2><p><strong>信息量：</strong></p><p>任何事件都会承载着一定的信息量，包括已经发生的事件和未发生的事件，只是它们承载的信息量会有所不同。如昨天下雨这个已知事件，因为已经发生，是既定事实，那么它的信息量就为0。如明天会下雨这个事件，因为未有发生，那么这个事件的信息量就大。</p><p>从上面例子可以看出信息量是一个与事件发生概率相关的概念，而且可以得出，事件发生的概率越小，其信息量越大。</p><p>假设$x$是一个离散型随机变量，其取值集合为$X$，概率分布函数为$p(x)$，则定义事件$x=x_0$的信息量为：$I(x_0)=-\log(p(x_0))$</p><h2 id="二，熵"><a href="#二，熵" class="headerlink" title="二，熵"></a>二，熵</h2><p><strong>熵是表示随机变量不确定的度量，是对所有可能发生的事件产生的信息量的期望。</strong>熵值越大，表明这个系统的不确定性就越大。公式如下：</p><p>$$H(X)=-\sum_{i=1}^n p(x_i)\log(p(x_i))$$</p><p>对于0-1分布问题，熵的计算方法可以简化为：</p><p>$$H(x)=-\sum_{i=1}^np(x_i)log(p(x_i))\ =-p(x)\log(p(x))-(1-p(x))\log(1-p(x))$$</p><h2 id="三，相对熵（KL散度）"><a href="#三，相对熵（KL散度）" class="headerlink" title="三，相对熵（KL散度）"></a>三，相对熵（KL散度）</h2><p>相对熵又称KL散度，用于衡量对于同一个随机变量x的两个分布p(x)和q(x)之间的差异。在机器学习中，p(x)常用于描述样本的真实分布，例如[1,0,0,0]表示样本属于第一类，而q(x)则常常用于表示预测的分布，例如[0.7,0.1,0.1,0.1]。显然使用q(x)来描述样本不如p(x)准确，q(x)需要不断地学习来拟合准确的分布p(x)。</p><p>KL散度的公式如下：</p><p>$$D_{KL}(p||q)=\sum_{i=1}^np(x_i)\log(\frac{p(x_i)}{q(x_i)})$$</p><p>KL散度的值越小，表示两个分布越接近。在机器学习中，p往往用来表示样本的真实分布，q用来表示模型所预测的分布，那么KL散度就可以计算两个分布的差异，也就是Loss损失值。</p><h2 id="四，交叉熵"><a href="#四，交叉熵" class="headerlink" title="四，交叉熵"></a>四，交叉熵</h2><p>将KL散度的公式进行变形，得到：</p><p>$$D_{KL}(p||q)=\sum_{i=1}^np(x_i)\log(\frac{p(x_i)}{q(x_i)})\ =\sum_{i=1}^np(x_i)\log(p(x_i))-\sum_{i=1}^np(x_i)\log(q(x_i))$$</p><p>根据熵的定义，前半部分是$p(x)$的熵$H(x)=-\sum_{i=1}^np(x_i)\log(p(x_i))$，而后半部分则是交叉熵，定义为：</p><p>$$H(p,q)=-\sum_{i=1}^np(x_i)\log(q(x_i))$$</p><p>因此$D_{KL}(p||q)=H(p,q)-H(p)$ ，在机器学习中，我们需要评估label和predicts之间的差距，使用KL散度刚刚好，即 $D_{KL}(p|| \widetilde {q})$ ，由于KL散度中的前一部分$−H(p)$不变，故在优化过程中，只需要关注交叉熵就可以了。</p><h2 id="五，交叉熵损失函数"><a href="#五，交叉熵损失函数" class="headerlink" title="五，交叉熵损失函数"></a>五，交叉熵损失函数</h2><p>在线性回归问题中，常常使用MSE(Mean Squared Error)作为loss函数，而在分类问题中常常使用交叉熵作为loss函数，特别是在神经网络作分类问题时，并且由于交叉熵涉及到计算每个类别的概率，所以交叉熵几乎每次都和sigmoid或者softmax函数一起出现。</p><p><strong>(1)二分类</strong></p><p>在二分的情况下，对于每个类别我们的预测的到的概率为p和1-p。此时表达式为：</p><p>$$L=\frac{1}{N}\sum_iL_i=\frac{1}{N}\sum_i(-[y_i\log(p_i)+(1-y_i)\log(1-p_i)])$$</p><p>其中：</p><ul><li>$y_i$表示样本i的label，正类为1，负类为0</li><li>$p_i$表示样本i预测为正的概率</li></ul><p><strong>(2)多分类</strong></p><p>多分类问题实际上就是对二分类问题的扩展：</p><p>$$L=\frac{1}{N}\sum_iL_i=\frac{1}{N}\sum_i(-\sum_{j=1}^My_{ij}\log(p_{ij}))$$</p><p>其中：</p><ul><li>M 表示类别的数量</li><li>$y_{ij}$表示该类别和样本i类别是否相同，相同为1，不同为0</li><li>$p_{ij}$表示对于观测样本i属于类别j的预测概率</li></ul><p>例如：</p><table><thead><tr><th>id</th><th>predict</th><th>label</th><th>isCorrect</th></tr></thead><tbody><tr><td>1</td><td>0.3 0.3 0.4</td><td>0 0 1</td><td>1</td></tr><tr><td>2</td><td>0.3 0.4 0.3</td><td>0 1 0</td><td>1</td></tr><tr><td>3</td><td>0.1 0.2 0.7</td><td>1 0 0</td><td>0</td></tr></tbody></table><p>那么求其Loss：<br>$$L_1=-(0\times \log 0.3+0\times \log 0.3+1\times \log 0.4)$$<br>$$L_2=-(0\times \log 0.3+1\times \log 0.4+0\times \log 0.3)$$<br>$$L_3=-(1\times \log 0.1+0\times \log 0.2+0\times \log 0.7)$$<br>对所有样本的Loss求平均<br>$$Loss=\frac{L_1+L_2+L_3}{3}$$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/74075915">https://zhuanlan.zhihu.com/p/74075915</a></p><p><a href="https://zhuanlan.zhihu.com/p/61944055">https://zhuanlan.zhihu.com/p/61944055</a></p><p><a href="https://zhuanlan.zhihu.com/p/35709485">https://zhuanlan.zhihu.com/p/35709485</a></p><p><a href="https://blog.csdn.net/b1055077005/article/details/100152102">https://blog.csdn.net/b1055077005/article/details/100152102</a></p>]]></content>
    
    
    <summary type="html">交叉熵损失函数经常用于分类问题中，特别是在神经网络做分类问题时，也经常使用交叉熵作为损失函数，此外，由于交叉熵涉及到计算每个类别的概率，所以交叉熵几乎每次都和sigmoid(或softmax)函数一起出现。这篇文章主要介绍什么是交叉熵损失函数。</summary>
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="损失函数" scheme="https://blog.justlovesmile.top/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 论文笔记（A Review on Generative Adversarial Networks）</title>
    <link href="https://blog.justlovesmile.top/posts/c63e7cba.html"/>
    <id>https://blog.justlovesmile.top/posts/c63e7cba.html</id>
    <published>2020-12-09T15:47:49.000Z</published>
    <updated>2020-12-09T15:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-Review-on-Generative-Adversarial-Networks-Algorithms-Theory-and-Applications"><a href="#A-Review-on-Generative-Adversarial-Networks-Algorithms-Theory-and-Applications" class="headerlink" title="A Review on Generative Adversarial Networks: Algorithms, Theory, and Applications"></a>A Review on Generative Adversarial Networks: Algorithms, Theory, and Applications</h2><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201209235414.jpg" alt="0fe50f6cc4ef45dbaee2e011ea2940bb_th"></p><p><a href="https://arxiv.org/pdf/2001.06937.pdf">Arxiv Link : https://arxiv.org/pdf/2001.06937.pdf</a></p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Generative Adversarial Networks (GANs)  have been widely studied since 2014. There are a large number of different GANs variants.</p><blockquote><p>生成对抗网络，始于2014年，现在已有很多变种</p></blockquote><h3 id="Index-Terms"><a href="#Index-Terms" class="headerlink" title="Index Terms"></a>Index Terms</h3><p>Deep Learning ; GANs ; Algorithm ; Theory ; Applications</p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>GANs consists of two models: a generator and a discriminator. These two models are typically implemented by neural networks, but they can be implemented with any form of differentiable system that maps data from one space to the other.</p><blockquote><p>GANs包括两个模型：一个生成器和一个辨别器。一般是由神经网络实现，但是也可以由不同类型的能映射数据到另一个空间的可微系统实现。</p></blockquote><p>The generator tries to capture the distribution of true examples for new data example  generation. </p><blockquote><p>生成器试图捕获真实示例的分布，以生成新的数据示例。</p></blockquote><p>The discriminator is usually a binary classifier, discriminating generated examples from the true examples as accurately as possible.</p><blockquote><p>鉴别器通常是一个二进制分类器，尽可能准确地将生成的示例与真实的示例区分开来。</p></blockquote><p>The optimization of GANs is a minimax optimization problem. The goal is to reach Nash equilibrium.</p><blockquote><p>Nash equilibrium即纳什均衡，对于GANs，其损失是：</p><p>$$\min_G \max_D V(D,G)=\mathbb{E} _ {x \sim p_{data}(x)}[\log D(x)]+\mathbb{E} _ {z \sim p_z(z)}[\log (1-D(G(z)))] $$</p><p>生成器G和判别器D两者相互对抗，共同学习，不断优化</p></blockquote><h3 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h3><p>GANs belong to generative algorithms</p><blockquote><p>GANs 属于生成算法</p></blockquote><h4 id="2-1-Generative-algorithms"><a href="#2-1-Generative-algorithms" class="headerlink" title="2.1 Generative algorithms"></a>2.1 Generative algorithms</h4><p>Generative algorithms can be classified into two classes: explicit density model and implicit density model.</p><blockquote><p>生成算法可分为两类：显式密度模型和隐式密度模型。</p></blockquote><h5 id="2-1-1-Explicit-density-model"><a href="#2-1-1-Explicit-density-model" class="headerlink" title="2.1.1 Explicit density model"></a>2.1.1 Explicit density model</h5><p>An explicit density model assumes the distribution and utilizes true data to train the model containing the distribution or fit the distribution parameters. When finished, new examples are produced utilizing the learned model or distribution.</p><blockquote><p>显式密度模型假设分布，并利用真实数据训练包含分布的模型或拟合分布参数。完成后，利用学习的模型或分布产生新的示例。</p></blockquote><p>The explicit density models include maximum likelihood estimation (MLE), approximate inference, and Markov chain method.</p><blockquote><p>显式密度模型包括最大似然估计（MLE），近似推断和马尔可夫链方法。</p></blockquote><h5 id="2-1-2-Implicit-density-model"><a href="#2-1-2-Implicit-density-model" class="headerlink" title="2.1.2 Implicit density model"></a>2.1.2 Implicit density model</h5><p>It produces data instances from the distribution without an explicit hypothesis and utilizes the produced examples to modify the model.</p><blockquote><p>它在没有明确假设的情况下从分布中生成数据实例，并利用生成的实例来修改模型。</p></blockquote><p>GANs belong to the directed implicit density model category.</p><blockquote><p>GANs属于有向隐式密度模型类别。</p></blockquote><h5 id="2-1-3-The-comparison-between-GANs-and-other-generative-algorithms"><a href="#2-1-3-The-comparison-between-GANs-and-other-generative-algorithms" class="headerlink" title="2.1.3 The comparison between GANs and other generative algorithms"></a>2.1.3 The comparison between GANs and other generative algorithms</h5><p>The basic idea behind adversarial learning is that the generator tries to create as realistic examples as possible to deceive the discriminator. The discriminator tries to distinguish fake examples from true examples. Both the generator and discriminator improve through adversarial learning. </p><blockquote><p>对抗式学习背后的基本思想是，生成器试图创建尽可能真实的示例来欺骗鉴别器。鉴别器试图区分假例子和真例子。生成器和鉴别器都通过对抗性学习进行改进。</p></blockquote><h4 id="2-2-Adversarial-idea"><a href="#2-2-Adversarial-idea" class="headerlink" title="2.2 Adversarial idea"></a>2.2 Adversarial idea</h4><p>Adversarial machine learning is a minimax problem. The defender, who builds the classifier that we want to work correctly, is searching over the parameter space to find the parameters that reduce the cost of the classifier as much as possible. Simultaneously, the attacker is searching over the inputs of the model to maximize the cost.</p><blockquote><p>对抗性机器学习是一个极小极大问题。防守者(defender)构建了我们想要正确工作的分类器，他在参数空间中搜索尽可能降低分类器成本（cost）的参数（parameter）。同时，攻击者(attacker)搜索模型的输入以使成本（cost）最大化。</p></blockquote><h3 id="3-Algorithms"><a href="#3-Algorithms" class="headerlink" title="3. Algorithms"></a>3. Algorithms</h3><h4 id="3-1-Generative-Adversarial-Nets-（GANs）"><a href="#3-1-Generative-Adversarial-Nets-（GANs）" class="headerlink" title="3.1 Generative Adversarial Nets （GANs）"></a>3.1 Generative Adversarial Nets （GANs）</h4><p>In order to learn the generator’s distribution $p_g$ over data $x$, a prior on input noise variables is defined as $p_z(z)$ and $z$ is the noise variable. </p><blockquote><p>为了了解生成器在数据$x$上的分布$p_g$，将输入噪声变量的先验定义为$p_z(z)$，$z$是噪声变量。</p></blockquote><p>Then, GANs represent a mapping from noise space to data space as $G(z, \theta_g)$, where G is a differentiable function represented by a neural network with parameters $\theta_g$. </p><blockquote><p>GANs将噪声空间到数据空间的映射表示为$G(z, \theta_g)$，其中G是一个由参数$\theta_g$的神经网络表示的可微函数</p></blockquote><p>Other than G, the other neural network $D(x, \theta_d)$ is also defined with parameters $\theta_d$ and the output of $D(x)$ is a single scalar. $D(x)$ denotes the probability that x was from the data rather than the generator G. </p><blockquote><p>除G外，另一个神经网络$D(x, \theta_d)$ 也根据参数$\theta_d$定义，$D(x)$的输出为单标量。$D(x)$表示$x$来自数据而不是生成器G的概率。</p></blockquote><p>The discriminator D is trained to maximize the probability of giving the correct label to both training data and fake samples generated from the generator G. G is trained to minimize $\log (1 −D (G(z)))$ simultaneously .</p><blockquote><p>对鉴别器D进行训练以最大限度地提高对训练数据和从生成器G生成的伪样本给出正确标签的概率。G被训练以同时最小化$\log(1−D(G(z))$。</p></blockquote><h5 id="3-1-1-Objective-function"><a href="#3-1-1-Objective-function" class="headerlink" title="3.1.1 Objective function"></a>3.1.1 Objective function</h5><p><strong>(1) Original minimax game</strong></p><p>The objective function of GANs is :</p><p>$$\min_G \max_D V(D,G)=\mathbb{E} _ {x \sim p_{data}(x)}[\log D(x)]+\mathbb{E} _ {z \sim p_z(z)}[\log (1-D(G(z)))]$$</p><p>$\log D(x)$ is the cross-entropy between $\begin{bmatrix}1 &amp; 0 \end{bmatrix}^T$ and $\begin{bmatrix}D(x) &amp; 1-D(x) \end{bmatrix}^T$. Similarly, $\log(1-D(G(z)))$ is the cross-entropy between  $\begin{bmatrix}0 &amp; 1 \end{bmatrix}^T$ and $\begin{bmatrix}D(G(z)) &amp; 1-D(G(z)) \end{bmatrix}^T$ . </p><blockquote><p>$\log D(x)$是$\begin{bmatrix}1 &amp; 0 \end{bmatrix}^T$和$\begin{bmatrix}D(x) &amp; 1-D(x) \end{bmatrix}^T$之间的<a href="/posts/fdbf585c.html">交叉熵</a>。同样，$\log(1-D(G(z)))$是$\begin{bmatrix}0 &amp; 1 \end{bmatrix}^T$和$\begin{bmatrix}D(G(z)) &amp; 1-D(G(z)) \end{bmatrix}^T$之间的<a href="/posts/fdbf585c.html">交叉熵</a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;A-Review-on-Generative-Adversarial-Networks-Algorithms-Theory-and-Applications&quot;&gt;&lt;a href=&quot;#A-Review-on-Generative-Adversarial-Network</summary>
      
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="GAN" scheme="https://blog.justlovesmile.top/tags/GAN/"/>
    
    <category term="论文笔记" scheme="https://blog.justlovesmile.top/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 如何理解卷积</title>
    <link href="https://blog.justlovesmile.top/posts/ef2381bd.html"/>
    <id>https://blog.justlovesmile.top/posts/ef2381bd.html</id>
    <published>2020-11-03T11:09:20.000Z</published>
    <updated>2020-11-03T11:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是卷积"><a href="#1-什么是卷积" class="headerlink" title="1.什么是卷积"></a>1.什么是卷积</h2><p>对于卷积的定义，如下：</p><p><strong>连续形式</strong></p><p>$$(f×g)(n)=\int_{-\infty}^{\infty}f(\tau )g(n-\tau)d\tau$$</p><p><strong>离散形式</strong></p><p>$$(f×g)(n)=\sum_{\tau=-\infty}^{\infty}f(\tau)g(n-\tau)$$</p><blockquote><p>先对g函数进行翻转，相当于在数轴上把g函数从右边褶到左边去，也就是卷积的“卷”的由来。<br>然后再把g函数平移到n，在这个位置对两个函数的对应点相乘，然后相加，这个过程是卷积的“积”的过程。</p></blockquote><p>上述公式中有一个共同的特征：<br>$$n=\tau + (n - \tau)$$</p><p>对于这个特征，我们可以令$x=\tau$,$y=n-\tau$，那么x+y=n就是一些直线</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/v2-8be52f6bada3f7a21cebfc210d2e7ea0_hd.gif"></p><p>如果遍历这些直线，就好比，把毛巾沿着角卷起来：</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/v2-1d0c819fc7ca6f8da25435da070a2715_hd.webp"></p><h2 id="2-通俗易懂的理解卷积"><a href="#2-通俗易懂的理解卷积" class="headerlink" title="2.通俗易懂的理解卷积"></a>2.通俗易懂的理解卷积</h2><h3 id="2-1离散卷积的例子：丢骰子"><a href="#2-1离散卷积的例子：丢骰子" class="headerlink" title="2.1离散卷积的例子：丢骰子"></a>2.1离散卷积的例子：丢骰子</h3><p><strong>问题：</strong></p><p>把两枚骰子抛出去，两枚骰子点数之和为4的概率是多少</p><p><strong>表示：</strong></p><p>如果用f(x)表示第一枚骰子投出x（x∈{1,2,3,4,5,6}）的概率，g(y)表示第二枚骰子投出y（y∈{1,2,3,4,5,6}）的概率</p><p><strong>结果：</strong></p><p>两枚骰子点数加起来等于4的情况有：<br>f(1)g(3)和f(2)g(2)和f(3)g(1)</p><p>那么概率为P=f(1)g(3)+f(2)g(2)+f(3)g(1)，符合卷积的定义，把他写成标准形式就是<br>$$(f×g)(4)=\sum_{m=1}^{3}f(m)g(4-m)$$</p><h3 id="2-2连续卷积的例子：做馒头"><a href="#2-2连续卷积的例子：做馒头" class="headerlink" title="2.2连续卷积的例子：做馒头"></a>2.2连续卷积的例子：做馒头</h3><p><strong>问题：</strong></p><p>如果有一家包子铺，会生产包子，但是包子会坏掉，那么一天后包子总共坏掉了多少？</p><p><strong>表示：</strong></p><p>假设包子生产速度是f(t)，对于包子铺一天生产的包子数量是<br>$$\int_{0}^{24}f(t)dt$$<br>假设腐败速度是g(t)，那么n个包子生产出来后，24小时会腐败个数<br>$$n * g(t)$$</p><p><strong>结果：</strong></p><p>一天后，包子总共腐败了：<br>$$\int_{0}^{24}f(t)g(24-t)dt$$</p><h3 id="2-3卷积提取图像特征"><a href="#2-3卷积提取图像特征" class="headerlink" title="2.3卷积提取图像特征"></a>2.3卷积提取图像特征</h3><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/v2-05f7af4e1d59e82412832c01b1144f52_720w.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/v2-c9b00043ba326451979abda5417bfcdf_720w.jpg"></p><p>卷积核和图像进行点乘（dot product), 就代表卷积核里的权重单独对相应位置的Pixel进行作用</p><p><strong>这里我想强调一下点乘，虽说我们称为卷积，实际上是位置一一对应的点乘，不是真正意义的卷积</strong></p><p>比如图像位置（1,1）乘以卷积核位置（1,1），仔细观察右上角你就会发现了</p><p>例如：对于一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201103204533.png"></p><p>我们进行手动卷积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> torch,torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">path=<span class="string">&quot;./1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(path)</span><br><span class="line">transform = transforms.Compose([transforms.ToTensor()])<span class="comment">#totensor 得到（C*H*W)</span></span><br><span class="line">im = transform(img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span>(<span class="params">img</span>):</span></span><br><span class="line">    npimg = img</span><br><span class="line">    plt.imshow(np.transpose(npimg,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))) <span class="comment">#chw-&gt;hwc</span></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">k = torch.ShortTensor([[<span class="number">0</span>,-<span class="number">4</span>,<span class="number">0</span>],[-<span class="number">4</span>,<span class="number">16</span>,-<span class="number">4</span>],[<span class="number">0</span>,-<span class="number">4</span>,<span class="number">0</span>]])</span><br><span class="line">stride=<span class="number">2</span> <span class="comment">#步长</span></span><br><span class="line">padding=<span class="number">0</span> <span class="comment"># 补0</span></span><br><span class="line">f = k.size(<span class="number">0</span>) <span class="comment"># 卷积核的形状</span></span><br><span class="line">channels = im.size(<span class="number">0</span>) <span class="comment">#输入的图片的通道数</span></span><br><span class="line">hin = im.size(<span class="number">1</span>) <span class="comment">#输入的图片的高</span></span><br><span class="line">win = im.size(<span class="number">2</span>) <span class="comment">#输入的图片的宽</span></span><br><span class="line">hout = math.floor((hin-f+<span class="number">2</span>*padding)/stride+<span class="number">1</span>) <span class="comment">#输出的图片的高</span></span><br><span class="line">wout = math.floor((win-f+<span class="number">2</span>*padding)/stride+<span class="number">1</span>) <span class="comment">#输出的图片的宽</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;input[&#123;&#125;,&#123;&#125;],output[&#123;&#125;,&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(hin,win,hout,wout))</span><br><span class="line">output=[]</span><br><span class="line">im = im.numpy()</span><br><span class="line">k = k.numpy()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Waite for calculating...&quot;</span>)</span><br><span class="line"><span class="comment"># 自定义卷积，一一对应相乘</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(channels):</span><br><span class="line">    lines=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(hout):</span><br><span class="line">        line=[]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(wout):</span><br><span class="line">            a=[[im[i][j*stride][n*stride],im[i][j*stride][n*stride+<span class="number">1</span>],im[i][j*stride][n*stride+<span class="number">2</span>]],[im[i][j*stride+<span class="number">1</span>][n*stride],im[i][j*stride+<span class="number">1</span>][n*stride+<span class="number">1</span>],im[i][j*stride+<span class="number">1</span>][n*stride+<span class="number">2</span>]],[im[i][j*stride+<span class="number">2</span>][n*stride],im[i][j*stride+<span class="number">2</span>][n*stride+<span class="number">1</span>],im[i][j*stride+<span class="number">2</span>][n*stride+<span class="number">2</span>]]]</span><br><span class="line">            line.append(<span class="built_in">sum</span>(<span class="built_in">sum</span>(a*k)))</span><br><span class="line">        lines.append(line)</span><br><span class="line">    output.append(lines)</span><br><span class="line"></span><br><span class="line">oo=np.array(output)</span><br><span class="line"><span class="built_in">print</span>(oo.shape)</span><br><span class="line">imshow(oo)</span><br></pre></td></tr></table></figure><p><strong>提取特征效果如下：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201103211407111.png"></p><p>部分内容参考<a href="https://www.zhihu.com/question/22298352/answer/637156871">知乎:如何通俗易懂的理解卷积</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是卷积&quot;&gt;&lt;a href=&quot;#1-什么是卷积&quot; class=&quot;headerlink&quot; title=&quot;1.什么是卷积&quot;&gt;&lt;/a&gt;1.什么是卷积&lt;/h2&gt;&lt;p&gt;对于卷积的定义，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$</summary>
      
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="卷积" scheme="https://blog.justlovesmile.top/tags/%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | 《深度学习入门之PyTorch》阅读笔记</title>
    <link href="https://blog.justlovesmile.top/posts/bfa4054.html"/>
    <id>https://blog.justlovesmile.top/posts/bfa4054.html</id>
    <published>2020-10-23T10:43:24.000Z</published>
    <updated>2020-10-23T10:43:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习入门之PyTorch"><a href="#深度学习入门之PyTorch" class="headerlink" title="深度学习入门之PyTorch"></a>深度学习入门之PyTorch</h1><h2 id="第一章-深度学习介绍"><a href="#第一章-深度学习介绍" class="headerlink" title="第一章 深度学习介绍"></a>第一章 深度学习介绍</h2><h3 id="1-1-人工智能"><a href="#1-1-人工智能" class="headerlink" title="1.1 人工智能"></a>1.1 人工智能</h3><ol><li>Artificial Intelligence，人工智能，也称机器智能。</li><li>人工智能分为三大类<br>（1）弱人工智能：擅长单方面<br>（2）强人工智能：类似人类等级<br>（3）超人工智能：全方面胜过人类</li></ol><h3 id="1-2-数据挖掘，机器学习和深度学习"><a href="#1-2-数据挖掘，机器学习和深度学习" class="headerlink" title="1.2 数据挖掘，机器学习和深度学习"></a>1.2 数据挖掘，机器学习和深度学习</h3><h4 id="1-2-1-数据挖掘"><a href="#1-2-1-数据挖掘" class="headerlink" title="1.2.1 数据挖掘"></a>1.2.1 数据挖掘</h4><p>KDD（knowledge discovery in database），从数据中获取有意义的信息</p><h4 id="1-2-2-机器学习"><a href="#1-2-2-机器学习" class="headerlink" title="1.2.2 机器学习"></a>1.2.2 机器学习</h4><ol><li>机器学习是实现人工智能的一种途径，涉及多门学科</li><li>大致分为五个大类<br>（1）监督学习：从给定的训练数据集中学习出一个函数，训练集中的目标是由人标注的，常见算法包括回归和分类<br>（2）无监督学习：训练集没有人为标注，常见算法如聚类<br>（3）半监督学习：介于两者之间<br>（4）迁移学习：将已经训练好的模型参数迁移到新的模型来帮助新模型训练数据集<br>（5）增强学习：通过观察周围环境来学习</li></ol><h4 id="1-2-3-深度学习"><a href="#1-2-3-深度学习" class="headerlink" title="1.2.3 深度学习"></a>1.2.3 深度学习</h4><ol><li>机器学习的一个分支，通过模拟人脑来实现数据特征的提取</li><li>常见网络结构：DNN，CNN，RNN，GAN等等</li></ol><h2 id="第二章-深度学习框架"><a href="#第二章-深度学习框架" class="headerlink" title="第二章 深度学习框架"></a>第二章 深度学习框架</h2><h3 id="2-1-深度学习框架介绍"><a href="#2-1-深度学习框架介绍" class="headerlink" title="2.1 深度学习框架介绍"></a>2.1 深度学习框架介绍</h3><ol><li>Tensorflow<br>Google开源的基于C++开发的数学计算软件</li><li>Caffe</li><li>Theano</li><li>Torch<br>支持动态图</li><li>MXNet</li></ol><h3 id="2-2-PyTorch介绍"><a href="#2-2-PyTorch介绍" class="headerlink" title="2.2 PyTorch介绍"></a>2.2 PyTorch介绍</h3><h4 id="2-2-1-什么是PyTorch"><a href="#2-2-1-什么是PyTorch" class="headerlink" title="2.2.1 什么是PyTorch"></a>2.2.1 什么是PyTorch</h4><p>Python优先的深度学习框架，支持GPU加速和动态神经网络</p><h4 id="2-2-2-为什么使用PyTorch"><a href="#2-2-2-为什么使用PyTorch" class="headerlink" title="2.2.2 为什么使用PyTorch"></a>2.2.2 为什么使用PyTorch</h4><p>1.多学习一个框架准没错<br>2.PyTorch通过一种反向自动求导的技术，可以让你零延迟地改变神经网络<br>3.线性，直观，易于使用<br>4.代码简洁直观，底层代码友好</p><h3 id="2-3-配置PyTorch深度学习环境"><a href="#2-3-配置PyTorch深度学习环境" class="headerlink" title="2.3 配置PyTorch深度学习环境"></a>2.3 配置PyTorch深度学习环境</h3><h4 id="2-3-1-操作系统"><a href="#2-3-1-操作系统" class="headerlink" title="2.3.1 操作系统"></a>2.3.1 操作系统</h4><p>Windows，Linux，Mac</p><h4 id="2-3-2-Python开发环境的安装"><a href="#2-3-2-Python开发环境的安装" class="headerlink" title="2.3.2 Python开发环境的安装"></a>2.3.2 Python开发环境的安装</h4><p>Anaconda</p><h4 id="2-3-3-PyTorch安装"><a href="#2-3-3-PyTorch安装" class="headerlink" title="2.3.3 PyTorch安装"></a>2.3.3 PyTorch安装</h4><p>官网或者anaconda</p><p>CPU或GPU</p><p>CUDA，CuDnn</p><h2 id="第三章-多层全连接神经网络"><a href="#第三章-多层全连接神经网络" class="headerlink" title="第三章 多层全连接神经网络"></a>第三章 多层全连接神经网络</h2><h3 id="3-1-PyTorch基础"><a href="#3-1-PyTorch基础" class="headerlink" title="3.1 PyTorch基础"></a>3.1 PyTorch基础</h3><h4 id="3-1-1-Tensor张量"><a href="#3-1-1-Tensor张量" class="headerlink" title="3.1.1 Tensor张量"></a>3.1.1 Tensor张量</h4><p>Tensor相当于多维的矩阵</p><p>Tensor的数据类型有：(32位浮点型)torch.FloatTensor，（64位浮点型）torch.DoubleTensor，（16位整型）torch.ShortTensor,（32位整型）torch.IntTensor，（64位整型）torch.LongTensor</p><p><strong>导入pytorch</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><p><strong>创建一个没有初始化的5×3矩阵</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.empty(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><strong>创建一个随机初始化矩阵</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#均匀分布[0,1],rand</span></span><br><span class="line">x=torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#正态分布，randn</span></span><br><span class="line">x=torch.randn(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><strong>构造一个0矩阵，且数据类型为long</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.zeros(<span class="number">5</span>,<span class="number">3</span>,dtype=torch.long)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><strong>直接根据数据构造张量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.tensor([<span class="number">5.5</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><strong>创建一个全为1的矩阵，且数据类型为double</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=torch.ones(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">x=x.new_ones(<span class="number">5</span>,<span class="number">3</span>,dtype=torch.double)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><strong>根据已有tensor建立新的tensor，且除非提供新值，将重用所给张量属性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=x.new_ones(<span class="number">5</span>,<span class="number">3</span>,dtype=torch.double)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">x=torch.randn_like(x,dtype=torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><strong>获取张量的形状</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.size())</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong><br><code>torch.Size</code>本质上还是tuple，所以支持tuple的一切操作</p></blockquote><p><strong>和numpy的相互转换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">numpy_x = x.numpy()</span><br><span class="line"><span class="built_in">print</span>(numpy_x)</span><br><span class="line">torch_x = torch.from_numpy(numpy_x)</span><br><span class="line"><span class="built_in">print</span>(torch_x)</span><br></pre></td></tr></table></figure><p><strong>绝对值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">b=torch.<span class="built_in">abs</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p><strong>运算</strong>，例如加法</p><p><strong>形式一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y=torch.rand(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(x+y)</span><br></pre></td></tr></table></figure><p><strong>形式二</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(torch.add(x,y))</span><br></pre></td></tr></table></figure><p><strong>形式三</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result=torch.empty(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">torch.add(x,y,out=result)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p><strong>形式四</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y.add_(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong><br>任何一个in-place改变张量的操作后面都固定一个_。例如x.copy_(y)、x.t_()将更改x</p></blockquote><p><strong>剪裁</strong>:如果在上下边界内则不变，否则大于上边界值，则改为上边界值，小于下边界值，则改为下边界值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">b=torch.clamp(a,-<span class="number">0.1</span>,<span class="number">0.1</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p><strong>除法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">b=torch.randn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">c=torch.div(a,b)</span><br><span class="line">d=torch.div(c,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><blockquote><p><strong>加法</strong>add，<strong>乘积</strong>mul，<strong>除法</strong>div，<strong>求幂</strong>pow，<strong>矩阵乘法</strong>mm，<strong>矩阵向量乘法</strong>mv</p></blockquote><p><strong>改变张量形状</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">y=x.view(<span class="number">16</span>)</span><br><span class="line">z=x.view(-<span class="number">1</span>,<span class="number">8</span>) <span class="comment"># -1将会自动取值</span></span><br><span class="line"><span class="built_in">print</span>(x.size(),y.size(),z.size())</span><br></pre></td></tr></table></figure><p><strong>对于只含一个元素的tensor，可以使用<code>.item()</code>来得到数值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(x.item())</span><br></pre></td></tr></table></figure><p><strong>使用GPU</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">    y = torch.ones_like(x, device=device)</span><br><span class="line">    x = x.to(device)</span><br><span class="line">    z = x+y</span><br><span class="line">    <span class="built_in">print</span>(z)</span><br><span class="line">    <span class="built_in">print</span>(z.to(<span class="string">&quot;CPU&quot;</span>,torch.double))</span><br></pre></td></tr></table></figure><h4 id="3-1-2-Variable（变量）"><a href="#3-1-2-Variable（变量）" class="headerlink" title="3.1.2 Variable（变量）"></a>3.1.2 Variable（变量）</h4><p><strong>1. Autograd：自动求导</strong></p><p><strong>创建一个张量并设置requires_grad=True用来追踪其计算历史</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><strong>对这个张量做一次运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y=x+<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment"># y是计算结果，所以他有grad_fn属性</span></span><br><span class="line"><span class="built_in">print</span>(y.grad_fn)</span><br><span class="line"><span class="comment"># 对y进行更多操作</span></span><br><span class="line">z=y*y*<span class="number">3</span></span><br><span class="line">out=z.mean()</span><br><span class="line"><span class="built_in">print</span>(z,out)</span><br></pre></td></tr></table></figure><p>.requires_grad_(…) 改变了现有张量的 requires_grad 标志。如果没有指定的话，默认输入的这个标志是 False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a = ((a * <span class="number">3</span>) / (a - <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a.requires_grad)</span><br><span class="line">b = (a * a).<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(b.grad_fn)</span><br></pre></td></tr></table></figure><p><strong>2. 梯度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">y=x+<span class="number">2</span></span><br><span class="line">z=y*y*<span class="number">3</span></span><br><span class="line">out=z.mean()</span><br><span class="line"><span class="comment"># 现在开始反向传播，因为out是一个标量，则out.backward()和out.backward(torch.tensor(1.))等价</span></span><br><span class="line">out.backward()</span><br><span class="line"><span class="comment">#输出导数d(out)/dx</span></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure><p>即</p><p>$$out=\frac{1}{4}\sum_iz_i$$</p><p>$$z_i=3(x_i+2)^2$$</p><p>并且$ z _ i| _ {x_i=1}=27$，因此，有</p><p>$$\frac{\partial_{out}}{\partial_{x_i}}=\frac{3}{2}(x_i+2)$$<br>因此<br>$$\frac{\partial _ {out}}{\partial_ {x_i}}|_ {x_i=1}=\frac{9}{2}=4.5$$</p><p><strong>雅可比矩阵</strong></p><p>数学上，若有向量值函数y=f(x)，那么y相当于对x的梯度是一个雅可比矩阵（下面是一个latex数学公式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">J=\begin&#123;bmatrix&#125;</span><br><span class="line">\frac&#123;\partial y_1&#125;&#123;\partial x_1&#125; &amp;\cdots&amp; \frac&#123;\partial y_1&#125;&#123;\partial x_n&#125; \\</span><br><span class="line">\vdots &amp; \ddots &amp; \vdots \\</span><br><span class="line">\frac&#123;\partial y_m&#125;&#123;\partial x_1&#125; &amp;\cdots&amp; \frac&#123;\partial y_m&#125;&#123;\partial x_n&#125;</span><br><span class="line">\end&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211125183936512.png" alt="image-20211125183936512"></p><p>通常来说，torch.autograd是计算雅可比向量积的一个引擎。也就是说，给定任意向量v，计算乘积$v^TJ$.如果v恰好是一个标量函数l=g(y)的导数，即$v=(\frac{\partial l}{\partial y_1} \cdots \frac{\partial l}{\partial y_m}^T)$，那么根据链式法则，雅可比向量积应该是l对x的导数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">J^T·v=\begin&#123;bmatrix&#125;</span><br><span class="line">\frac&#123;\partial y_1&#125;&#123;\partial x_1&#125; &amp;\cdots&amp; \frac&#123;\partial y_m&#125;&#123;\partial x_1&#125; \\</span><br><span class="line">\vdots &amp; \ddots &amp; \vdots \\</span><br><span class="line">\frac&#123;\partial y_1&#125;&#123;\partial x_n&#125; &amp;\cdots&amp; \frac&#123;\partial y_m&#125;&#123;\partial x_n&#125;</span><br><span class="line">\end&#123;bmatrix&#125;</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">\frac&#123;\partial l&#125;&#123;\partial y_1&#125;\\</span><br><span class="line">\cdots\\</span><br><span class="line">\frac&#123;\partial l&#125;&#123;\partial y_m&#125;</span><br><span class="line">\end&#123;bmatrix&#125;=</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">\frac&#123;\partial l&#125;&#123;\partial x_1&#125;\\</span><br><span class="line">\cdots\\</span><br><span class="line">\frac&#123;\partial l&#125;&#123;\partial x_n&#125;</span><br><span class="line">\end&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211125184143947.png" alt="image-20211125184143947"></p><p>(注意：行向量的$v^T⋅J$也可以被视作列向量的$J^T⋅v$)</p><p>雅可比向量积的这一特性使得将外部梯度输入到具有非标量输出的模型中变得非常方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=torch.randn(<span class="number">3</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">y=x*<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt;<span class="number">1000</span>:</span><br><span class="line">    y=y*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>在这种情况下，y 不再是标量。torch.autograd 不能直接计算完整的雅可比矩阵，但是如果我们只想要雅可比向量积，只需将这个向量作为参数传给 backward</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">y.backward(v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure><p>也可以通过将代码块包装在 with torch.no_grad(): 中，来阻止autograd跟踪设置了 .requires_grad=True 的张量的历史记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.requires_grad)</span><br><span class="line"><span class="built_in">print</span>((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="built_in">print</span>((x ** <span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure><p><strong>3. Variable</strong></p><p>Variable和Tensor的区别，Variable会被放入计算图中，然后进行前向传播，反向传播，自动求导</p><p>Variable是在torch.autograd.Variable中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line">x=Variable(torch.Tensor([<span class="number">1</span>]),requires_grad=<span class="literal">True</span>)</span><br><span class="line">w=Variable(torch.Tensor([<span class="number">2</span>]),requires_grad=<span class="literal">True</span>)</span><br><span class="line">b=Variable(torch.Tensor([<span class="number">3</span>]),requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">y=w*x+b</span><br><span class="line"></span><br><span class="line">y.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br></pre></td></tr></table></figure><p><strong>搭建一个简单的神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">batch_n = <span class="number">100</span> <span class="comment"># 一个批次中输入数据的数量</span></span><br><span class="line">hidden_layer = <span class="number">100</span> <span class="comment"># 经过隐藏层后保留的数据特征的个数</span></span><br><span class="line">input_data = <span class="number">1000</span> <span class="comment"># 每个数据包含的数据量</span></span><br><span class="line">output_data = <span class="number">10</span> <span class="comment"># 每个输出的数据包含的数据量</span></span><br><span class="line"></span><br><span class="line">x=torch.randn(batch_n,input_data) <span class="comment">#100*1000</span></span><br><span class="line">y=torch.randn(batch_n,output_data) <span class="comment">#100*10</span></span><br><span class="line"></span><br><span class="line">w1=torch.randn(input_data,hidden_layer) <span class="comment">#1000*100</span></span><br><span class="line">w2=torch.randn(hidden_layer,output_data) <span class="comment"># 100*10</span></span><br><span class="line"></span><br><span class="line">epoch_n = <span class="number">20</span> <span class="comment">#训练的次数</span></span><br><span class="line">learning_rate = <span class="number">1e-6</span> <span class="comment">#学习率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch_n):</span><br><span class="line">    h1=x.mm(w1)<span class="comment">#100*100</span></span><br><span class="line">    h1=h1.clamp(<span class="built_in">min</span>=<span class="number">0</span>) <span class="comment"># if x&lt;0 ,x=0</span></span><br><span class="line">    y_pred=h1.mm(w2) <span class="comment">#100*10，前向传播预测结果</span></span><br><span class="line">    </span><br><span class="line">    loss = (y_pred - y).<span class="built_in">pow</span>(<span class="number">2</span>).<span class="built_in">sum</span>() <span class="comment">#损失函数，即均方误差</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch:&#123;&#125;, Loss:&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(epoch,loss))</span><br><span class="line">    grad_y_pred = <span class="number">2</span>*(y_pred-y) <span class="comment">#dloss/dy</span></span><br><span class="line">    grad_w2 = h1.t().mm(grad_y_pred) <span class="comment">#dloss/dy * dy/dw2</span></span><br><span class="line">    </span><br><span class="line">    grad_h = grad_y_pred.clone() <span class="comment">#复制</span></span><br><span class="line">    grad_h = grad_h.mm(w2.t()) <span class="comment">#dloss/dy * dy/dh1</span></span><br><span class="line">    grad_h.clamp_(<span class="built_in">min</span>=<span class="number">0</span>) <span class="comment"># if x&lt;0 ,x=0</span></span><br><span class="line">    grad_w1 = x.t().mm(grad_h) </span><br><span class="line">    </span><br><span class="line">    w1 -= learning_rate*grad_w1 <span class="comment">#梯度下降</span></span><br><span class="line">    w2 -= learning_rate*grad_w2</span><br></pre></td></tr></table></figure><p><strong>使用Variable搭建一个自动计算梯度的神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line">batch_n = <span class="number">100</span> <span class="comment"># 一个批次中输入数据的数量</span></span><br><span class="line">hidden_layer = <span class="number">100</span> <span class="comment"># 经过隐藏层后保留的数据特征的个数</span></span><br><span class="line">input_data = <span class="number">1000</span> <span class="comment"># 每个数据包含的数据量</span></span><br><span class="line">output_data = <span class="number">10</span> <span class="comment"># 每个输出的数据包含的数据量</span></span><br><span class="line"></span><br><span class="line">x=Variable(torch.randn(batch_n,input_data),requires_grad = <span class="literal">False</span>) <span class="comment">#requires_grad = False不保留梯度</span></span><br><span class="line">y=Variable(torch.randn(batch_n,output_data),requires_grad = <span class="literal">False</span>)</span><br><span class="line">w1=Variable(torch.randn(input_data,hidden_layer),requires_grad = <span class="literal">True</span>) <span class="comment">#requires_grad = True自动保留梯度</span></span><br><span class="line">w2=Variable(torch.randn(hidden_layer,output_data),requires_grad = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">epoch_n = <span class="number">20</span></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch_n):</span><br><span class="line">    y_pred = x.mm(w1).clamp(<span class="built_in">min</span> = <span class="number">0</span>).mm(w2) <span class="comment">#y_pred=w2*(w1*x)</span></span><br><span class="line">    loss = (y_pred-y).<span class="built_in">pow</span>(<span class="number">2</span>).<span class="built_in">sum</span>() <span class="comment">#损失函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch:&#123;&#125;,Loss:&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(epoch,loss))</span><br><span class="line">    </span><br><span class="line">    loss.backward() <span class="comment">#后向传播计算</span></span><br><span class="line">    </span><br><span class="line">    w1.data -= learning_rate*w1.grad.data</span><br><span class="line">    w2.data -=learning_rate*w2.grad.data</span><br><span class="line">    </span><br><span class="line">    w1.grad.data.zero_() <span class="comment">#置0</span></span><br><span class="line">    w2.grad.data.zero_()</span><br></pre></td></tr></table></figure><p><strong>使用nn.Module自定义传播函数来搭建神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line">batch_n = <span class="number">100</span></span><br><span class="line">hidden_layer = <span class="number">100</span></span><br><span class="line">input_data = <span class="number">1000</span></span><br><span class="line">output_data = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Model,self).__init__()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,input_n,w1,w2</span>):</span></span><br><span class="line">        x = torch.mm(input_n,w1)</span><br><span class="line">        x = torch.clamp(x,<span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line">        x = torch.mm(x,w2)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">model = Model()</span><br><span class="line"></span><br><span class="line">x=Variable(torch.randn(batch_n,input_data),requires_grad = <span class="literal">False</span>) <span class="comment">#requires_grad = False不保留梯度</span></span><br><span class="line">y=Variable(torch.randn(batch_n,output_data),requires_grad = <span class="literal">False</span>)</span><br><span class="line">w1=Variable(torch.randn(input_data,hidden_layer),requires_grad = <span class="literal">True</span>) <span class="comment">#requires_grad = True自动保留梯度</span></span><br><span class="line">w2=Variable(torch.randn(hidden_layer,output_data),requires_grad = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">epoch_n = <span class="number">20</span></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch_n):</span><br><span class="line">    y_pred = model(x,w1,w2)</span><br><span class="line">    loss = (y_pred-y).<span class="built_in">pow</span>(<span class="number">2</span>).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch:&#123;&#125;,Loss:&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(epoch,loss))</span><br><span class="line">    loss.backward() <span class="comment">#后向传播计算</span></span><br><span class="line">    </span><br><span class="line">    w1.data -= learning_rate*w1.grad.data</span><br><span class="line">    w2.data -=learning_rate*w2.grad.data</span><br><span class="line">    </span><br><span class="line">    w1.grad.data.zero_() <span class="comment">#置0</span></span><br><span class="line">    w2.grad.data.zero_()</span><br></pre></td></tr></table></figure><h4 id="3-1-3-Dataset-数据集"><a href="#3-1-3-Dataset-数据集" class="headerlink" title="3.1.3 Dataset(数据集)"></a>3.1.3 Dataset(数据集)</h4><p>torch.utils.data.Dataset是代表这一数据的抽象类，可以自己定义数据类继承和重写这个抽象类，只需要定义<code>__len__</code>和<code>__getitem__</code>函数即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, csv_file, txt_file, root_dir, other_file</span>):</span></span><br><span class="line">        self.csv_data = pd.read_csv(csv_file)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(txt_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            data_list=f.readlines()</span><br><span class="line">        self.txt_data = data_list</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.csv_data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,idx</span>):</span></span><br><span class="line">        data = (self.csv_data[idx],self.txt_data[idx])</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>通过上面的方式，可以定义需要的数据类，可以通过迭代的方法取得每一个数据，但是这样很难实现取batch，shuffle或者多线程去读取数据，所以Pytorch中提供了torch.utils.data.DataLoader来定义一个新迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line">dataiter = DataLoader(myDataset,batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure><h4 id="3-1-4-nn-Module-模组"><a href="#3-1-4-nn-Module-模组" class="headerlink" title="3.1.4 nn.Module(模组)"></a>3.1.4 nn.Module(模组)</h4><p>所有的层结构和损失函数来自torch.nn</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">net_name</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,other_arguments</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(net_name, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels,out_channels, kernel_size)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>一个神经网络的典型训练过程如下：</p><ul><li>定义包含一些可学习参数(或者叫权重）的神经网络</li><li>在输入数据集上迭代</li><li>通过网络处理输入</li><li>计算loss(输出和正确答案的距离）</li><li>将梯度反向传播给网络的参数</li><li>更新网络的权重，一般使用一个简单的规则：weight = weight - learning_rate * gradient</li></ul><p><strong>使用torch.nn内的序列容器Sequential</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">batch_n = <span class="number">100</span></span><br><span class="line">hidden_layer = <span class="number">100</span></span><br><span class="line">input_data = <span class="number">1000</span></span><br><span class="line">output_data = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line">models_1 = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(input_data,hidden_layer),</span><br><span class="line">    torch.nn.ReLU(),</span><br><span class="line">    torch.nn.Linear(hidden_layer,output_data)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">models_2 = torch.nn.Sequential(OrderedDict([</span><br><span class="line">    (<span class="string">&quot;Line1&quot;</span>,torch.nn.Linear(input_data,hidden_layer)),</span><br><span class="line">    (<span class="string">&quot;ReLU1&quot;</span>,torch.nn.ReLU()),</span><br><span class="line">    (<span class="string">&quot;Line2&quot;</span>,torch.nn.Linear(hidden_layer,output_data))])    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(models_1)</span><br><span class="line"><span class="built_in">print</span>(models_2)</span><br></pre></td></tr></table></figure><p><strong>使用nn.Module定义一个神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 输入图像channel：1；输出channel：6；5x5卷积核</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># an affine operation: y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 2x2 Max pooling</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 如果是方阵,则可以只使用一个数字进行定义</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, self.num_flat_features(x))</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># 除去批处理维度的其他所有维度</span></span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"><span class="built_in">print</span>(net)</span><br></pre></td></tr></table></figure><h4 id="3-1-5-torch-optim-优化"><a href="#3-1-5-torch-optim-优化" class="headerlink" title="3.1.5 torch.optim(优化)"></a>3.1.5 torch.optim(优化)</h4><p>优化算法分为两大类：</p><p>（1）一阶优化算法<br>使用各个参数的梯度值来更新参数，最常用的是梯度下降。梯度下降的功能是通过寻找最小值，控制方差，更新模型参数，最终使模型收敛，网络的参数更新公式<br>$$\theta = \theta - \eta × \frac{\partial J(\theta)}{\partial \theta}$$<br>其中$\eta$是学习率，$\frac{\partial J(\theta)}{\partial \theta}$是函数的梯度</p><p>（2）二阶优化算法<br>二阶优化算法使用了二阶导数（Hessian方法）来最小化或最大化损失函数，主要是基于牛顿法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer=torch.optim.SGD(model.parameters(),lr=<span class="number">0.01</span>,momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><h4 id="3-1-6-模型的保存和加载"><a href="#3-1-6-模型的保存和加载" class="headerlink" title="3.1.6 模型的保存和加载"></a>3.1.6 模型的保存和加载</h4><p>1.保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#保存模型</span></span><br><span class="line">torch.save(model,path)</span><br><span class="line"><span class="comment">#保存模型的状态</span></span><br><span class="line">torch.save(model.state_dict(),path)</span><br></pre></td></tr></table></figure><p>2.加载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加载完整的模型</span></span><br><span class="line">load_model = torch.load(path)</span><br><span class="line"><span class="comment">#加载模型参数，需要先导入模型的结构</span></span><br><span class="line">model.load_state_dic(torch.load(path))</span><br></pre></td></tr></table></figure><h3 id="3-2-线性模型"><a href="#3-2-线性模型" class="headerlink" title="3.2 线性模型"></a>3.2 线性模型</h3><h4 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h4><p>f(x)=wx+b</p><p>f(x)=w1x1+w2x2+…+wdxd+b</p><p>w和b都是需要学习的参数</p><h4 id="3-2-2-一维线性回归"><a href="#3-2-2-一维线性回归" class="headerlink" title="3.2.2 一维线性回归"></a>3.2.2 一维线性回归</h4><p>给定数据集D={(x1,y1),(x2,y2),…,(xm,ym)}，线性回归希望得到一个f(x)=wx+b能够很好的拟合y</p><p>方法是利用$Loss=\sum_{i=1}^m(f(x_i)-y_i)^2$来衡量误差，即均方误差，那么<br>$$(w^*,b^*)=arg\min_{w,b}\sum_{i=1}^m(f(x_i)-y_i)^2=arg\min_{w,b}\sum_{i=1}^m(y_i-wx_i-b)^2$$</p><p>求解办法：求它的偏导数,并让其为0来估计参数<br>$$\frac{\partial Loss_{(w,b)}}{\partial w} = 2(w\sum_{i=1}^{m}x_i^2-\sum_{i=1}^{m}(y_i-b)x_i)=0$$<br>$$\frac{\partial Loss_{(w,b)}}{\partial b} = 2(mb-\sum_{i=1}^{m}(y_i-wx_i))=0$$<br>得到w和b的最优解<br>$$w=\frac{\sum_{i=1}^{m}y_i(x_i- \bar x)}{\sum_{i=1}^{m}x_i^2-\frac{1}{m}(\sum_{i=1}^{m}x_i)^2}$$<br>$$b=\frac{1}{m}\sum_{i=1}^{m}(y_i-wx_i)$$<br>其中$\bar x$是x的均值<br>$$\bar x = \frac{1}{m}\sum_{i=1}^{m}x_i$$</p><h4 id="3-2-3-多维线性回归"><a href="#3-2-3-多维线性回归" class="headerlink" title="3.2.3 多维线性回归"></a>3.2.3 多维线性回归</h4><p>$$f(x_i)=w^Tx_i+b$$<br>为使得$\sum_{i=1}^{m}(f(x_i)-y_i)^2$最小，这也称为“多元线性回归”，使用最小二乘法对w和b进行估计，假设有d个属性，将w和d写入同一个矩`阵，将数据集D表示成一个m×(d+1)的矩阵X，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X=\begin&#123;bmatrix&#125;</span><br><span class="line">x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \cdots &amp; x_&#123;1d&#125; &amp; 1 \\</span><br><span class="line">x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \cdots &amp; x_&#123;2d&#125; &amp; 1 \\</span><br><span class="line">\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\</span><br><span class="line">x_&#123;m1&#125; &amp; x_&#123;m2&#125; &amp; \cdots &amp; x_&#123;md&#125; &amp; 1</span><br><span class="line">\end&#123;bmatrix&#125;=</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">x_1^T &amp; 1\\</span><br><span class="line">x_2^T &amp; 1\\</span><br><span class="line">\vdots &amp; \vdots\\</span><br><span class="line">x_m^T &amp; 1</span><br><span class="line">\end&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211125184508266.png" alt="image-20211125184508266"></p><p>将目标y也写成乘向量的形式y=(y1,y2,…,ym),那么可得<br>$$w^* = arg \min_w(y-Xw)^T(y-Xw)$$<br>对其求导，令它为0<br>$$\frac{\partial Loss_w}{\partial w}=2X^T(Xw-y)=0$$</p><blockquote><p>上面涉及到矩阵的逆运算，所以需要$X^TX$是一个满秩矩阵或者正定矩阵</p></blockquote><p>可以得到:<br>$$w ^ * =(X^TX)^{-1}X^Ty$$<br>故回归模型可以写成：<br>$$f(x _ i)=x _ i^T(X^TX)^{-1}X^Ty$$</p><h4 id="3-2-4-一维线性回归的代码实现"><a href="#3-2-4-一维线性回归的代码实现" class="headerlink" title="3.2.4 一维线性回归的代码实现"></a>3.2.4 一维线性回归的代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_train = np.array([[<span class="number">3.3</span>],[<span class="number">4.4</span>],[<span class="number">5.5</span>],[<span class="number">6.71</span>],[<span class="number">6.93</span>],[<span class="number">4.168</span>],[<span class="number">9.779</span>],[<span class="number">6.182</span>],[<span class="number">7.59</span>],[<span class="number">2.167</span>],[<span class="number">7.042</span>],[<span class="number">10.791</span>],[<span class="number">5.313</span>],[<span class="number">7.997</span>],[<span class="number">3.1</span>]],dtype=np.float32)</span><br><span class="line">y_train = np.array([[<span class="number">1.7</span>],[<span class="number">2.76</span>],[<span class="number">2.09</span>],[<span class="number">3.19</span>],[<span class="number">1.694</span>],[<span class="number">1.573</span>],[<span class="number">3.366</span>],[<span class="number">2.596</span>],[<span class="number">2.53</span>],[<span class="number">1.221</span>],[<span class="number">2.827</span>],[<span class="number">3.465</span>],[<span class="number">1.65</span>],[<span class="number">2.904</span>],[<span class="number">1.3</span>]],dtype=np.float32)</span><br><span class="line"></span><br><span class="line">x_train = torch.from_numpy(x_train)</span><br><span class="line">y_train = torch.from_numpy(y_train)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearRegression</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LinearRegression,self).__init__() <span class="comment">#继承父类</span></span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>,<span class="number">1</span>) <span class="comment"># 1*1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        out=self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    model = LinearRegression().cuda()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    model = LinearRegression()</span><br><span class="line"></span><br><span class="line">criterion = torch.nn.MSELoss() <span class="comment"># 均方误差</span></span><br><span class="line"><span class="comment">#优化函数，model.parameters()为该实例中可优化的参数，lr为参数优化的选项（学习率等）</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">1e-3</span>) <span class="comment">#梯度下降</span></span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        inputs = Variable(x_train).cuda()</span><br><span class="line">        target = Variable(y_train).cuda()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        inputs = Variable(x_train)</span><br><span class="line">        target = Variable(y_train)</span><br><span class="line">    <span class="comment"># forward</span></span><br><span class="line">    out = model(inputs)</span><br><span class="line">    loss = criterion(out,target) <span class="comment">#均方误差</span></span><br><span class="line">    <span class="comment"># backward</span></span><br><span class="line">    optimizer.zero_grad() <span class="comment">#置0</span></span><br><span class="line">    loss.backward() <span class="comment">#求梯度</span></span><br><span class="line">    optimizer.step() <span class="comment">#更新所有的参数，梯度下降</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(epoch+<span class="number">1</span>)%<span class="number">50</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch[&#123;&#125;/&#123;&#125;],Loss:&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(epoch+<span class="number">1</span>,num_epochs,loss))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">eval</span>() <span class="comment">#将模型变成测试模式</span></span><br><span class="line">predict = model(Variable(x_train))</span><br><span class="line">predict = predict.data.numpy()</span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line"><span class="comment">#plt.plot(x_train.numpy(),y_train.numpy(),&#x27;ro&#x27;,label=&#x27;Original data&#x27;)</span></span><br><span class="line"><span class="comment">#plt.plot(x_train.numpy(),predict,label=&quot;Fitting Line&quot;)</span></span><br><span class="line"><span class="comment">#plt.show()</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201022195143.png"></p><h4 id="3-2-5-多项式回归"><a href="#3-2-5-多项式回归" class="headerlink" title="3.2.5 多项式回归"></a>3.2.5 多项式回归</h4><p>对于$y=b+w_1×x+w_2×x^2+w_3×x^3$，预处理数据，变成矩阵形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X=\begin&#123;bmatrix&#125;</span><br><span class="line">x_1 &amp; x_1^2 &amp; x_1^3 \\</span><br><span class="line">x_2 &amp; x_2^2 &amp; x_2^3 \\</span><br><span class="line">\vdots &amp; \ddots &amp; \vdots \\</span><br><span class="line">x_n &amp; x_n^2 &amp; x_n^3</span><br><span class="line">\end&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/image-20211125184611404.png" alt="image-20211125184611404"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_features</span>(<span class="params">x</span>):</span></span><br><span class="line">    x=x.unsqueeze(<span class="number">1</span>)  <span class="comment"># 在第1维（从0开始）增加一维</span></span><br><span class="line">    <span class="keyword">return</span> torch.cat([x ** i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>)],<span class="number">1</span>) <span class="comment">#1代表横着拼接x,x^2,x^3</span></span><br><span class="line"></span><br><span class="line">w_target = torch.FloatTensor([<span class="number">0.5</span>,<span class="number">3</span>,<span class="number">2.4</span>]).unsqueeze(<span class="number">1</span>) <span class="comment"># 在第1维（从0开始）加一层</span></span><br><span class="line">b_target = torch.FloatTensor([<span class="number">0.9</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="comment">#定义∑wix^i+b</span></span><br><span class="line">    <span class="keyword">return</span> x.mm(w_target) + b_target[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_batch</span>(<span class="params">batch_size=<span class="number">32</span></span>):</span></span><br><span class="line">    <span class="comment">#产生数据</span></span><br><span class="line">    random = torch.randn(batch_size)</span><br><span class="line">    x = make_features(random)</span><br><span class="line">    y = f(x)</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        <span class="keyword">return</span> Variable(x).cuda(),Variable(y).cuda()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Variable(x),Variable(y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">poly_model</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(poly_model,self).__init__()</span><br><span class="line">        self.poly = nn.Linear(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        out = self.poly(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    model = poly_model().cuda()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    model = poly_model()</span><br><span class="line">    </span><br><span class="line">criterion = nn.MSELoss() <span class="comment"># 均方误差</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(),lr=<span class="number">1e-3</span>)<span class="comment">#梯度下降</span></span><br><span class="line"></span><br><span class="line">epoch = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    batch_x,batch_y = get_batch()</span><br><span class="line">    <span class="comment">#前向传播</span></span><br><span class="line">    output = model(batch_x)</span><br><span class="line">    loss = criterion(output,batch_y)</span><br><span class="line">    epoch+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> epoch%<span class="number">50</span> ==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Epoch:&#123;&#125;,Loss:&#123;:.6f&#125;&quot;</span>.<span class="built_in">format</span>(epoch,loss.data.item()))</span><br><span class="line">    optimizer.zero_grad() <span class="comment">#置0</span></span><br><span class="line">    loss.backward() <span class="comment">#后向传播</span></span><br><span class="line">    optimizer.step() <span class="comment">#优化参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> loss &lt;<span class="number">1e-2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><blockquote><p>注意：<br><code>torch.nn</code>只支持小批量处理<code>(mini-batches）</code>。整个<code>torch.nn</code>包只支持小批量样本的输入，不支持单个样本的输入。<br>比如，<code>nn.Conv2d</code> 接受一个4维的张量，即<code>nSamples x nChannels x Height x Width</code>.<br>如果是一个单独的样本，只需要使用<code>input.unsqueeze(0)</code>来添加一个“假的”批大小维度。</p></blockquote><h3 id="3-3-分类问题"><a href="#3-3-分类问题" class="headerlink" title="3.3 分类问题"></a>3.3 分类问题</h3><h4 id="3-3-1-问题介绍"><a href="#3-3-1-问题介绍" class="headerlink" title="3.3.1 问题介绍"></a>3.3.1 问题介绍</h4><p>机器学习中的监督学习主要分为回归问题和分类问题，对于回归问题，希望预测的结果是连续的，对于分类问题所预测的结果是离散的。</p><p>监督学习从数据中学习一个分类模型或者分类决策函数，被称为分类器</p><h4 id="3-3-2-Logistic起源"><a href="#3-3-2-Logistic起源" class="headerlink" title="3.3.2 Logistic起源"></a>3.3.2 Logistic起源</h4><p>著名的二分类算法，Logistic回归。起源于对人口数量增长情况的研究</p><h4 id="3-3-3-Logistic分布"><a href="#3-3-3-Logistic分布" class="headerlink" title="3.3.3 Logistic分布"></a>3.3.3 Logistic分布</h4><p>设x是连续的随机变量，服从Logistic分布是指X的分布函数和密度函数是如下<br>$$F(x)=P(X≤x)=\frac{1}{1+e^{-(x-\mu)/\gamma}}$$<br>$$f(x)=\frac{e^{-(x-\mu)/\gamma}}{\gamma (1+e^{-(x-\mu)/\gamma})^2}$$<br>其中μ影响中心对称点的位置，γ越小中心点附件的增长速度越快<br>Sigmoid函数是Logistic分布函数中γ=1，μ=0的特殊形式，表达式如下：$$p(x)=\frac{1}{1+e^{-x}}$$</p><h4 id="3-3-4-二分类的Logistic回归"><a href="#3-3-4-二分类的Logistic回归" class="headerlink" title="3.3.4 二分类的Logistic回归"></a>3.3.4 二分类的Logistic回归</h4><p>假设输入的数据的特征向量$x∈R^n$，那么决策边界可以表示为$\sum_{i=1}^{n}w_ix_i+b=0$，建设存在一个样本点使得$h_w(x)=\sum_{i=1}^{n}w_ix_i+b&gt;0$，那么判定它的类别是1，如果&lt;0，判定其类别是0.<br>Logistic回归通过找到分类概率P(Y=1)与输入变量x的直接关系，然后通过比较概率值来判断类别，简单来说就是通过计算下面两个概率分布<br>$$P(Y=0|x)=\frac{1}{1+e^{wx+b}}$$<br>$$P(Y=1|x)=\frac{e^{wx+b}}{1+e^{wx+b}}$$<br>其中w是权重，b是偏置</p><blockquote><p>一个事件发生的几率（odds）是指该事件发生的概率（p）与不发生的概率的比值（1-p），该事件的对数几率或logit函数是：$logit(p)=log\frac{p}{1-p}$</p></blockquote><p>对于Logistic回归而言，可以得到：<br>$$log \frac{P(Y=1|x)}{1-P(Y=1|x)}=wx+b$$</p><h4 id="3-3-5-模型的参数估计"><a href="#3-3-5-模型的参数估计" class="headerlink" title="3.3.5 模型的参数估计"></a>3.3.5 模型的参数估计</h4><p>对于给定的训练集数据T={(x1,y1),(x2,y2),…,(xn,yn)}，其中$x_i \in R^n,y_i \in ${0,1}，假设P(Y=1|x)=Π(x)，那么P(Y=0|x)=1-Π(x)，所以似然函数为：<br>$$\prod_{i=1}^{n}[\pi (x_i)]^{y_1}[1-\pi (x_i)]^{1-y_i}$$<br>取对数后的对数似然函数：<br>$$L(w)=\sum_{i=1}^{n}[y_i(wx_i+b)-log(1+e^{wx_i+b})]$$<br>用L(w)对w求导：<br>$$\frac{\partial L(w)}{\partial w}=\sum_{i=1}^{n}y_ix_i-\sum_{i=1}^{n}\frac{e^{wx_i+b}}{1+e^{wx_i+b}}x_i=\sum_{i=1}^{n}(y_i-logit(wx_i))x_i$$<br>$$\frac{\partial L(w)}{\partial b}=\sum_{i=1}^{n}y_i-\sum_{i=1}^{n}\frac{e^{wx_i+b}}{1+e^{wx_i+b}}=\sum_{i=1}^{n}(y_i-logit(wx_i))$$</p><h4 id="3-3-6-Logistic回归的代码实现"><a href="#3-3-6-Logistic回归的代码实现" class="headerlink" title="3.3.6 Logistic回归的代码实现"></a>3.3.6 Logistic回归的代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取数据</span></span><br><span class="line">url=<span class="string">&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/code-of-learn-deep-learning-with-pytorch/chapter3_NN/logistic-regression/data.txt&quot;</span></span><br><span class="line">data = requests.get(url)</span><br><span class="line">data_list=data.text.split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>]</span><br><span class="line">data_list=[i.split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> data_list]</span><br><span class="line">data = [(<span class="built_in">float</span>(i[<span class="number">0</span>]),<span class="built_in">float</span>(i[<span class="number">1</span>]),<span class="built_in">float</span>(i[<span class="number">2</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> data_list]</span><br><span class="line"></span><br><span class="line">np_data = np.array(data, dtype=<span class="string">&#x27;float32&#x27;</span>) <span class="comment"># 转换成 numpy array</span></span><br><span class="line">x_data = torch.from_numpy(np_data[:, <span class="number">0</span>:<span class="number">2</span>]) <span class="comment"># 转换成 Tensor, 大小是 [100, 2]</span></span><br><span class="line">y_data = torch.from_numpy(np_data[:, -<span class="number">1</span>]).unsqueeze(<span class="number">1</span>) <span class="comment"># 转换成 Tensor，大小是 [100, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(x_data,y_data)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#画数据的散点图</span></span><br><span class="line">x0=<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x[-<span class="number">1</span>]==<span class="number">0.0</span>,data))</span><br><span class="line">x1=<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x[-<span class="number">1</span>]==<span class="number">1.0</span>,data))</span><br><span class="line">plot_x0_0 = [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> x0]</span><br><span class="line">plot_x0_1 = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> x0]</span><br><span class="line">plot_x1_0 = [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> x1]</span><br><span class="line">plot_x1_1 = [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> x1]</span><br><span class="line"></span><br><span class="line">plt.plot(plot_x0_0,plot_x0_1,<span class="string">&#x27;ro&#x27;</span>,label=<span class="string">&quot;x_0&quot;</span>) <span class="comment">#0类用红色</span></span><br><span class="line">plt.plot(plot_x1_0,plot_x1_1,<span class="string">&#x27;bo&#x27;</span>,label=<span class="string">&quot;x_1&quot;</span>) <span class="comment">#1类用蓝色</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>) <span class="comment">#图例的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(LogisticRegression,self).__init__() <span class="comment">#继承</span></span><br><span class="line">        self.lr = nn.Linear(<span class="number">2</span>,<span class="number">1</span>) <span class="comment">#2*1</span></span><br><span class="line">        self.sm = nn.Sigmoid() <span class="comment">#sigmoid函数</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x=self.lr(x)</span><br><span class="line">        x=self.sm(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">logistic_model = LogisticRegression()</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    logistic_model.cuda()</span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss() <span class="comment">#二分类的损失函数</span></span><br><span class="line"><span class="comment">#随机梯度下降优化，parameters是可优化参数，lr是学习率，momentum是动量因子</span></span><br><span class="line">optimizer = torch.optim.SGD(logistic_model.parameters(),lr=<span class="number">1e-3</span>,momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>):</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        x=Variable(x_data).cuda()</span><br><span class="line">        y=Variable(y_data).cuda()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x=Variable(x_data)</span><br><span class="line">        y=Variable(y_data)</span><br><span class="line">    <span class="comment">#forward</span></span><br><span class="line">    out = logistic_model(x)</span><br><span class="line">    loss = criterion(out,y)</span><br><span class="line">    mask = out.ge(<span class="number">0.5</span>).<span class="built_in">float</span>() <span class="comment">#if out&gt;0.5,out=1,else out=0</span></span><br><span class="line">    acc = <span class="built_in">float</span>((mask == y_data).<span class="built_in">sum</span>().item()) / y_data.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#backward</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    <span class="keyword">if</span>(epoch+<span class="number">1</span>)%<span class="number">2000</span> ==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>*<span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch: &#123;&#125;,Loss: &#123;:.4f&#125;,Acc: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(epoch+<span class="number">1</span>,loss,acc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画线w1x+w2y+b=0</span></span><br><span class="line">w0,w1 = logistic_model.lr.weight[<span class="number">0</span>]</span><br><span class="line">b = logistic_model.lr.bias.data[<span class="number">0</span>]</span><br><span class="line">plot_x = np.arange(<span class="number">30</span>,<span class="number">100</span>,<span class="number">0.1</span>)</span><br><span class="line">w0=w0.data</span><br><span class="line">w1=w1.data</span><br><span class="line">plot_y = (-w0*plot_x-b) /w1</span><br><span class="line">plt.plot(plot_x,plot_y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201023124844.png"></p><h3 id="3-4-简单多层全连接前向网络"><a href="#3-4-简单多层全连接前向网络" class="headerlink" title="3.4 简单多层全连接前向网络"></a>3.4 简单多层全连接前向网络</h3><h4 id="3-4-1-模拟神经元"><a href="#3-4-1-模拟神经元" class="headerlink" title="3.4.1 模拟神经元"></a>3.4.1 模拟神经元</h4><p>神经网络就是受到了模拟脑神经元的启发</p><h4 id="3-4-2-单层神经网络的分类器"><a href="#3-4-2-单层神经网络的分类器" class="headerlink" title="3.4.2 单层神经网络的分类器"></a>3.4.2 单层神经网络的分类器</h4><p>例如之前的Logistic回归，是使用了sigmoid函数作为激活函数的一层神经网络</p><h4 id="3-4-3-激活函数"><a href="#3-4-3-激活函数" class="headerlink" title="3.4.3 激活函数"></a>3.4.3 激活函数</h4><p>1.Sigmoid函数</p><p>$$\sigma (x)=\frac{1}{1+e^{-x}}$$</p><p>缺点：<br>（1）造成梯度消失。在靠近0，1两端，梯度几乎为0，导致没有信息来更新参数<br>（2）输出不是以0为均值。</p><p>2.Tanh</p><p>$$tanh(x)=2\sigma(2x)-1$$</p><p>Tanh激活函数是sigmoid函数的变形，将输入的数据转化到-1到1之间，解决了sigmoid函数第二个问题，但仍存在梯度消失的问题</p><p>3.ReLU</p><p>ReLU的数学表达式为$f(x)=max(0,x)$</p><p>优点：<br>（1）相比较sigmoid和tanh，ReLU可以极大地加速随机梯度下降法的收敛速度，因为是线性的，不存在梯度消失<br>（2）计算方法更简单</p><p>缺点：<br>训练的时候很脆弱，一个很大的梯度经过ReLU激活函数，更新参数之后，会使得这个神经元不会对任何数据有激活现象，之后再经过ReLU的梯度都是0，参数无法更新。可以通过设置较小的学习率来避免这个问题</p><p>4.Leaky ReLU</p><p>ReLU的变式，为了修复ReLU脆弱的缺点，将x&lt;0的部分变成一个很小的负的斜率，但是效果时好时不好</p><p>5.Maxout</p><p>$$f(x)=max(w_1x+b_1,w_2x+b_2)$$<br>ReLU只是Maxout中w1=0，b1=0的特殊形式</p><p>优点：包含ReLU的优点，避免了ReLU的脆弱性<br>缺点：参数存储变大</p><h4 id="3-4-4-神经网络的结构"><a href="#3-4-4-神经网络的结构" class="headerlink" title="3.4.4 神经网络的结构"></a>3.4.4 神经网络的结构</h4><p>神经网络是一个由神经元组成的无环图</p><p>nn.Linear(in,out，bias=False)是全连接神经网络层的函数</p><h4 id="3-4-5-模型的表示能力与容量"><a href="#3-4-5-模型的表示能力与容量" class="headerlink" title="3.4.5 模型的表示能力与容量"></a>3.4.5 模型的表示能力与容量</h4><p>在实际中，我们可能发现一个三层的全连接神经网络比一个两层的全连接神经网络表现更好，但是更深的网络结构对全连接神经网络效果提升表现不大。<br>我们需要注意的是，增大网络的层数和每层的节点数，相当于在增大网络的容量，容量的增大意味着网络有着更大的潜在表现能力。</p><p>但是当我们在做一个二分类问题时，更复杂的模型或许有着更复杂的形状，能将测试用例完美的分类，但是却忽略了潜在的数学关系，将噪声的干扰放大，这种效果被称为过拟合</p><h3 id="3-5-深度学习的基石：反向传播算法"><a href="#3-5-深度学习的基石：反向传播算法" class="headerlink" title="3.5 深度学习的基石：反向传播算法"></a>3.5 深度学习的基石：反向传播算法</h3><h4 id="3-5-1-链式法则"><a href="#3-5-1-链式法则" class="headerlink" title="3.5.1 链式法则"></a>3.5.1 链式法则</h4><p>求导的链式法则（高数知识）</p><h4 id="3-5-2-反向传播算法"><a href="#3-5-2-反向传播算法" class="headerlink" title="3.5.2 反向传播算法"></a>3.5.2 反向传播算法</h4><p>是链式求导法则的应用</p><p>局部求导，不断迭代传播</p><h3 id="3-6-各种优化算法的变式"><a href="#3-6-各种优化算法的变式" class="headerlink" title="3.6 各种优化算法的变式"></a>3.6 各种优化算法的变式</h3><h4 id="3-6-1-梯度下降法"><a href="#3-6-1-梯度下降法" class="headerlink" title="3.6.1 梯度下降法"></a>3.6.1 梯度下降法</h4><p>梯度下降的更新公式<br>$$x^i=x^{i-1}-\eta \nabla L(x^{i-1})$$</p><h4 id="3-6-2-梯度下降法的变式"><a href="#3-6-2-梯度下降法的变式" class="headerlink" title="3.6.2 梯度下降法的变式"></a>3.6.2 梯度下降法的变式</h4><p>1.SGD<br>随机梯度下降法，每次使用一批（batch）数据进行梯度的计算，而不是全部数据的梯度</p><p>2.Momentum<br>在随机梯度下降的同时，增加动量（momentum），帮助跳出一些鞍点或局部极小值点</p><p>3.Adagrad<br>自适应学习率的方法，公式是<br>$$w^{t+1}←w^{t}-\frac{\eta}{\sqrt{\sum_{i=0}^{t}(g^i)^2}+\varepsilon }$$</p><p>学习率在不断变小，但是在某些情况下会导致学习过早停止</p><p>4.RMSprop<br>一种非常有效的自适应学习率的改进方法，公式是<br>$$cache^t=\alpha * cache^{t-1}+(1-\alpha)(g^t)^2$$<br>$$w^{t+1}←w^{t}-\frac{\eta}{\sqrt{cache^t+\varepsilon}}g^t$$<br>其中α是衰减率，能有效避免Adagrad学习率一直递减太多的问题，能够更快地收敛</p><p>5.Adam<br>一种综合型学习方法，可以看成RMSprop加上momentum的学习方法</p><h3 id="3-7-处理数据和训练模型的技巧"><a href="#3-7-处理数据和训练模型的技巧" class="headerlink" title="3.7 处理数据和训练模型的技巧"></a>3.7 处理数据和训练模型的技巧</h3><h4 id="3-7-1-数据预处理"><a href="#3-7-1-数据预处理" class="headerlink" title="3.7.1 数据预处理"></a>3.7.1 数据预处理</h4><p>1.中心化<br>变成0均值</p><p>2.标准化<br>使得每个特征维度的最大值和最小值按比例缩放到-1到1之间</p><p>3.PCA（主成分分析）<br>将数据去相关性，将其投影到一个特征空间，取一些较大的，主要的特征向量来降低数据的维度</p><p>4.白噪声<br>将数据投影到一个特征空间，然后每个维度除以特征值来标准化这些数据</p><h4 id="3-7-2-权重初始化"><a href="#3-7-2-权重初始化" class="headerlink" title="3.7.2 权重初始化"></a>3.7.2 权重初始化</h4><p>1.全0初始化<br>不应该采用这种策略</p><p>2.随机初始化<br>包括了高斯随机化，均匀随机化</p><p>3.稀疏初始化</p><p>4.初始化偏置</p><p>5.批标准化</p><h4 id="3-7-3-防止过拟合"><a href="#3-7-3-防止过拟合" class="headerlink" title="3.7.3 防止过拟合"></a>3.7.3 防止过拟合</h4><p>1.正则化<br>2.Dropout</p><h3 id="3-8-多层全连接神经网络实现MNIST手写数字分类"><a href="#3-8-多层全连接神经网络实现MNIST手写数字分类" class="headerlink" title="3.8 多层全连接神经网络实现MNIST手写数字分类"></a>3.8 多层全连接神经网络实现MNIST手写数字分类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn,optim</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"></span><br><span class="line"><span class="comment">#带有批标准化和激活函数的三层全连接神经网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Batch_Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,in_dim,n_hidden_1,n_hidden_2,out_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Batch_Net,self).__init__()</span><br><span class="line">        self.layer1 = nn.Sequential(nn.Linear(in_dim,n_hidden_1),nn.BatchNorm1d(n_hidden_1),nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        self.layer2 = nn.Sequential(nn.Linear(n_hidden_1,n_hidden_2),nn.BatchNorm1d(n_hidden_2),nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        self.layer3 = nn.Sequential(nn.Linear(n_hidden_2,out_dim))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x=self.layer1(x)</span><br><span class="line">        x=self.layer2(x)</span><br><span class="line">        x=self.layer3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br><span class="line">num_epoch = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#transforms.ToTensor()将图片转换成PyTorch中从处理的对象，并自动将图片标准化了，即范围0到1</span></span><br><span class="line"><span class="comment">#transforms.Normalize(均值，方差)，处理：减均值，除以方差</span></span><br><span class="line"><span class="comment">#图片为灰度图，只有一个通道，如果是三通道则为transforms.Normalize([a,b,c],[d,e,f])</span></span><br><span class="line">data_tf = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),transforms.Normalize([<span class="number">0.5</span>],[<span class="number">0.5</span>])]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据集</span></span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&quot;./data&quot;</span>,train=<span class="literal">True</span>,transform=data_tf,download=<span class="literal">True</span>)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&quot;./data&quot;</span>,train=<span class="literal">False</span>,transform=data_tf)</span><br><span class="line"><span class="comment"># 数据迭代器，传入数据集和batch_size，通过shuffle=True来表示是否将数据打乱</span></span><br><span class="line">train_loader = DataLoader(train_dataset,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_dataset,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">model = Batch_Net(<span class="number">28</span>*<span class="number">28</span>,<span class="number">300</span>,<span class="number">100</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    model = model.cuda()</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss() <span class="comment">#交叉熵</span></span><br><span class="line"><span class="comment"># 优化</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(),lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    eval_loss = <span class="number">0</span></span><br><span class="line">    eval_acc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_loader:</span><br><span class="line">        img,label=data</span><br><span class="line">        img = img.view(img.size(<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            img = Variable(img).cuda()</span><br><span class="line">            label = Variable(label).cuda()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img = Variable(img)</span><br><span class="line">            label = Variable(label)</span><br><span class="line">        out=model(img)</span><br><span class="line">        loss = criterion(out,label)</span><br><span class="line">        <span class="comment"># backward</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment">#置0</span></span><br><span class="line">        loss.backward() <span class="comment">#求梯度</span></span><br><span class="line">        optimizer.step() <span class="comment">#更新所有的参数，梯度下降</span></span><br><span class="line">        <span class="comment">#acc</span></span><br><span class="line">        eval_loss +=loss*label.size(<span class="number">0</span>)</span><br><span class="line">        _,pred = torch.<span class="built_in">max</span>(out,<span class="number">1</span>)</span><br><span class="line">        num_correct = (pred == label).<span class="built_in">sum</span>()</span><br><span class="line">        eval_acc +=num_correct</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#123;&#125;,Loss: &#123;:.6f&#125;,Acc:&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(epoch,eval_loss/(<span class="built_in">len</span>(train_dataset)),<span class="built_in">float</span>(eval_acc)/(<span class="built_in">len</span>(train_dataset))))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line">eval_loss = <span class="number">0</span></span><br><span class="line">eval_acc = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">    img,label=data</span><br><span class="line">    img = img.view(img.size(<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        img = Variable(img).cuda()</span><br><span class="line">        label = Variable(label).cuda()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img = Variable(img)</span><br><span class="line">        label = Variable(label)</span><br><span class="line">    out=model(img)</span><br><span class="line">    loss = criterion(out,label)</span><br><span class="line">    eval_loss +=loss.data*label.size(<span class="number">0</span>)</span><br><span class="line">    _,pred = torch.<span class="built_in">max</span>(out,<span class="number">1</span>)</span><br><span class="line">    num_correct = (pred == label).<span class="built_in">sum</span>()</span><br><span class="line">    eval_acc +=num_correct.data</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test Loss: &#123;:.6f&#125;,Acc:&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(eval_loss/(<span class="built_in">len</span>(test_dataset)),<span class="built_in">float</span>(eval_acc)/(<span class="built_in">len</span>(test_dataset))))</span><br></pre></td></tr></table></figure><h2 id="第四章-卷积神经网络"><a href="#第四章-卷积神经网络" class="headerlink" title="第四章 卷积神经网络"></a>第四章 卷积神经网络</h2><p>1998年由Yann Lecun提出，2012年Alex Krizhecsky凭借它赢得了ImageNet挑战赛</p><h3 id="4-1-主要任务及起源"><a href="#4-1-主要任务及起源" class="headerlink" title="4.1 主要任务及起源"></a>4.1 主要任务及起源</h3><p>对于计算机视觉，主要用提取图像中的特征</p><h3 id="4-2-卷积神经网络的原理和结构"><a href="#4-2-卷积神经网络的原理和结构" class="headerlink" title="4.2 卷积神经网络的原理和结构"></a>4.2 卷积神经网络的原理和结构</h3><p>一，卷积神经网络的三种思想</p><p>1.局部性</p><p>对于图片而言，需要检测图片中的特征来决定图片的类别，通常情况下这些特征都不是由整张图片决定的，而是由一些局部的区域决定的</p><p>2.相同性</p><p>对不同图片，如果具有同样的特征，这些特征会出现在不同位置，但特征检测所作的操作几乎一样</p><p>3.不变性</p><p>对于一张大图片，如果进行下采样，那么图片的性质基本保持不变</p><p>二，卷积神经网络的层结构</p><p>对于全连接神经网络，其由一系列隐藏层构成，每个隐藏层由若干个神经元构成，其中每个神经元都和前一层的所有神经元相关联，但是每一层中的神经元是相互独立的。全连接神经网络在处理图片时，比如在minist数据集上，图片大小是28×28，那么每层的单个神经元的权重数目就是28×28=784，但这知识一张小图片，且只有一个通道，如果是大图片，那么就会导致参数增长特别快，所以全连接神经网络在处理图像并不是好的选择</p><p>而卷积神经网络是一个3D容量的神经元，每个神经元由三个维度排列：宽带，高度和深度。如果输入的图片是32×32×3，那么这张图片的宽度就是32，高度也是32，深度是3</p><p>卷积神经网络的主要层结构有三个：卷积层，池化层，全连接层，通过堆叠这些层结构形成了一个完整的卷积神经网络结构，其中一些层包含参数（如：卷积层，全连接层），一些层不包含参数（如：激活层，池化层）。</p><h4 id="4-2-1-卷积层"><a href="#4-2-1-卷积层" class="headerlink" title="4.2.1 卷积层"></a>4.2.1 卷积层</h4><p>卷积层是卷积神经网络的核心</p><p>1.概述</p><p>卷积神经网络的参数，是由一些可学习的滤波器集合构成，每个滤波器在空间上（宽度和高度）都比较小，但深度和输入数据的深度保持一致。在前向传播时，让每个滤波器都在输入数据的宽度和高度上滑动（卷积），然后计算整个滤波器和输入数据任意一处的内积。<br>当滤波器沿着输入数据的宽度和高度滑动时，会生成一个二维的激活图。每个卷积层上，会有一整个集合的滤波器，这样会形成多个二维的不同的激活图，将这些激活图在深度方向堆叠起来形成卷积层的输出</p><p>2.局部连接</p><p>与神经元连接的空间大小叫做神经元的感受野，其大小是一个人为设置的超参数，其实是滤波器的宽和高</p><p>3.空间排列</p><p>卷积层的输出深度是一个超参数，与使用的滤波器数量一致，并且在滑动滤波器的时候必须指定步长</p><p>4.边界填充</p><p>可以将输入数据用0在边界进行填充，用来控制输出数据在空间上的尺寸，输出的尺寸可以用一个公式来计算，$\frac{W-F+2P}{S}+1$，其中W是输入的数据大小，F表示卷积层中神经元的感受野尺寸，S表示步长，P表示边界填充0的数量</p><p>5.步长的限制</p><p>步长的选择是有所限制的。当输入尺寸W是10时，如果不使用0填充，即P=0，滤波器尺寸F=3，这样步长S=2就行不通，因为(10-3+0)/2+1=4.5，不是一个整数，说明神经元不能整齐对称地滑过输入数据体，这样的超参数是无效的</p><p>6.参数共享</p><p>输出体数据在深度切片上所有的权重都使用同一个权重向量，那么卷积层在向前传播的过程中每个深度切片都可以看成是神经元的权重对输入数据体做卷积，这也就是为什么把这些3D的权重集合称为滤波器或者卷积核</p><p>7.总结</p><p>卷积层的性质</p><ul><li>（1）输入数据体尺寸是W1×H1×D1</li><li>（2）4个超参数：卷积核数量K，卷积核空间尺寸F，滑动步长S，零填充的数量P</li><li>（3）输出数据体的尺寸为W2×H2×D2，其中$W_2=\frac{W_1-F+2P}{S}+1$,$H_2=\frac{H_1-F+2P}{S}+1$,D2=K</li><li>（4）由于参数共享，每个卷积核包含的权重数目为F×F×D1，卷积层一共有F×F×D1×K个权重和K个偏置</li><li>（5）在输出体数据中，第d个深度切片（空间尺寸是W2×H2），用第d个卷积器和输入数据进行有效卷积运算的结果，再加上第d个偏置</li></ul><p>对于卷积神经网络的一些超参数，常见的设置是F=3，S=1，P=1</p><h4 id="4-2-2-池化层"><a href="#4-2-2-池化层" class="headerlink" title="4.2.2 池化层"></a>4.2.2 池化层</h4><p>通常或者卷积层之间周期性插入一个池化层，作用是逐渐减低数据体的空间尺寸，这样能减少网络中参数的数量，减少计算资源耗费，同时也能有效地控制过拟合</p><p>步骤：设定一个空间窗口，不断滑动窗口，取这些窗口中的最大值作为输出结果</p><p>池化层之所有有效，是因为之前介绍的图片特征具有不变性，也就是通过下采样不会丢失图片拥有的特征</p><p>常用的池化层形式是尺寸为2×2的窗口，滑动步长是2，对图像进行下采样，将其中75%的激活信息都丢掉，选择其中最大的保留，池化层很少引入零填充</p><p>除最大值池化外，还有平均池化，或者L2范数池化，实际证明，最大池化效果最好，平均池化一般放在卷积神经网络最后一层</p><h4 id="4-2-3-全连接层"><a href="#4-2-3-全连接层" class="headerlink" title="4.2.3 全连接层"></a>4.2.3 全连接层</h4><p>全连接层的每个神经元与前一层所有的神经元全部连接，在这个过程中为了防止过拟合会引入<code>Dropout</code>。在进入全连接层之前，使用全局平均池化能够有效地降低过拟合</p><h4 id="4-2-4-卷积神经网络的基本形式"><a href="#4-2-4-卷积神经网络的基本形式" class="headerlink" title="4.2.4 卷积神经网络的基本形式"></a>4.2.4 卷积神经网络的基本形式</h4><p>卷积神经网络最常见的形式就是将一些卷积层和<code>ReLU</code>层放在一起，有可能在<code>ReLU</code>层前面加上批标准化层，随后紧跟池化层，再不断重复，直到图像被缩小到一个足够小的尺寸，然后将特征图展开，连接几层全连接层，最后输出结果</p><p>1.小滤波器的有效性</p><p>2.网络的尺寸</p><p>经验<br>（1）输入层：一般而言，输入层的大小应该能够被2整除很多次，常用的数字包括32，44，96，224<br>（2）卷积层：卷积层应该尽可能使用小尺寸，比如3×3或5×5，滑动步长取1。7×7通常用在第一个面对原始图像的卷积层上<br>（3）池化层：池化层负责对输入的数据空间维度进行下采样，常用的设置使用2×2的感受野做最大值池化，步长取2<br>（4）零填充：零填充的使用可以让卷积层的输入和输出在空间上的维度保持一致</p><h3 id="4-3-Pytorch卷积模块"><a href="#4-3-Pytorch卷积模块" class="headerlink" title="4.3 Pytorch卷积模块"></a>4.3 Pytorch卷积模块</h3><h4 id="4-3-1-卷积层"><a href="#4-3-1-卷积层" class="headerlink" title="4.3.1 卷积层"></a>4.3.1 卷积层</h4><p><code>nn.Conv2d(in_channels,out_channels,kernel_size,stride,padding,dilation,groups,bias)</code><br>其中</p><ul><li><code>in_channels</code>对应输入数据体的深度</li><li><code>out_channels</code>对应输出数据体的深度</li><li><code>kernel_size</code>表示滤波器（卷积核）的大小，例如：<code>kernel_size=3</code>或<code>kernel_size=(3,2)</code></li><li><code>stride</code>表示滑动步长，默认<code>1</code></li><li><code>padding=0</code>表示四周不进行零填充，<code>padding=1</code>表示四周进行<code>1</code>个像素点的零填充，默认<code>0</code></li><li><code>bias</code>是一个布尔值，默认为<code>True</code>，表示使用偏置</li><li><code>groups</code>表示输出数据体深度上的联系，默认<code>groups=1</code>，即所有的输出和输入都是相关联的，如果<code>groups=2</code>表示输入的深度被分割成两份，输出的深度也被分割成两份，他们之间分别对应起来，所以要求输出和输入都必须要能被<code>groups</code>整除</li><li><code>dilation</code>表示卷积对于输入数据体的空间间隔，默认为<code>1</code></li></ul><h4 id="4-3-2-池化层"><a href="#4-3-2-池化层" class="headerlink" title="4.3.2 池化层"></a>4.3.2 池化层</h4><p><code>nn.MaxPool2d(kernel_size,stride,padding,dilation,return_indices,ceil_model)</code><br>其中</p><ul><li><code>kernel_size</code>,<code>stride</code>,<code>padding</code>,<code>dilation</code>和卷积层相同</li><li><code>return_indices</code>表示是否返回最大值所处的下标，默认为<code>False</code></li><li><code>ceil_mode</code>表示使用一些方格代替层结构，默认<code>False</code></li></ul><p><code>nn.AvgPool2d()</code>表示均值池化，里面的参数和MaxPool2d类似，但多一个参数<code>count_include_pad</code>表示计算均值的时候是否包含零填充，默认为<code>True</code></p><p>其他还有<code>nn.LPPool2d()</code>,<code>nn.AdaptiveMaxPool2d()</code></p><p><strong>下面是一个简单的多层卷积神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(SimpleCNN,self).__init__()</span><br><span class="line">        layer1 = nn.Sequential()</span><br><span class="line">        layer1.add_module(<span class="string">&#x27;conv1&#x27;</span>,nn.Conv2d(<span class="number">3</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">1</span>,padding=<span class="number">1</span>))</span><br><span class="line">        layer1.add_module(<span class="string">&#x27;relu1&#x27;</span>,nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer1.add_module(<span class="string">&#x27;pool1&#x27;</span>,nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        self.layer1=layer1</span><br><span class="line"></span><br><span class="line">        layer2 = nn.Sequential()</span><br><span class="line">        layer2.add_module(<span class="string">&#x27;conv2&#x27;</span>,nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">3</span>,<span class="number">1</span>,padding=<span class="number">1</span>))</span><br><span class="line">        layer2.add_module(<span class="string">&#x27;relu2&#x27;</span>,nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer2.add_module(<span class="string">&#x27;pool2&#x27;</span>,nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        self.layer2=layer2</span><br><span class="line">        </span><br><span class="line">        layer3 = nn.Sequential()</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;conv3&#x27;</span>,nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">3</span>,<span class="number">1</span>,padding=<span class="number">1</span>))</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;relu3&#x27;</span>,nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;pool3&#x27;</span>,nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        self.layer3=layer3</span><br><span class="line"></span><br><span class="line">        layer4 = nn.Sequential()</span><br><span class="line">        layer4.add_module(<span class="string">&#x27;fc1&#x27;</span>,nn.Linear(<span class="number">2048</span>,<span class="number">512</span>))</span><br><span class="line">        layer4.add_module(<span class="string">&#x27;fc_relu1&#x27;</span>,nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer4.add_module(<span class="string">&#x27;fc2&#x27;</span>,nn.Linear(<span class="number">512</span>,<span class="number">64</span>))</span><br><span class="line">        layer4.add_module(<span class="string">&#x27;fc_relu2&#x27;</span>,nn.ReLU(<span class="literal">True</span>))</span><br><span class="line">        layer4.add_module(<span class="string">&#x27;fc3&#x27;</span>,nn.Linear(<span class="number">64</span>,<span class="number">10</span>))</span><br><span class="line">        self.layer4=layer4</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        conv1 = self.layer1(x)</span><br><span class="line">        conv2 = self.layer2(conv1)</span><br><span class="line">        conv3 = self.layer3(conv2)</span><br><span class="line">        fc_input = conv3.view(conv3.size(<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">        fc_out = slef.layer4(fc_input)</span><br><span class="line">        <span class="keyword">return</span> fc_out</span><br><span class="line"></span><br><span class="line">model = SimpleCNN()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure><h4 id="4-3-3-提取层结构"><a href="#4-3-3-提取层结构" class="headerlink" title="4.3.3 提取层结构"></a>4.3.3 提取层结构</h4><p>nn.Module具有几个重要属性</p><ul><li><code>children()</code>，会返回下一级模块的迭代器，比如上面这个模型，直会返回在<code>self.layer1</code>,<code>slef.layer2</code>,<code>slef.layer3</code>以及<code>self.layer4</code>上的迭代器，不会返回他们内部的东西</li><li><code>modules()</code>，会返回模型中所有模块的迭代器，这样就有了一个好处，即它能够访问到最内层，比如<code>self.layer1.conv1</code>这个模块</li><li><code>named_children()</code>和<code>named_modules()</code>不仅会返回模块的迭代器，还会返回网络层的名字</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提取前面两层</span></span><br><span class="line"><span class="built_in">print</span>(nn.Sequential(*<span class="built_in">list</span>(model.children())[:<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><p><strong>提取所有的卷积层</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conv_model = nn.Sequential()</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> model.named_modules():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(layer[<span class="number">1</span>],nn.Conv2d):</span><br><span class="line">        conv_model.add_module(layer[<span class="number">0</span>].split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>],layer[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(conv_model)</span><br></pre></td></tr></table></figure><h4 id="4-3-4-提取参数及自定义初始化"><a href="#4-3-4-提取参数及自定义初始化" class="headerlink" title="4.3.4 提取参数及自定义初始化"></a>4.3.4 提取参数及自定义初始化</h4><p><code>nn.Module</code>关于参数的属性</p><ul><li><code>named_parameters()</code>，给出网络层的名字和参数的迭代器</li><li><code>parameters()</code>，给出一个网络的全部参数的迭代器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">    <span class="built_in">print</span>(param[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><strong>对权重初始化</strong>，因为权重是Variable，只需要取出data属性就能处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> model.modules():</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(m,nn.Conv2d):</span><br><span class="line">        nn.init.normal(m.weight.data)</span><br><span class="line">        nn.init.xavier_normal(m.weight.data)</span><br><span class="line">        nn.init.kaiming_normal(m.weight.data)<span class="comment">#卷积层参数初始化</span></span><br><span class="line">        m.bias.data.fill_(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m,nn.Linear):</span><br><span class="line">        m.weight.data.normal_()<span class="comment">#全连接层参数初始化</span></span><br></pre></td></tr></table></figure><h3 id="4-4-卷积神经网络案例分析"><a href="#4-4-卷积神经网络案例分析" class="headerlink" title="4.4 卷积神经网络案例分析"></a>4.4 卷积神经网络案例分析</h3><h4 id="4-4-1-LeNet"><a href="#4-4-1-LeNet" class="headerlink" title="4.4.1 LeNet"></a>4.4.1 LeNet</h4><p>LeNet是整个卷积神经网络的开山之作，共有7层，其中2层卷积和2层池化层交替出现，最后输出3层全连接层得到整体的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lenet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Lenet,self).__init__()</span><br><span class="line">        layer1 = nn.Sequential()</span><br><span class="line">        layer1.add_module(<span class="string">&#x27;conv1&#x27;</span>,nn.Conv2d(<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,padding=<span class="number">1</span>))</span><br><span class="line">        layer1.add_module(<span class="string">&#x27;pool1&#x27;</span>,nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        self.layer1 = layer1</span><br><span class="line">        </span><br><span class="line">        layer2 = nn.Sequential()</span><br><span class="line">        layer2.add_module(<span class="string">&#x27;conv2&#x27;</span>,nn.Conv2d(<span class="number">6</span>,<span class="number">16</span>,<span class="number">5</span>))</span><br><span class="line">        layer2.add_module(<span class="string">&#x27;pool2&#x27;</span>,nn.MaxPool2d(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">        self.layer2 = layer2</span><br><span class="line">        </span><br><span class="line">        layer3 = nn.Sequential()</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;fc1&#x27;</span>,nn.Linear(<span class="number">400</span>,<span class="number">120</span>))</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;fc2&#x27;</span>,nn.Linear(<span class="number">120</span>,<span class="number">84</span>))</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;fc3&#x27;</span>,nn.Linear(<span class="number">84</span>,<span class="number">10</span>))</span><br><span class="line">        self.layer3 = layer3</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>),-<span class="number">1</span>) <span class="comment"># 将第二次卷积的输出拉伸为一行</span></span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h4 id="4-4-2-AlexNet"><a href="#4-4-2-AlexNet" class="headerlink" title="4.4.2 AlexNet"></a>4.4.2 AlexNet</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlexNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num_classes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(AlexNet,self).__init__()</span><br><span class="line">        self.features = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">64</span>,kernel_size=<span class="number">11</span>,stride=<span class="number">4</span>,padding=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">192</span>,kernel_size=<span class="number">5</span>,padding=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">192</span>,<span class="number">384</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">384</span>,<span class="number">256</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>,<span class="number">256</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>,stride=<span class="number">2</span>),</span><br><span class="line">        )</span><br><span class="line">        self.classifier = nn.Sequential(</span><br><span class="line">            nn.Dropout(),</span><br><span class="line">            nn.Linear(<span class="number">256</span>*<span class="number">6</span>*<span class="number">6</span>,<span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Dropout(),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>,<span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>,num_classes),</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.features(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>),<span class="number">256</span>*<span class="number">6</span>*<span class="number">6</span>)</span><br><span class="line">        x = self.classifier(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h4 id="4-4-3-VGGNet"><a href="#4-4-3-VGGNet" class="headerlink" title="4.4.3 VGGNet"></a>4.4.3 VGGNet</h4><p>使用了更小的滤波器，同时使用了更深的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VGG</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num_classes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(VGG,self).__init__()</span><br><span class="line">        self.features = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">64</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">64</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">128</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>,<span class="number">256</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>,<span class="number">256</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>,<span class="number">512</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">512</span>,<span class="number">512</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">512</span>,<span class="number">512</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">512</span>,<span class="number">512</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">512</span>,<span class="number">512</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">512</span>,<span class="number">512</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>),</span><br><span class="line">        )</span><br><span class="line">        self.classifier = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">512</span>*<span class="number">7</span>*<span class="number">7</span>,<span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Dropout(),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>,<span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Dropout(),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>,num_classes),</span><br><span class="line">        )</span><br><span class="line">        self._initialize_weights()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.features(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">        x = self.classifier(x)</span><br></pre></td></tr></table></figure><h4 id="4-4-4-GoogleNet"><a href="#4-4-4-GoogleNet" class="headerlink" title="4.4.4 GoogleNet"></a>4.4.4 GoogleNet</h4><p>也叫InceptionNet，采用了比VGG更深的网络结构，一共22层，但是参数却比AlexNet少了12倍，同时有很高的计算效率，因为它采用了一种很有效的Inception模块，而且没有全连接层。</p><p><strong>Inception模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicConv2d</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,in_channels,out_channels,**kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(BasicConv2d,self).__init__()</span><br><span class="line">        self.conv = nn.Conv2d(in_channels,out_channels,bias=<span class="literal">False</span>,**kwargs)</span><br><span class="line">        self.bn = nn.BatchNorm2d(out_channels,eps=<span class="number">0.001</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        x = self.bn(x)</span><br><span class="line">        <span class="keyword">return</span> F.relu(x,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inception</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,in_channels,pool_features</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Inception,self).__init__()</span><br><span class="line">        self.branch1x1 = BasicConv2d(in_channels,<span class="number">64</span>,kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch5x5_1 = BasicConv2d(in_channels,<span class="number">48</span>,kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch5x5_2 = BasicConv2d(<span class="number">48</span>,<span class="number">64</span>,kernel_size=<span class="number">5</span>,padding=<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        self.branch3x3db1_1 = BasicConv2d(in_channels,<span class="number">64</span>,kernel_size=<span class="number">1</span>)</span><br><span class="line">        self.branch3x3db1_2 = BasicConv2d(<span class="number">64</span>,<span class="number">96</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>)</span><br><span class="line">        self.branch3x3db1_3 = BasicConv2d(<span class="number">96</span>,<span class="number">96</span>,kernel_size=<span class="number">3</span>,padding=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        self.branch_pool = BasicConv2d(in_channels,pool_features,kernel_size=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        branch1x1 = self.branch1x1(x)</span><br><span class="line">        </span><br><span class="line">        branch5x5 = self.branch5x5_1(x)</span><br><span class="line">        branch5x5 = self.branch5x5_2(branch5x5)</span><br><span class="line">        </span><br><span class="line">        branch3x3db1 = self.branch3x3db1_1(x)</span><br><span class="line">        branch3x3db1 = self.branch3x3db1_2(branch3x3db1)</span><br><span class="line">        branch3x3db1 = self.branch3x3db1_3(branch3x3db1)</span><br><span class="line">        </span><br><span class="line">        branch_pool = F.avg_pool2d(x,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">1</span>)</span><br><span class="line">        branch_pool = self.branch_pool(branch_pool)</span><br><span class="line">        </span><br><span class="line">        outputs = [branch1x1,branch5x5,branch3x3db1,branch_pool]</span><br><span class="line">        <span class="keyword">return</span> torch.cat(outputs,<span class="number">1</span>) <span class="comment">#按深度拼接</span></span><br></pre></td></tr></table></figure><h4 id="4-4-5-ResNet"><a href="#4-4-5-ResNet" class="headerlink" title="4.4.5 ResNet"></a>4.4.5 ResNet</h4><p>由微软研究院提出，通过残差模块能够成功地训练高达152层深的神经网络</p><p>ResNet 最初的设计灵感来自这个问题:在不断加深神经网络的时候，会出现一个Degradation ，即准确率会先上升然后达到饱和，再持续增加深度则会导致模型准确率下降。</p><p>这并不是过拟合的问题，因为不仅在验证集上误差增加，训练集本身误差也会增加，假设一个比较浅的网络达到了饱和的准确率，那么在后面加上几个恒等映射层，误差不会增加，也就说更深的模型起码不会使得模型效果下降。</p><p>这里提到的使用恒等映射直接将前一层输出传到后面的思想，就是 ResNet 的灵感来源。假设某个神经网络的输入是x， 期望输出是 H(x)，如果直接把输入x传到输出作为初始结果，那么此时需要学习的目标就是 F(x) = H (x) - x<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/post/20201027143439.png"><br>左边是一个普通的网络，右边是一个 ResNet 的残差学习 单元， ResNet 相当于将学习目 标改变了.不再是学习一个完整的输出H ( x ) ， 而是学习输出和输入的差别H (x) - x，即残差。</p><p>除了这些比较出名的以外还有很多。并且并不需要重复造轮子，PyTorch内为我们实现了以上网络，都在<code>torchvision.model</code>里面，并且大部分网络都有预训练好的参数</p><h3 id="4-5-再实现MNIST手写数字分类"><a href="#4-5-再实现MNIST手写数字分类" class="headerlink" title="4.5 再实现MNIST手写数字分类"></a>4.5 再实现MNIST手写数字分类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn,optim</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CNN,self).__init__()</span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">16</span>,kernel_size=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),<span class="comment"># 归一化处理，使得数据分布一致，避免梯度消失或梯度爆炸</span></span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">16</span>,<span class="number">32</span>,kernel_size=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.layer3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,kernel_size=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.layer4 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,kernel_size=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>,stride=<span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">128</span>*<span class="number">4</span>*<span class="number">4</span>,<span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>,<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">128</span>,<span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x  = self.layer1(x)</span><br><span class="line">        x  = self.layer2(x)</span><br><span class="line">        x  = self.layer3(x)</span><br><span class="line">        x  = self.layer4(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">        x  = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br><span class="line">num_epoch = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">data_tf = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),transforms.Normalize([<span class="number">0.5</span>],[<span class="number">0.5</span>])]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据集</span></span><br><span class="line">train_dataset = datasets.MNIST(root=<span class="string">&quot;./data&quot;</span>,train=<span class="literal">True</span>,transform=data_tf,download=<span class="literal">True</span>)</span><br><span class="line">test_dataset = datasets.MNIST(root=<span class="string">&quot;./data&quot;</span>,train=<span class="literal">False</span>,transform=data_tf)</span><br><span class="line"><span class="comment"># 数据迭代器，传入数据集和batch_size，通过shuffle=True来表示是否将数据打乱</span></span><br><span class="line">train_loader = DataLoader(train_dataset,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_dataset,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">model = CNN()</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    model = model.cuda()</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(),lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">    eval_loss = <span class="number">0.0</span></span><br><span class="line">    eval_acc = <span class="number">0.0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Epoch &#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch,num_epoch))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_loader:</span><br><span class="line">        img,label=data</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            img = Variable(img).cuda()</span><br><span class="line">            label = Variable(label).cuda()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img = Variable(img)</span><br><span class="line">            label = Variable(label)</span><br><span class="line">        out=model(img)</span><br><span class="line">        loss = criterion(out,label)</span><br><span class="line">        <span class="comment"># backward</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment">#置0</span></span><br><span class="line">        loss.backward() <span class="comment">#求梯度</span></span><br><span class="line">        optimizer.step() <span class="comment">#更新所有的参数，梯度下降</span></span><br><span class="line">        <span class="comment">#acc</span></span><br><span class="line">        eval_loss += loss.data</span><br><span class="line">        _,pred = torch.<span class="built_in">max</span>(out,<span class="number">1</span>)</span><br><span class="line">        eval_acc += (pred == label).<span class="built_in">sum</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#123;&#125;,Loss: &#123;:.4f&#125;,Acc:&#123;:.4f&#125;%&#x27;</span>.<span class="built_in">format</span>(epoch,eval_loss/(<span class="built_in">len</span>(train_dataset)),<span class="number">100</span>*<span class="built_in">float</span>(eval_acc)/(<span class="built_in">len</span>(train_dataset))))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">PATH=<span class="string">&#x27;./minist_net.pth&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Train finished!&quot;</span>)</span><br><span class="line">torch.save(model.state_dict(), PATH)</span><br></pre></td></tr></table></figure><h3 id="4-6-图像增强的方法"><a href="#4-6-图像增强的方法" class="headerlink" title="4.6 图像增强的方法"></a>4.6 图像增强的方法</h3><p>torchvision.transforms包括所有图像增强的方法</p><ul><li>Scale，对图片的尺寸进行缩小和放大</li><li>CenterCrop，对图像正中心进行给定大小的随机裁剪</li><li>RandomCrop，对图片进行给定大小的随机裁剪</li><li>RandomHorizaontalFlip，对图像进行概率为0.5的随机水平翻转</li><li>RandomSizedCrop，首先对图片进行随机尺寸的裁剪，然后对裁剪图片进行一个随即比例的缩放，最后将图片变成给定的大小</li><li>Pad，对图片进行边界零填充</li></ul><p>除此之外，还可以使用OpenCV或者PIL等第三方图形库来实现</p><h3 id="4-7-实现cifar10分类"><a href="#4-7-实现cifar10分类" class="headerlink" title="4.7 实现cifar10分类"></a>4.7 实现cifar10分类</h3><p>cifar10数据集中有60000张图片，每张图片的大小都是32×32的三通道彩色图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据处理</span></span><br><span class="line">train_transform = transforms.Compose([</span><br><span class="line">    transforms.Scale(<span class="number">40</span>),</span><br><span class="line">    transforms.RandomHorizontalFlip(),</span><br><span class="line">    transforms.RandomCrop(<span class="number">32</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">test_transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据集获取</span></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=train_transform)</span><br><span class="line">train_data = torch.utils.data.DataLoader(train_set, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=test_transform)</span><br><span class="line">test_data = torch.utils.data.DataLoader(test_set, batch_size=<span class="number">32</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br><span class="line"><span class="comment">#3×3卷积层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv3x3</span>(<span class="params">in_channel, out_channel, stride=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> nn.Conv2d(in_channel, out_channel, <span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">residual_block</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channel, out_channel, same_shape=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(residual_block, self).__init__()</span><br><span class="line">        self.same_shape = same_shape</span><br><span class="line">        stride = <span class="number">1</span> <span class="keyword">if</span> self.same_shape <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">          </span><br><span class="line">        self.conv1 = conv3x3(in_channel, out_channel, stride=stride)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(out_channel)</span><br><span class="line">          </span><br><span class="line">        self.conv2 = conv3x3(out_channel, out_channel)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(out_channel)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.same_shape:</span><br><span class="line">            self.conv3 = nn.Conv2d(in_channel, out_channel, <span class="number">1</span>, stride=stride)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = F.relu(self.bn1(out), <span class="literal">True</span>)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = F.relu(self.bn2(out), <span class="literal">True</span>)</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.same_shape:</span><br><span class="line">            x = self.conv3(x)</span><br><span class="line">        <span class="keyword">return</span> F.relu(x+out, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">resnet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channel, num_classes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(resnet, self).__init__()</span><br><span class="line">        self.block1 = nn.Conv2d(in_channel, <span class="number">64</span>, <span class="number">7</span>, <span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 32-7+2*3/2+1=16</span></span><br><span class="line">        self.block2 = nn.Sequential(</span><br><span class="line">            nn.MaxPool2d(<span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">            residual_block(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">            residual_block(<span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        )</span><br><span class="line">        self.block3 = nn.Sequential(</span><br><span class="line">            residual_block(<span class="number">64</span>, <span class="number">128</span>, <span class="literal">False</span>),</span><br><span class="line">            residual_block(<span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">        )</span><br><span class="line">        self.block4 = nn.Sequential(</span><br><span class="line">            residual_block(<span class="number">128</span>, <span class="number">256</span>, <span class="literal">False</span>),</span><br><span class="line">            residual_block(<span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">        )</span><br><span class="line">        self.block5 = nn.Sequential(</span><br><span class="line">            residual_block(<span class="number">256</span>, <span class="number">512</span>, <span class="literal">False</span>),</span><br><span class="line">            residual_block(<span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">        )</span><br><span class="line">        self.avg_pool = nn.AvgPool2d(<span class="number">2</span>)</span><br><span class="line">        self.classifier = nn.Linear(<span class="number">512</span>, num_classes)</span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.block1(x)</span><br><span class="line">        <span class="comment">#print(x.shape)</span></span><br><span class="line">        x = self.block2(x)</span><br><span class="line">        <span class="comment">#print(x.shape)</span></span><br><span class="line">        x = self.block3(x)</span><br><span class="line">        <span class="comment">#print(x.shape)</span></span><br><span class="line">        x = self.block4(x)</span><br><span class="line">        <span class="comment">#print(x.shape)</span></span><br><span class="line">        x = self.block5(x)</span><br><span class="line">        <span class="comment">#print(x.shape)</span></span><br><span class="line">        x = self.avg_pool(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        x = self.classifier(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">PATH = <span class="string">&#x27;./cifar_net.pth&#x27;</span></span><br><span class="line">net = resnet(<span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">#if os.path.exists(PATH):</span></span><br><span class="line"><span class="comment">#    net.load_state_dict(torch.load(PATH))</span></span><br><span class="line">criterion = nn.CrossEntropyLoss() <span class="comment">#交叉熵</span></span><br><span class="line">optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.01</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算正确率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_acc</span>(<span class="params">output, label</span>):</span></span><br><span class="line">    total = output.shape[<span class="number">0</span>]</span><br><span class="line">    _, pred_label = output.<span class="built_in">max</span>(<span class="number">1</span>)</span><br><span class="line">    num_correct = (pred_label == label).<span class="built_in">sum</span>().data</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(num_correct) / total</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_data, valid_data, num_epochs, optimizer, criterion</span>):</span></span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        net = net.cuda()</span><br><span class="line">    <span class="comment">#计时</span></span><br><span class="line">    prev_time = datetime.now()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line">        train_loss = <span class="number">0.0</span></span><br><span class="line">        train_acc = <span class="number">0.0</span></span><br><span class="line">        net = net.train() <span class="comment">#训练模式</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> train_data:</span><br><span class="line">            im,label = data</span><br><span class="line">            <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">                im = Variable(im.cuda())</span><br><span class="line">                label = Variable(label.cuda())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                im = Variable(im)</span><br><span class="line">                label = Variable(label)</span><br><span class="line">            <span class="comment">#forward</span></span><br><span class="line">            output = net(im)</span><br><span class="line">            loss = criterion(output, label)</span><br><span class="line">            <span class="comment">#forward</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">               </span><br><span class="line">            train_loss += loss.data</span><br><span class="line">            train_acc += get_acc(output, label)</span><br><span class="line">        <span class="comment">#计时</span></span><br><span class="line">        cur_time = datetime.now()</span><br><span class="line">        h, remainder = <span class="built_in">divmod</span>((cur_time-prev_time).seconds, <span class="number">3600</span>)</span><br><span class="line">        m, s = <span class="built_in">divmod</span>(remainder, <span class="number">60</span>)</span><br><span class="line">        time_str = <span class="string">&quot;Time %02d:%02d:%02d&quot;</span> % (h, m, s)</span><br><span class="line">        <span class="comment">#测试</span></span><br><span class="line">        <span class="keyword">if</span> valid_data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            valid_loss = <span class="number">0.0</span></span><br><span class="line">            valid_acc = <span class="number">0.0</span></span><br><span class="line">            net = net.<span class="built_in">eval</span>() <span class="comment"># 切换测试模式</span></span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> valid_data:</span><br><span class="line">                im, label = data</span><br><span class="line">                <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">                    im = Variable(im.cuda())</span><br><span class="line">                    label = Variable(label.cuda())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    im = Variable(im)</span><br><span class="line">                    label = Variable(label)</span><br><span class="line">                output = net(im)</span><br><span class="line">                loss = criterion(output, label)</span><br><span class="line">                valid_loss += loss.item()</span><br><span class="line">                valid_acc += get_acc(output, label)</span><br><span class="line">            epoch_str = (</span><br><span class="line">                <span class="string">&quot;Epoch %d. Train Loss: %f, Train Acc: %f, Valid Loss: %f, Valid Acc: %f, &quot;</span></span><br><span class="line">                % (epoch, train_loss / <span class="built_in">len</span>(train_data),</span><br><span class="line">                   train_acc / <span class="built_in">len</span>(train_data), valid_loss / <span class="built_in">len</span>(valid_data),</span><br><span class="line">                   valid_acc / <span class="built_in">len</span>(valid_data)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            epoch_str = (<span class="string">&quot;Epoch %d. Train Loss: %f, Train Acc: %f, &quot;</span> %</span><br><span class="line">                         (epoch, train_loss / <span class="built_in">len</span>(train_data),</span><br><span class="line">                          train_acc / <span class="built_in">len</span>(train_data)))</span><br><span class="line">               </span><br><span class="line">        prev_time = cur_time</span><br><span class="line">        <span class="built_in">print</span>(epoch_str + time_str)</span><br><span class="line"></span><br><span class="line">train(net, train_data, test_data, <span class="number">10</span>, optimizer, criterion) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Finished Training&#x27;</span>)</span><br><span class="line"></span><br><span class="line">torch.save(net.state_dict(), PATH)</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">test_set = torchvision.datasets.CIFAR10(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=test_transform)</span><br><span class="line">test_data = torch.utils.data.DataLoader(test_set, batch_size=<span class="number">4</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出图像的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span>(<span class="params">img</span>):</span></span><br><span class="line">    img = img / <span class="number">2</span> + <span class="number">0.5</span>     <span class="comment"># unnormalize</span></span><br><span class="line">    npimg = img.numpy()</span><br><span class="line">    plt.imshow(np.transpose(npimg, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">dataiter = <span class="built_in">iter</span>(test_data)</span><br><span class="line">images, labels = dataiter.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(images.shape)</span></span><br><span class="line"><span class="comment"># 输出图片</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GroundTruth: &#x27;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">&#x27;%5s&#x27;</span> % classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">PATH = <span class="string">&#x27;./cifar_net.pth&#x27;</span></span><br><span class="line">net.load_state_dict(torch.load(PATH))</span><br><span class="line"></span><br><span class="line">outputs = net(images)</span><br><span class="line"></span><br><span class="line">_, predicted = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Predicted: &#x27;</span>, <span class="string">&#x27; &#x27;</span>.join(<span class="string">&#x27;%5s&#x27;</span> % classes[predicted[j]] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">class_correct = <span class="built_in">list</span>(<span class="number">0.</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">class_total = <span class="built_in">list</span>(<span class="number">0.</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_data:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predicted = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)</span><br><span class="line">        c = (predicted == labels).squeeze()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            label = labels[i]</span><br><span class="line">            class_correct[label] += c[i].item()</span><br><span class="line">            class_total[label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accuracy of %5s : %2d %%&#x27;</span> % (</span><br><span class="line">        classes[i], <span class="number">100</span> * class_correct[i] / class_total[i]))</span><br></pre></td></tr></table></figure><h2 id="第五章-循环神经网络"><a href="#第五章-循环神经网络" class="headerlink" title="第五章 循环神经网络"></a>第五章 循环神经网络</h2><p>RNN，在序列问题和自然语言处理等领域取得很大的成功</p><h3 id="5-1-循环神经网络"><a href="#5-1-循环神经网络" class="headerlink" title="5.1 循环神经网络"></a>5.1 循环神经网络</h3><p>卷积神经网络相当于人类的视觉，但是它没有记忆能力，所以它只能处理一种特定的视觉任务，没办法根据以前的记忆来处理新的任务。</p><p>循环神经网络的提出便是居于记忆模型的想法，期望网络能够记住前面出现的特征，并依据特征推断后面的结果，而且整体的网络结构不断循环，因而得名循环神经网络</p><p>比如：某一个单词的意思会因为上文提到的内容不同而有不同的含义，RNN可以很好的解决这类问题</p><h4 id="5-1-1-问题介绍"><a href="#5-1-1-问题介绍" class="headerlink" title="5.1.1 问题介绍"></a>5.1.1 问题介绍</h4><p>对于下面两句话</p><ul><li>arrive beijing on November 2nd</li><li>leave beijing on November 2nd</li></ul><p>第一句话表达到达，第二句话表示离开，如果网络能构记忆“beijing”前面的词，就会预测出不同的结果。</p><h4 id="5-1-2-循环神经网络的基本结构"><a href="#5-1-2-循环神经网络的基本结构" class="headerlink" title="5.1.2 循环神经网络的基本结构"></a>5.1.2 循环神经网络的基本结构</h4><p>将网络的输出保存在一个记忆单元中，这个记忆单元和下一次的输入一起进入神经网络中。因此，输入序列（sequences）的顺序改变，会改变网络的输出结果。</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/post/v2-206db7ba9d32a80ff56b6cc988a62440_r.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/post/v2-b0175ebd3419f9a11a3d0d8b00e28675_r.jpg"></p><p>这个网络在t时刻接收到输入$x_t$之后，隐藏层的值是$S_t$，输出值是$O_t$。关键一点是，$S_t$的值不仅仅取决于$x_t$，还取决于$S_{t-1}$。我们可以用下面的公式来表示循环神经网络的计算方法：</p><p>$$O _ t = g(VS_t)$$<br>$$S _ t = f(UX_t+WS_{t-1})$$</p><h4 id="5-1-3-存在的问题"><a href="#5-1-3-存在的问题" class="headerlink" title="5.1.3 存在的问题"></a>5.1.3 存在的问题</h4><p>循环神经网络具有很好的记忆特性，能够将记忆内容应用到当前情景下，但是记忆最大的问题在于遗忘性</p><h3 id="5-2-循环神经网络的变式：LSTM和GRU"><a href="#5-2-循环神经网络的变式：LSTM和GRU" class="headerlink" title="5.2 循环神经网络的变式：LSTM和GRU"></a>5.2 循环神经网络的变式：LSTM和GRU</h3><h4 id="5-2-1-LSTM"><a href="#5-2-1-LSTM" class="headerlink" title="5.2.1 LSTM"></a>5.2.1 LSTM</h4><p>LSTM是Long Short Term Memory Networks的缩写，是一种链式循环的网络结构，在网络内部有着更复杂的结构，主要为了解决长序列训练过程中的梯度下降和梯度爆炸问题。</p><p>LSTM由三个门来控制，分别是输入门，遗忘门和输出门。顾名思义，输入门控制着网络的输入，遗忘门控制着记忆单元，输出门控制着网络的输出。这其中最重要的就是遗忘门，遗忘门的作用是决定之前的哪些记忆及那个被保留，那些记忆将被去掉，正是由于遗忘门的作用，使得LSTM具有了长时记忆的功能</p><h4 id="5-2-2-GRU"><a href="#5-2-2-GRU" class="headerlink" title="5.2.2 GRU"></a>5.2.2 GRU</h4><p>GRU是Gated Recurrent Unit的缩写，由Cho于2014年提出，GRU和LSTM最大的不同在于GRU将遗忘门和输入门合成了一个“更新门”，同时网络不再额外给出记忆状态Ct，而是将输出结果ht作为记忆状态不断向后循环传递，网络的输出和出入变得简单</p><h4 id="5-2-3-收敛性问题"><a href="#5-2-3-收敛性问题" class="headerlink" title="5.2.3 收敛性问题"></a>5.2.3 收敛性问题</h4><p>如果写了一个简单的LSTM网络去训练数据，会发现loss并不会按照想象的方式下降，而是在乱跳，这是因为RNN的误差曲面粗糙不平导致的，而解决方法是梯度裁剪（gradient clipping）</p><h3 id="5-3-循环神经网络的PyTorch实现"><a href="#5-3-循环神经网络的PyTorch实现" class="headerlink" title="5.3 循环神经网络的PyTorch实现"></a>5.3 循环神经网络的PyTorch实现</h3><h4 id="5-3-1-PyTorch的循环网络模块"><a href="#5-3-1-PyTorch的循环网络模块" class="headerlink" title="5.3.1 PyTorch的循环网络模块"></a>5.3.1 PyTorch的循环网络模块</h4><p><strong>1.标准RNN</strong></p><p><code>nn.RNN()</code><br><strong>参数</strong></p><ul><li><code>input_size</code>表示输入$x_t$的维度</li><li><code>hidden_size</code>表示输出$h_t$的维度</li><li><code>num_layers</code>表示网络层数，默认为1层</li><li><code>nonlinearity</code>表示非线性激活函数，默认为tanh，可选relu</li><li><code>bias</code>表示是否使用偏置，默认为True</li><li><code>batch_first</code>决定网络输入的维度顺序，默认输入顺序（seq,batch,feature），如果设置为True，则顺序为（batch，seq，feature）</li><li><code>dropout</code>，接受一个0到1的数值，并在除最后一层的其他输出层加上dropout层</li><li><code>bidirectional</code>默认是False，如果设置为True，就是双向循环神经网络的结构</li></ul><p><strong>网络接受的输入</strong></p><ul><li>序列输入$x_t$：$x_t$的维度是（seq，batch，feature），分别表示序列长度，批量和输入的特征维度</li><li>记忆输入$h_0$：$h_0$也叫隐藏状态，它的维度是（layers×direction，batch，hidden），分别表示层数乘方向（单向1，双向2），批量和输出的维度</li></ul><p><strong>网络的输出</strong></p><ul><li>output，表示网络实际的输出，维度是（seq，batch，hidden×direction），分别表示序列长度，批量和输出维度乘方向</li><li>$h_n$表示记忆单元，维度是（layer×direction，batch，hidden）分别表示层数乘方向，批量，输出维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">basic_rnn = nn.RNN(input_size=<span class="number">20</span>,hidden_size=<span class="number">50</span>,num_layers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">toy_input = Variable(torch.randn(<span class="number">100</span>,<span class="number">32</span>,<span class="number">20</span>)) <span class="comment"># seq,batch,input_size</span></span><br><span class="line">h_0 = Variable(torch.rand(<span class="number">2</span>,<span class="number">32</span>,<span class="number">50</span>)) <span class="comment"># layer * direction,batch,hidden_size</span></span><br><span class="line"></span><br><span class="line">toy_output,h_n = basic_rnn(toy_input,h_0)</span><br></pre></td></tr></table></figure><p><strong>2.LSTM</strong></p><p><code>nn.LSTM()</code><br>参数和标准RNN一样</p><p>LSTM与RNN不同的地方：</p><ul><li>LSTM的参数比标准RNN多，是标准RNN维度的4倍，但是访问的方式仍然是相同的</li><li>LSTM的输入还多了一个$C_0$，它们合在一起称为网络的隐藏状态，即（layer×direction，batch，hidden），当然输出也会有$h_0$,$C_0$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lstm = nn.LSTM(input_size=<span class="number">20</span>,hidden_size=<span class="number">50</span>,num_layers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">lstm_input = Variable(torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">20</span>))</span><br><span class="line">out, (h, c) = lstm(lstm_input)</span><br></pre></td></tr></table></figure><p><strong>3.GRU</strong></p><p>GRU本质上和LSTM一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gru_seq = nn.GRU(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">gru_input = Variable(torch.randn(<span class="number">3</span>, <span class="number">32</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">out, h = gru_seq(gru_input)</span><br></pre></td></tr></table></figure><p>它和LSTM不同的地方：</p><ul><li>参数是标准RNN的三倍</li><li>网络的隐藏状态只有h0</li></ul><h4 id="5-3-2-实例介绍"><a href="#5-3-2-实例介绍" class="headerlink" title="5.3.2 实例介绍"></a>5.3.2 实例介绍</h4><p>序列预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#希望通过前两个月的流量来预测当月的流量</span></span><br><span class="line"><span class="comment">#将前两个月的流量当做输入，当月的流量当做输出</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dataset</span>(<span class="params">dataset,look_back=<span class="number">2</span></span>):</span></span><br><span class="line">    dataX,dataY = [],[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dataset)-look_back):</span><br><span class="line">        a = dataset[i:(i+look_back)]</span><br><span class="line">        dataX.append(a)</span><br><span class="line">        dataY.append(dataset[i+look_back])</span><br><span class="line">    <span class="keyword">return</span> np.array(dataX),np.array(dataY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lstm_reg</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_size, hidden_size, output_size=<span class="number">1</span>, num_layers=<span class="number">2</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(lstm_reg, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.rnn = nn.LSTM(input_size, hidden_size, num_layers) <span class="comment"># rnn</span></span><br><span class="line">        self.reg = nn.Linear(hidden_size, output_size) <span class="comment"># 回归</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x, _ = self.rnn(x) <span class="comment"># (seq, batch, hidden)</span></span><br><span class="line">        s, b, h = x.shape</span><br><span class="line">        x = x.view(s*b, h) <span class="comment"># 转换成线性层的输入格式</span></span><br><span class="line">        x = self.reg(x)</span><br><span class="line">        x = x.view(s, b, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">data_csv = pd.read_csv(<span class="string">&#x27;./data.csv&#x27;</span>, usecols=[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理，将数据中na的数据去掉，然后将数据标准化到0~1之间</span></span><br><span class="line">data_csv = data_csv.dropna()</span><br><span class="line">dataset = data_csv.values</span><br><span class="line">dataset = dataset.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">max_value = np.<span class="built_in">max</span>(dataset)</span><br><span class="line">min_value = np.<span class="built_in">min</span>(dataset)</span><br><span class="line">scalar = max_value - min_value</span><br><span class="line">dataset = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x / scalar, dataset))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建好输入输出</span></span><br><span class="line">data_X, data_Y = create_dataset(dataset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集，70% 作为训练集</span></span><br><span class="line">train_size = <span class="built_in">int</span>(<span class="built_in">len</span>(data_X) * <span class="number">0.7</span>)</span><br><span class="line">test_size = <span class="built_in">len</span>(data_X) - train_size</span><br><span class="line">train_X = data_X[:train_size]</span><br><span class="line">train_Y = data_Y[:train_size]</span><br><span class="line">test_X = data_X[train_size:]</span><br><span class="line">test_Y = data_Y[train_size:]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将数据改变一下形状 (seq, batch, feature)</span></span><br><span class="line"><span class="comment">#只有一个序列，所以 batch 是 1</span></span><br><span class="line"><span class="comment">#输入的feature是希望依据的几个月份，这里定的是两个月份，feature=2.</span></span><br><span class="line">train_X = train_X.reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">train_Y = train_Y.reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">test_X = test_X.reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">train_x = torch.from_numpy(train_X)</span><br><span class="line">train_y = torch.from_numpy(train_Y)</span><br><span class="line">test_x = torch.from_numpy(test_X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失和优化</span></span><br><span class="line">net = lstm_reg(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=<span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    var_x = Variable(train_x)</span><br><span class="line">    var_y = Variable(train_y)</span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    out = net(var_x)</span><br><span class="line">    loss = criterion(out, var_y)</span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    <span class="keyword">if</span> (e + <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>: <span class="comment"># 每 100 次输出结果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch: &#123;&#125;, Loss: &#123;:.5f&#125;&#x27;</span>.<span class="built_in">format</span>(e + <span class="number">1</span>, loss.data))</span><br><span class="line">        </span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">net = net.<span class="built_in">eval</span>() <span class="comment"># 转换成测试模式</span></span><br><span class="line">data_X = data_X.reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">data_X = torch.from_numpy(data_X)</span><br><span class="line">var_data = Variable(data_X)</span><br><span class="line">pred_test = net(var_data) <span class="comment"># 测试集的预测结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变输出的格式</span></span><br><span class="line">pred_test = pred_test.view(-<span class="number">1</span>).data.numpy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出实际结果和预测的结果</span></span><br><span class="line">plt.plot(pred_test, <span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;prediction&#x27;</span>)</span><br><span class="line">plt.plot(dataset, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;real&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201102181225.png"></p><h3 id="5-4-自然语言处理的应用"><a href="#5-4-自然语言处理的应用" class="headerlink" title="5.4 自然语言处理的应用"></a>5.4 自然语言处理的应用</h3><h4 id="5-4-1-词嵌入"><a href="#5-4-1-词嵌入" class="headerlink" title="5.4.1 词嵌入"></a>5.4.1 词嵌入</h4><p>词嵌入（word embedding），也称为词向量，即对于每个词，可以使用一个高维向量去表示它</p><p>例如：</p><ul><li>(1)The cat likes playing ball</li><li>(2)The kitty likes playing wool</li><li>(3)The dog likes playing ball</li><li>(4)The boy doesn’t like playing ball</li></ul><p>对于这四句话里的四个词，cat，kitty，dog，boy，如果用one-hot编码，那么cat可以是（1，0，0，0），kitty可以是（0，1，0，0），但是cat和kitty都是小猫，所以这两个词实际语义是接近的，但是one-hot不能体现这个特点，于是可以用词嵌入的方式表示这四个词。</p><p>假设使用一个二维向量（a，b）来表示一个词，其中a代表是否喜欢玩球，b代表是否喜欢玩毛线，且数值越大代表越喜欢，那么对于cat可以表示（-1，4），对于kitty可以表示为（-2，5），对于dog可以表示为（3，-2），对于boy可以表示为（-2，-3）</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201102190952.png"></p><p>可以发现kitty和cat的夹角更小，所以它们更加相似</p><h4 id="5-4-2-词嵌入的PyTorch实现"><a href="#5-4-2-词嵌入的PyTorch实现" class="headerlink" title="5.4.2 词嵌入的PyTorch实现"></a>5.4.2 词嵌入的PyTorch实现</h4><p>PyTorch中的词嵌入是通过函数<code>nn.Embedding(m,n)</code>来实现的，其中m表示所有的单词数目，n表示词嵌入的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word_to_ix = &#123;<span class="string">&#x27;hello&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;world&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line">embeds = nn.Embeding(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">hello_idx = torch.LongTensor([word_to_ix[<span class="string">&#x27;hello&#x27;</span>]])</span><br><span class="line">hello_idx = Variable(hello_idx)</span><br><span class="line">hello_embed = embeds(hello_idx)</span><br><span class="line"><span class="built_in">print</span>(hello_embed)</span><br></pre></td></tr></table></figure><h4 id="5-4-3-N-Gram模型"><a href="#5-4-3-N-Gram模型" class="headerlink" title="5.4.3 N Gram模型"></a>5.4.3 N Gram模型</h4><p>对于一句话，单词的排列顺序是非常重要的，所以我们能否由前面的几个词来预测后面的几个单词呢，比如 ‘I lived in France for 10 years, I can speak _ ‘ 这句话中，我们能够预测出最后一个词是 French。</p><p>对于一句话T，它由w1，w2,…,wn这n个词构成，可以得到下面的公式<br>$$<br>P(T) = P(w_1)P(w_2 | w_1)P(w_3 |w_2 w_1) \cdots P(w_n |w_{n-1} w_{n-2}\cdots w_2w_1)<br>$$<br>但是该模型存在如参数空间过大等缺陷，因此引入了马尔科夫假设，也就是说这个单词只与前面的几个词有关系。</p><p>对于这个条件概率，传统的方式是统计语料中每个单词出现的频率，据此来估计这个条件概率，这里使用词嵌入的办法，直接在语料中计算这个条件概率，然后最大化条件概率从而优化词向量，据此进行预测</p><h4 id="5-4-4-单词预测的PyTorch实现"><a href="#5-4-4-单词预测的PyTorch实现" class="headerlink" title="5.4.4 单词预测的PyTorch实现"></a>5.4.4 单词预测的PyTorch实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line">CONTEXT_SIZE = <span class="number">2</span> <span class="comment"># 依据的单词数</span></span><br><span class="line">EMBEDDING_DIM = <span class="number">10</span> <span class="comment"># 词向量的维度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">n_gram</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, vocab_size, context_size=CONTEXT_SIZE, n_dim=EMBEDDING_DIM</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(n_gram, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.embed = nn.Embedding(vocab_size, n_dim)</span><br><span class="line">        self.classify = nn.Sequential(</span><br><span class="line">            nn.Linear(context_size * n_dim, <span class="number">128</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">128</span>, vocab_size)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        voc_embed = self.embed(x) <span class="comment"># 得到词嵌入</span></span><br><span class="line">        voc_embed = voc_embed.view(<span class="number">1</span>, -<span class="number">1</span>) <span class="comment"># 将两个词向量拼在一起</span></span><br><span class="line">        out = self.classify(voc_embed)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们使用莎士比亚的诗</span></span><br><span class="line">test_sentence = <span class="string">&quot;&quot;&quot;When forty winters shall besiege thy brow,</span></span><br><span class="line"><span class="string">And dig deep trenches in thy beauty&#x27;s field,</span></span><br><span class="line"><span class="string">Thy youth&#x27;s proud livery so gazed on now,</span></span><br><span class="line"><span class="string">Will be a totter&#x27;d weed of small worth held:</span></span><br><span class="line"><span class="string">Then being asked, where all thy beauty lies,</span></span><br><span class="line"><span class="string">Where all the treasure of thy lusty days;</span></span><br><span class="line"><span class="string">To say, within thine own deep sunken eyes,</span></span><br><span class="line"><span class="string">Were an all-eating shame, and thriftless praise.</span></span><br><span class="line"><span class="string">How much more praise deserv&#x27;d thy beauty&#x27;s use,</span></span><br><span class="line"><span class="string">If thou couldst answer &#x27;This fair child of mine</span></span><br><span class="line"><span class="string">Shall sum my count, and make my old excuse,&#x27;</span></span><br><span class="line"><span class="string">Proving his beauty by succession thine!</span></span><br><span class="line"><span class="string">This were to be new made when thou art old,</span></span><br><span class="line"><span class="string">And see thy blood warm when thou feel&#x27;st it cold.&quot;&quot;&quot;</span>.split()</span><br><span class="line"></span><br><span class="line">trigram = [((test_sentence[i], test_sentence[i+<span class="number">1</span>]), test_sentence[i+<span class="number">2</span>]) </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_sentence)-<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立每个词与数字的编码，据此构建词嵌入</span></span><br><span class="line">vocb = <span class="built_in">set</span>(test_sentence) <span class="comment"># 使用 set 将重复的元素去掉</span></span><br><span class="line">word_to_idx = &#123;word: i <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(vocb)&#125;</span><br><span class="line">idx_to_word = &#123;word_to_idx[word]: word <span class="keyword">for</span> word <span class="keyword">in</span> word_to_idx&#125;</span><br><span class="line"></span><br><span class="line">net = n_gram(<span class="built_in">len</span>(word_to_idx))</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">1e-2</span>, weight_decay=<span class="number">1e-5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    train_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> word, label <span class="keyword">in</span> trigram: <span class="comment"># 使用前 100 个作为训练集</span></span><br><span class="line">        word = Variable(torch.LongTensor([word_to_idx[i] <span class="keyword">for</span> i <span class="keyword">in</span> word])) <span class="comment"># 将两个词作为输入</span></span><br><span class="line">        label = Variable(torch.LongTensor([word_to_idx[label]]))</span><br><span class="line">        <span class="comment"># 前向传播</span></span><br><span class="line">        out = net(word)</span><br><span class="line">        loss = criterion(out, label)</span><br><span class="line">        train_loss += loss.data</span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    <span class="keyword">if</span> (e + <span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch: &#123;&#125;, Loss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(e + <span class="number">1</span>, train_loss / <span class="built_in">len</span>(trigram)))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">word, label = trigram[<span class="number">19</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;input: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(word))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;label: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(label))</span><br><span class="line"></span><br><span class="line">word = Variable(torch.LongTensor([word_to_idx[i] <span class="keyword">for</span> i <span class="keyword">in</span> word]))</span><br><span class="line">out = net(word)</span><br><span class="line">pred_label_idx = out.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">1</span>].item()</span><br><span class="line">predict_word = idx_to_word[pred_label_idx]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;real word is &#123;&#125;, predicted word is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(label, predict_word))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">epoch: 20, Loss: 0.873597</span><br><span class="line">epoch: 40, Loss: 0.153170</span><br><span class="line">epoch: 60, Loss: 0.090456</span><br><span class="line">epoch: 80, Loss: 0.071410</span><br><span class="line">epoch: 100, Loss: 0.061979</span><br><span class="line">input: (&#x27;so&#x27;, &#x27;gazed&#x27;)</span><br><span class="line">label: on</span><br><span class="line"></span><br><span class="line">real word is on, predicted word is on</span><br></pre></td></tr></table></figure><h4 id="5-4-5-词性判断"><a href="#5-4-5-词性判断" class="headerlink" title="5.4.5 词性判断"></a>5.4.5 词性判断</h4><p><strong>1.LSTM做词性判断的基本原理</strong></p><p>同构LSTM，根据它记忆的特性，能够通过这个单词前面记忆的一些词语来对它做一个判断，比如前面的单词如果是my，那么紧跟的词很可能是一个名词，这样就能充分利用上文来处理这个问题</p><p><strong>2.字符增强</strong></p><p>通过引入字符来增强表达，比如有些单词存在前缀或者后缀，比如<code>-ly</code>这种后缀很有可能是副词，这样我们就能在字符水平对词性进一步判断，把两种方法集成起来，能够得到一个更好的结果</p><h4 id="5-4-6-词性判断的PyTorch实现"><a href="#5-4-6-词性判断的PyTorch实现" class="headerlink" title="5.4.6 词性判断的PyTorch实现"></a>5.4.6 词性判断的PyTorch实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line">training_data = [(<span class="string">&quot;The dog ate the apple&quot;</span>.split(),</span><br><span class="line">                  [<span class="string">&quot;DET&quot;</span>, <span class="string">&quot;NN&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;DET&quot;</span>, <span class="string">&quot;NN&quot;</span>]),</span><br><span class="line">                 (<span class="string">&quot;Everybody read that book&quot;</span>.split(), </span><br><span class="line">                  [<span class="string">&quot;NN&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;DET&quot;</span>, <span class="string">&quot;NN&quot;</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment">#对单词和标签进行编码</span></span><br><span class="line">word_to_idx = &#123;&#125;</span><br><span class="line">tag_to_idx = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> context, tag <span class="keyword">in</span> training_data:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> context:</span><br><span class="line">        <span class="keyword">if</span> word.lower() <span class="keyword">not</span> <span class="keyword">in</span> word_to_idx:</span><br><span class="line">            word_to_idx[word.lower()] = <span class="built_in">len</span>(word_to_idx)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> tag:</span><br><span class="line">        <span class="keyword">if</span> label.lower() <span class="keyword">not</span> <span class="keyword">in</span> tag_to_idx:</span><br><span class="line">            tag_to_idx[label.lower()] = <span class="built_in">len</span>(tag_to_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对字母编码</span></span><br><span class="line">alphabet = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">char_to_idx = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alphabet)):</span><br><span class="line">    char_to_idx[alphabet[i]] = i</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_sequence</span>(<span class="params">x, dic</span>):</span> <span class="comment"># 字符编码</span></span><br><span class="line">    idx = [dic[i.lower()] <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">    idx = torch.LongTensor(idx)</span><br><span class="line">    <span class="keyword">return</span> idx</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建单个字符的lstm模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">char_lstm</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_char, char_dim, char_hidden</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(char_lstm, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.char_embed = nn.Embedding(n_char, char_dim)</span><br><span class="line">        self.lstm = nn.LSTM(char_dim, char_hidden)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.char_embed(x)</span><br><span class="line">        out, _ = self.lstm(x)</span><br><span class="line">        <span class="keyword">return</span> out[-<span class="number">1</span>] <span class="comment"># (batch, hidden)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建词性分类的lstm模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lstm_tagger</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_word, n_char, char_dim, word_dim, </span></span></span><br><span class="line"><span class="params"><span class="function">                 char_hidden, word_hidden, n_tag</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(lstm_tagger, self).__init__()</span><br><span class="line">        self.word_embed = nn.Embedding(n_word, word_dim)</span><br><span class="line">        self.char_lstm = char_lstm(n_char, char_dim, char_hidden)</span><br><span class="line">        self.word_lstm = nn.LSTM(word_dim + char_hidden, word_hidden)</span><br><span class="line">        self.classify = nn.Linear(word_hidden, n_tag)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, word</span>):</span></span><br><span class="line">        char = []</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word: <span class="comment"># 对于每个单词做字符的 lstm</span></span><br><span class="line">            char_list = make_sequence(w, char_to_idx)</span><br><span class="line">            char_list = char_list.unsqueeze(<span class="number">1</span>) <span class="comment"># (seq, batch, feature) 满足 lstm 输入条件</span></span><br><span class="line">            char_infor = self.char_lstm(Variable(char_list)) <span class="comment"># (batch, char_hidden)</span></span><br><span class="line">            char.append(char_infor)</span><br><span class="line">        char = torch.stack(char, dim=<span class="number">0</span>) <span class="comment"># (seq, batch, feature)</span></span><br><span class="line">        </span><br><span class="line">        x = self.word_embed(x) <span class="comment"># (batch, seq, word_dim)</span></span><br><span class="line">        x = x.permute(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment"># 改变顺序</span></span><br><span class="line">        x = torch.cat((x, char), dim=<span class="number">2</span>) <span class="comment"># 沿着特征通道将每个词的词嵌入和字符 lstm 输出的结果拼接在一起</span></span><br><span class="line">        x, _ = self.word_lstm(x)</span><br><span class="line">        </span><br><span class="line">        s, b, h = x.shape</span><br><span class="line">        x = x.view(-<span class="number">1</span>, h) <span class="comment"># 重新 reshape 进行分类线性层</span></span><br><span class="line">        out = self.classify(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">net = lstm_tagger(<span class="built_in">len</span>(word_to_idx), <span class="built_in">len</span>(char_to_idx), <span class="number">10</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">128</span>, <span class="built_in">len</span>(tag_to_idx))</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">1e-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>):</span><br><span class="line">    train_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> word, tag <span class="keyword">in</span> training_data:</span><br><span class="line">        word_list = make_sequence(word, word_to_idx).unsqueeze(<span class="number">0</span>) <span class="comment"># 添加第一维 batch</span></span><br><span class="line">        tag = make_sequence(tag, tag_to_idx)</span><br><span class="line">        word_list = Variable(word_list)</span><br><span class="line">        tag = Variable(tag)</span><br><span class="line">        <span class="comment"># 前向传播</span></span><br><span class="line">        out = net(word_list, word)</span><br><span class="line">        loss = criterion(out, tag)</span><br><span class="line">        train_loss += loss.data</span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    <span class="keyword">if</span> (e + <span class="number">1</span>) % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch: &#123;&#125;, Loss: &#123;:.5f&#125;&#x27;</span>.<span class="built_in">format</span>(e + <span class="number">1</span>, train_loss / <span class="built_in">len</span>(training_data)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">net = net.<span class="built_in">eval</span>()</span><br><span class="line">test_sent = <span class="string">&#x27;Everybody ate the apple&#x27;</span></span><br><span class="line">test = make_sequence(test_sent.split(), word_to_idx).unsqueeze(<span class="number">0</span>)</span><br><span class="line">out = net(Variable(test), test_sent.split())</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="built_in">print</span>(tag_to_idx)</span><br></pre></td></tr></table></figure><h3 id="5-5-循环神经网络的更多应用"><a href="#5-5-循环神经网络的更多应用" class="headerlink" title="5.5 循环神经网络的更多应用"></a>5.5 循环神经网络的更多应用</h3><h4 id="5-5-1-Many-to-one"><a href="#5-5-1-Many-to-one" class="headerlink" title="5.5.1 Many to one"></a>5.5.1 Many to one</h4><p>循环神经网络不仅能够输入序列，输出序列，还能后输入序列，输出单个向量。只需要再输出的序列里面取其中一个就可以，通常是取最后一个。这样的结构被称为Many to one。</p><p>Many to one的结构可以用来执行什么任务：</p><ul><li>情感分析</li><li>关键字提取</li></ul><h4 id="5-5-2-Many-to-Many-shorter"><a href="#5-5-2-Many-to-Many-shorter" class="headerlink" title="5.5.2 Many to Many (shorter)"></a>5.5.2 Many to Many (shorter)</h4><p>这种结构是输入和输出都是序列，但是输出的序列比输入的序列短。这种类型的结构通常在语音识别中遇到，因为一段话如果用语言表达往往会比这段话更长。这种情况需要使用CTC算法解决重复的问题，CTC就是将输出的所有可能列举出来，然后通过去重复，去空格的方式来选择最大的概率。</p><h4 id="5-5-3-Seq2seq"><a href="#5-5-3-Seq2seq" class="headerlink" title="5.5.3 Seq2seq"></a>5.5.3 Seq2seq</h4><p>这种情况是输出的长度不确定，一般是在机器翻译的任务中出现。</p><h4 id="5-5-4-CNN-RNN"><a href="#5-5-4-CNN-RNN" class="headerlink" title="5.5.4 CNN+RNN"></a>5.5.4 CNN+RNN</h4><p>RNN和CNN可以联合在一起完成图像描述任务，简而言之，就是通过预训练的卷积神经网络提取图片特征，接着通过循环网络将特征变成文字描述</p><h2 id="第6章-生成对抗网络"><a href="#第6章-生成对抗网络" class="headerlink" title="第6章 生成对抗网络"></a>第6章 生成对抗网络</h2><p>2014年，lan Goodfellow提出的生成对抗网络（Generative Adversarial Networks，GANs）推进了整个无监督学习的发展进程，让机器实现一些创造性工作，如画画，写诗，创作歌词等成为可能…</p><h3 id="6-1-生成模型"><a href="#6-1-生成模型" class="headerlink" title="6.1 生成模型"></a>6.1 生成模型</h3><p>生成模型(Generative Model)这一概念属于概率统计和机器学习,是指一系列用于随机生成可观测数据的模型.简而言之,就是”生成”的样本和”真实”的样本尽可能地相似.</p><p>生成模型的两个主要功能就是学习一个概率分布$P_{model}(x)$和生成数据</p><h4 id="6-1-1-自动编码器"><a href="#6-1-1-自动编码器" class="headerlink" title="6.1.1 自动编码器"></a>6.1.1 自动编码器</h4><p>自动编码器(AutoEncoder)最开始作为一种数据的压缩方法,其特点有:</p><ul><li>和数据相关程度很高</li><li>压缩后数据是有损的</li></ul><p>所以现在自动编码器主要应用在几个方面:</p><ul><li>数据去噪</li><li>可视化降维</li><li>生成数据</li></ul><p>自动编码器的一般结构</p><ul><li>编码器(Encoder)</li><li>解码器(Decoder)</li></ul><p>编码器和解码器可以是任意的模型,通常使用神经网络模型作为编码器和解码器.输入的数据经过神经网络降维到一个编码(code),接着又通过另一个神经网络去解码得到一个与输入原数据一模一样的生成数据,然后通过比较这两个数据,最小化它们之间的差异来训练这个网络中编码器和解码器的参数.当这个过程训练完之后,拿出这个解码器,随机传入一个编码,通过解码器能够生成一个和原数据差不多的数据</p><p>下面我们使用 mnist 数据集来说明一个如何构建一个简单的自动编码器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行数据预处理和迭代器的构建</span></span><br><span class="line">im_tfs = tfs.Compose([</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    tfs.Normalize([<span class="number">0.5</span>], [<span class="number">0.5</span>]) <span class="comment"># 标准化</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = MNIST(<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>,transform=im_tfs,download=<span class="literal">True</span>)</span><br><span class="line">train_data = DataLoader(train_set, batch_size=<span class="number">128</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">autoencoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(autoencoder,self).__init__()</span><br><span class="line">        self.encoder = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>,<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">128</span>,<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>,<span class="number">12</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">12</span>,<span class="number">3</span>) <span class="comment"># 输出的 code 是 3 维，便于可视化</span></span><br><span class="line">        )</span><br><span class="line">        self.decoder = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">3</span>,<span class="number">12</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">12</span>,<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>,<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">128</span>,<span class="number">28</span>*<span class="number">28</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        encode = self.encoder(x)</span><br><span class="line">        decode = self.decoder(encode)</span><br><span class="line">        <span class="keyword">return</span> encode,decode</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这里定义的编码器和解码器都是 4 层神经网络作为模型，</span></span><br><span class="line"><span class="string">中间使用 relu 激活函数，最后输出的 code 是三维，</span></span><br><span class="line"><span class="string">注意解码器最后我们使用tanh作为激活函数，</span></span><br><span class="line"><span class="string">因为输入图片标准化在 -1 ~ 1 之间，</span></span><br><span class="line"><span class="string">所以输出也要在 -1 ~ 1 这个范围内</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">net = autoencoder()</span><br><span class="line">criterion = nn.MSELoss(size_average=<span class="literal">False</span>)</span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_img</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="comment"># 定义一个函数将最后的结果转换回图片</span></span><br><span class="line">    x = <span class="number">0.5</span> * (x + <span class="number">1.</span>)</span><br><span class="line">    x = x.clamp(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    x = x.view(x.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练自动编码器</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> im, _ <span class="keyword">in</span> train_data:</span><br><span class="line">        im = im.view(im.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        im = Variable(im)</span><br><span class="line">        <span class="comment"># 前向传播</span></span><br><span class="line">        _, output = net(im)</span><br><span class="line">        loss = criterion(output, im) / im.shape[<span class="number">0</span>] <span class="comment"># 平均</span></span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e+<span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>: <span class="comment"># 每 20 次，将生成的图片保存一下</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch: &#123;&#125;, Loss: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(e + <span class="number">1</span>, loss.data))</span><br><span class="line">        pic = to_img(output.cpu().data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./simple_autoencoder&#x27;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;./simple_autoencoder&#x27;</span>)</span><br><span class="line">        save_image(pic, <span class="string">&#x27;./simple_autoencoder/image_&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(e + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>训练完成之后看看效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">view_data = Variable((train_set.train_data[:<span class="number">200</span>].<span class="built_in">type</span>(torch.FloatTensor).view(-<span class="number">1</span>, <span class="number">28</span>*<span class="number">28</span>) / <span class="number">255.</span> - <span class="number">0.5</span>) / <span class="number">0.5</span>)</span><br><span class="line">encode, _ = net(view_data)    <span class="comment"># 提取压缩的特征值</span></span><br><span class="line">fig = plt.figure(<span class="number">2</span>)</span><br><span class="line">ax = Axes3D(fig)    <span class="comment"># 3D 图</span></span><br><span class="line"><span class="comment"># x, y, z 的数据值</span></span><br><span class="line">X = encode.data[:, <span class="number">0</span>].numpy()</span><br><span class="line">Y = encode.data[:, <span class="number">1</span>].numpy()</span><br><span class="line">Z = encode.data[:, <span class="number">2</span>].numpy()</span><br><span class="line">values = train_set.train_labels[:<span class="number">200</span>].numpy()  <span class="comment"># 标签值</span></span><br><span class="line"><span class="keyword">for</span> x, y, z, s <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y, Z, values):</span><br><span class="line">    c = cm.rainbow(<span class="built_in">int</span>(<span class="number">255</span>*s/<span class="number">9</span>))    <span class="comment"># 上色</span></span><br><span class="line">    ax.text(x, y, z, s, backgroundcolor=c)  <span class="comment"># 标位子</span></span><br><span class="line">ax.set_xlim(X.<span class="built_in">min</span>(), X.<span class="built_in">max</span>())</span><br><span class="line">ax.set_ylim(Y.<span class="built_in">min</span>(), Y.<span class="built_in">max</span>())</span><br><span class="line">ax.set_zlim(Z.<span class="built_in">min</span>(), Z.<span class="built_in">max</span>())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/untitled.png"><br>可以看到，不同种类的图片进入自动编码器之后会被编码得不同，而相同类型的图片经过自动编码之后的编码在几何示意图上距离较近，在训练好自动编码器之后，我们可以给一个随机的 code，通过 decoder 生成图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code = Variable(torch.FloatTensor([[-<span class="number">20.19</span>, <span class="number">10.36</span>, -<span class="number">0.06</span>]])) <span class="comment"># 给一个 code</span></span><br><span class="line">decode = net.decoder(code)</span><br><span class="line">decode_img = to_img(decode).squeeze()</span><br><span class="line">decode_img = decode_img.data.numpy() * <span class="number">255</span></span><br><span class="line">plt.imshow(decode_img.astype(<span class="string">&#x27;uint8&#x27;</span>), cmap=<span class="string">&#x27;gray&#x27;</span>) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201104180838.png"><br>这里我们仅仅使用多层神经网络定义了一个自动编码器，当然你会想到，为什么不使用效果更好的卷积神经网络呢？我们当然可以使用卷积神经网络来定义，下面我们就重新定义一个卷积神经网络来进行 autoencoder</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">conv_autoencoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(conv_autoencoder, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.encoder = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, <span class="number">3</span>, stride=<span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># (b, 16, 10, 10)</span></span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>),  <span class="comment"># (b, 16, 5, 5)</span></span><br><span class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">8</span>, <span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>),  <span class="comment"># (b, 8, 3, 3)</span></span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">1</span>)  <span class="comment"># (b, 8, 2, 2)</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.decoder = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">8</span>, <span class="number">16</span>, <span class="number">3</span>, stride=<span class="number">2</span>),  <span class="comment"># (b, 16, 5, 5)</span></span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">16</span>, <span class="number">8</span>, <span class="number">5</span>, stride=<span class="number">3</span>, padding=<span class="number">1</span>),  <span class="comment"># (b, 8, 15, 15)</span></span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>),  <span class="comment"># (b, 1, 28, 28)</span></span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        encode = self.encoder(x)</span><br><span class="line">        decode = self.decoder(encode)</span><br><span class="line">        <span class="keyword">return</span> encode, decode</span><br><span class="line"></span><br><span class="line">conv_net = conv_autoencoder()</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    conv_net = conv_net.cuda()</span><br><span class="line">optimizer = torch.optim.Adam(conv_net.parameters(), lr=<span class="number">1e-3</span>, weight_decay=<span class="number">1e-5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练自动编码器</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">    <span class="keyword">for</span> im, _ <span class="keyword">in</span> train_data:</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            im = im.cuda()</span><br><span class="line">            <span class="built_in">print</span>(torch.device(<span class="string">&quot;cuda&quot;</span>))</span><br><span class="line">        im = Variable(im)</span><br><span class="line">        <span class="comment"># 前向传播</span></span><br><span class="line">        _, output = conv_net(im)</span><br><span class="line">        loss = criterion(output, im) / im.shape[<span class="number">0</span>] <span class="comment"># 平均</span></span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e+<span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>: <span class="comment"># 每 20 次，将生成的图片保存一下</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch: &#123;&#125;, Loss: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(e+<span class="number">1</span>, loss.data))</span><br><span class="line">        pic = to_img(output.cpu().data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./conv_autoencoder&#x27;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;./conv_autoencoder&#x27;</span>)</span><br><span class="line">        save_image(pic, <span class="string">&#x27;./conv_autoencoder/image_&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(e+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>为了时间更短，只跑 40 次，如果有条件可以再 gpu 上跑跑.这里我们展示了简单的自动编码器，也用了多层神经网络和卷积神经网络作为例子，但是自动编码器存在一个问题，我们并不能任意生成我们想要的数据，因为我们并不知道 encode 之后的编码到底是什么样的概率分布，所以有一个改进的版本变分自动编码器，其能够解决这个问题</p><h4 id="6-1-2-变分自动编码器"><a href="#6-1-2-变分自动编码器" class="headerlink" title="6.1.2 变分自动编码器"></a>6.1.2 变分自动编码器</h4><p>变分自动编码器（Variational Auto Encoder, VAE）是自动编码器的升级版本，它的结构和自动编码器相似，也是由编码器和解码器构成的。</p><p>自动编码器不能任意生成数据，因为没办法自己去构造隐藏向量，需要通过数据输入编码才知道得到的隐含向量是什么，这个时候变分自动编码器就可以解决这个问题</p><p>它的原理是，在编码过程给他增加一些限制，迫使他生成的隐含向量能够粗略地遵循一个标准正态分布。</p><p>这样我们生成一张新图片就很简单了，我们只需要给它一个标准正态分布的随机隐含向量，这样通过解码器就能够生成我们想要的图片，而不需要给它一张原始图片先编码。</p><p>一般来讲，我们通过 encoder 得到的隐含向量并不是一个标准的正态分布，为了衡量两种分布的相似程度，我们使用 KL divergence，利用其来表示隐含向量与标准正态分布之间差异的 loss，另外一个 loss 仍然使用生成图片与原图片的均方误差来表示。</p><p>KL divergence 的公式如下<br>$$<br>D_{KL} (P || Q) =  \sum_{i} p(i) \log \frac{P(i)}{Q(i)}<br>$$</p><p>$$<br>D_{KL} (P || Q) =  \int_{-\infty}^{\infty} p(x) \log \frac{p(x)}{q(x)} dx<br>$$</p><p><strong>重参数</strong></p><p>为了避免计算 KL divergence 中的积分，我们使用重参数的技巧，不是每次产生一个隐含向量，而是生成两个向量，一个表示均值，一个表示标准差，这里我们默认编码之后的隐含向量服从一个正态分布的之后，就可以用一个标准正态分布先乘上标准差再加上均值来合成这个正态分布，最后 loss 就是希望这个生成的正态分布能够符合一个标准正态分布，也就是希望均值为 0，方差为 1</p><p><a href="https://arxiv.org/pdf/1606.05908.pdf">详细内容见https://arxiv.org/pdf/1606.05908.pdf</a></p><p>所以最后我们可以将我们的 loss 定义为下面的函数，由均方误差和 KL divergence 求和得到一个总的 loss</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">reconstruction_funtion = nn.BCELoss(size_average=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span>(<span class="params">recon_x, x, mu, logvar</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    recon_x: generating images</span></span><br><span class="line"><span class="string">    x: origin images</span></span><br><span class="line"><span class="string">    mu: latent mean</span></span><br><span class="line"><span class="string">    logvar: latent log variance</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    MSE = reconstruction_function(recon_x, x)</span><br><span class="line">    <span class="comment"># loss = 0.5 * sum(1 + log(sigma^2) - mu^2 - sigma^2)</span></span><br><span class="line">    KLD_element = mu.<span class="built_in">pow</span>(<span class="number">2</span>).add_(logvar.exp()).mul_(-<span class="number">1</span>).add_(<span class="number">1</span>).add_(logvar)</span><br><span class="line">    KLD = torch.<span class="built_in">sum</span>(KLD_element).mul_(-<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># KL divergence</span></span><br><span class="line">    <span class="keyword">return</span> MSE + KLD</span><br></pre></td></tr></table></figure><p>下面我们用 mnist 数据集来简单说明一下变分自动编码器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"></span><br><span class="line">im_tfs = tfs.Compose([</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    tfs.Normalize([<span class="number">0.5</span>], [<span class="number">0.5</span>]) <span class="comment"># 标准化</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = MNIST(<span class="string">&#x27;./data&#x27;</span>, transform=im_tfs)</span><br><span class="line">train_data = DataLoader(train_set, batch_size=<span class="number">128</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VAE</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(VAE, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">784</span>, <span class="number">400</span>)</span><br><span class="line">        self.fc21 = nn.Linear(<span class="number">400</span>, <span class="number">20</span>) <span class="comment"># mean</span></span><br><span class="line">        self.fc22 = nn.Linear(<span class="number">400</span>, <span class="number">20</span>) <span class="comment"># var</span></span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">20</span>, <span class="number">400</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">400</span>, <span class="number">784</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        h1 = F.relu(self.fc1(x))</span><br><span class="line">        <span class="keyword">return</span> self.fc21(h1), self.fc22(h1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reparametrize</span>(<span class="params">self, mu, logvar</span>):</span></span><br><span class="line">        std = logvar.mul(<span class="number">0.5</span>).exp_()</span><br><span class="line">        eps = torch.FloatTensor(std.size()).normal_()</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            eps = Variable(eps.cuda())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            eps = Variable(eps)</span><br><span class="line">        <span class="keyword">return</span> eps.mul(std).add_(mu)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">self, z</span>):</span></span><br><span class="line">        h3 = F.relu(self.fc3(z))</span><br><span class="line">        <span class="keyword">return</span> F.tanh(self.fc4(h3))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        mu, logvar = self.encode(x) <span class="comment"># 编码</span></span><br><span class="line">        z = self.reparametrize(mu, logvar) <span class="comment"># 重新参数化成正态分布</span></span><br><span class="line">        <span class="keyword">return</span> self.decode(z), mu, logvar <span class="comment"># 解码，同时输出均值方差</span></span><br><span class="line"></span><br><span class="line">net = VAE() <span class="comment"># 实例化网络</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    net = net.cuda()</span><br><span class="line"></span><br><span class="line">reconstruction_function = nn.MSELoss(size_average=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span>(<span class="params">recon_x, x, mu, logvar</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    recon_x: generating images</span></span><br><span class="line"><span class="string">    x: origin images</span></span><br><span class="line"><span class="string">    mu: latent mean</span></span><br><span class="line"><span class="string">    logvar: latent log variance</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    MSE = reconstruction_function(recon_x, x)</span><br><span class="line">    <span class="comment"># loss = 0.5 * sum(1 + log(sigma^2) - mu^2 - sigma^2)</span></span><br><span class="line">    KLD_element = mu.<span class="built_in">pow</span>(<span class="number">2</span>).add_(logvar.exp()).mul_(-<span class="number">1</span>).add_(<span class="number">1</span>).add_(logvar)</span><br><span class="line">    KLD = torch.<span class="built_in">sum</span>(KLD_element).mul_(-<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># KL divergence</span></span><br><span class="line">    <span class="keyword">return</span> MSE + KLD</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_img</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="comment">#定义一个函数将最后的结果转换回图片</span></span><br><span class="line">    x = <span class="number">0.5</span> * (x + <span class="number">1.</span>)</span><br><span class="line">    x = x.clamp(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    x = x.view(x.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> im, _ <span class="keyword">in</span> train_data:</span><br><span class="line">        im = im.view(im.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        im = Variable(im)</span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            im = im.cuda()</span><br><span class="line">            <span class="built_in">print</span>(torch.device(<span class="string">&quot;cuda&quot;</span>))</span><br><span class="line">        recon_im, mu, logvar = net(im)</span><br><span class="line">        loss = loss_function(recon_im, im, mu, logvar) / im.shape[<span class="number">0</span>] <span class="comment"># 将 loss 平均</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e + <span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch: &#123;&#125;, Loss: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(e + <span class="number">1</span>, loss.data[<span class="number">0</span>]))</span><br><span class="line">        save = to_img(recon_im.cpu().data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;./vae_img&#x27;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;./vae_img&#x27;</span>)</span><br><span class="line">        save_image(save, <span class="string">&#x27;./vae_img/image_&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(e + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>可以看看使用变分自动编码器得到的结果，可以发现效果比一般的编码器要好很多</p><h3 id="6-2-生成对抗网络"><a href="#6-2-生成对抗网络" class="headerlink" title="6.2 生成对抗网络"></a>6.2 生成对抗网络</h3><p>前面我们讲了自动编码器和变分自动编码器，不管是哪一个，都是通过计算生成图像和输入图像在每个像素点的误差来生成 loss，这一点是特别不好的，因为不同的像素点可能造成不同的视觉结果，但是可能他们的 loss 是相同的，所以通过单个像素点来得到 loss 是不准确的，这个时候我们需要一种全新的 loss 定义方式，就是通过对抗进行学习。</p><h4 id="6-2-1-什么是生成对抗网络"><a href="#6-2-1-什么是生成对抗网络" class="headerlink" title="6.2.1 什么是生成对抗网络"></a>6.2.1 什么是生成对抗网络</h4><p>这种训练方式定义了一种全新的网络结构，就是生成对抗网络，也就是 GANs。</p><p>根据这个名字就可以知道这个网络是由两部分组成的，第一部分是生成，第二部分是对抗。简单来说，就是有一个生成网络和一个判别网络，通过训练让两个网络相互竞争，生成网络来生成假的数据，对抗网络通过判别器去判别真伪，最后希望生成器生成的数据能够以假乱真。</p><p><strong>对抗：Discriminator Network</strong></p><p>首先我们来讲一下对抗过程，因为这个过程更加简单。</p><p>对抗过程简单来说就是一个判断真假的判别器，相当于一个二分类问题，我们输入一张真的图片希望判别器输出的结果是1，输入一张假的图片希望判别器输出的结果是0。这其实已经和原图片的 label 没有关系了，不管原图片到底是一个多少类别的图片，他们都统一称为真的图片，label 是 1 表示真实的；而生成的假的图片的 label 是 0 表示假的。</p><p>我们训练的过程就是希望这个判别器能够正确的判出真的图片和假的图片，这其实就是一个简单的二分类问题，对于这个问题可以用我们前面讲过的很多方法去处理，比如 logistic 回归，深层网络，卷积神经网络，循环神经网络都可以。</p><p><strong>生成：Generator Network</strong></p><p>接着我们看看生成网络如何生成一张假的图片。首先给出一个简单的高维的正态分布的噪声向量，这个时候我们可以通过仿射变换，也就是 xw+b 将其映射到一个更高的维度，然后将他重新排列成一个矩形，这样看着更像一张图片，接着进行一些卷积、转置卷积、池化、激活函数等进行处理，最后得到了一个与我们输入图片大小一模一样的噪音矩阵，这就是我们所说的假的图片。</p><p>这个时候我们如何去训练这个生成器呢？这就需要通过对抗学习，增大判别器判别这个结果为真的概率，通过这个步骤不断调整生成器的参数，希望生成的图片越来越像真的，而在这一步中我们不会更新判别器的参数，因为如果判别器不断被优化，可能生成器无论生成什么样的图片都无法骗过判别器。</p><p>关于生成对抗网络，出现了很多变形，比如 WGAN，LS-GAN 等等，这里我们只使用 mnist 举一些简单的例子来说明，更复杂的网络结构可以在 github 上找到相应的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, sampler</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>) <span class="comment"># 设置画图的尺寸</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;image.interpolation&#x27;</span>] = <span class="string">&#x27;nearest&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;image.cmap&#x27;</span>] = <span class="string">&#x27;gray&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_images</span>(<span class="params">images</span>):</span> <span class="comment"># 定义画图工具</span></span><br><span class="line">    images = np.reshape(images, [images.shape[<span class="number">0</span>], -<span class="number">1</span>])</span><br><span class="line">    sqrtn = <span class="built_in">int</span>(np.ceil(np.sqrt(images.shape[<span class="number">0</span>])))</span><br><span class="line">    sqrtimg = <span class="built_in">int</span>(np.ceil(np.sqrt(images.shape[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(figsize=(sqrtn, sqrtn))</span><br><span class="line">    gs = gridspec.GridSpec(sqrtn, sqrtn)</span><br><span class="line">    gs.update(wspace=<span class="number">0.05</span>, hspace=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">        ax = plt.subplot(gs[i])</span><br><span class="line">        plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        ax.set_xticklabels([])</span><br><span class="line">        ax.set_yticklabels([])</span><br><span class="line">        ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">        plt.imshow(img.reshape([sqrtimg,sqrtimg]))</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_img</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = tfs.ToTensor()(x)</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">0.5</span>) / <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deprocess_img</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">1.0</span>) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChunkSampler</span>(<span class="params">sampler.Sampler</span>):</span> <span class="comment"># 定义一个取样的函数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Samples elements sequentially from some offset. </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        num_samples: # of desired datapoints</span></span><br><span class="line"><span class="string">        start: offset where we should start selecting from</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_samples, start=<span class="number">0</span></span>):</span></span><br><span class="line">        self.num_samples = num_samples</span><br><span class="line">        self.start = start</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="built_in">range</span>(self.start, self.start + self.num_samples))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.num_samples</span><br><span class="line"></span><br><span class="line">NUM_TRAIN = <span class="number">50000</span></span><br><span class="line">NUM_VAL = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">NOISE_DIM = <span class="number">96</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">train_set = MNIST(<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=preprocess_img)</span><br><span class="line"></span><br><span class="line">train_data = DataLoader(train_set, batch_size=batch_size, sampler=ChunkSampler(NUM_TRAIN, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">val_set = MNIST(<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=preprocess_img)</span><br><span class="line"></span><br><span class="line">val_data = DataLoader(val_set, batch_size=batch_size, sampler=ChunkSampler(NUM_VAL, NUM_TRAIN))</span><br><span class="line"></span><br><span class="line">imgs = deprocess_img(train_data.__iter__().<span class="built_in">next</span>()[<span class="number">0</span>].view(batch_size, <span class="number">784</span>)).numpy().squeeze() <span class="comment"># 可视化图片效果</span></span><br><span class="line">show_images(imgs)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201105142821.png"></p><p><strong>简单版本的生成对抗网络</strong></p><p>通过前面我们知道生成对抗网络有两个部分构成，一个是生成网络，一个是对抗网络，我们首先写一个简单版本的网络结构，生成网络和对抗网络都是简单的多层神经网络</p><p><strong>判别网络</strong></p><p>判别网络的结构非常简单，就是一个二分类器，结构如下:</p><ul><li>全连接(784 -&gt; 256)</li><li>leakyrelu,  $\alpha$ 是 0.2</li><li>全连接(256 -&gt; 256)</li><li>leakyrelu, $\alpha$ 是 0.2</li><li>全连接(256 -&gt; 1)</li></ul><p>其中 leakyrelu 是指 f(x) = max($\alpha$ x, x)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator</span>():</span></span><br><span class="line">    net = nn.Sequential(        </span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>, <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p><strong>生成网络</strong></p><p>接下来我们看看生成网络，生成网络的结构也很简单，就是根据一个随机噪声生成一个和数据维度一样的张量，结构如下：</p><ul><li>全连接(噪音维度 -&gt; 1024)</li><li>relu</li><li>全连接(1024 -&gt; 1024)</li><li>relu</li><li>全连接(1024 -&gt; 784)</li><li>tanh 将数据裁剪到 -1 ~ 1 之间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>(<span class="params">noise_dim=NOISE_DIM</span>):</span>   </span><br><span class="line">    net = nn.Sequential(</span><br><span class="line">        nn.Linear(noise_dim, <span class="number">1024</span>),</span><br><span class="line">        nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">        nn.Linear(<span class="number">1024</span>, <span class="number">1024</span>),</span><br><span class="line">        nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">        nn.Linear(<span class="number">1024</span>, <span class="number">784</span>),</span><br><span class="line">        nn.Tanh()</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p>接下来我们需要定义生成对抗网络的 loss，通过前面的讲解我们知道，对于对抗网络，相当于二分类问题，将真的判别为真的，假的判别为假的，作为辅助，可以参考一下论文中公式</p><p>$$ \ell_D = \mathbb{E}_{x \sim p_\text{data}}\left[\log D(x)\right] + \mathbb{E} _ {z \sim p(z)}\left[\log \left(1-D(G(z))\right)\right]$$</p><p>而对于生成网络，需要去骗过对抗网络，也就是将假的也判断为真的，作为辅助，可以参考一下论文中公式</p><p>$$\ell_G  =  \mathbb{E} _ {z \sim p(z)}\left[\log D(G(z))\right]$$</p><p>如果你还记得前面的二分类 loss，那么你就会发现上面这两个公式就是二分类 loss</p><p>$$ bce(s, y) = y * \log(s) + (1 - y) * \log(1 - s) $$</p><p>如果我们把 D(x) 看成真实数据的分类得分，那么 D(G(z)) 就是假数据的分类得分，所以上面判别器的 loss 就是将真实数据的得分判断为 1，假的数据的得分判断为 0，而生成器的 loss 就是将假的数据判断为 1</p><p>下面我们来实现一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, sampler</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">NUM_TRAIN = <span class="number">50000</span></span><br><span class="line">NUM_VAL = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">NOISE_DIM = <span class="number">96</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator</span>():</span></span><br><span class="line">    net = nn.Sequential(        </span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>, <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span>(<span class="params">noise_dim=NOISE_DIM</span>):</span>   </span><br><span class="line">    net = nn.Sequential(</span><br><span class="line">        nn.Linear(noise_dim, <span class="number">1024</span>),</span><br><span class="line">        nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">        nn.Linear(<span class="number">1024</span>, <span class="number">1024</span>),</span><br><span class="line">        nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">        nn.Linear(<span class="number">1024</span>, <span class="number">784</span>),</span><br><span class="line">        nn.Tanh()</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line">bce_loss = nn.BCEWithLogitsLoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator_loss</span>(<span class="params">logits_real, logits_fake</span>):</span> <span class="comment"># 判别器的 loss</span></span><br><span class="line">    size = logits_real.shape[<span class="number">0</span>]</span><br><span class="line">    true_labels = Variable(torch.ones(size, <span class="number">1</span>)).<span class="built_in">float</span>().cuda()</span><br><span class="line">    false_labels = Variable(torch.zeros(size, <span class="number">1</span>)).<span class="built_in">float</span>().cuda()</span><br><span class="line">    loss = bce_loss(logits_real, true_labels) + bce_loss(logits_fake, false_labels)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_loss</span>(<span class="params">logits_fake</span>):</span> <span class="comment"># 生成器的 loss  </span></span><br><span class="line">    size = logits_fake.shape[<span class="number">0</span>]</span><br><span class="line">    true_labels = Variable(torch.ones(size, <span class="number">1</span>)).<span class="built_in">float</span>().cuda()</span><br><span class="line">    loss = bce_loss(logits_fake, true_labels)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 adam 来进行训练，学习率是 3e-4, beta1 是 0.5, beta2 是 0.999</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_optimizer</span>(<span class="params">net</span>):</span></span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(), lr=<span class="number">3e-4</span>, betas=(<span class="number">0.5</span>, <span class="number">0.999</span>))</span><br><span class="line">    <span class="keyword">return</span> optimizer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_img</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = tfs.ToTensor()(x)</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">0.5</span>) / <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deprocess_img</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">1.0</span>) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChunkSampler</span>(<span class="params">sampler.Sampler</span>):</span> <span class="comment"># 定义一个取样的函数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Samples elements sequentially from some offset. </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        num_samples: # of desired datapoints</span></span><br><span class="line"><span class="string">        start: offset where we should start selecting from</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_samples, start=<span class="number">0</span></span>):</span></span><br><span class="line">        self.num_samples = num_samples</span><br><span class="line">        self.start = start</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="built_in">range</span>(self.start, self.start + self.num_samples))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.num_samples</span><br><span class="line"></span><br><span class="line">train_set = MNIST(<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=preprocess_img)</span><br><span class="line"></span><br><span class="line">train_data = DataLoader(train_set, batch_size=batch_size, sampler=ChunkSampler(NUM_TRAIN, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">val_set = MNIST(<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, transform=preprocess_img)</span><br><span class="line"></span><br><span class="line">val_data = DataLoader(val_set, batch_size=batch_size, sampler=ChunkSampler(NUM_VAL, NUM_TRAIN))</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面我们开始训练一个这个简单的生成对抗网络</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_a_gan</span>(<span class="params">D_net, G_net, D_optimizer, G_optimizer, discriminator_loss, generator_loss, show_every=<span class="number">250</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                noise_size=<span class="number">96</span>, num_epochs=<span class="number">10</span></span>):</span></span><br><span class="line">    iter_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> x, _ <span class="keyword">in</span> train_data:</span><br><span class="line">            bs = x.shape[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 判别网络</span></span><br><span class="line">            real_data = Variable(x).view(bs, -<span class="number">1</span>).cuda() <span class="comment"># 真实数据</span></span><br><span class="line">            logits_real = D_net(real_data) <span class="comment"># 判别网络得分</span></span><br><span class="line">            </span><br><span class="line">            sample_noise = (torch.rand(bs, noise_size) - <span class="number">0.5</span>) / <span class="number">0.5</span> <span class="comment"># -1 ~ 1 的均匀分布</span></span><br><span class="line">            g_fake_seed = Variable(sample_noise).cuda()</span><br><span class="line">            fake_images = G_net(g_fake_seed) <span class="comment"># 生成的假的数据</span></span><br><span class="line">            logits_fake = D_net(fake_images) <span class="comment"># 判别网络得分</span></span><br><span class="line"></span><br><span class="line">            d_total_error = discriminator_loss(logits_real, logits_fake) <span class="comment"># 判别器的 loss</span></span><br><span class="line">            D_optimizer.zero_grad()</span><br><span class="line">            d_total_error.backward()</span><br><span class="line">            D_optimizer.step() <span class="comment"># 优化判别网络</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 生成网络</span></span><br><span class="line">            g_fake_seed = Variable(sample_noise).cuda()</span><br><span class="line">            fake_images = G_net(g_fake_seed) <span class="comment"># 生成的假的数据</span></span><br><span class="line"></span><br><span class="line">            gen_logits_fake = D_net(fake_images)</span><br><span class="line">            g_error = generator_loss(gen_logits_fake) <span class="comment"># 生成网络的 loss</span></span><br><span class="line">            G_optimizer.zero_grad()</span><br><span class="line">            g_error.backward()</span><br><span class="line">            G_optimizer.step() <span class="comment"># 优化生成网络</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (iter_count % show_every == <span class="number">0</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Iter: &#123;&#125;, D: &#123;:.4&#125;, G:&#123;:.4&#125;&#x27;</span>.<span class="built_in">format</span>(iter_count, d_total_error.data, g_error.data))</span><br><span class="line">                imgs_numpy = deprocess_img(fake_images.data.cpu().numpy())</span><br><span class="line">                show_images(imgs_numpy[<span class="number">0</span>:<span class="number">16</span>])</span><br><span class="line">                plt.show()</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">            iter_count += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D = discriminator().cuda()</span><br><span class="line">G = generator().cuda()</span><br><span class="line"></span><br><span class="line">D_optim = get_optimizer(D)</span><br><span class="line">G_optim = get_optimizer(G)</span><br><span class="line"></span><br><span class="line">train_a_gan(D, G, D_optim, G_optim, discriminator_loss, generator_loss)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201105174301-min.gif"></p><p>我们已经完成了一个简单的生成对抗网络，是不是非常容易呢。但是可以看到效果并不是特别好，生成的数字也不是特别完整，因为我们仅仅使用了简单的多层全连接网络。</p><p>除了这种最基本的生成对抗网络之外，还有很多生成对抗网络的变式，有结构上的变式，也有 loss 上的变式，我们先讲一讲其中一种在 loss 上的变式，Least Squares GAN</p><p><strong>Least Squares GAN</strong></p><p><a href="https://arxiv.org/abs/1611.04076">Least Squares GAN</a> 比最原始的 GANs 的 loss 更加稳定，通过名字我们也能够看出这种 GAN 是通过最小平方误差来进行估计，而不是通过二分类的损失函数，下面我们看看 loss 的计算公式</p><p>$$\ell_G  =  \frac{1}{2}\mathbb{E} _ {z \sim p(z)}\left[\left(D(G(z))-1\right)^2\right]$$</p><p>$$ \ell_D = \frac{1}{2}\mathbb{E}_{x \sim p_\text{data}}\left[\left(D(x)-1\right)^2\right] + \frac{1}{2}\mathbb{E} _ {z \sim p(z)}\left[ \left(D(G(z))\right)^2\right]$$</p><p>可以看到 Least Squares GAN 通过最小二乘代替了二分类的 loss，下面我们定义一下 loss 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ls_discriminator_loss</span>(<span class="params">scores_real, scores_fake</span>):</span></span><br><span class="line">    loss = <span class="number">0.5</span> * ((scores_real - <span class="number">1</span>) ** <span class="number">2</span>).mean() + <span class="number">0.5</span> * (scores_fake ** <span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ls_generator_loss</span>(<span class="params">scores_fake</span>):</span></span><br><span class="line">    loss = <span class="number">0.5</span> * ((scores_fake - <span class="number">1</span>) ** <span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D = discriminator().cuda()</span><br><span class="line">G = generator().cuda()</span><br><span class="line"></span><br><span class="line">D_optim = get_optimizer(D)</span><br><span class="line">G_optim = get_optimizer(G)</span><br><span class="line"></span><br><span class="line">train_a_gan(D, G, D_optim, G_optim, ls_discriminator_loss, ls_generator_loss)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201105174302-min.gif"></p><p>上面我们讲了 最基本的 GAN 和 least squares GAN，最后我们讲一讲使用卷积网络的 GAN，叫做深度卷积生成对抗网络</p><p><strong>Deep Convolutional GANs</strong></p><p>深度卷积生成对抗网络特别简单，就是将生成网络和对抗网络都改成了卷积网络的形式，下面我们来实现一下</p><p>卷积判别网络就是一个一般的卷积网络，结构如下</p><ul><li>32 Filters, 5x5, Stride 1, Leaky ReLU(alpha=0.01)</li><li>Max Pool 2x2, Stride 2</li><li>64 Filters, 5x5, Stride 1, Leaky ReLU(alpha=0.01)</li><li>Max Pool 2x2, Stride 2</li><li>Fully Connected size 4 x 4 x 64, Leaky ReLU(alpha=0.01)</li><li>Fully Connected size 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">build_dc_classifier</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(build_dc_classifier, self).__init__()</span><br><span class="line">        self.conv = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.01</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, <span class="number">1</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.01</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.01</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        x = x.view(x.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>卷积生成网络需要将一个低维的噪声向量变成一个图片数据，结构如下</p><ul><li>Fully connected of size 1024, ReLU</li><li>BatchNorm</li><li>Fully connected of size 7 x 7 x 128, ReLU</li><li>BatchNorm</li><li>Reshape into Image Tensor</li><li>64 conv2d^T filters of 4x4, stride 2, padding 1, ReLU</li><li>BatchNorm</li><li>1 conv2d^T filter of 4x4, stride 2, padding 1, TanH</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">build_dc_generator</span>(<span class="params">nn.Module</span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, noise_dim=NOISE_DIM</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(build_dc_generator, self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(noise_dim, <span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.BatchNorm1d(<span class="number">1024</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">7</span> * <span class="number">7</span> * <span class="number">128</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.BatchNorm1d(<span class="number">7</span> * <span class="number">7</span> * <span class="number">128</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        self.conv = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">128</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">2</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">64</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.view(x.shape[<span class="number">0</span>], <span class="number">128</span>, <span class="number">7</span>, <span class="number">7</span>) <span class="comment"># reshape 通道是 128，大小是 7x7</span></span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_dc_gan</span>(<span class="params">D_net, G_net, D_optimizer, G_optimizer, discriminator_loss, generator_loss, show_every=<span class="number">250</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                noise_size=<span class="number">96</span>, num_epochs=<span class="number">10</span></span>):</span></span><br><span class="line">    iter_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> x, _ <span class="keyword">in</span> train_data:</span><br><span class="line">            bs = x.shape[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 判别网络</span></span><br><span class="line">            real_data = Variable(x).cuda() <span class="comment"># 真实数据</span></span><br><span class="line">            logits_real = D_net(real_data) <span class="comment"># 判别网络得分</span></span><br><span class="line">            </span><br><span class="line">            sample_noise = (torch.rand(bs, noise_size) - <span class="number">0.5</span>) / <span class="number">0.5</span> <span class="comment"># -1 ~ 1 的均匀分布</span></span><br><span class="line">            g_fake_seed = Variable(sample_noise).cuda()</span><br><span class="line">            fake_images = G_net(g_fake_seed) <span class="comment"># 生成的假的数据</span></span><br><span class="line">            logits_fake = D_net(fake_images) <span class="comment"># 判别网络得分</span></span><br><span class="line"></span><br><span class="line">            d_total_error = discriminator_loss(logits_real, logits_fake) <span class="comment"># 判别器的 loss</span></span><br><span class="line">            D_optimizer.zero_grad()</span><br><span class="line">            d_total_error.backward()</span><br><span class="line">            D_optimizer.step() <span class="comment"># 优化判别网络</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 生成网络</span></span><br><span class="line">            g_fake_seed = Variable(sample_noise).cuda()</span><br><span class="line">            fake_images = G_net(g_fake_seed) <span class="comment"># 生成的假的数据</span></span><br><span class="line"></span><br><span class="line">            gen_logits_fake = D_net(fake_images)</span><br><span class="line">            g_error = generator_loss(gen_logits_fake) <span class="comment"># 生成网络的 loss</span></span><br><span class="line">            G_optimizer.zero_grad()</span><br><span class="line">            g_error.backward()</span><br><span class="line">            G_optimizer.step() <span class="comment"># 优化生成网络</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (iter_count % show_every == <span class="number">0</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Iter: &#123;&#125;, D: &#123;:.4&#125;, G:&#123;:.4&#125;&#x27;</span>.<span class="built_in">format</span>(iter_count, d_total_error.data, g_error.data))</span><br><span class="line">                imgs_numpy = deprocess_img(fake_images.data.cpu().numpy())</span><br><span class="line">                show_images(imgs_numpy[<span class="number">0</span>:<span class="number">16</span>])</span><br><span class="line">                plt.show()</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">            iter_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">D_DC = build_dc_classifier().cuda()</span><br><span class="line">G_DC = build_dc_generator().cuda()</span><br><span class="line"></span><br><span class="line">D_DC_optim = get_optimizer(D_DC)</span><br><span class="line">G_DC_optim = get_optimizer(G_DC)</span><br><span class="line"></span><br><span class="line">train_dc_gan(D_DC, G_DC, D_DC_optim, G_DC_optim, discriminator_loss, generator_loss, num_epochs=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201105174303-min.gif"><br>可以看到，通过 DCGANs 能够得到更加清楚的结果</p><h3 id="6-3-Improving-GAN"><a href="#6-3-Improving-GAN" class="headerlink" title="6.3 Improving GAN"></a>6.3 Improving GAN</h3><h4 id="6-3-1-Wasserstein-GAN"><a href="#6-3-1-Wasserstein-GAN" class="headerlink" title="6.3.1 Wasserstein GAN"></a>6.3.1 Wasserstein GAN</h4><p>Wasserstein GAN是GAN的一种变式，WGAN的出现解决了下面这些难点</p><ul><li>彻底解决了训练不稳定的问题</li><li>基本解决了coolapse mode 的问题，确保了生成样本的多样性</li><li>训练中有一个向交叉熵，准确率的数值指标来衡量训练的进程，数值越小代表GAN训练得越好，同时也代表着生成的图片质量越高</li><li>不需要精心设计网络结构也能取得较好的效果</li></ul><h3 id="6-4-应用介绍"><a href="#6-4-应用介绍" class="headerlink" title="6.4 应用介绍"></a>6.4 应用介绍</h3><h4 id="6-4-1-Conditional-GAN"><a href="#6-4-1-Conditional-GAN" class="headerlink" title="6.4.1 Conditional GAN"></a>6.4.1 Conditional GAN</h4><p>Conditional GAN的一个应用是文字生成图片</p><h4 id="6-4-2-Cycle-GAN"><a href="#6-4-2-Cycle-GAN" class="headerlink" title="6.4.2 Cycle GAN"></a>6.4.2 Cycle GAN</h4><p>根据一个人的作品，想象他完成其他场景会是什么样</p><h2 id="第七章-深度学习实战"><a href="#第七章-深度学习实战" class="headerlink" title="第七章 深度学习实战"></a>第七章 深度学习实战</h2><h3 id="7-1-实例一，猫狗大战：运用预训练卷积神经网络进行特征提取与预训"><a href="#7-1-实例一，猫狗大战：运用预训练卷积神经网络进行特征提取与预训" class="headerlink" title="7.1 实例一，猫狗大战：运用预训练卷积神经网络进行特征提取与预训"></a>7.1 实例一，猫狗大战：运用预训练卷积神经网络进行特征提取与预训</h3><h4 id="7-1-1-背景介绍"><a href="#7-1-1-背景介绍" class="headerlink" title="7.1.1 背景介绍"></a>7.1.1 背景介绍</h4><p>Asirra是一个图像识别机制的验证码，其有很多不同猫狗的照片（三百万张），可以用他的子集当作训练集</p><h4 id="7-1-2-原理分析"><a href="#7-1-2-原理分析" class="headerlink" title="7.1.2 原理分析"></a>7.1.2 原理分析</h4><p>对于这个问题，简单的网络模型可能效果并不好，这个时候，使用一些成熟的模型，比如VggNet，GoogleNet，ResNet等可以帮助我们解决问题，为了节省计算资源和时间，可以通过迁移学习实现。</p><p><strong>迁移学习</strong></p><p>对于一个特定任务，如果没有来自该任务足够的数据集，传统的监督学习无法支持，而迁移学习允许通过借用已经存在的一些相关任务的标签数据来处理这些场景，把解决相关任务时获得的知识存储下来，并将它应用到我们感兴趣的目标任务中。</p><p>卷积神经网络可以理解为两个部分：前面的<strong>卷积</strong>部分和后面的<strong>分类</strong>部分，卷积部分主要用于提取图片特征，而预训练的网络对于特征提取效果已经非常好。我们可以直接用预训练的网络卷积部分来提取我们自己的图片特征，而对于自己的任务，比如猫狗二分类，就用自己的分类全连接层即可。</p><p>当然，迁移学习并不是任何时候都能使用，需要它们<strong>完成的任务是相关的</strong>，所以迁移学习在相似数据集上的应用效果才是良好的。</p><p><strong>实现方法</strong></p><ol><li>第一种方法：导入预训练的卷积网络，将最后的全连接层改成我们自己设计的全连接层，然后更新整个网络，最后能特别快地达到收敛</li><li>第二种方法：锁定前面卷积层的参数，让网络训练只更新最后全连接层的参数，可以使训练时间大大减少</li><li>第三种方法：使用多个预训练好的网络，将它们并联在一起，图片经过每个网络都会得到特征图，我们将这些特征图拼接在一起进入最后的全连接层</li></ol><h4 id="7-1-3-代码实现"><a href="#7-1-3-代码实现" class="headerlink" title="7.1.3 代码实现"></a>7.1.3 代码实现</h4><p>1.数据预处理</p><p>数据集可以去 <a href="https://www.kaggle.com/c/dogs-vs-cats/data">https://www.kaggle.com/c/dogs-vs-cats/data</a> 下载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">train_root = <span class="string">&#x27;./data/dogs-vs-cats/train/&#x27;</span></span><br><span class="line">val_root = <span class="string">&#x27;./data/dogs-vs-cats/val/&#x27;</span></span><br><span class="line">data_file=os.listdir(train_root)</span><br><span class="line"><span class="comment">#print(data_file)</span></span><br><span class="line">dog_file = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]==<span class="string">&#x27;dog&#x27;</span><span class="keyword">and</span> x!=<span class="string">&quot;dog&quot;</span>,data_file))</span><br><span class="line">cat_file = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]==<span class="string">&#x27;cat&#x27;</span><span class="keyword">and</span> x!=<span class="string">&quot;cat&quot;</span>,data_file))</span><br><span class="line"></span><br><span class="line">root = <span class="string">&#x27;./data/dogs-vs-cats/&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_root+<span class="string">&#x27;dog/&#x27;</span>):</span><br><span class="line">    os.makedirs(train_root+<span class="string">&#x27;dog/&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_root+<span class="string">&#x27;cat/&#x27;</span>):</span><br><span class="line">    os.makedirs(train_root+<span class="string">&#x27;cat/&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(val_root+<span class="string">&#x27;dog/&#x27;</span>):</span><br><span class="line">    os.makedirs(val_root+<span class="string">&#x27;dog/&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(val_root+<span class="string">&#x27;cat/&#x27;</span>):</span><br><span class="line">    os.makedirs(val_root+<span class="string">&#x27;cat/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dog_file)):</span><br><span class="line">    pic_path = root+<span class="string">&#x27;train/&#x27;</span>+dog_file[i]</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(dog_file)*<span class="number">0.9</span>:</span><br><span class="line">        obj_path = train_root+<span class="string">&#x27;dog/&#x27;</span>+dog_file[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        obj_path = val_root+<span class="string">&#x27;dog/&#x27;</span>+dog_file[i]</span><br><span class="line">    shutil.move(pic_path,obj_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cat_file)):</span><br><span class="line">    pic_path = root+<span class="string">&#x27;train/&#x27;</span>+cat_file[i]</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(cat_file)*<span class="number">0.9</span>:</span><br><span class="line">        obj_path = train_root+<span class="string">&#x27;cat/&#x27;</span>+cat_file[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        obj_path = val_root+<span class="string">&#x27;cat/&#x27;</span>+cat_file[i]</span><br><span class="line">    shutil.move(pic_path,obj_path)</span><br></pre></td></tr></table></figure><p>上面的操作实现了，将猫狗照片分别移动到训练集和验证集，其中90%的数据作为训练集，10%的图片作为验证集，使用<code>shutil.move()</code>来移动图片</p><p>2.迁移学习模型训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models,transforms,datasets</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">img_classes=<span class="number">2</span></span><br><span class="line">epoch_num = <span class="number">2</span></span><br><span class="line">path = <span class="string">&quot;./data/dogs-vs-cats/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据</span></span><br><span class="line">data_transform = transforms.Compose([</span><br><span class="line">    transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>],[<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ImageFOLDER 返回的是一个list，这里的写法是字典的形式</span></span><br><span class="line">data_image = &#123;x: datasets.ImageFolder(root=os.path.join(path, x),transform=data_transform) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>]&#125;</span><br><span class="line">data_loader_image = &#123;x: DataLoader(dataset=data_image[x],batch_size=<span class="number">4</span>,shuffle=<span class="literal">True</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类</span></span><br><span class="line">classes = data_image[<span class="string">&quot;train&quot;</span>].classes <span class="comment"># 按文件夹名字分类</span></span><br><span class="line">classes_index = data_image[<span class="string">&quot;train&quot;</span>].class_to_idx <span class="comment"># 文件夹类名所对应的链值</span></span><br><span class="line"><span class="comment"># 打印类别</span></span><br><span class="line"><span class="built_in">print</span>(classes) </span><br><span class="line"><span class="built_in">print</span>(classes_index)</span><br><span class="line"><span class="comment"># 打印训练集，验证集大小</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train data set:&quot;</span>, <span class="built_in">len</span>(data_image[<span class="string">&quot;train&quot;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;val data set:&quot;</span>, <span class="built_in">len</span>(data_image[<span class="string">&quot;val&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入预训练的网络，并修改全连接层</span></span><br><span class="line">model = models.resnet18(pretrained=<span class="literal">True</span>) <span class="comment"># 18层的残差网络</span></span><br><span class="line"><span class="comment">#print(model)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> parma <span class="keyword">in</span> model.parameters():</span><br><span class="line">    parma.requires_grad = <span class="literal">False</span>  <span class="comment"># 不进行梯度更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变模型的全连接层，本项目只需要输出2类</span></span><br><span class="line">model.fc = nn.Sequential(nn.Linear(<span class="number">512</span>, <span class="number">256</span>),</span><br><span class="line">                                       nn.ReLU(),</span><br><span class="line">                                       nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">                                       nn.Linear(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">                                       nn.ReLU(),</span><br><span class="line">                                       nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">                                       nn.Linear(<span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, parma <span class="keyword">in</span> <span class="built_in">enumerate</span>(model.fc.parameters()):</span><br><span class="line">    parma.requires_grad = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否有GPU</span></span><br><span class="line">use_gpu = torch.cuda.is_available()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Find GPU: &quot;</span>,use_gpu)</span><br><span class="line"><span class="keyword">if</span> use_gpu:</span><br><span class="line">    model = model.cuda()</span><br><span class="line"><span class="comment">#print(model)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义代价函数</span></span><br><span class="line">cost = torch.nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment"># 定义优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(model.fc.parameters(),lr=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epoch_num):</span><br><span class="line">        since = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Epoch&#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch+<span class="number">1</span>, epoch_num))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>]:</span><br><span class="line">            <span class="keyword">if</span> param == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">                model.train = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                model.train = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line">            running_correct = <span class="number">0</span></span><br><span class="line">            batch = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> data <span class="keyword">in</span> data_loader_image[param]:</span><br><span class="line">                batch += <span class="number">1</span></span><br><span class="line">                X, y = data</span><br><span class="line">                <span class="keyword">if</span> use_gpu:</span><br><span class="line">                    X, y = Variable(X.cuda()), Variable(y.cuda())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    X, y = Variable(X), Variable(y)</span><br><span class="line"></span><br><span class="line">                optimizer.zero_grad()</span><br><span class="line">                y_pred = model(X)</span><br><span class="line">                _, pred = torch.<span class="built_in">max</span>(y_pred.data, <span class="number">1</span>)</span><br><span class="line">                loss = cost(y_pred,y)</span><br><span class="line">                <span class="keyword">if</span> param == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">                    loss.backward()</span><br><span class="line">                    optimizer.step()</span><br><span class="line">                running_loss += loss.item()</span><br><span class="line">                <span class="comment"># running_loss += loss.data</span></span><br><span class="line">                running_correct += torch.<span class="built_in">sum</span>(pred == y.data)</span><br><span class="line">                <span class="keyword">if</span> batch % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">and</span> param == <span class="string">&quot;train&quot;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Batch &#123;&#125;, Train Loss:&#123;:.4f&#125;, Train ACC:&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                        batch, running_loss / (<span class="number">4</span> * batch), <span class="number">100</span> * running_correct / (<span class="number">4</span> * batch)))</span><br><span class="line"></span><br><span class="line">            epoch_loss = running_loss / <span class="built_in">len</span>(data_image[param])</span><br><span class="line">            epoch_correct = <span class="number">100</span> * running_correct / <span class="built_in">len</span>(data_image[param])</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; Loss:&#123;:.4f&#125;, Correct:&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(param, epoch_loss, epoch_correct))</span><br><span class="line">        now_time = time.time() - since</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Training time is:&#123;:.0f&#125;m &#123;:.0f&#125;s&quot;</span>.<span class="built_in">format</span>(now_time // <span class="number">60</span>, now_time % <span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">train()</span><br><span class="line">torch.save(model, <span class="string">&#x27;dogsvscats.pth&#x27;</span>)</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms, models</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">model = torch.load(<span class="string">&#x27;dogsvscats.pth&#x27;</span>)</span><br><span class="line">path = <span class="string">&quot;./data/dogs-vs-cats&quot;</span></span><br><span class="line"></span><br><span class="line">transform = transforms.Compose([transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">                                transforms.ToTensor(),</span><br><span class="line">                                transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])])</span><br><span class="line"></span><br><span class="line">data_test_img = datasets.ImageFolder(root=path+<span class="string">&quot;/val/&quot;</span>, transform = transform) </span><br><span class="line"></span><br><span class="line">data_loader_test_img = torch.utils.data.DataLoader(dataset=data_test_img,</span><br><span class="line">                                                  batch_size = <span class="number">16</span>,shuffle=<span class="literal">True</span>) <span class="comment">#载入测试数据集，并随机打乱</span></span><br><span class="line">classes = data_test_img.classes   <span class="comment">##class</span></span><br><span class="line"></span><br><span class="line">image, label = <span class="built_in">next</span>(<span class="built_in">iter</span>(data_loader_test_img))</span><br><span class="line">images = Variable(image).cuda()</span><br><span class="line">y_pred = model(images)</span><br><span class="line">_,pred = torch.<span class="built_in">max</span>(y_pred.data, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(pred)</span><br><span class="line"><span class="built_in">print</span>(label)</span><br><span class="line"></span><br><span class="line">img = torchvision.utils.make_grid(image)</span><br><span class="line">img = img.numpy().transpose(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">mean = [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>]</span><br><span class="line">std = [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>]</span><br><span class="line">img = img * std + mean</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Pred Label:&quot;</span>, [classes[i] <span class="keyword">for</span> i <span class="keyword">in</span> pred])</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="7-2-实例二，Deep-Dream：探索卷积神经网络眼中的世界"><a href="#7-2-实例二，Deep-Dream：探索卷积神经网络眼中的世界" class="headerlink" title="7.2 实例二，Deep Dream：探索卷积神经网络眼中的世界"></a>7.2 实例二，Deep Dream：探索卷积神经网络眼中的世界</h3><p>2015年，Google发布了一个有意思的东西，叫做Deep Dream</p><h4 id="7-2-1-原理介绍"><a href="#7-2-1-原理介绍" class="headerlink" title="7.2.1 原理介绍"></a>7.2.1 原理介绍</h4><p><strong>1.反向神经网络</strong></p><p>我们知道经过训练之后，每一层网络足部提取越来越高级的图像特征，知道最后一层将这些特征比较做出分类的结果。比如前面几层也许在寻找边缘和拐角的特征，中间几层分析整体的轮廓特征，这样不断的增加层数就可以发展出越来越多的复杂特征，最后几层将这些特征要素组合起来形成完整的解释，这样到最后网络就会对非常复杂的东西，比如小猫，树叶等图片有所反应</p><p><strong>2.Deep Dream</strong></p><p>如果我们将算法反复地应用到自身的输出上，不断迭代，并在每次迭代后应用一些缩放，就能不断地激活特征，得到无尽的新效果。</p><h4 id="7-2-2-代码实现"><a href="#7-2-2-代码实现" class="headerlink" title="7.2.2 代码实现"></a>7.2.2 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, utils</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment"># PIL.ImageFilter是Python中的图像滤波，主要对图像进行平滑、锐化、边界增强等滤波处理</span></span><br><span class="line"><span class="comment"># PIL.ImageChops模块包含一些算术图形操作，叫做channel operations（“chops”）。这些操作可用于诸多目的，比如图像特效，图像组合，算法绘图等等</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter, ImageChops</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载图像并显示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image</span>(<span class="params">path</span>):</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(path)</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.title(<span class="string">&quot;Image loaded successfully&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数据集的标准化设置——减去均值再除以标准差</span></span><br><span class="line">normalise = transforms.Normalize(</span><br><span class="line">    mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">    std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集的预处理，包括缩放、转换成Tensor、标准化</span></span><br><span class="line">preprocess = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">224</span>,<span class="number">224</span>)),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    normalise</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆向处理过程，逆标准化，图像乘以标准差再加上均值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deprocess</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="keyword">return</span> image * torch.Tensor([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]).cuda()  + torch.Tensor([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]).cuda()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载vgg16的预训练模型，传到GPU上，输出网络结构</span></span><br><span class="line">vgg = models.vgg16(pretrained=<span class="literal">True</span>)</span><br><span class="line">vgg = vgg.cuda()</span><br><span class="line">modulelist = <span class="built_in">list</span>(vgg.features.modules())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是deep dream的实际代码，特定层的梯度被设置为等于该层的响应，这导致了该层响应最大化。换句话说，我们正在增强一层检测到的特征，对输入图像（octaves）应用梯度上升算法。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dd_helper</span>(<span class="params">image, layer, iterations, lr</span>):</span>        </span><br><span class="line">    <span class="comment"># 一开始的输入是图像经过预处理、在正数第一个维度上增加一个维度以匹配神经网络的输入、传到GPU上</span></span><br><span class="line">    <span class="built_in">input</span> = Variable(preprocess(image).unsqueeze(<span class="number">0</span>).cuda(), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># vgg梯度清零</span></span><br><span class="line">    vgg.zero_grad()</span><br><span class="line">    <span class="comment"># 开始迭代</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">        <span class="comment"># 一层一层传递输入</span></span><br><span class="line">        out = <span class="built_in">input</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(layer):</span><br><span class="line">            out = modulelist[j+<span class="number">1</span>](out)</span><br><span class="line">        <span class="comment"># 损失是输出的范数</span></span><br><span class="line">        loss = out.norm()</span><br><span class="line">        <span class="comment"># 损失反向传播</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># 输入的数据是上次迭代时的输入数据+学习率×输入的梯度</span></span><br><span class="line">        <span class="built_in">input</span>.data = <span class="built_in">input</span>.data + lr * <span class="built_in">input</span>.grad.data</span><br><span class="line">    <span class="comment"># 将从网络结构中取出的输入数据的第一个维度去掉</span></span><br><span class="line">    <span class="built_in">input</span> = <span class="built_in">input</span>.data.squeeze()</span><br><span class="line">    <span class="comment"># 矩阵转置</span></span><br><span class="line">    <span class="built_in">input</span>.transpose_(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">input</span>.transpose_(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 将输入逆标准化后强制截断在0到1的范围内</span></span><br><span class="line">    <span class="built_in">input</span> = np.clip(deprocess(<span class="built_in">input</span>), <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 得到像素值为0到255的图像</span></span><br><span class="line">    im = Image.fromarray(np.uint8(<span class="built_in">input</span>*<span class="number">255</span>))</span><br><span class="line">    <span class="keyword">return</span> im</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一个递归函数，用于创建octaves，并且将由一次递归调用生成的图像与由上一级递归调用生成的图像相融合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep_dream_vgg</span>(<span class="params">image, layer, iterations, lr, octave_scale, num_octaves</span>):</span></span><br><span class="line">    <span class="comment"># 若octave序号大于0，即还未到达最底层的octave时，一层一层递归</span></span><br><span class="line">    <span class="keyword">if</span> num_octaves&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 对图像进行高斯滤波（高斯模糊）</span></span><br><span class="line">        image1 = image.<span class="built_in">filter</span>(ImageFilter.GaussianBlur(<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># 判断是否缩放</span></span><br><span class="line">        <span class="keyword">if</span>(image1.size[<span class="number">0</span>]/octave_scale &lt; <span class="number">1</span> <span class="keyword">or</span> image1.size[<span class="number">1</span>]/octave_scale&lt;<span class="number">1</span>):</span><br><span class="line">            size = image1.size</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            size = (<span class="built_in">int</span>(image1.size[<span class="number">0</span>]/octave_scale), <span class="built_in">int</span>(image1.size[<span class="number">1</span>]/octave_scale))</span><br><span class="line">        <span class="comment"># 图像缩放    </span></span><br><span class="line">        image1 = image1.resize(size,Image.ANTIALIAS)</span><br><span class="line">        <span class="comment"># 递归调用，直至num_octave==0</span></span><br><span class="line">        image1 = deep_dream_vgg(image1, layer, iterations, lr, octave_scale, num_octaves-<span class="number">1</span>)</span><br><span class="line">        size = (image.size[<span class="number">0</span>], image.size[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 将图像缩放到最初输入图像的大小</span></span><br><span class="line">        image1 = image1.resize(size,Image.ANTIALIAS)</span><br><span class="line">        <span class="comment"># 将最初输入的图像与合成的相同尺寸大小的图像融合</span></span><br><span class="line">        image = ImageChops.blend(image, image1, <span class="number">0.6</span>)</span><br><span class="line"><span class="comment">#     print(&quot;-------------- Recursive level: &quot;, num_octaves, &#x27;--------------&#x27;)</span></span><br><span class="line">    <span class="comment"># 按照dd_helper中的流程生成图像</span></span><br><span class="line">    img_result = dd_helper(image, layer, iterations, lr)</span><br><span class="line">    <span class="comment"># 图像缩放并显示</span></span><br><span class="line">    img_result = img_result.resize(image.size)</span><br><span class="line">    plt.imshow(img_result)</span><br><span class="line">    <span class="keyword">return</span> img_result</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 加载图像(原始图像)</span></span><br><span class="line">sky = load_image(<span class="string">&#x27;1.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于vgg16最后一个卷积层conv5_3,迭代5次，学习率为0.2,octave缩放比例为2,octave从第20层开始</span></span><br><span class="line">sky_28 = deep_dream_vgg(sky, <span class="number">28</span>, <span class="number">5</span>, <span class="number">0.2</span>, <span class="number">2</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度学习入门之PyTorch&quot;&gt;&lt;a href=&quot;#深度学习入门之PyTorch&quot; class=&quot;headerlink&quot; title=&quot;深度学习入门之PyTorch&quot;&gt;&lt;/a&gt;深度学习入门之PyTorch&lt;/h1&gt;&lt;h2 id=&quot;第一章-深度学习介绍&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="python" scheme="https://blog.justlovesmile.top/tags/python/"/>
    
    <category term="pytorch" scheme="https://blog.justlovesmile.top/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>深度学习 | “花书”，Deep Learning笔记</title>
    <link href="https://blog.justlovesmile.top/posts/43678.html"/>
    <id>https://blog.justlovesmile.top/posts/43678.html</id>
    <published>2020-10-09T08:26:12.000Z</published>
    <updated>2020-10-09T08:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h3 id="第一章-前言"><a href="#第一章-前言" class="headerlink" title="第一章 前言"></a>第一章 前言</h3><p>深度学习(Deep Learning) ∈ 表示学习(Representation Learning) ∈ 机器学习(Machine Learning) ∈ 人工智能(AI)</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201015120220.png"></p><p>分类，回归，聚类，降维</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20201015120404.png"></p><p>神经网络</p><p><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/149537710807280383.jpg"></p><h2 id="第一部分-应用数学与机器学习基础"><a href="#第一部分-应用数学与机器学习基础" class="headerlink" title="第一部分 应用数学与机器学习基础"></a>第一部分 应用数学与机器学习基础</h2><h3 id="第二章-线性代数"><a href="#第二章-线性代数" class="headerlink" title="第二章 线性代数"></a>第二章 线性代数</h3><h4 id="2-1-标量，向量，矩阵和张量"><a href="#2-1-标量，向量，矩阵和张量" class="headerlink" title="2.1 标量，向量，矩阵和张量"></a>2.1 标量，向量，矩阵和张量</h4><p>1.标量(scalar)是一个单独的数<br>2.向量(vector)是一列数，这些数是有序排列的</p><p>$$<br>x = \begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots\<br>x_n\<br>\end{bmatrix}<br>$$</p><p>3.矩阵(matrix)是一个二维数组</p><p>$$<br>\begin{bmatrix}<br>A_{1,1} &amp; A_{1,2}\<br>B_{2,1} &amp; B_{2,2}\<br>\end{bmatrix}<br>$$</p><p>4.张量(tensor)：一般将超过二维的数组称为张量</p><ul><li>转置：以对角线为轴的镜像</li></ul><p>$$<br>(A^T)<em>{i,j}=A</em>{j,i}<br>$$</p><ul><li>广播：将一个向量隐式的复制到每一行生成矩阵（用于运算）的方式</li></ul><p>$$C=A+b$$<br>$$C_{i,j}=A_{i,j}+b$$<br>$$<br>\begin{bmatrix}<br>C_{1,1} &amp; C_{1,2} &amp; C_{1,3}\<br>C_{2,1} &amp; C_{2,2} &amp; C_{2,3}\<br>C_{3,1} &amp; C_{3,2} &amp; C_{3,3}\<br>\end{bmatrix}=<br>\begin{bmatrix}<br>A_{1,1} &amp; A_{1,2} &amp; A_{1,3}\<br>A_{2,1} &amp; A_{2,2} &amp; A_{2,3}\<br>A_{3,1} &amp; A_{3,2} &amp; A_{3,3}\<br>\end{bmatrix}+<br>\begin{bmatrix}<br>b_{1} &amp; b_{2} &amp; b_{3}\<br>\end{bmatrix}=<br>\begin{bmatrix}<br>A_{1,1} &amp; A_{1,2} &amp; A_{1,3}\<br>A_{2,1} &amp; A_{2,2} &amp; A_{2,3}\<br>A_{3,1} &amp; A_{3,2} &amp; A_{3,3}\<br>\end{bmatrix}+<br>\begin{bmatrix}<br>b_{1} &amp; b_{2} &amp; b_{3}\<br>b_{1} &amp; b_{2} &amp; b_{3}\<br>b_{1} &amp; b_{2} &amp; b_{3}\<br>\end{bmatrix}<br>$$</p><h4 id="2-2-矩阵和向量相乘"><a href="#2-2-矩阵和向量相乘" class="headerlink" title="2.2 矩阵和向量相乘"></a>2.2 矩阵和向量相乘</h4><p>如果A的形状是m×n，B的形状是n×p，<code>C=AB</code>，那么C的形状是m×p<br>具体地，该乘法操作定义为：<br>$$C_{i,j}=\sum_kA_{i,k}B_{k,j}$$</p><blockquote><p>注意区分：存在一种两个矩阵对应元素的乘积，叫<code>Hadamard乘积</code>，记为<code>A⊙B</code></p></blockquote><p>性质：</p><ul><li>分配律<br>$$A(B+C)=AB+AC$$</li><li>结合律<br>$$A(BC)=(AB)C$$</li><li><strong>矩阵乘积不具有交换律</strong>，但是两个向量的点积满足交换律<br>$$x^Ty=y^Tx$$<br>$$(AB)^T=B^TA^T$$</li></ul><p>对于AX=b，可表示<br>$$A_{1,1}x_1+A_{1,2}x_2+\cdots+A_{1,n}x_n=b_1$$<br>$$A_{2,1}x_1+A_{2,2}x_2+\cdots+A_{2,n}x_n=b_2$$<br>$$\vdots$$<br>$$A_{m,1}x_1+A_{m,2}x_2+\cdots+A_{m,n}x_n=b_m$$<br>即<br>$$<br>\begin{bmatrix}<br>A_{1,1} &amp; A_{1,2} &amp; \cdots &amp; A_{1,n}\<br>A_{2,1} &amp; A_{2,2} &amp; \cdots &amp; A_{2,n}\<br>\vdots\<br>A_{m,1} &amp; A_{m,2} &amp; \cdots &amp; A_{m,n}\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x_{1}\<br>x_{2}\<br>\vdots\<br>x_{n}\<br>\end{bmatrix}=<br>\begin{bmatrix}<br>b_{1}\<br>b_{2}\<br>\vdots\<br>b_{m}\<br>\end{bmatrix}<br>$$</p><h4 id="2-3-单位矩阵和逆矩阵"><a href="#2-3-单位矩阵和逆矩阵" class="headerlink" title="2.3 单位矩阵和逆矩阵"></a>2.3 单位矩阵和逆矩阵</h4><p>单位矩阵：任何向量和单位矩阵相乘，都不会改变<br>$${\forall}x{\in}R^n,I_nx=x$$</p><p>$$I_3=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0\<br>0 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 1\<br>\end{bmatrix}<br>$$<br>矩阵逆，记作$$A^{-1}$$，定义<br>$$A^{-1}A=I_n$$</p><h4 id="2-4-线性相关和生成子空间"><a href="#2-4-线性相关和生成子空间" class="headerlink" title="2.4 线性相关和生成子空间"></a>2.4 线性相关和生成子空间</h4><p>对于矩阵逆的定义：<br>$$A^{-1}A=I_n$$<br>可以通过以下步骤求解：<br>$$Ax=b$$<br>$$A^{-1}Ax=A^{-1}b$$<br>$$I_nx=A^{-1}b$$<br>$$x=A^{-1}b$$<br>如果能找到一个逆矩阵$A^{-1}$，那么若$s=w_1x_1+w_2x_2+{\cdots}+w_kx_k$。s变量是对变量x的加权线性”混合”。因此，将s定义为变量的线性组合。</p><ul><li><p>生成子空间：原始向量的一切线性组合生成的子空间</p></li><li><p>线性无关：一组向量中的任意一个向量都不能表示成其他向量的线性组合，那么这组向量被称为线性无关</p></li></ul><blockquote><p>如果数组向量中的某一个或多个向量可以由数组内的其余向量通过加法或数乘表达，则该向量组线性相关，反之则线性无关。</p></blockquote><ul><li>方阵：行列大小相同的矩阵</li></ul><h4 id="2-5-范数"><a href="#2-5-范数" class="headerlink" title="2.5 范数"></a>2.5 范数</h4><p>为了衡量一个向量的大小，在机器学习中，我们经常使用范数（norm）的函数衡量。形式上，$L^p$范数定义如下：<br>$$<br>\left | x \right | _ p=\left ( \sum_i\left | x_i \right |^p\right )^\frac{1}{p}<br>$$<br>其中$p \in \mathbb{R},p \geqslant 1$</p><ul><li>范数，是将向量映射到非负值的函数。直观上来说，向量x的范数衡量从原点到点x的距离。更严格的说，范数是满足下列性质的任意函数：<br>$$f\left (x \right )=0\Rightarrow x=0$$<br>$$<br>f\left (x + y \right )\leqslant f \left ( x \right ) + f\left(y \right)<br>$$</li></ul><p>$$<br>\forall \alpha \in \mathbb{R},f({\alpha}x)=|\alpha|f(x)<br>$$</p><ul><li><p>当p=2时，$L^2$范数被称为<strong>欧几里得范数</strong>。平方$L^2$范数，也经常用来衡量向量的大小。</p></li><li><p>$L^1$范数的定义，$||x|| _ 1 = \sum_i|x_i|$</p></li><li><p>另一个常在机器学习中出现的范数是$L^∞$范数，也被称为<strong>最大范数</strong>。这个范数表示向量中具有最大幅值的元素的绝对值：<br>$$||x|| _ ∞ =\max_i|x_i|$$</p></li><li><p>Frobenius范数：$$\left |A\right | _ F = \sqrt{\sum _ {i,j}{A^2} _ {i,j}}$$</p></li></ul><p>两个向量的<strong>点积</strong>，可以用范数来表示：<br>$$x^Ty=||x|| _ 2 ||y|| _ 2 \cos \theta $$<br>其中$\theta$，表示x和y之间的夹角</p><h4 id="2-6-特殊类型的矩阵和向量"><a href="#2-6-特殊类型的矩阵和向量" class="headerlink" title="2.6 特殊类型的矩阵和向量"></a>2.6 特殊类型的矩阵和向量</h4><p><strong>对角矩阵</strong>:只在主对角线上含有非零元素，其他位置都是零的矩阵。单位矩阵是对角元素都为1的对角矩阵。</p><ul><li>如果用diag(v)表示一个对角元素由向量v中的元素给定的对角方阵,那么$diag(v)x=v\odot x$，并且计算对角方阵的逆矩阵也很高效，如果对角方阵的逆矩阵存在，当且仅当对角元素都是非零值，这种情况下有，$diag(v)^{-1}=diag([\frac{1}{v_1},\cdots,\frac{1}{v_n}]^T)$</li><li>不是所有的对角矩阵都是方阵，非方阵的对角矩阵没有逆矩阵</li></ul><p><strong>对称矩阵</strong>是转置和自己相等的矩阵<br>$$A=A^T$$</p><p><strong>单位向量</strong>是具有<strong>单位范数</strong>的向量<br>$$||x|| _ 2 = 1$$</p><p><strong>正交</strong>：如果$x^Ty=0$，那么向量x和向量y互相正交，如果两个向量都有非零范数，那么他们之间的夹角为90度。<br><strong>标准正交</strong>：如果这些向量的不仅互相正交，并且范数都为1，那么我们称他们为标准正交<br><strong>正交矩阵</strong>：指行向量和列向量是分别标准正交的方针<br>$$A^TA=AA^T=I$$<br>$$A^{-1}=A^T$$</p><blockquote><p>补充关于点乘和叉乘：<br>点乘，也叫数量积，结果是一个向量在另一个向量方向上的投影的长度，是一个标量；<br>$A·B=|A||B|\cos\theta$，点积为0，说明两个向量正交<br>叉乘，也叫向量积，结果是一个和已有两个向量都垂直的向量，向量模长是向量A，B组成平行四边形的面积，即$\left | A×B\right|=\left|A \right|\left|B \right|\sin\theta$；向量方向垂直于向量A,B组成的平面；<br>$$A×B=\begin{vmatrix}<br>i &amp; j &amp; k\<br>a_1 &amp; a_2 &amp; a_3\<br>b_1 &amp; b_2 &amp; b_3<br>\end{vmatrix}=<br>\begin{vmatrix}<br>a_2 &amp; a_3\<br>b_2 &amp; b_3<br>\end{vmatrix}i-<br>\begin{vmatrix}<br>a_1 &amp; a_3\<br>b_1 &amp; b_3<br>\end{vmatrix}j+<br>\begin{vmatrix}<br>a_1 &amp; a_2\<br>b_1 &amp; b_2<br>\end{vmatrix}k$$<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/v2-1bc29eef9c32d93b6b9d6604b0ce65ea_720w.png"></p></blockquote><h4 id="2-7-特征分解"><a href="#2-7-特征分解" class="headerlink" title="2.7 特征分解"></a>2.7 特征分解</h4><p><strong>特征分解</strong>是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值</p><ul><li><strong>方阵A</strong>的特征向量是指与A相乘后相当于对该向量进行缩放的非零向量v：$Av=λv$</li></ul><p>$({\lambda}E-A)v=0$，求特征值$\lambda$，其中$|{\lambda}E-A|$被称为特征多项式</p><ul><li>标量λ被称为这个特征向量对应的特征值。如果v是A的特征向量，那么任何缩放后的向量sv（s∈R，s≠0）也是A的特征向量。此外sv和v有相同的特征值。</li></ul><p>假设矩阵A有n个线性无关的特征向量</p><p>$$v^{(1)},\cdots,v^{(n)}$$</p><p>对应着特征值</p><p>$${\lambda} _ 1,\cdots,{\lambda} _ n$$</p><p>将特征向量连接成一个矩阵，使得每一列是一个特征向量：</p><p>$$V=[v^{(1)},\cdots,v^{(n)}]$$</p><p>类似地，将特征值连接成一个向量</p><p>$$\lambda =[{\lambda} _ 1,\cdots,{\lambda} _ n]^T$$</p><p>因此A的特征分解可以记作：</p><p>$$A=Vdiag(\lambda)V^{-1}$$</p><ul><li>特征分解唯一当且仅当所有的特征值都是唯一的</li><li>矩阵是奇异的当且仅当含有零特征值（奇异：非满秩）</li><li>正定（所有特征值为正），半正定（所有特征值非负），负定（所有特征值为负），半负定（所有特征值非正）</li></ul><p>对于每个实对称矩阵，都可以分解成实特征向量和实特征值<br>$$A=QΛQ^T$$<br>其中Ｑ是Ａ的特征向量组成的正交矩阵，Λ是对角矩阵。特征值$Λ_{i,j}$对应的特征向量是矩阵Q的第i列，记作$Q_{:,j}$</p><h4 id="2-8-奇异值分解"><a href="#2-8-奇异值分解" class="headerlink" title="2.8 奇异值分解"></a>2.8 奇异值分解</h4><p><a href="https://www.bilibili.com/video/BV1N4411a78K?from=search&seid=2326855606635926731">奇异值分解视频</a></p><p>奇异值分解：将矩阵分解为<strong>奇异向量</strong>和<strong>奇异值</strong><br>假设A是一个m×n的矩阵，那么U是一个m×m的矩阵，D是一个m×n的矩阵，V是一个n×n的矩阵，其中U和V是正交矩阵，D是对角矩阵（不一定是方阵）<br>$$A=UDV^T$$<br>对角矩阵D对角线上的元素被称为矩阵A的<strong>奇异值</strong>，矩阵U的列向量被称为<strong>左奇异向量</strong>(是$AA^T$的特征向量)，矩阵V的列向量被称为<strong>右奇异向量</strong>（是$A^TA$的特征向量）。A的非零奇异值是$A^TA$特征值的平方根，也是$AA^T$特征值的平方根</p><p>正交-对角-正交：旋转-拉伸-旋转</p><p>$$A^TA=(VD^TU^T)(UDV^T)=V(D^TD)V^T$$<br>$$AA^T=(UDV^T)(VD^TU^T)=U(D^TD)U^T$$<br>$$A=<br>\begin{bmatrix}<br>u_1 &amp; u_2<br>\end{bmatrix}<br>\begin{bmatrix}<br>\sigma_1 &amp; \<br> &amp; \sigma_2<br>\end{bmatrix}<br>\begin{bmatrix}<br>v_1^T\<br>v_2^T<br>\end{bmatrix}<br>$$</p><p>例子：</p><p>$$A=\begin{bmatrix}<br>2 &amp; 2\<br>1 &amp; 1<br>\end{bmatrix}=<br>\begin{bmatrix}<br>\frac{2}{\sqrt{5}} &amp; \frac{1}{\sqrt{5}}\<br>\frac{-1}{\sqrt{5}} &amp; \frac{2}{\sqrt{5}}<br>\end{bmatrix}<br>\begin{bmatrix}<br>\sqrt{10} &amp; \<br> &amp; 0<br>\end{bmatrix}<br>\begin{bmatrix}<br>\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}\<br>\frac{1}{\sqrt{2}} &amp; \frac{-1}{\sqrt{2}}<br>\end{bmatrix}<br>$$</p><h4 id="2-9-Moore-Penrose伪逆"><a href="#2-9-Moore-Penrose伪逆" class="headerlink" title="2.9 Moore-Penrose伪逆"></a>2.9 Moore-Penrose伪逆</h4><p>对于非方阵，将矩阵A 的伪逆定义为：<br>$$A^+=\lim_{a\rightarrow0}(A^TA+{\alpha}I)^{-1}A^T$$<br>实际计算公式<br>$$A^+=VD^+U^T$$<br>其中，矩阵U，D和V是矩阵A奇异值分解后得到的矩阵，对角矩阵D的伪逆$D^+$是其非零元素取倒数之后再转置得到的</p><h4 id="2-10-迹运算"><a href="#2-10-迹运算" class="headerlink" title="2.10 迹运算"></a>2.10 迹运算</h4><p>迹运算返回的是矩阵对角元素的和：<br>$$Tr(A)=\sum_iA_{i,i}$$</p><p>迹运算提供了另一种描述矩阵Frobenius范数的方式$$\left|A\right|<em>F=\sqrt{Tr(AA^T)}$$<br>迹运算在转置条件下是不变的<br>$$Tr(A)=Tr(A^T)$$<br>如果多个矩阵相乘交换顺序后仍有定义，那么有<br>$$Tr(ABC)=Tr(CAB)=Tr(BCA)$$<br>$$Tr(\prod</em>{i=1}^{n}F^{(i)})=Tr(F^{(n)}\prod_{i=1}^{n-1}F^{(i)})$$<br>标量的迹运算还是它自己</p><h4 id="2-11-行列式"><a href="#2-11-行列式" class="headerlink" title="2.11 行列式"></a>2.11 行列式</h4><p>记作det(A),是一个将方阵A映射到实数的函数。行列式等于矩阵特征值的乘积</p><h4 id="2-12-实例：主成分分析"><a href="#2-12-实例：主成分分析" class="headerlink" title="2.12 实例：主成分分析"></a>2.12 实例：主成分分析</h4><p>主成分分析（PCA,Principle component analysis）是一个简单的机器学习算法，可以通过基础的线性代数知识推导。</p><p>假设，在$\mathbb{R}^n$空间中我们有m个点，为了对这些点进行有损压缩，可以采取低维表示（线性降维），对于每个点$x^{(i)}\in \mathbb{R}^n$,会有一个对应的编码向量$c^{(i)}\in \mathbb{R}^l$。如果l比n小，那么便实现了压缩。需要设置一个编码函数，根据输入返回编码$f(x)=c$，也希望设置一个解码函数，给定编码重构输入$x≈g(f(x))$，为了简化解码器，使用矩阵乘法将编码映射回$\mathbb{R}^n$，即g(c)=Dc，其中D∈$\mathbb{R}^{n×l}$是定义解码的矩阵</p><p>首先，我们需要明确如何根据每一个输入x得到一个最优编码<br>$$c ^ <em>$$<br>一种方法是最小化原始输入向量x和重构向量<br>$$g(c^</em>)$$<br>之间的距离,在PCA中，我们使用L2范数：<br>$$c ^ * =arg\min _ c \left|x-g(c)\right| _ 2$$</p><blockquote><p>arg min f(x) 是指使得函数 f(x) 取得其最小值的所有自变量 x 的集合。</p></blockquote><p>当然也可以用平方L2范数来替代L2范数：<br>$$c^*=arg\min_c\left|x-g(c)\right|<em>2^2$$<br>该最小化函数可以简化成：<br>$$(x-g(c))^T(x-g(c))$$<br>$$=x^Tx-x^Tg(c)-g(c)^Tx+g(c)^Tg(c)$$<br>$$=x^Tx-2x^Tg(c)+g(c)^Tg(c)$$<br>因为第一项$x^Tx$不依赖于c所以我们可以忽略它，得到：<br>$$c^*=arg\min_c - 2x^Tg(c)+g(c)^Tg(c)$$<br>代入g(c)的定义：<br>$$c^*=arg\min_c - 2x^TDc+c^TD^TDc=arg\min_c - 2x^TDc+c^TI_lc=arg\min_c - 2x^TDc+c^Tc$$<br>$$\nabla_c(-2x^TDc+c^Tc)=0$$<br>$$-2D^Tx+2c=0$$<br>$$c=D^Tx$$<br>于是，最优编码x只需要一个矩阵-向量乘法操作<br>$$f(x)=D^Tx$$<br>PCA重构操作<br>$$r(x)=g(f(x))=DD^Tx$$<br>接下来需要挑选编码矩阵D，所以我们需要最小化所有维数和所有点上的误差矩阵的Frobenius范数：<br>$$D^*=arg\min_D\sqrt{\sum</em>{i,j}(x_j^{(i)}-r(x^{(i)})_j)^2}\text{ subject to } D^TD=I_l$$<br>先考虑l=1的情况，此时D是一个单一向量d<br>$$d^*=arg\min_d\sum\left|x^{(i)}-dd^Tx^{(i)}\right|_2^2\text{ subject to } \left|d\right|<em>2=1$$<br>将表示个点的向量堆叠成一个矩阵，记为X∈$\mathbb{R}^{m×n}$，其中$X</em>{i,:}=x^{(i)^T}$<br>原问题可以重新表示为：<br>$$d^*=arg\min_d\left|X-Xdd^T\right|_F^2\text{ subject to }d^Td=1$$<br>暂不考虑约束，可以把Frobenius范数简化成<br>$$arg\min_d\left|X-Xdd^T\right|_F^2$$<br>$$=arg\min_dTr((X-Xdd^T)^T(X-Xdd^T))$$<br>$$=arg\min_d-2Tr(X^TXdd^T)+Tr(X^TXdd^Tdd^T)$$<br>再考虑约束条件<br>$$arg\min_d-2Tr(X^TXdd^T)+Tr(X^TXdd^Tdd^T)\text{ subject to } d^td=1$$<br>$$=arg\max_dTr(d^TX^TXd)\text{ subject to }d^Td=1$$<br>即，最优的d是X^TX最大特征值对应的特征向量</p><blockquote><p>PCA算法两种实现方法：<br>（1）基于特征值分解协方差矩阵实现<br>输入数据集X={x1,x2,x3,…,xn}，需要降到k维。<br>1）去平均值（去中心化），即每一位特征减去各自的平均值<br>2）计算协方差矩阵$\frac{1}{n}XX^T$<br>3）用特征值分解方法求协方差矩阵的特征值和特征向量<br>4）对特征值从大到小排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为行向量组成特征向量矩阵P<br>5）将数据转换到k个特征向量构建的新空间中，即Y=PX<br>(2) 基于SVD分解（奇异值分解）协方差矩阵实现PCA算法</p></blockquote><h3 id="第三章-概率与信息论"><a href="#第三章-概率与信息论" class="headerlink" title="第三章 概率与信息论"></a>第三章 概率与信息论</h3><p>概率论是用于表示不确定性申明的数学框架</p><h4 id="3-1-为什么要使用概率"><a href="#3-1-为什么要使用概率" class="headerlink" title="3.1 为什么要使用概率"></a>3.1 为什么要使用概率</h4><p>几乎所有的活动都需要能够再不确定性存在时进行推理<br>不确定性的三种来源：被建模系统内在的随机性，不完全观测，不完全建模</p><h4 id="3-2-随机变量"><a href="#3-2-随机变量" class="headerlink" title="3.2 随机变量"></a>3.2 随机变量</h4><p>随机变量时可以随机地取不同值的变量。</p><h4 id="3-3-概率分布"><a href="#3-3-概率分布" class="headerlink" title="3.3 概率分布"></a>3.3 概率分布</h4><p>概率分布用来描述随机变量或一簇随机变量在每一个可能取到的状态的可能性大小</p><h5 id="3-3-1-离散型变量和概率质量函数"><a href="#3-3-1-离散型变量和概率质量函数" class="headerlink" title="3.3.1 离散型变量和概率质量函数"></a>3.3.1 离散型变量和概率质量函数</h5><ol><li>离散型变量的概率分布可以用概率质量函数(PMF，probability mass function)来描述</li><li>联合概率分布是多个变量的概率分布</li><li>如果用P表示概率质量函数，则满足以下条件</li></ol><ul><li>P的定义域必须是随机变量x所有可能状态的集合</li><li>$\forall x \in X, 0 \leq P(x) \leq 1$，不可能发生的事件概率为0，并且不存在比这概率更低的状态。类似的，一定发生的事件概率为1，且不存在比这概率更高的事件。</li><li>$\sum_i P(x)=1$</li></ul><h5 id="3-3-2-连续型变量和概率密度函数"><a href="#3-3-2-连续型变量和概率密度函数" class="headerlink" title="3.3.2 连续型变量和概率密度函数"></a>3.3.2 连续型变量和概率密度函数</h5><p>对于连续型随机变量，用概率密度函数（PDF，probability density function），如果用p表示概率密度函数，则满足以下条件</p><ul><li>p的定义域必须是x所有可能状态的集合</li><li>$\forall x \in X,p(x) \geq 0$.并不要求p(x)≤1</li><li>$\int p(x) \text{d}x = 1$</li></ul><h4 id="3-4-边缘概率"><a href="#3-4-边缘概率" class="headerlink" title="3.4 边缘概率"></a>3.4 边缘概率</h4><p>边缘概率分布，定义在其中一个子集上的概率分布</p><p>$\forall x \in X,P(X=x)=\sum_yP(X=x,Y=y)$<br>$p(x)=\int p(x,y) \text{d}y$</p><h4 id="3-5-条件概率"><a href="#3-5-条件概率" class="headerlink" title="3.5 条件概率"></a>3.5 条件概率</h4><p>条件概率，在给定其他事件发生时出现的概率，我们将给定X=x，Y=y发生的条件概率记为P(Y=y|X=x)<br>计算公式如下<br>$$P(Y=y|X=x)=\frac{P(Y=y,X=x)}{P(X=x)}$$</p><p>条件概率只在P(X=x)＞0时有定义</p><h4 id="3-6-条件概率的链式法则"><a href="#3-6-条件概率的链式法则" class="headerlink" title="3.6 条件概率的链式法则"></a>3.6 条件概率的链式法则</h4><p>任何多维随机变量的联合概率分布，都可以分解成只有一个变量的条件概率相乘的形式<br>$$P(x^{(1)},\cdots,x^{(n)})=P(x^{(1)})\prod_{i=2}^{n}P(x^{(i)}|x^{(1)},\cdots,x^{(i-1)})$$</p><p>例如：<br>P(a,b,c)=P(a|b,c)P(b,c)<br>P(b,c)=P(b|c)P(c)<br>P(a,b,c)=P(a|b,c)P(b|c)P(c)</p><h4 id="3-7-独立性和条件独立性"><a href="#3-7-独立性和条件独立性" class="headerlink" title="3.7 独立性和条件独立性"></a>3.7 独立性和条件独立性</h4><p><strong>相互独立</strong>：两个随机变量x，y的概率分布可以表示为两个因子的乘积形式，并且一个因子只包含x，另一个只包含y，那么这两个随机变量是相互独立的<br>$$\forall x \in X,y\in Y,p(X=x,Y=y)=p(X=x)p(Y=y)$$</p><p><strong>条件独立</strong>：如果关于x和y的条件概率分布对于z的每一个值都可以写成乘积的形式，那么这两个随机变量x和y在给定随机变量z时是条件独立的</p><p>$$\forall x \in X,y\in Y,z\in Z,p(X=x,Y=y|Z=z)=p(X=x|Z=z)p(Y=y|Z=z)$$</p><h4 id="3-8-期望，方差，协方差"><a href="#3-8-期望，方差，协方差" class="headerlink" title="3.8 期望，方差，协方差"></a>3.8 期望，方差，协方差</h4><p>（1）期望(expected value)<br>函数f(x)关于某分布P(x)的期望或者期望值是指，当x由P产生，f作用到x时，f(x)的平均值</p><p>离散型随机变量的期望<br>$$\mathbb{E} _ {x\sim P}[f(x)]=\sum_x P(x)f(x)$$<br>连续型随机变量的期望<br>$$\mathbb{E} _ {x\sim P}[f(x)]=\int p(x)f(x)\text{d}x$$</p><p>期望是线性的，假设α和β不依赖于x<br>$$\mathbb{E}_ x[\alpha f(x)+ \beta g(x) ]=\alpha \mathbb{E}_ x[f(x)] +\beta \mathbb{E}_ x[g(x)]$$</p><p>（2）方差(variance)<br>$$Var(f(x))=\mathbb{E}[(f(x)-\mathbb{E}[f(x)])^2]$$</p><p>方差的平方根被称为标准差</p><p>（3）协方差<br>$$Cov(f(x),g(y))=\mathbb{E}[(f(x)-\mathbb{E}[f(x)])(g(y)-\mathbb{E}[g(y)])]$$</p><p>两个随机变量独立→协方差为0→没有线性关系<br>但是协方差为0，两个变量不一定独立</p><p>协方差矩阵：<br>$$Cov(x)_ {i,j}=Cov(x_i,x_j)$$<br>协方差矩阵的对角元是方差：<br>$$Cov(x_i,x_i)=Var(x_i)$$</p><h4 id="3-9-常用概率分布"><a href="#3-9-常用概率分布" class="headerlink" title="3.9 常用概率分布"></a>3.9 常用概率分布</h4><h5 id="3-9-1-Bernoulli分布（伯努利分布）"><a href="#3-9-1-Bernoulli分布（伯努利分布）" class="headerlink" title="3.9.1 Bernoulli分布（伯努利分布）"></a>3.9.1 Bernoulli分布（伯努利分布）</h5><p>单个二值随机变量的分布，又名两点分布，0-1分布</p><ul><li><p>对于单次随机试验，对于一个随机变量X而言：<br>$$P(X=1)=p$$<br>$$P(X=0)=1-p$$<br>$$P(X=x)=p^x(1-p)^{1-x}$$<br>$$E(X)=p$$<br>$$Var(X)=p(1-p)$$</p></li><li><p>进行一次伯努利试验，成功(X=1)概率为p(0≤p≤1)，失败(X=0)概率为1-p，则称随机变量X服从伯努利分布。伯努利分布是离散型概率分布，其概率质量函数为：</p></li></ul><p>$$f(x)=p^x(1-p)^{1-x}=\left{\begin{matrix}<br>p \text{ ,if x=1}\<br>1-p \text{ ,if x=0}\<br>0 \text{ ,otherwise}<br>\end{matrix}\right.$$</p><h5 id="3-9-2-Multinoulli分布"><a href="#3-9-2-Multinoulli分布" class="headerlink" title="3.9.2 Multinoulli分布"></a>3.9.2 Multinoulli分布</h5><p>Multinoulli分布，或称范畴分布，是指在具有k个不同状态的单个离散型随机变量上的分布，其中k是一个有限值</p><blockquote><p>Multinoulli分布是多项式分布（Multinomial distribution）的一个特例。多项式分布是${0,…,n}^k$中的向量的分布，用于表示当对Multinoulli分布采样n次时k个类中的每一个被访问的次数。即n=1的多项式分布是Multinoulli分布。</p></blockquote><p>Multinoulli分布由向量$p∈[0,1]^{k−1}$参数化，其中每一个分量$ p_i $表示第 i 个状态的概率。最后的第k个状态的概率可以通过$1−1^Tp$给出。注意我们必须限制$1^⊤p≤1$。Multinoulli分布经常用来表示对象分类的分布，所以我们很少假设状态 1 具有数值 1 之类的。因此，我们通常不需要去计算 Multinoulli 分布的随机变量的期望和方差。</p><p>Bernoulli 分布和 Multinoulli 分布足够用来描述在它们领域内的任意分布。它们能够描述这些分布，不是因为它们特别强大，而是因为它们的领域很简单。它们可以对那些能够将所有的状态进行枚举的离散型随机变量进行建模。当处理的是连续型随机变量时，会有不可数无限多的状态，所以任何通过少量参数描述的概率分布都必须在分布上加以严格的限制。</p><h5 id="3-9-3-高斯分布"><a href="#3-9-3-高斯分布" class="headerlink" title="3.9.3 高斯分布"></a>3.9.3 高斯分布</h5><p>高斯分布，也叫正态分布</p><p>$$N(x;\mu ,\sigma^2 )=\sqrt{\frac{1}{2\pi \sigma^2}}exp(-\frac{1}{2\sigma^2}(x-\mu)^2)$$<br>$$N(x;\mu ,\sigma^2 )=\sqrt{\frac{1}{2\pi \sigma^2}}e^{(-\frac{1}{2\sigma^2}(x-\mu)^2)}$$</p><p>正态分布的概率密度函数的图象的中心峰的x坐标由μ给出，峰的宽度受σ控制<br>标准正态分布：μ=0，σ=1</p><p>$$\mathbb{E}(x)=\mu$$<br>$$Var(x)=\sigma^2$$</p><p>令β为方差的倒数，来控制分布的精度<br>$$N(x;\mu ,\beta^{-1} )=\sqrt{\frac{\beta}{2\pi}}e^{(-\frac{1}{2}\beta(x-\mu)^2)}$$</p><p>正态分布可以推广到$\mathbb{R}^n$空间，这种情况下被称为多维正态分布<br>$$N(x;\mu ,\sum )=\sqrt{\frac{1}{(2\pi)^ndet(\sum)}}e^{(-\frac{1}{2}(x-\mu)^T\sum^{-1}(x-\mu))}$$</p><p>参数μ仍然表示分布的均值，只不过现在是向量值。参数∑给出了分布的协方差矩阵，但并不是一个很高效的参数化分布的方式，因为要对∑求逆，因此可以使用一个精度矩阵<strong>β</strong>替换<br>$$N(x;\mu ,\beta^{-1} )=\sqrt{\frac{det(\beta)}{(2\pi)^n}}e^{(-\frac{1}{2}(x-\mu)^T\beta(x-\mu))}$$</p><h5 id="3-9-4-指数分布和Laplace分布"><a href="#3-9-4-指数分布和Laplace分布" class="headerlink" title="3.9.4 指数分布和Laplace分布"></a>3.9.4 指数分布和Laplace分布</h5><p>指数分布，可以用来表示事件的时间间隔的概率，可以由泊松分布推导出来</p><p>其概率密度函数<br>$$f(x)=\left{\begin{matrix}<br>\lambda e^{-\lambda x} , x &gt;0 \<br>0 , otherwise<br>\end{matrix}\right.$$<br>分布函数<br>$$F(x)=\left{\begin{matrix}<br>1-\lambda e^{-\lambda x} , x \geqslant 0 \<br>0 , x＜0<br>\end{matrix}\right.（\lambda&gt;0）$$</p><p>Laplace分布，允许我们在任意一点μ处设置概率质量的峰值<br>$$Laplace(x;\mu , \gamma ) = \frac{1}{2\gamma}exp(-\frac{|x-\mu|}{\gamma})$$</p><h5 id="3-9-5-Dirac分布和经验分布"><a href="#3-9-5-Dirac分布和经验分布" class="headerlink" title="3.9.5 Dirac分布和经验分布"></a>3.9.5 Dirac分布和经验分布</h5><p>概率密度函数<br>$$p(x)=\delta(x-\mu)$$</p><p>Dirac分布经常作为经验分布的组成部分出现</p><h5 id="3-9-6-分布的混合"><a href="#3-9-6-分布的混合" class="headerlink" title="3.9.6 分布的混合"></a>3.9.6 分布的混合</h5><p>潜变量：不能直接观测到的随机变量</p><p>高斯混合模型，概率密度的万能近似器</p><p>先验概率：在观测到x之前计算的<br>后验概率：在观测到x之后计算的</p><h4 id="3-10-常用函数的有用性质"><a href="#3-10-常用函数的有用性质" class="headerlink" title="3.10 常用函数的有用性质"></a>3.10 常用函数的有用性质</h4><p>logistic sigmoid函数,在变量取绝对值很大的正值或负值时出现饱和现象</p><p>$$\sigma(x)=\frac{1}{1+e^{-x}}$$</p><p>softplus函数,范围（0,∞）</p><p>$$\zeta (x)=log(1+e^x)$$</p><p>ReLU函数，人工神经网络常用的激活函数</p><p>$$f(x)=max(0,x)$$</p><h4 id="3-11-贝叶斯规则"><a href="#3-11-贝叶斯规则" class="headerlink" title="3.11 贝叶斯规则"></a>3.11 贝叶斯规则</h4><p>$$P(x|y)=\frac{P(x)P(y|x)}{P(y)}$$</p><h4 id="3-12-连续型变量的技术细节"><a href="#3-12-连续型变量的技术细节" class="headerlink" title="3.12 连续型变量的技术细节"></a>3.12 连续型变量的技术细节</h4><p>测度论<br>零测度<br>几乎处处<br>Jacobin矩阵</p><h4 id="3-13-信息论"><a href="#3-13-信息论" class="headerlink" title="3.13 信息论"></a>3.13 信息论</h4><p>量化信息</p><ul><li>非常可能发生的事件信息量要比较少，并且极端情况下，确保能够发生的事件没有信息量</li><li>较不可能发生的事件具有更高的信息量</li><li>独立事件应具有增量的信息。例如，投掷的硬币两次正面朝上传递的信息量，应该是投掷一次硬币正面朝上信息量的两倍</li></ul><p>定义一个事件X=x的自信息为<br>$$I(x)=-logP(x)$$<br>log为自然对数，底为e，I(x)单位是奈特，一奈特是以1/e概率观测到一个事件时获得的信息量<br>若以2为底数，单位是比特或者香农</p><p>香农熵，一个分布的香农熵时指遵循这个分布的事件所产生的期望信息总量<br>$$H(x)=\mathbb{E}_ {x\sim P}[I(x)]=-\mathbb{E} _ {x \sim P}[logP(x)]$$</p><p>当x连续，香农熵被称为微分熵</p><p>KL散度，用域衡量两个分布的差异<br>$$D_{KL}(P||Q)=\mathbb{E} _ {x \sim P}[log\frac{P(x)}{Q(x)}]=\mathbb{E} _ {x \sim P}[logP(x)-logQ(x)]$$</p><p>交叉熵<br>$$H(P,Q)=-\mathbb{E}_ {x \sim P} logQ(x)$$</p><h4 id="3-14-结构化概率模型"><a href="#3-14-结构化概率模型" class="headerlink" title="3.14 结构化概率模型"></a>3.14 结构化概率模型</h4><p>结构化概率模型，又叫图模型</p><p>有向<br>无向</p><h3 id="第四章-数值计算"><a href="#第四章-数值计算" class="headerlink" title="第四章 数值计算"></a>第四章 数值计算</h3><h4 id="4-1-上溢和下溢"><a href="#4-1-上溢和下溢" class="headerlink" title="4.1 上溢和下溢"></a>4.1 上溢和下溢</h4><p>通过有限数量的位表示无限多的实数，总会引入舍入误差，包括了上溢和下溢<br>对上溢和下溢进行数值稳定的一个例子是softmax函数<br>$$softmax(x) _ i=\frac{exp(x_i)}{\sum_{j=1}^nexp(x_j)}$$</p><h4 id="4-2-病态条件"><a href="#4-2-病态条件" class="headerlink" title="4.2 病态条件"></a>4.2 病态条件</h4><p>条件数表征函数相对于输入的微小变化而变化的快慢程度<br>考虑函数$f(x)=A^{-1}x$，当A∈$\mathbb{R}^{n×n}$具有特征分解时，其条件数为<br>$$\max_{i,j}|\frac{\lambda_i}{\lambda_j}|$$</p><h4 id="4-3-基于梯度的优化方法"><a href="#4-3-基于梯度的优化方法" class="headerlink" title="4.3 基于梯度的优化方法"></a>4.3 基于梯度的优化方法</h4><p>（1）优化<br>大多数深度学习算法涉及某种形式的优化，包括改变x以最小化或最大化某个函数f(x)。通常以最小化指代大多数最优化问题，最大化可以经由-f(x)来实现</p><p>目标函数（准则）：要最小化或最大化的函数<br>代价函数（损失函数/误差函数）：对其进行最小化时也称之为代价函数</p><p>梯度下降：将x往导数反方向移动来减小f(x)</p><p>$\frac{df(x)}{x}=0$的点称为临界点，驻点<br>有些临界点既不是最大点也不是最小点，被称为鞍点</p><p>（2）偏导，梯度，方向导数<br>对于多维输入函数，提出了<strong>偏导数</strong>。偏导数为函数在每个位置处沿着自变量坐标轴方向上的导数（切线斜率）</p><p><strong>梯度</strong>，写作$\nabla_xf(x)$，当前位置的梯度方向，为函数在该位置处方向导数最大的方向，也是函数值上升最快的方向，反方向为下降最快的方向。当前位置的梯度长度（模），为最大方向导数的值</p><p><strong>方向导数</strong>，如果是方向不是沿着坐标轴方向，而是任意方向，则为方向导数</p><h5 id="4-3-1-梯度之上：Jacobin和Hessian矩阵"><a href="#4-3-1-梯度之上：Jacobin和Hessian矩阵" class="headerlink" title="4.3.1 梯度之上：Jacobin和Hessian矩阵"></a>4.3.1 梯度之上：Jacobin和Hessian矩阵</h5><p>1.Jacobin<br>在向量分析中, 雅可比矩阵是一阶偏导数以一定方式排列成的矩阵, 其行列式称为雅可比行列式. 还有, 在代数几何中, 代数曲线的雅可比量表示雅可比簇：伴随该曲线的一个代数群, 曲线可以嵌入其中. </p><p>雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近. 因此, 雅可比矩阵类似于多元函数的导数.<br>$$\begin{bmatrix}<br>\frac{\partial y_1}{\partial x_1} &amp;\cdots&amp; \frac{\partial y_1}{\partial x_n} \<br>\vdots &amp; \ddots &amp; \vdots \<br>\frac{\partial y_m}{\partial x_1} &amp;\cdots&amp; \frac{\partial y_m}{\partial x_n}<br>\end{bmatrix}$$</p><p>2.Hessian<br>在数学中, 海森矩阵(Hessian matrix或Hessian)是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵, 此函数如下：<br>$f(x_1,x_2,\cdots,x_n)$，如果f的所有二阶导数都存在，那么<br>$$\begin{bmatrix}<br>\frac{\partial^2 f}{\partial x_1^2} &amp; \frac{\partial^2 f}{\partial x_1 \partial x_2} &amp;\cdots&amp; \frac{\partial^2 f}{\partial x_1 \partial x_n} \<br>\frac{\partial^2 f}{\partial x_2 \partial x_1} &amp; \frac{\partial^2 f}{\partial x_2^2} &amp;\cdots&amp; \frac{\partial^2 f}{\partial x_2 \partial x_n} \<br>\vdots &amp; \vdots &amp; \ddots &amp;\vdots\<br>\frac{\partial^2 f}{\partial x_n \partial x_1} &amp; \frac{\partial^2 f}{\partial x_n \partial x_2} &amp;\cdots&amp; \frac{\partial^2 f}{\partial x_n^2}<br>\end{bmatrix}$$</p><p>Hessian矩阵等价于梯度的Jacobian矩阵<br>海森矩阵在牛顿法中的应用，牛顿法时一个基于二阶泰勒展开来近似x附近的f(x)的方法</p><p>例如：在x0处展开<br>$$f(x)=f(x_0)+(x-x_0)^T\nabla_xf(x_0)+\frac{1}{2}(x-x_0)^TH(f)(x_0)(x-x_0)$$<br>临界点为<br>$$X’=X_0-H(f)(x_0)^{-1}\nabla_xf(x_0)$$</p><h4 id="4-4-约束优化"><a href="#4-4-约束优化" class="headerlink" title="4.4 约束优化"></a>4.4 约束优化</h4><p>在x的某些集合S中找f(x)的最大值或最小值，称为约束优化</p><p>Karush-Kuhn-Tucker（KKT）方法</p><p>广义Lagrangian（广义Lagrange函数）,通过m个函数g和n个函数h描述S，那么S可以表示为$\mathbb{S}={x|\forall i,g^{(i)}(x)=0 and \forall j ,h^{(j)}(x)≤0}$，其中涉及g的等式称为等式约束，涉及h的不等式称为不等式约束，定义如下：<br>$$L(x,\lambda , \alpha)=f(x)+\sum_i\lambda_ig^{(i)}(x)+\sum_j\alpha_jh^{(j)}(x)$$</p><h4 id="4-5-实例：线性最小二乘"><a href="#4-5-实例：线性最小二乘" class="headerlink" title="4.5 实例：线性最小二乘"></a>4.5 实例：线性最小二乘</h4><p>假设我们希望最小化下式中的x值：</p><p>$$f(x)=\frac{1}{2}\left|Ax-b\right| _ 2 ^ 2$$</p><p>首先，计算梯度<br>$$\nabla_xf(x)=A^T(Ax-b)=A^TAx-A^Tb$$</p><p>假设希望最小化同样的函数，但受$x^Tx≤1$的约束<br>$$L(x,\lambda)=f(x)+\lambda(x^Tx-1)$$</p><p>现在，我们解决以下问题<br>$$\min_x\max_{\lambda , \lambda ≥ 0}L(x,\lambda)$$</p><p>我们可以用Moore-Penrose伪逆。<br>关于x对Lagrangian微分，得到<br>$$A^TAx-A^Tb+2\lambda x=0$$</p><p>解为：<br>$$x=(A^TA+2\lambda I)^{-1}A^Tb$$</p><p>观察<br>$$\frac{\partial}{\partial \lambda}L(x,\lambda)=x^Tx-1$$</p><p>当x的范数超过1时，该导数是正的，所以为了跟随导数上坡并相对λ增加Lagrangian，我们需要增加λ。因为$x^Tx$的惩罚系数增加，秋节关于x的线性方程现在将得到具有较小范数的解</p><h3 id="第五章-机器学习基础"><a href="#第五章-机器学习基础" class="headerlink" title="第五章 机器学习基础"></a>第五章 机器学习基础</h3><h4 id="5-1-学习算法"><a href="#5-1-学习算法" class="headerlink" title="5.1 学习算法"></a>5.1 学习算法</h4><p>能够从数据中学习的算法</p><h5 id="5-1-1-任务T"><a href="#5-1-1-任务T" class="headerlink" title="5.1.1 任务T"></a>5.1.1 任务T</h5><p>通常机器学习任务定义为机器学习系统应该如何处理样本。<br>样本是我们从希望机器学习系统处理的对象或事件中收集到的已经量化的特征的集合</p><p>常见任务：分类，输入缺失分类，回归，转录，机器翻译，结构化输出，异常检测，合成和采样，缺失值填补，去噪，密度估计或概率质量函数估计</p><h5 id="5-1-2-性能度量P"><a href="#5-1-2-性能度量P" class="headerlink" title="5.1.2 性能度量P"></a>5.1.2 性能度量P</h5><p>为了评估机器学习算法的能力，提出准确率，错误率</p><p>使用测试集数据来评估系统性能，将其与训练机器学习系统的训练集数据分开</p><h5 id="5-1-3-经验E"><a href="#5-1-3-经验E" class="headerlink" title="5.1.3 经验E"></a>5.1.3 经验E</h5><p>机器学习算法分为无监督算法和监督算法</p><h5 id="5-1-4-示例：线性回归"><a href="#5-1-4-示例：线性回归" class="headerlink" title="5.1.4 示例：线性回归"></a>5.1.4 示例：线性回归</h5><h4 id="5-2-容量，过拟合和欠拟合"><a href="#5-2-容量，过拟合和欠拟合" class="headerlink" title="5.2 容量，过拟合和欠拟合"></a>5.2 容量，过拟合和欠拟合</h4><h5 id="5-2-1-没有免费午餐定理"><a href="#5-2-1-没有免费午餐定理" class="headerlink" title="5.2.1 没有免费午餐定理"></a>5.2.1 没有免费午餐定理</h5><h5 id="5-2-2-正则化"><a href="#5-2-2-正则化" class="headerlink" title="5.2.2 正则化"></a>5.2.2 正则化</h5><h4 id="5-3-超参数和验证集"><a href="#5-3-超参数和验证集" class="headerlink" title="5.3 超参数和验证集"></a>5.3 超参数和验证集</h4><h5 id="5-3-1-交叉验证"><a href="#5-3-1-交叉验证" class="headerlink" title="5.3.1 交叉验证"></a>5.3.1 交叉验证</h5><h4 id="5-4-估计，偏差和方差"><a href="#5-4-估计，偏差和方差" class="headerlink" title="5.4 估计，偏差和方差"></a>5.4 估计，偏差和方差</h4><h5 id="5-4-1-点估计"><a href="#5-4-1-点估计" class="headerlink" title="5.4.1 点估计"></a>5.4.1 点估计</h5><h5 id="5-4-2-偏差"><a href="#5-4-2-偏差" class="headerlink" title="5.4.2 偏差"></a>5.4.2 偏差</h5><h5 id="5-4-3-方差和标准差"><a href="#5-4-3-方差和标准差" class="headerlink" title="5.4.3 方差和标准差"></a>5.4.3 方差和标准差</h5><h5 id="5-4-4-权衡偏差和方差以最小化均方误差"><a href="#5-4-4-权衡偏差和方差以最小化均方误差" class="headerlink" title="5.4.4 权衡偏差和方差以最小化均方误差"></a>5.4.4 权衡偏差和方差以最小化均方误差</h5><h5 id="5-4-5-一致性"><a href="#5-4-5-一致性" class="headerlink" title="5.4.5 一致性"></a>5.4.5 一致性</h5><h4 id="5-5-最大似然估计"><a href="#5-5-最大似然估计" class="headerlink" title="5.5 最大似然估计"></a>5.5 最大似然估计</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深度学习&quot;&gt;&lt;a href=&quot;#深度学习&quot; class=&quot;headerlink&quot; title=&quot;深度学习&quot;&gt;&lt;/a&gt;深度学习&lt;/h1&gt;&lt;h3 id=&quot;第一章-前言&quot;&gt;&lt;a href=&quot;#第一章-前言&quot; class=&quot;headerlink&quot; title=&quot;第一章 前</summary>
      
    
    
    
    <category term="人工智能" scheme="https://blog.justlovesmile.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="深度学习" scheme="https://blog.justlovesmile.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>大学课程 | 计算机系统结构精简知识点</title>
    <link href="https://blog.justlovesmile.top/posts/651e6a0b.html"/>
    <id>https://blog.justlovesmile.top/posts/651e6a0b.html</id>
    <published>2020-09-08T06:31:25.000Z</published>
    <updated>2020-09-08T06:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/posts/50754.html">计算机系统结构笔记传送门</a></p><h1 id="计算机系统结构知识点"><a href="#计算机系统结构知识点" class="headerlink" title="计算机系统结构知识点"></a>计算机系统结构知识点</h1><ol><li>多级层次结构：<br>（1）按功能划分成多层机器级组成的层次结构，从上到下依次为，应用语言机器级，高级语言机器级，汇编语言机器级，操作系统机器级，传统机器语言机器级，微程序机器级。<br>（2）机器，被定义为能存储和执行相应语言程序的算法和数据结构的集合体<br>（3）微程序机器级用硬件实现，传统机器语言机器级用固件实现<br>（4）固件：具有软件功能的硬件<br>（5）以软件为主实现的机器称为虚拟机器，由硬件或固件实现的称为实际机器</li><li>透明性：<br>（1）客观存在的事物或属性从某个角度看不见</li><li>翻译与解释<br>（1）翻译：先用转换程序将高一级机器级上的程序<code>整个</code>变换成低一级机器级上等效的程序，然后再在低一级机器级上实现的技术<br>（2）解释：在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级的机器级语言程序中的每条语句或指令<code>逐条</code>解释来实现的技术</li><li>软硬件逻辑功能等效<br>（1）概念：软硬件逻辑功能等效是指计算机系统的某功能可以由硬件实现也可以由软件实现，在逻辑功能上是等价的。由硬件实现功能的特点是速度快、增加硬件成本，灵活性低。由软件实现功能的特点是灵活性好、但速度较慢，增加软件设计费用等</li><li>计算机系统结构、组成与实现的定义及三者之间的关系，以乘法指令为例说明上述三者各自的研究内容<br>（1）计算机系统结构的定义：对计算机系统中各级界面的定义及其上下的功能分配<br>（2）计算机组成的定义：计算机系统结构的逻辑实现，包括机器级内部的数据流和控制流的组成以及逻辑设计等<br>（3）计算机实现：是指计算机组成的物理实现（具体电路，器件的设计，装配技术等等）<br>（4）三者的关系：三者互不相同，但又相互影响。组成向上决定于结构，向下受限于实现技术。<br>（5）对于乘法指令，计算机系统结构主要考虑是否要设置乘法指令；而计算机组成主要考虑乘法指令是用专门的高速乘法器还是用加法器和移位器实现；计算机实现主要考虑乘法器，加法器的物理显示，如器件的类型，继承父，数量的确定和选择</li><li>计算机系统结构的设计思路<br>（1）<code>“由上往下”设计</code>，由顶向底。先考虑应用要求，再逐级向下，下一级是对上一级的优化。是一种穿行设计方法，设计周期较长<br>（2）<code>“由下往上”设计</code>，由底向顶。先设计底层，再加配操作系统和编译系统，以及设施的系统软件和算法等等。软硬件容易脱节，串行设计，周期长，很少采用<br>（3）<code>“从中间开始”向两边设计</code>。一般方法。软硬件并行设计，较好的设计方法</li><li>软件移植及三种移植技术<br>（1）软件的可移植性：软件不修改或只经少量修改就可以由一台机器移到另一台机器上允许，同一软件可应用于不同的环境<br>（2）移植技术：<code>统一高级语言</code>；<code>采用系列机</code>；<code>模拟和仿真</code></li><li>软件兼容及分类<br>（1）软件兼容：机器语言程序以及编译程序能不加修改地通用于各档机器<br>（2）分类：<br>a. 向上兼容/向下兼容：向上（下）兼容是指，按某党机器编制的软件，不加修改就能运行于比他高（低）档的机器上。<br>b. 向前兼容/向后兼容：向前（后）兼容是指，按某个时期投入市场的该型号机器上编制的软件，不加修改就能运行于在它之前（后）的投入市场的机器上。<br>（3）系列机软件必须保证向后兼容，力争向上兼容</li><li>系列机与兼容机，模拟与仿真<br>（1）系列机：是具有相同体系结构，但组成和实现不同的一系列不同型号的计算机系统。<br>兼容机：不同厂家生产的具有相同体系结构的计算机。<br>（2）模拟：用机器语言程序（在主存）解释实现软件移植的方法；运行速度低，实时性差，模拟程序复杂<br>仿真：用微程序（在控制寄存器）直接解释另一种机器指令系统的方法；两种系统结构差别较大时，难以仿真<br>两者的主要区别在于解释用的语言，其次有解释程序的所存位置不同</li><li>应用与器件对系统结构的影响<br>（1）应用的发展对结构设计提出范围广泛的要求<br>（2）器件的发展改变了逻辑设计的传统方法；推动结构和组成前进的关键因素；加速了结构“下移”；促进了算法，语言和软件的发展</li><li>并行性概念及发展并行性的三种技术途径<br>（1）并行性：把解题中具有可以同时进行运算或操作的特性称为并行性，并行性包括同时性和并发性<br>（2）并行性等级：<br>①按计算机系统执行程序的角度，从低到高：指令内部，指令之间，任务或进程之间，作业或程序之间<br>②从计算机系统中处理数据的角度来看，从低到高：位串字串，位并字串，位片串字并，全并行<br>（3）三种技术途径：时间重叠，资源重叠，资源共享<br>时间重叠：多个处理过程在时间上错开<br>资源重叠：重复设置硬件资源来提高可靠性和性能<br>资源共享：多个用户按时间顺序轮流使用同一套资源</li><li>耦合度概念<br>（1）耦合度概念：反映多机系统中各机器之间物理连接的紧密度和交叉作用能力<br>（2）分类：<br>最低耦合：除存储介质，无物理连接，脱机<br>松散耦合：通过通道或通信线路互连，磁带，磁盘…<br>紧密耦合：通过总线或高速开关互连，主存…</li><li>弗林分类法<br>（1）单指令流单数据流（SISD），传统单处理器计算机<br>（2）单指令流多数据流（SIMD），阵列处理机和相联处理机<br>（3）多指令流单数据流（MISD），很少见<br>（4）多指令流多数据流（MIMD），多级系统</li><li>数据表示与数据结构<br>（1）数据表示：能由机器硬件识别和引用的数据类型（数据类型指一类值的集合和可作用于其上的操作集）<br>（2）数据结构：结构数据类型的组织方式，反映了应用中要用到的各种数据元素或信息单元之间的结构关系<br>（3）数据结构和数据表示是软硬件的交界面，数据结构是软，数据表示是硬</li><li>高级数据表示<br>（1）自定义数据表示：<br>a). 标识符数据表示<br>①每个数据带了类型标志位，标识符主要用于指明数据类型，但也可以用域指明所用信息类型。标识符由编译程序建立，对高级语言程序透明。<br>②优点：简化了指令系统和程序设计；简化了编译程序；便于一致性校验；能由硬件自动变换数据类型；支持数据库系统的实现与数据类型无关的要求；为软件调试和应用软件开发提供了支持，便于程序的跟踪和调试<br>③缺点：增加程序所占的主存空间；降低指令的执行速度<br>b). 数据描述符<br>①描述符和数据分开存放，用于描述所访问的数据是整块的还是单个的，访问该数据块或数据元素所要的地址以及其它信息<br>②优点：进一步减少标识符所占存储空间<br>（2）向量，数组数据表示<br>①有向量数据表示的处理机是向量处理机<br>②优点：加快形成元素地址，便于实现把向量各元素成块预取到中央处理机，用一条向量，数组指令流水或同事对整个向量，数组进行高速处理<br>（3）堆栈数据表示<br>①有堆栈数据表示的处理机是堆栈机器<br>②通常用于保存子程序调用时的返回地址<br>③堆栈机器特点：有丰富的堆栈操作指令且功能强大；有力地支持了高级语言程序的编译；有力的支持了子程序的嵌套和递归调用</li><li>引入数据表示的原则<br>（1）原则1：看系统的效率是否显著提高，包括实现时间和存储空间是否显著减少。实现时间是否减少又主要看主存和处理机之间传送的信息量是否减少<br>（2）原则2：看引入这种数据表示后，其通用性和利用率是否提高<br>（3）原则3：基本的数据表示，也有可挖掘的细节问题<br>（4）原则4：基本的数据类型必须设</li><li>浮点数尾数基值的选择与下溢处理方法<br>（1）浮点数尾数基值的选择<br>如果小数点的位置事先已有约定，不再改变，此类数称为“定点数”。<br>如果小数点的位置可变，则称为“浮点数”。<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200826171758.png"><br>rm ：尾数的基<br>re ：阶码的基（re =2）<br>m： 尾数长度 (注意其含义)<br>p： 阶码长度<br>【p表示数的范围大小；尾数的位数m主要影响表示值的精度】<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200415135441.png"></li></ol><table><thead><tr><th align="center">条件：非负阶，规格化，正尾数</th><th align="center">阶值：二进制p位，尾数：rm进制m’位</th><th align="center">若p=2，m=4，当rm=2（即m’=4）时</th><th align="center">若p=2，m=4，当rm=16（即m’=1）时</th></tr></thead><tbody><tr><td align="center">可表示最小尾数值</td><td align="center">rm^(-1)</td><td align="center">1/2</td><td align="center">1/16</td></tr><tr><td align="center">可表示最大尾数值</td><td align="center">1-1×rm^(-m’)</td><td align="center">15/16</td><td align="center">15/16</td></tr><tr><td align="center">最大阶值</td><td align="center">2^p-1</td><td align="center">3</td><td align="center">3</td></tr><tr><td align="center">可表示最小值</td><td align="center">rm^(-1)</td><td align="center">1/2</td><td align="center">1/16</td></tr><tr><td align="center">可表示最大值</td><td align="center">rm^(2^p-1)×(1-rm^(-m’))</td><td align="center">7.5</td><td align="center">3840</td></tr><tr><td align="center">可表示的尾数个数</td><td align="center">rm^(m’)×(rm-1)/rm</td><td align="center">8</td><td align="center">15</td></tr><tr><td align="center">可表示阶的个数</td><td align="center">2^p</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">可表示数的个数</td><td align="center">2^p×rm^(m’)×(rm-1)/rm</td><td align="center">32</td><td align="center">60</td></tr></tbody></table><p>（2）下溢处理方法（对应用程序员，系统程序员透明）<br>减少运算中的精度损失关键是要处理好运算中尾数超出字长的部分，使精度损失最小<br>a) <strong>截断法</strong><br>①方法：<strong>将尾数超出机器字长的部分去掉</strong><br>②以rm=2，m=2为例讨论最大误差：在整数时接近于1(“11:111…1”截断成“11:”)；在分数时接近于2^(-m) (“.01:111…1”截断成“.01:”)<br>③对于正数，如有误差总是负误差<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200415140626.png"><br>④优点：实现简单，不增加硬件，不需要处理时间<br>缺点：最大误差较大，且平均误差为负且较大，无法调节，因而已很少使用<br>b) <strong>舍入法</strong><br>①方法：在机器运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加1，[整数加0.5，分数加2^(-(m+1))]<br>②例如：整数：“10:10…0”舍入成“11:” 正误差；分数：“.10:01…0”舍入成“.10:” 负误差<br>③优点：实现简单，增加的硬件开销少，最大误差小，平均误差接近于零，略偏正<br>缺点：处理速度慢，需要花费在数的附加位加1以及因此产生进位的时间，最坏情况下，需要从尾数最低位进制<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/Y5E%7B1ZHXC%25%5B77%7BW_5Z2%5BY%5DO.png"><br>c) <strong>恒置“1”法</strong><br>①方法：将机器运算的规定字长之最低位恒置“1”<br>②最大误差：整数为1（如“10:00…0”处理成“11:”）；分数为2-m（如“.00:00…0”处理成“.01:”）<br>③误差有正负：负误差（如“.11:10…1”处理成“.11:”）；正误差（如“.00:00…0”处理成“.01:”)<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/%25%7DMG%25YPJF2L0QNXJ%7DK8FC%402.png"><br>④优点：实现简单，不需要增加硬件和处里时间，平均误差趋于0<br>缺点：最大误差最大，比截断法还大（接近于1）<br>⑤多用于中、高速机器中，由于尾数位数比微、小型机器长<br>d) <strong>查表舍入法</strong><br>①方法：取尾数p位的最后k-1位和准备舍弃的最高1位，共k位。通过ROM或PLA查表得到k-1位，作为新的尾数p位的最后k-1位<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/%29%7DUAT%7DO7%7D%7B%25%28WNSFI%40I%25MOP.png"><br>②下溢处理表的内容：当尾数最低k-1位为全”1“时以<code>截断法</code>设置处理结果；其余情况采用<code>舍入法</code><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200415142649.png"><br>③优点：ROM法速度较快，平均误差可调到0；避免再次右规操作<br>缺点：需要硬件配合，硬件量大<br>（3）上述4种处理方法中：<br><strong>最大误差最大</strong>的是恒置“1”法，<br><strong>最大误差最小</strong>的是舍入法；<br><strong>平均误差最大</strong>的是截断法；<br><strong>平均误差可人为调节</strong>的是查表舍入法；<br><strong>下溢处理不需要附加时间开销，即速度最快</strong>的是截断法和恒置“1”法，<br><strong>处理速度最慢</strong>的是舍入法；<br><strong>实现上最花费硬件</strong>的是查表舍入法，<br><strong>最省硬件</strong>的是截断法和恒置“1”法。 </p><ol start="18"><li>程序在主存中的定位技术<br>（1）静态再定位：再目的程序装入主存时，由装入程序用软件方法把目的程序的逻辑地址变换成物理地址，程序执行时，物理地址不再改变<br>（2）动态再定位：在执行每条指令时才形成访存物理地址的方法<br>①基址寻址：设置基址寄存器和地址加法器硬件，实现逻辑地址到物理地址空间变换的支持<br>②优越性：地址加法器形成物理地址的速度快于装入程序形成的物理地址速度；具有越界保护措施，如设置上、下界寄存器，判断是否出现地址越界错误<br>（3）虚实地址映像表：用虚拟存储器增加映像表硬件后，程序空间可以超过实际主存空间，采用基地址寄存器加位移量的方法</li><li>基址寻址与变址寻址的区别<br>（1）基址寻址：基址寄存器里的值加上指令格式内的逻辑地址形成物理地址；对逻辑地址空间到物理地址空间变换的支持；通常基址寄存器的内容不变，逻辑地址可变；<br>（2）变址寻址：变址寄存器的值和指令地址码部分给出的地址之和作为操作数地址；对诸如向量，数组等数据块运算的支持；通常逻辑地址不变，变址寄存器里面的值由用户定义</li><li>信息按整数边界存储<br>（1）为了使任何时候所需的信息都只用一个存储周期访问到，要求信息在主存中存放的地址必须是该信息宽度（字节数）的整数倍，防止信息跨主存边界存放<br>（2）优点：访问周期短；缺点：存储空间浪费</li><li>哈夫曼压缩思想与指令格式的优化<br>（1）指令包含操作码和地址码两部分，为了优化指令格式，要使指令的平均字长最短，减少程序总位数以及增加指令字能表示的操作信息和地址信息<br>（2）哈夫曼压缩思想：当各种时间发生的概率不均等时，对发生概率最高的事件用最短的位数（时间）来表示（处理），而对出现概率较低的事件允许用较长的位数（时间）来表示（处理），就会使表示（处理）的平均位数（时间）缩短<br>（3）扩展操作码编码</li><li>CISC与RISC的常用技术<br>（1）CISC（复杂指令系统计算机）：进一步增强原有指令的功能以及设置更为复杂的新指令，取代原先由软件子程序完成的功能，实现软件功能的硬化；<br>a)面向目标程序的优化实现改进<br>①途径1：对大量已有机器的机器语言程序及其执行情况进行统计各种指令和指令串的使用频度来加以分析和改进。<br>使用频度分为<code>静态使用频度</code>（程序中统计出的指令及指令串的使用频度称为静态使用频度。着眼于减少目标程序所占用的存储空间）和<code>动态使用频度</code>（目标程序执行过程中对指令和指令串统计出的频度称为动态使用频度。着眼于减少目标程序的执行时间）<br>②途径2：增设强功能复合指令来取代原先由常用宏指令或子程序实现的功能，由微程序解释实现，不仅大大提高了运算速度，减少了程序调用的额外开销，也减少了子程序所占的主存空间。<br>b)面向高级语言的优化实现改进<br>①目的：缩短高级语言和机器语言的语义差距，支持高级语言编译，缩短编译程序长度和时间<br>②途径1：通过对源程序中各种高级语言语句的使用频度进行统计来分析改进<br>③途径2：如何面向编译，优化代码生成来改进<br>④途径3：改进指令系统，使它与各种语言间的语义差距都有同等的缩小<br>⑤途径4：让机器具有分别面向各种高级语言的多种指令系统，多种系统结构的面向问题动态自寻优的计算机系统<br>⑥途径5：发展高级语言计算机（或称高级语言机器）<br>c)面向操作系统的优化实现改进<br>①目的：通过缩短操作系统与计算机系统结构之间的语义差距，来进一步减少运行操作系统的时间和节省操作系统软件所占用的存储空间<br>②途径1：通过对操作系统中常用指令和指令串的使用频度进行统计分析来改进<br>③途径2：考虑如何增设专用于操作系统的新指令<br>④途径3：把操作系统中频繁使用的，对速度影响大的机构型软件子程序硬化或固化，直接用硬件或微程序解释实现<br>⑤途径4：发展让操作系统由专门的处理机来执行的功能分布处理系统结构<br>d) CISC的问题：指令系统庞大；许多质量操作繁杂，执行速度很低；编译程序太长，太复杂；部分指令利用率很低<br>（2）RISC（精简指令系统计算机）：通过减少指令种数和简化指令功能来降低硬件设计的复杂度，提高指令的执行速度<br>a) RISC的基本技术<br>①按照设计RISC一般原则来设计<br>②逻辑实现采用硬联和微程序相结合<br>③在CPU中设置大量工作寄存器并采用重叠寄存器窗口<br>④指令用流水和延迟转移<br>⑤采用高速缓冲寄存器cache，设置指令cache和数据cache分别存放指令和数据<br>⑥优化设计编译系统<br>b) RISC的问题<br>①指令少，加重汇编语言程序设计的负担，增加了机器语言程序的长度，占用存储空间多，加大了指令的信息流量<br>②对浮点运算和虚拟存储器支持不足<br>③RISC机器的编译程序比CISC的难写</li><li>总线的分类<br>（1）按在系统中的位置分为<code>芯片级</code>，<code>板级</code>，<code>系统级</code><br>（2）按允许信息传送方向分为<code>单向传输</code>，<code>双向传输（半双向和全双向）</code><br>（3）按用法分为<code>专用</code>和<code>非专用</code></li><li>总线的控制技术及通讯技术<br>（1）控制技术<br>a） 集中式控制<br>①优先次序的确定方法：串行链接，定时查询，独立请求<br>②串行链接获得使用总线权优先次序由“总线可用”线所接不见的物理位置决定，离总线控制器越近，优先级越高；三根总线，总线忙，总线可用，总线请求<br>③定时查询：查询线上计数值与发出请求的部件号是否一致；总线忙+总线请求+「logn「个定时查询计数线=2+「logn「<br>④独立请求：1根总线已被分配线+每个部件各有一对总线请求和总线准许线=2×N+1<br>b） 分布式控制<br>（2）通讯技术<br>a) 同步通信：定宽，定距的系统时标同步<br>b) 异步通信：<br>分为单向控制（分为单向源控和单向目控）和请求/回答双向控制（分为源控式（互锁和非互锁）和目控）</li><li>中断响应优先级与中断处理程序优先级及分析过程<br>（1）基本概念:<br>中断：CPU中止正在执行的程序，转去处理随机提出的请求，待处理完后，再回到预先被打断的程序继续恢复执行的过程<br>中断系统：相应和处理各种中断的软硬件总体称为中断系统<br>中断分为内部中断（CPU内的异常引起），外部中断（由中断信号引起）和软件中断（由自陷指令引起）；外部中断又分为可屏蔽中断和不可屏蔽中断<br>中断源：引起中断的各种事件<br>中断请求：中断源向中断系统发出请求中断的申请<br>中断响应：允许中断CPU现行程序的运行，转去对该请求进行预处理，包括保存好断电及其现场，调出有关处理该中断的中断服务程序，准备运行（交换新旧程序状态字PSW）<br>中断现行程序细分为中断（可屏蔽）和异常（不可屏蔽，如自陷，故障，失败）<br>（2）中断分级<br>机器校验（第1级），程序性中断和管理程序调用（第2级），外部中断（第3级），输入/输出（第4级），重新启动（最低级）<br>（3）中断的响应次序与处理次序<br>中断级屏蔽位寄存器<br>本级对本级屏蔽<br>中断响应次序，中断处理完成次序，中断处理次序<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909153438.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909154306.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909160431.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909160611.png"><br>（4）通道程序结束引起的中断属于I/O中断；<br>访管中断属于第2级；</li><li>通道的工作原理及三类通道的流量计算<br>（1）通道的工作原理：用户只能再目态程序中安排要求输入输出的广义指令，然后进入相应管理程序执行这些输入输出管态指令<br>a) 目态和管态：<br>管态又叫特权态，系统态或核心态。CPU在管态下可以执行指令系统的全集。通常，操作系统在管态下运行。<br>目态又叫常态或用户态。机器处于目态时，程序只能执行非特权指令。<br>从目态转换为管态的唯一途径是中断。<br>从管态到目态可以通过修改程序状态字来实现，这将伴随这由操作系统程序到用户程序的转换。<br>启动I/O指令属于管态指令<br>（2）三类通道：<code>字节多路</code>，<code>数组多路</code>和<code>选择通道</code><br>通道流量和通道工作方式，数据传送期内选择一次设备的时间Ts，传送一个字节的时间Td有关<br>通道的极限流量：<br>fmaxbyte=1/(Ts+Td)<br>fmaxblock=K/(Ts+K×Td)<br>fmaxselect=N/(Ts+N×Td)<br>设备要求通道的实际最大流量只有小于等于通道所能达到的极限<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909165849.png"><br>工作周期小的不能挂载<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909171038.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909171326.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909171903.png"></li><li>存储器的性能指标<br>（1）容量Sm：存储器的位数或总字节数<br>Sm=W×L×m （W:存储体的字长，L每个存储体的字数，m并行工作存储体的个数）<br>（2）速度<br>访问时间Tn，存储周期Tm，频宽Bm<br>（3）价格<br>总价格C，每位价格c<br>同等容量下，存储器的访问速度由高到低：双极型→MOS→电荷耦合型→磁泡→定位磁盘→动头磁盘→磁带</li><li>单体多字、多体单字与多体多字<br>（1）并行主存系统的三种模式：单体多字，多体单字，多体多字</li><li>存储器系统、并行存储体系与存储层次<br>（1）存储系统：存储系统是指计算机中由存放程序和数据的各种存储设备、控制部件及管理信息调度的设备（硬件）和算法（软件）所组成的系统。<br>（2）存储体系（存储层次）：构成存储系统的几种不同的存储器之间，配上辅助软硬件或辅助硬件，使之从应用程序员来看，在逻辑上是一个整体<br>基本的二级存储体系：虚拟存储器和Cache存储器（主存-辅存存储层次）<br>Cache存储器对于应用程序员和系统程序员都是透明的<br>（3）并行主存系统：可以并行读出多个CPU字的单体多字，多体单字，，多体多字的交叉存储主存系统</li><li>虚拟存储器与高速缓冲存储器<br>（1）在具有层次结构存储器的计算机系统中，增设地址映像表机构来实现程序在主存中的定位，自动实现部分装入和部分替换功能，能从逻辑上为用户提供一个比物理贮存容量大得多，可寻址的“主存储器”。虚拟存储区的容量与物理主存大小无关，而受限于计算机的地址结构和可用磁盘容量。<br>（2）存储管理方式：段式，页式，段页式</li><li>段式存储管理与页式存储管理技术<br>（1）段式管理：将主存按段分配的存储管理方式<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909201223.png"><br>首先分配算法<br>最佳分配算法<br>（2）页式管理：将主存空间和程序空间都机械等分成固定大小的页<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909201854.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909202427.png"><br>（3）段页式管理：将主存机械等分成固定大小的页，程序按模块分段，每个段又分为和主存页面大小相同的页</li><li>地址的映像与变换<br>（1）地址的映像：将每个虚存单元按什么规则（算法）装入（定位于）主存，建立起多用户虚地址N和贮存地址n之间的对应关系<br>（2）地址变换：是指程序按照映像关系装入实存后，在执行中，如何将多用户虚地址N变换成对应的实地址</li><li>全相联映像、直接相联映像与组相联映像<br>（1）Cache的全相联映像：主存中任意一块都可映像装入到Cache中任意一块位置<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909212811.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909212838.png"><br>（2）Cache的直接相联映像：把主存空间按Cache大小等分成区，每区内的各块只能映像到Cache中唯一一个特定块位置<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909212844.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909212845.png"><br>（3）Cache的组相联映像：将Cache和贮存空间先分成若干个组，共有2^n个组。Cache中多有的组构成Cache的唯一一个区。而主存则分成与Cache同样大小的2^(nd)个区<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909212846.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909212847.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910083257.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910212801.png"></li><li>常用替换算法<br>（1）随机算法：RAND，随机产生页号，命中率低，不采用<br>（2）先进先出算法：FIFO，选择最早装如主存的页作为被替换的页<br>（3）近期最少使用算法：LRU，选择近期最少访问的页作为被替换的页<br>（4）优化替换算法：OPT，将未来的近期内不用的页替换出去的算法，有较高的主存命中率，但是不太现实<br>（5）页面失效频率法（动态算法）：PFF，根据各道程序运行中的主存页面失效率的高低，由操作系统来动态操控</li><li>堆栈型替换算法<br>（1）堆栈型替换算法：任何时刻t，在n个实页中的虚页集合总是被包含在给其增加一个实页，即n+1个实页时，在实存中的虚页集合之内的<br>（2）堆栈型替换算法，命中率H随着主存页数n的增减单调上升，至少不下降。<br>LRU替换算法属于堆栈型替换算法，操作：将刚访问过的页号置于栈顶，最久未被访问过的页号置于栈底<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200909212445.png"></li><li>重叠与流水的区别<br>（1）重叠解释方式：在解释第K条指令的操作完成之前，就开始解释第K+1条指令<br>（2）重叠和流水的区别：依次重叠时把一条指令的解释分为两个子程序，而流水是分为更多个子过程</li><li>流水线中的各种相关及解决方案<br>（1）局部性相关：指的是在机器同时解释的多条指令之间出现了对同一主存单元或寄存器要求“先写后读”；包括<code>指令相关</code>，<code>访存操作数相关</code>和<code>通用寄存器组相关</code>等;<br>a）指令相关：包含寄存器相关（包括数据相关和名字相关）和控制相关<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910101227.png"><br>b）主存空间数相关：相邻两条指令之间出现要求对同一主存单元先写入而后再读出的关联<br>解决方法：推后读<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910101451.png"><br>（2）全局性相关：已进入流水线的转移指令（尤其时条件转移指令）和后续指令之间的相关</li><li>流水线的分类及三个性能指标的计算方法<br>（1）流水线分类：<br>按处理级别：部件级，处理机级，系统级<br>按具有的功能多少：单功能流水线，多功能流水线<br>按多功能流水线的各段能否允许同时用于多种不同功能连接流水：静态流水线，动态流水线<br>按机器所具有的数据表示：标量流水机和向量流水机<br>按各功能段间是否有反馈电路分为：线性流水和非线性流水<br>按信息流动控制方式：顺序流动流水线，异步流动流水线<br>（2）三个性能指标<br>a) 吞吐率Tp ：流水线单位时间里能流出的任务数或结果数<br>Tpmax = 1/max{各个子过程的时间}<br>Tp = n/(m×▲t+(n-1)×▲t) ：m段流水线，各段时间为▲t，完成n个任务的解释共需要时间m×▲t+(n-1)×▲t<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910102823.png"><br>b) 加速比Sp ：流水线方式相对于非流水线顺序方式速度提高的比值<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910103021.png"><br>c) 效率η：流水线设备的时间利用率，设备实际使用时间占整个设备运行时间的比值<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910103134.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910103907.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910103939.png"><br>（3）消除瓶颈：<br>①瓶颈子过程再细分<br>②重复设置多套瓶颈段并联</li><li>单功能非线性流水线的调度技术<br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910105055.png"><br><img src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN2/post/20200910104959.png"></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/posts/50754.html&quot;&gt;计算机系统结构笔记传送门&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;计算机系统结构知识点&quot;&gt;&lt;a href=&quot;#计算机系统结构知识点&quot; class=&quot;headerlink&quot; title=&quot;计算机系统结构知识点&quot;&gt;&lt;/a&gt;计算机系</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://blog.justlovesmile.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="大学课程" scheme="https://blog.justlovesmile.top/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机系统结构" scheme="https://blog.justlovesmile.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
